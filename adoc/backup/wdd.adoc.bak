= Writing Device Drivers
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js
:highlightjs-theme: github
:icons: font
:linkattrs:
:sectanchors:
:stylesdir: .
:stylesheet: illumos-docs.css

== Preface

Writing Device Drivers provides information on developing drivers for
character-oriented devices, block-oriented devices, network devices,
SCSI target and HBA devices, and USB devices for the illumos Operating
System (illumos). This book discusses how to develop multithreaded
reentrant device drivers for all architectures that conform to the
illumos DDI/DKI (Device Driver Interface, Driver-Kernel Interface). A
common driver programming approach is described that enables drivers to
be written without concern for platform-specific issues such as
endianness and data ordering.

Additional topics include hardening illumos drivers; power management;
driver autoconfiguration; programmed I/O; Direct Memory Access (DMA);
device context management; compilation, installation, and testing
drivers; debugging drivers; and porting illumos drivers to a 64-bit
environment.

[NOTE]
This illumos release supports systems that use the SPARC and x86
families of processor architectures: UltraSPARC, SPARC64, AMD64,
Pentium, and Xeon EM64T. For supported systems, see the illumos Hardware
Compatibility Lists at http://www.illumos.org/hcl/. This document cites
any implementation differences between the platform types.

[[whats-new]]
=== What's New

*SX build 96:* Rewrote the description of the sleep-flag flag on page
86.

*SX build 88:* Added the `strnlen` function to
link:#utility-functions[Utility Functions]. Added the
`ddi++_++periodic++_++add` and `ddi++_++periodic++_++delete` functions
to link:#time-related-functions[Time-Related Functions].

[[who-should-use-this-book]]
=== Who Should Use This Book

This book is written for UNIX programmers who are familiar with UNIX
device drivers. Overview information is provided, but the book is not
intended to serve as a general tutorial on device drivers.

[NOTE]

The illumos operating system (illumos) runs on both SPARC and x86
architectures. illumos also runs on both 64-bit and 32-bit address
spaces. The information in this document applies to all platforms and
address spaces unless specifically noted.
===

[[how-this-book-is-organized]]
=== How This Book Is Organized

* link:#overview-of-illumos-device-drivers[Overview of illumos Device Drivers] provides an
introduction to device drivers and associated entry points on the
illumos platform. The entry points for each device driver type are
presented in tables.
* link:#illumos-kernel-and-device-tree[illumos Kernel and Device Tree] provides an
overview of the illumos kernel with an explanation of how devices are
represented as nodes in a device tree.
* link:#multithreading[Multithreading] describes the aspects of the illumos
multithreaded kernel that are relevant for device driver developers.
* link:#properties[Properties] describes the set of interfaces for
using device properties.
* link:#managing-events-and-queueing-tasks[Managing Events and Queueing Tasks] describes how
device drivers log events and how to use task queues to perform a task
at a later time.
* link:#driver-autoconfiguration[Driver Autoconfiguration] explains the support that
a driver must provide for autoconfiguration.
* link:#device-access-programmed-io[Device Access: Programmed I/O] describes the
interfaces and methodologies for drivers to read or write to device
memory.
* link:#interrupt-handlers[Interrupt Handlers] describes the mechanisms for
handling interrupts. These mechanisms include registering, servicing,
and removing interrupts.
* link:#direct-memory-access-dma[Direct Memory Access (DMA)] describes direct memory
access (DMA) and the DMA interfaces.
* link:#mapping-device-and-kernel-memory[Mapping Device and Kernel Memory] describes
interfaces for managing device and kernel memory.
* link:#device-context-management[Device Context Management] describes the set of
interfaces that enable device drivers to manage user access to devices.
* link:#power-management[Power Management] explains the interfaces for
Power Management, a framework for managing power consumption.
* link:#hardening-illumos-drivers[Hardening illumos Drivers] describes how to integrate
fault management capabilities into I/O device drivers, how to
incorporate defensive programming practices, and how to use the driver
hardening test harness.
* link:#layered-driver-interface-ldi[Layered Driver Interface (LDI)] describes the LDI, which
enables kernel modules to access other devices in the system.
* link:#drivers-for-character-devices[Drivers for Character Devices] describes drivers
for character-oriented devices.
* link:#drivers-for-block-devices[Drivers for Block Devices] describes drivers for a
block-oriented devices.
* link:#scsi-target-drivers[SCSI Target Drivers] outlines the Sun Common SCSI
Architecture (SCSA) and the requirements for SCSI target drivers.
* link:#scsi-host-bus-adapter-drivers[SCSI Host Bus Adapter Drivers] explains how to
apply SCSA to SCSI Host Bus Adapter (HBA) drivers.
* link:#drivers-for-network-devices[Drivers for Network Devices] describes the Generic LAN
driver (GLD), an illumos network driver that uses STREAMS technology and
the Data Link Provider Interface (DLPI).
* link:#usb-drivers[USB Drivers] describes how to write a client USB device
driver using the USBA 2.0 framework.
* link:#compiling-loading-packaging-and-testing-drivers[Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers] provides information on compiling, linking, and
installing a driver.
* link:#debugging-testing-and-tuning-device-drivers[Debugging&#44; Testing&#44; and Tuning Device Drivers]
describes techniques for debugging, testing, and tuning drivers.
* link:#recommended-coding-practices[Recommended Coding Practices] describes the
recommended coding practices for writing drivers.
* link:#hardware-overview[appendix++_++title] discusses multi-platform
hardware issues for device drivers.
* link:#summary-of-illumos-ddidki-services[appendix++_++title] provides tables of kernel
functions for device drivers. Deprecated functions are indicated as
well.
* link:#making-a-device-driver-64-bit-ready[appendix++_++title] provides guidelines for updating
a device driver to run in a 64-bit environment.
* link:#console-frame-buffer-drivers[appendix++_++title] describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.

[[related-books-and-papers]]
=== Related Books and Papers

For detailed reference information about the device driver interfaces,
see the section 9 man pages. Section 9E, `Intro(9E)`, describes DDI/DKI
(Device Driver Interface, Driver-Kernel Interface) driver entry points.
Section 9F, `Intro(9F)`, describes DDI/DKI kernel functions. Sections 9P
and 9S, `Intro(9S)`, describe DDI/DKI properties and data structures.

* Device Driver Tutorial. Sun Microsystems, Inc., 2008.
* Application Packaging Developer’s Guide. Sun Microsystems, Inc., 2005.
* Open Boot PROM Toolkit User's Guide. Sun Microsystems, Inc., 1996.
* STREAMS Programming Guide. Sun Microsystems, Inc., 2005.
* Multithreaded Programming Guide. Sun Microsystems, Inc., 2008.
* Solaris 64-bit Developer’s Guide. Sun Microsystems, Inc., 2005.
* Modular Debugger Guide. Sun Microsystems, Inc., 2008.
* Dynamic Tracing Guide. Sun Microsystems, Inc., 2007.
* DTrace User Guide. Sun Microsystems, Inc., 2006.

* The SPARC Architecture Manual, Version 9. Prentice Hall, 1998. ISBN
0-13-099227-5.
* The SPARC Architecture Manual, Version 8. Prentice Hall, 1994. ISBN
0-13-825001-4.
* Pentium Pro Family Developer's Manual, Volumes 1-3. Intel Corporation, 1996. Volume 1, ISBN 1-55512-259-0; Volume 2, ISBN 1-55512-260-4; Volume 3, ISBN 1-55512-261-2.

=== Typographic Conventions

The following table describes the typographic conventions that are used
in this book.

.Typographic Conventions
[width="100%",cols="21%,45%,34%",options="header",]
|===
|Typeface |Meaning |Example
|`AaBbCc123` |The names of commands, files, and directories, and
onscreen computer output a|
Edit your `.login` file.

Use `ls` `a` to list all files.

`machine++_++name% you have mail.`

|`AaBbCc123` |What you type, contrasted with onscreen computer output a|
`machine++_++name%` `su`

`Password:`

|++<++aabbcc123++>++ |Placeholder: replace with a real name or value
|The command to remove a file is `rm` ++<++filename++>++.

|_AaBbCc123_ |Book titles, new terms, and terms to be emphasized a|
Read Chapter 6 in the User's Guide.

A _cache_ is a copy that is stored locally.

Do _not_ save the file.

*Note:* Some emphasized items appear bold online.

|===

[[shell-prompts-in-command-examples]]
=== Shell Prompts in Command Examples

The following table shows the default UNIX system prompt and superuser
prompt for the C shell, Bourne shell, and Korn shell.

.Shell Prompts
[width="100%",cols="50%,50%",options="header",]
|===
|Shell |Prompt
|C shell |`machine++_++name%`
|C shell for superuser |`machine++_++name#`
|Bourne shell and Korn shell |`$`
|Bourne shell and Korn shell for superuser |`#`
|===

== Designing Device Drivers for the illumos Platform

The first part of this manual provides general information for
developing device drivers on the illumos platform. This part includes
the following chapters:

* link:#overview-of-illumos-device-drivers[Overview of illumos Device Drivers] provides an
introduction to device drivers and associated entry points on the
illumos platform. The entry points for each device driver type are
presented in tables.
* link:#illumos-kernel-and-device-tree[illumos Kernel and Device Tree] provides an
overview of the illumos kernel with an explanation of how devices are
represented as nodes in a device tree.
* link:#multithreading[Multithreading] describes the aspects of the illumos
multithreaded kernel that are relevant for device driver developers.
* link:#properties[Properties] describes the set of interfaces for
using device properties.
* link:#managing-events-and-queueing-tasks[Managing Events and Queueing Tasks] describes how
device drivers log events and how to use task queues to perform a task
at a later time.
* link:#driver-autoconfiguration[Driver Autoconfiguration] explains the support that
a driver must provide for autoconfiguration.
* link:#device-access-programmed-io[Device Access: Programmed I/O] describes the
interfaces and methodologies for drivers to read or write to device
memory.
* link:#interrupt-handlers[Interrupt Handlers] describes the mechanisms for
handling interrupts. These mechanisms include registering, servicing,
and removing interrupts.
* link:#direct-memory-access-dma[Direct Memory Access (DMA)] describes direct memory
access (DMA) and the DMA interfaces.
* link:#mapping-device-and-kernel-memory[Mapping Device and Kernel Memory] describes
interfaces for managing device and kernel memory.
* link:#device-context-management[Device Context Management] describes the set of
interfaces that enable device drivers to manage user access to devices.
* link:#power-management[Power Management] explains the interfaces for the
Power Management feature, a framework for managing power consumption.
* link:#hardening-illumos-drivers[Hardening illumos Drivers] describes how to integrate
fault management capabilities into I/O device drivers, how to
incorporate defensive programming practices, and how to use the driver
hardening test harness.
* link:#layered-driver-interface-ldi[Layered Driver Interface (LDI)] describes the LDI, which
enables kernel modules to access other devices in the system.

[[overview-of-illumos-device-drivers]]
=== Overview of illumos Device Drivers

This chapter gives an overview of illumos device drivers. The chapter
provides information on the following subjects:

* link:#device-driver-basics[Device Driver Basics]
* link:#device-driver-entry-points[Device Driver Entry Points]
* link:#considerations-in-device-driver-design[Considerations in Device Driver Design]

[[device-driver-basics]]
=== Device Driver Basics

This section introduces you to device drivers and their entry points on
the illumos platform.

[[what-is-a-device-driver]]
==== What Is a Device Driver?

A _device driver_ is a
kernel module that is responsible for managing the low-level I/O
operations of a hardware device. Device drivers are written with
standard interfaces that the kernel can call to interface with a device.
Device drivers can also be software-only, emulating a device that exists
only in software, such as RAM disks, buses, and pseudo-terminals.

A device driver contains all the device-specific code necessary to
communicate with a device. This code includes a standard set of
interfaces to the rest of the system. This interface shields the kernel
from device specifics just as the system call interface protects
application programs from platform specifics. Application programs and
the rest of the kernel need little, if any, device-specific code to
address the device. In this way, device drivers make the system more
portable and easier to maintain.

When illumos is initialized, devices identify themselves and are
organized into the _device tree_, a hierarchy of devices. In effect, the
device tree is a hardware model for the kernel. An individual device
driver is represented as a node in the tree with no children. This type
of node is referred to as a _leaf driver_. A driver that provides
services to other drivers is called a _bus nexus driver_ and is shown as
a node with children. As part of the boot process, physical devices are
mapped to drivers in the tree so that the drivers can be located when
needed. For more information on how illumos accommodates devices, see
link:#illumos-kernel-and-device-tree[illumos Kernel and Device Tree].

Device drivers are classified by how they handle I/O. Device drivers
fall into three broad categories:

* *Block device drivers* – For cases where handling I/O data as
asynchronous chunks is appropriate. Typically, block drivers are used to
manage devices with physically addressable storage media, such as disks.
* *Character device drivers* – For devices that perform I/O on a
continuous flow of bytes.
+
[NOTE]

A driver can be both block and character at the same time if you set up
two different interfaces to the file system. See
link:#devices-as-special-files[Devices as Special Files].
===
+
Included in the character category are drivers that use the STREAMS
model (see below), programmed I/O, direct memory access, SCSI buses,
USB, and other network I/O.
* *STREAMS device drivers* – Subset of character drivers that uses the
`streamio(4I)` set of routines for character I/O within the kernel.

[[what-is-a-device-driver-entry-point]]
==== What Is a Device Driver Entry Point?

An _entry point_ is a
function within a device driver that can be called by an external entity
to get access to some driver functionality or to operate a device. Each
device driver provides a standard set of functions as entry points. For
the complete list of entry points for all driver types, see the
`Intro(9E)` man page. The illumos kernel uses entry points for these
general task areas:

* *Loading and unloading the driver*
* *Autoconfiguring the device* – Autoconfiguration is the process of
loading a device driver's code and static data into memory so that the
driver is registered with the system.
* *Providing I/O services for the driver*

Drivers for different types of devices have different sets of entry
points according to the kinds of operations the devices perform. A
driver for a memory-mapped character-oriented device, for example,
supports a `devmap(9E)` entry point, while a block driver does not
support this entry.

Use a prefix based on the name of your
driver to give driver functions unique names. Typically, this prefix is
the name of the driver, such as `xx++_++open` for the `open(9E)` routine
of driver `xx`. See link:#use-a-unique-prefix-to-avoid-kernel-symbol-collisions[Use a Unique Prefix to Avoid Kernel
Symbol Collisions] for more information. In subsequent examples in this
book, `xx` is used as the driver prefix.

[[device-driver-entry-points]]
=== Device Driver Entry Points

This section provides lists of entry points for the following
categories:

* link:#entry-points-common-to-all-drivers[Entry Points Common to All Drivers]
* link:#entry-points-for-block-device-drivers[Entry Points for Block Device Drivers]
* link:#entry-points-for-character-device-drivers[Entry Points for Character Device Drivers]
* link:#entry-points-for-streams-device-drivers[Entry Points for STREAMS Device Drivers]
* link:#entry-points-for-memory-mapped-devices[Entry Points for Memory Mapped Devices]
* link:#entry-points-for-the-generic-lan-device-gld-driver[Entry Points for the Generic LAN Device (GLD) Driver]
* link:#entry-points-for-scsi-hba-drivers[Entry Points for SCSI HBA Drivers]
* link:#entry-points-for-pc-card-drivers[Entry Points for PC Card Drivers]

[[entry-points-common-to-all-drivers]]
==== Entry Points Common to All Drivers

Some operations can be performed by any type of driver, such as the
functions that are required for module loading and for the required
autoconfiguration entry points. This section discusses types of entry
points that are common to all drivers. The common entry points are
listed in link:#summary-of-common-entry-points[Summary of Common Entry Points] with links to man
pages and other relevant discussions.

[[device-access-entry-points]]
===== Device Access Entry Points

Drivers for character and block devices export the `cb++_++ops(9S)`
structure, which defines the driver entry points for block device access
and character device access. Both types of drivers are required to
support the `open(9E)` and `close(9E)` entry points. Block drivers are
required to support `strategy(9E)`, while character drivers can choose
to implement whatever mix of `read(9E)`, `write(9E)`, `ioctl(9E)`,
`mmap(9E)`, or `devmap(9E)` entry points is appropriate for the type of
device. Character drivers can also support a polling interface through
`chpoll(9E)`. Asynchronous I/O is supported through `aread(9E)` and
`awrite(9E)` for block drivers and those drivers that can use both block
and character file systems.

[[loadable-module-entry-points]]
===== Loadable Module Entry Points

All drivers
are required to implement the loadable module entry points
`++_++init(9E)`, `++_++fini(9E)`, and `++_++info(9E)` to load, unload,
and report information about the driver module.

Drivers should allocate and initialize any global resources in
`++_++init(9E)`. Drivers should release their resources in
`++_++fini(9E)`.

[NOTE]

In illumos, only the loadable module routines must be visible outside
the driver object module. Other routines can have the storage class
`static`.
===

[[autoconfiguration-entry-points]]
===== Autoconfiguration Entry Points

Drivers are required to implement the `attach(9E)`, `detach(9E)`, and
`getinfo(9E)` entry points for device autoconfiguration. Drivers can
also implement the optional entry point `probe(9E)` in cases where
devices do not identify themselves during boot-up, such as SCSI target
devices. See link:#driver-autoconfiguration[Driver Autoconfiguration] for more
information on these routines.

[[kernel-statistics-entry-points]]
===== Kernel Statistics Entry Points

The illumos platform provides a rich set of interfaces to maintain and
export kernel-level statistics, also known as _kstats_. Drivers are free
to use these interfaces to export driver and device statistics that can
be used by user applications to observe the internal state of the
driver. Two entry points are provided for working with kernel
statistics:

* `ks++_++snapshot(9E)` captures kstats at a specific time.
* `ks++_++update(9E)` can be used to update kstat data at will.
`ks++_++update` is useful in situations where a device is set up to
track kernel data but extracting that data is time-consuming.

For further information, see the `kstat++_++create(9F)` and `kstat(9S)`
man pages. See also link:#kernel-statistics[Kernel Statistics].

[[power-management-entry-point]]
===== Power Management Entry Point

Drivers for hardware devices that provide Power Management functionality
can support the optional `power(9E)` entry point. See
link:#power-management[Power Management] for details about this entry
point.

[[summary-of-common-entry-points]]
===== Summary of Common Entry Points

The following table lists entry points that can be used by all types of
drivers.

.Entry Points for All Driver Types
[width="100%",cols="29%,11%,60%",options="header",]
|===
|Category / Entry Point |Usage |Description
|`cb++_++ops` *Entry Points* | |

|`open(9E)` |Required a|
Gets access to a device. Additional information:

* link:#open-entry-point-character-drivers[ Entry Point (Character Drivers)]
* link:#open-entry-point-block-drivers[ Entry Point (Block Drivers)]

|`close(9E)` |Required a|
Gives up access to a device. The version of `close` for STREAMS drivers
has a different signature than character and block drivers. Additional
information:

* link:#close-entry-point-character-drivers[ Entry Point (Character Drivers)]
* link:#close-entry-point-block-drivers[ Entry Point (Block Drivers)]

|*Loadable Module Entry Points* | |

|`++_++init(9E)` |Required |Initializes a loadable module. Additional
information: link:#loadable-driver-interfaces[Loadable Driver Interfaces]

|`++_++fini(9E)` |Required |Prepares a loadable module for unloading.
Required for all driver types. Additional information:
link:#loadable-driver-interfaces[Loadable Driver Interfaces]

|`++_++info(9E)` |Required |Returns information about a loadable module.
Additional information: link:#loadable-driver-interfaces[Loadable Driver Interfaces]

|*Autoconfiguration Entry Points* | |

|`attach(9E)` |Required |Adds a device to the system as part of
initialization. Also used to resume a system that has been suspended.
Additional information: link:#attach-entry-point[ Entry Point]

|`detach(9E)` |Required |Detaches a device from the system. Also, used
to suspend a device temporarily. Additional information:
link:#detach-entry-point[ Entry Point]

|`getinfo(9E)` |Required a|
Gets device information that is specific to the driver, such as the
mapping between a device number and the corresponding instance.
Additional information:

* link:#getinfo-entry-point[ Entry Point]
* link:#getinfo-entry-point-scsi-target-drivers[ Entry Point (SCSI Target Drivers)].

|`probe(9E)` |See Description a|
Determines if a non-self-identifying device is present. Required for a
device that cannot identify itself. Additional information:

* link:#probe-entry-point[ Entry Point]
* link:#probe-entry-point-scsi-target-drivers[ Entry Point (SCSI Target Drivers)]

|*Kernel Statistics Entry Points* | |

|`ks++_++snapshot(9E)` |Optional |Takes a snapshot of `kstat(9S)` data.
Additional information: link:#kernel-statistics[Kernel Statistics]

|`ks++_++update(9E)` |Optional |Updates `kstat(9S)` data dynamically.
Additional information: link:#kernel-statistics[Kernel Statistics]

|*Power Management Entry Points* | |

|`power(9E)` |Required |Sets the power level of a device. If not used,
set to `NULL`. Additional information: link:#power-entry-point[ Entry Point]

|*Miscellaneous Entry Points* | |

|`prop++_++op(9E)` |See Description a|
Reports driver property information. Required unless
`ddi++_++prop++_++op(9F)` is substituted. Additional information:

* link:#creating-and-updating-properties[Creating and Updating Properties]
* link:#prop_op-entry-point[ Entry Point]

|`dump(9E)` |See Description a|
Dumps memory to a device during system failure. Required for any device
that is to be used as the dump device during a panic. Additional
information:

* link:#dump-entry-point-block-drivers[ Entry Point (Block Drivers)]
* link:#dump-handling[Dump Handling]

|`identify`(9E) |Obsolete |Do not use this entry point. Assign
`nulldev(9F)` to this entry point in the `dev++_++ops` structure.
|===

[[entry-points-for-block-device-drivers]]
==== Entry Points for Block Device Drivers

Devices that
support a file system are known as _block devices_. Drivers written for
these devices are known as block device drivers. Block device drivers
take a file system request, in the form of a `buf(9S)` structure, and
issue the I/O operations to the disk to transfer the specified block.
The main interface to the file system is the `strategy(9E)` routine. See
link:#drivers-for-block-devices[Drivers for Block Devices] for more information.

A block device driver can also provide a character driver interface to
enable utility programs to bypass the file system and to access the
device directly. This device access is commonly referred to as the _raw_
interface to a block device.

The following table lists additional entry points that can be used by
block device drivers. See also link:#entry-points-common-to-all-drivers[Entry Points Common to All
Drivers].

.Additional Entry Points for Block Drivers
[width="100%",cols="29%,11%,60%",options="header",]
|===
|Entry Point |Usage |Description
|`aread(9E)` |Optional a|
Performs an asynchronous read. Drivers that do not support an `aread`
entry point should use the `nodev(9F)` error return function. Additional
information:

* link:#differences-between-synchronous-and-asynchronous-io[Differences Between Synchronous and Asynchronous
I/O]
* link:#dma-transfers-asynchronous[DMA Transfers (Asynchronous)]

|`awrite(9E)` |Optional a|
Performs an asynchronous write. Drivers that do not support an `awrite`
entry point should use the `nodev(9F)` error return function. Additional
information:

* link:#differences-between-synchronous-and-asynchronous-io[Differences Between Synchronous and Asynchronous
I/O]
* link:#dma-transfers-asynchronous[DMA Transfers (Asynchronous)]

|`print(9E)` |Required |Displays a driver message on the system console.
Additional information: link:#print-entry-point-block-drivers[ Entry Point (Block Drivers)]

|`strategy(9E)` |Required a|
Perform block I/O. Additional information:

* link:#canceling-dma-callbacks[Canceling DMA Callbacks]
* link:#dma-transfers-synchronous[DMA Transfers (Synchronous)]
* link:#strategy-entry-point[ Entry Point]
* link:#dma-transfers-asynchronous[DMA Transfers (Asynchronous)]
* link:#general-flow-of-control[General Flow of Control]
* link:#x86-target-driver-configuration-properties[x86 Target Driver Configuration Properties]

|===

[[entry-points-for-character-device-drivers]]
==== Entry Points for Character Device Drivers

device drivers

standard character driver

character device driver

Character device drivers normally perform I/O in a byte stream. Examples
of devices that use character drivers include tape drives and serial
ports. Character device drivers can also provide additional interfaces
not present in block drivers, such as I/O control (`ioctl`) commands,
memory mapping, and device polling. See link:#drivers-for-character-devices[Drivers
for Character Devices] for more information.

The main task of any device driver is to perform I/O,
and many character device drivers do what is called _byte-stream_ or
_character_ I/O. The driver transfers data to and from the device
without using a specific device address. This type of transfer is in
contrast to block device drivers, where part of the file system request
identifies a specific location on the device.

The `read(9E)` and `write(9E)` entry points handle byte-stream I/O for
standard character drivers. See link:#io-request-handling[I/O Request
Handling] for more information.

The following table lists additional entry points that can be used by
character device drivers. For other entry points, see link:#entry-points-common-to-all-drivers[Entry
Points Common to All Drivers].

.Additional Entry Points for Character Drivers
[width="100%",cols="30%,11%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`chpoll(9E)` |Optional |Polls events for a non-STREAMS character
driver. Additional information: link:#multiplexing-io-on-file-descriptors[Multiplexing I/O
on File Descriptors]

|`ioctl(9E)` |Optional a|
Performs a range of I/O commands for character drivers. `ioctl` routines
must make sure that user data is copied into or out of the kernel
address space explicitly using `copyin(9F)`, `copyout(9F)`,
`ddi++_++copyin(9F)`, and `ddi++_++copyout(9F)`, as appropriate.
Additional information:

* link:#ioctl-entry-point-character-drivers[ Entry Point (Character Drivers)]
* link:#implemented-ioctl-functions[Implemented Functions]
* link:#well-known-ioctl-interfaces[Well Known Interfaces]

|`read(9E)` |Required a|
Reads data from a device. Additional information:

* link:#vectored-io[Vectored I/O]
* link:#differences-between-synchronous-and-asynchronous-io[Differences Between Synchronous and Asynchronous
I/O]
* link:#programmed-io-transfers[Programmed I/O Transfers]
* link:#dma-transfers-synchronous[DMA Transfers (Synchronous)]
* link:#general-flow-of-control[General Flow of Control]

|`segmap(9E)` |Optional a|
Maps device memory into user space. Additional information:

* link:#exporting-the-mapping[Exporting the Mapping]
* link:#allocating-kernel-memory-for-user-access[Allocating Kernel Memory for User Access]
* link:#associating-user-mappings-with-driver-notifications[Associating User Mappings With Driver Notifications]

|`write(9E)` |Required a|
Writes data to a device. Additional information:

* link:#device-access-functions[Device Access Functions]
* link:#vectored-io[Vectored I/O]
* link:#differences-between-synchronous-and-asynchronous-io[Differences Between Synchronous and Asynchronous
I/O]
* link:#programmed-io-transfers[Programmed I/O Transfers]
* link:#dma-transfers-synchronous[DMA Transfers (Synchronous)]
* link:#general-flow-of-control[General Flow of Control]

|===

[[entry-points-for-streams-device-drivers]]
==== Entry Points for STREAMS Device Drivers

STREAMS is a separate programming model
for writing a character driver. Devices that receive data
asynchronously, such as terminal and network devices, are suited to a
STREAMS implementation. STREAMS device drivers must provide the loading
and autoconfiguration support described in link:#driver-autoconfiguration[Driver
Autoconfiguration]. See the STREAMS Programming Guide for additional
information on how to write STREAMS drivers.

The following table lists additional entry points that can be used by
STREAMS device drivers. For other entry points, see link:#entry-points-common-to-all-drivers[Entry
Points Common to All Drivers] and link:#entry-points-for-character-device-drivers[Entry Points for Character
Device Drivers].

.Entry Points for STREAMS Drivers
[width="100%",cols="30%,11%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`put(9E)` |See Description |Coordinates the passing of messages from
one queue to the next queue in a stream. Required, except for the side
of the driver that reads data. Additional information: STREAMS
Programming Guide

|`srv(9E)` |Required |Manipulate messages in a queue. Additional
information: STREAMS Programming Guide
|===

[[entry-points-for-memory-mapped-devices]]
==== Entry Points for Memory Mapped Devices

For certain
devices, such as frame buffers, providing application programs with
direct access to device memory is more efficient than byte-stream I/O.
Applications can map device memory into their address spaces using the
`mmap(2)` system call. To support memory mapping, device drivers
implement `segmap(9E)` and `devmap(9E)` entry points. For information on
`devmap(9E)`, see link:#mapping-device-and-kernel-memory[Mapping Device and Kernel Memory].
For information on `segmap(9E)`, see link:#drivers-for-character-devices[Drivers for
Character Devices].

Drivers that define the `devmap(9E)` entry point usually do not define
`read(9E)` and `write(9E)` entry points, because application programs
perform I/O directly to the devices after calling `mmap(2)`.

The following table lists additional entry points that can be used by
character device drivers that use the `devmap` framework to perform
memory mapping. For other entry points, see link:#entry-points-common-to-all-drivers[Entry Points
Common to All Drivers] and link:#entry-points-for-character-device-drivers[Entry Points for Character Device
Drivers].

.Entry Points for Character Drivers That Use `devmap` for Memory Mapping
[width="100%",cols="30%,11%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`devmap(9E)` |Required |Validates and translates virtual mapping for a
memory-mapped device. Additional information: link:#exporting-the-mapping[Exporting
the Mapping]

|`devmap++_++access(9E)` |Optional |Notifies drivers when an access is
made to a mapping with validation or protection problems. Additional
information: link:#devmap_access-entry-point[ Entry Point]

|`devmap++_++contextmgt(9E)` |Required |Performs device context
switching on a mapping. Additional information: link:#devmap_contextmgt-entry-point[ Entry
Point]

|`devmap++_++dup(9E)` |Optional |Duplicates a device mapping. Additional
information: link:#devmap_dup-entry-point[ Entry Point]

|`devmap++_++map(9E)` |Optional |Creates a device mapping. Additional
information: link:#devmap_map-entry-point[ Entry Point]

|`devmap++_++unmap(9E)` |Optional |Cancels a device mapping. Additional
information: link:#devmap_unmap-entry-point[ Entry Point]
|===

[[entry-points-for-the-generic-lan-device-gld-driver]]
==== Entry Points for the Generic LAN Device (GLD) Driver

The following table lists additional entry points that can be used by
the general LAN driver (GLD). For more information on GLD drivers, see
the `gld(9E)`, `gld(4D)`, and `gld++_++mac++_++info(9S)` man pages. For
other entry points, see link:#entry-points-common-to-all-drivers[Entry Points Common to All Drivers]
and link:#entry-points-for-character-device-drivers[Entry Points for Character Device Drivers].

.Additional Entry Points for the Generic LAN Driver
[width="100%",cols="30%,11%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`gldm++_++get++_++stats(9E)` |Optional |Gathers statistics from private
counters in a generic LAN driver. Updates the `gld++_++stats(9S)`
structure. Additional information: link:#gldmgetstats-entry-point[ Entry Point]

|`gldm++_++intr(9E)` |See Description |Receives calls for potential
interrupts to a generic LAN driver (GLD). Required if `gld++_++intr(9F)`
is used as interrupt handler. Additional information: link:#gldm_intr-entry-point[ Entry
Point]

|`gldm++_++ioctl(9E)` |Optional |Implements device-specific commands for
a generic LAN driver (GLD). Additional information: link:#gldm_ioctl-entry-point[ Entry
Point]

|`gldm++_++reset(9E)` |Required |Resets a generic LAN driver (GLD) to
the initial state. Additional information: link:#gldm_reset-entry-point[ Entry Point]

|`gldm++_++send(9E)` |Required |Queues a packet to a generic LAN driver
(GLD) for transmission. Additional information: link:#gldm_send-entry-point[ Entry
Point]

|`gldm++_++set++_++mac++_++addr(9E)` |Required |Sets the physical
address that the generic LAN driver (GLD) uses to receive data.
Additional information: link:#gldmsetmac_addr-entry-point[ Entry Point]

|`gldm++_++set++_++multicast(9E)` |Optional |Enables and disables
device-level reception of specific multicast addresses for generic LAN
driver (GLD). Additional information: link:#gldmsetmulticast-entry-point[ Entry Point]

|`gldm++_++set++_++promiscuous(9E)` |Required |Enables and disables
promiscuous mode for a generic LAN driver (GLD) to receive packets on
the medium. Additional information: link:#gldmsetpromiscuous-entry-point[ Entry Point]

|`gldm++_++start(9E)` |Required |Enables a generic LAN driver (GLD) to
generate interrupts. Prepares the driver to call `gld++_++recv(9F)` to
deliver received data packets. Additional information: link:#gldm_start-entry-point[
Entry Point]

|`gldm++_++stop(9E)` |Required |Disables a generic LAN driver (GLD) from
generating interrupts and from calling `gld++_++recv(9F)`. Additional
information: link:#gldm_stop-entry-point[ Entry Point]
|===

[[entry-points-for-scsi-hba-drivers]]
==== Entry Points for SCSI HBA Drivers

The following table lists additional entry points that can be used by
SCSI HBA device drivers. For information on the SCSI HBA transport
structure, see `scsi++_++hba++_++tran(9S)`. For other entry points, see
link:#entry-points-common-to-all-drivers[Entry Points Common to All Drivers] and link:#entry-points-for-character-device-drivers[Entry
Points for Character Device Drivers].

.Additional Entry Points for SCSI HBA Drivers
[width="100%",cols="29%,12%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`tran++_++abort(9E)` |Required |Aborts a specified SCSI command that
has been transported to a SCSI Host Bus Adapter (HBA) driver. Additional
information: link:#tran_abort-entry-point[ Entry Point]

|`tran++_++bus++_++reset(9E)` |Optional |Resets a SCSI bus. Additional
information: link:#tranbusreset-entry-point[ Entry Point]

|`tran++_++destroy++_++pkt(9E)` |Required |Frees resources that are
allocated for a SCSI packet. Additional information: link:#trandestroypkt-entry-point[
Entry Point]

|`tran++_++dmafree(9E)` |Required |Frees DMA resources that have been
allocated for a SCSI packet. Additional information: link:#tran_dmafree-entry-point[
Entry Point]

|`tran++_++getcap(9E)` |Required |Gets the current value of a specific
capability that is provided by the HBA driver. Additional information:
link:#tran_getcap-entry-point[ Entry Point]

|`tran++_++init++_++pkt(9E)` |Required |Allocate and initialize
resources for a SCSI packet. Additional information:
link:#resource-allocation[Resource Allocation]

|`tran++_++quiesce(9E)` |Optional |Stop all activity on a SCSI bus,
typically for dynamic reconfiguration. Additional information:
link:#dynamic-reconfiguration[Dynamic Reconfiguration]

|`tran++_++reset(9E)` |Required |Resets a SCSI bus or target device.
Additional information: link:#tran_reset-entry-point[ Entry Point]

|`tran++_++reset++_++notify(9E)` |Optional |Requests notification of a
SCSI target device for a bus reset. Additional information:
link:#tranresetnotify-entry-point[ Entry Point]

|`tran++_++setcap(9E)` |Required |Sets the value of a specific
capability that is provided by the SCSI HBA driver. Additional
information: link:#tran_setcap-entry-point[ Entry Point]

|`tran++_++start(9E)` |Required |Requests the transport of a SCSI
command. Additional information: link:#tran_start-entry-point[ Entry Point]

|`tran++_++sync++_++pkt(9E)` |Required |Synchronizes the view of data by
an HBA driver or device. Additional information: link:#transyncpkt-entry-point[ Entry
Point]

|`tran++_++tgt++_++free(9E)` |Optional a|
Requests allocated SCSI HBA resources to be freed on behalf of a target
device. Additional information:

* link:#trantgtfree-entry-point[ Entry Point]
* link:#transport-structure-cloning[Transport Structure Cloning]

|`tran++_++tgt++_++init(9E)` |Optional a|
Requests SCSI HBA resources to be initialized on behalf of a target
device. Additional information:

* link:#trantgtinit-entry-point[ Entry Point]
* link:#scsi_device-structure[ Structure]

|`tran++_++tgt++_++probe(9E)` |Optional |Probes a specified target on a
SCSI bus. Additional information: link:#trantgtprobe-entry-point[ Entry Point]

|`tran++_++unquiesce(9E)` |Optional |Resumes I/O activity on a SCSI bus
after `tran++_++quiesce(9E)` has been called, typically for dynamic
reconfiguration. Additional information: link:#dynamic-reconfiguration[Dynamic
Reconfiguration]
|===

[[entry-points-for-pc-card-drivers]]
==== Entry Points for PC Card Drivers

The following table lists additional entry points that can be used by PC
Card device drivers. For other entry points, see link:#entry-points-common-to-all-drivers[Entry
Points Common to All Drivers] and link:#entry-points-for-character-device-drivers[Entry Points for Character
Device Drivers].

.Entry Points for PC Card Drivers Only
[width="100%",cols="30%,11%,59%",options="header",]
|===
|Entry Point |Usage |Description
|`csx++_++event++_++handler(9E)` |Required |Handles events for a PC Card
driver. The driver must call the `csx++_++RegisterClient(9F)` function
explicitly to set the entry point instead of using a structure field
like `cb++_++ops`.
|===

[[considerations-in-device-driver-design]]
=== Considerations in Device Driver Design

A device driver must be compatible with illumos, both as a consumer and
provider of services. This section discusses the following issues, which
should be considered in device driver design:

* link:#ddidki-facilities[DDI/DKI Facilities]
* link:#driver-context[Driver Context]
* link:#returning-errors[Returning Errors]
* link:#dynamic-memory-allocation[Dynamic Memory Allocation]
* link:#hotplugging[Hotplugging]

[[ddidki-facilities]]
==== DDI/DKI Facilities

The illumos DDI/DKI interfaces are provided for
driver portability. With DDI/DKI, developers can write driver code in a
standard fashion without having to worry about hardware or platform
differences. This section describes aspects of the DDI/DKI interfaces.

[[device-ids]]
===== Device IDs

The DDI interfaces enable drivers to provide a persistent, unique
identifier for a device. The device ID can be used to identify or locate
a device. The ID is independent of the device's name or number
(`dev++_++t`). Applications can use the functions defined in
`libdevid(3LIB)` to read and manipulate the device IDs registered by the
drivers.

[[device-properties]]
===== Device Properties

The attributes of a device or device driver are specified by
_properties_. A property is a name-value pair. The name is a string that
identifies the property with an associated value. Properties can be
defined by the FCode of a self-identifying device, by a hardware
configuration file (see the `driver.conf(5)` man page), or by the driver
itself using the `ddi++_++prop++_++update(9F)` family of routines.

[[interrupt-handling]]
===== Interrupt Handling

interrupt handling

The DDI/DKI addresses the following aspects of device interrupt
handling:

* Registering device interrupts with the system
* Removing device interrupts
* Dispatching interrupts to interrupt handlers

Device interrupt sources are contained in
a property called _interrupt_, which is either provided by the PROM of a
self-identifying device, in a hardware configuration file, or by the
booting system on the x86 platform.

[[callback-functions]]
===== Callback Functions

Certain DDI mechanisms provide a _callback_ mechanism. DDI functions
provide a mechanism for scheduling a callback when a condition is met.
Callback functions can be used for the following typical conditions:

* A transfer has completed
* A resource has become available
* A time-out period has expired

Callback functions are somewhat similar to
entry points, for example, interrupt handlers. DDI functions that allow
callbacks expect the callback function to perform certain tasks. In the
case of DMA routines, a callback function must return a value indicating
whether the callback function needs to be rescheduled in case of a
failure.

Callback functions execute as a separate interrupt thread. Callbacks
must handle all the usual multithreading issues.

[NOTE]

A driver must cancel all scheduled callback functions before detaching a
device.
===

[[software-state-management]]
===== Software State Management

To assist device driver writers in allocating state
structures, the DDI/DKI provides a set of memory management routines
called the _software state management routines_, also known as the
_soft-state routines_. These routines dynamically allocate, retrieve,
and destroy memory items of a specified size, and hide the details of
list management. An _instance number_ is used to identify the desired
memory item. This number is typically the instance number assigned by
the system.

Routines are provided for the following tasks:

* Initialize a driver's soft-state list
* Allocate space for an instance of a driver's soft state
* Retrieve a pointer to an instance of a driver's soft state
* Free the memory for an instance of a driver's soft state
* Finish using a driver's soft-state list

See link:#loadable-driver-interfaces[Loadable Driver Interfaces] for an example of
how to use these routines.

[[programmed-io-device-access]]
===== Programmed I/O Device Access

Programmed I/O device access is the act of reading and writing of device
registers or device memory by the host CPU. The illumos DDI provides
interfaces for mapping a device's registers or memory by the kernel as
well as interfaces for reading and writing to device memory from the
driver. These interfaces enable drivers to be developed that are
platform and bus independent, by automatically managing any difference
in device and host endianness as well as by enforcing any memory-store
sequence requirements imposed by the device.

[[direct-memory-access-dma]]
===== Direct Memory Access (DMA)

The illumos platform defines a high-level, architecture-independent
model for supporting DMA-capable devices. The illumos DDI shields
drivers from platform-specific details. This concept enables a common
driver to run on multiple platforms and architectures.

[[layered-driver-interfaces]]
===== Layered Driver Interfaces

The DDI/DKI provides a group of interfaces referred to as layered device
interfaces (LDI). These interfaces enable a device to be accessed from
within the illumos kernel. This capability enables developers to write
applications that observe kernel device usage. For example, both the
`prtconf(8)` and `fuser(8)` commands use LDI to enable system
administrators to track aspects of device usage. The LDI is covered in
more detail in link:#layered-driver-interface-ldi[Layered Driver Interface (LDI)].

[[driver-context]]
==== Driver Context

The driver context refers to
the condition under which a driver is currently operating. The context
limits the operations that a driver can perform. The driver context
depends on the executing code that is invoked. Driver code executes in
four contexts:

* *User context*. A driver entry point has _user context_ when invoked
by a user thread in a synchronous fashion. That is, the user thread
waits for the system to return from the entry point that was invoked.
For example, the `read(9E)` entry point of the driver has user context
when invoked by a `read(2)` system call. In this case, the driver has
access to the user area for copying data into and out of the user
thread.
* *Kernel context*. A driver function has _kernel context_ when invoked
by some part of the kernel. In a block device driver, the `strategy(9E)`
entry point can be called by the `pageout` daemon to write pages to the
device. Because the page daemon has no relation to the current user
thread, `strategy(9E)` has kernel context in this case.
* *Interrupt context*. _Interrupt context_ is a more restrictive form of
kernel context. Interrupt context is invoked as a result of the
servicing of an interrupt. Driver interrupt routines operate in
interrupt context with an associated interrupt level. Callback routines
also operate in an interrupt context. See
link:#interrupt-handlers[Interrupt Handlers] for more information.
* *High-level interrupt context*. _High-level interrupt context_ is a
more restricted form of interrupt context. If
`ddi++_++intr++_++hilevel(9F)` indicates that an interrupt is high
level, the driver interrupt handler runs in high-level interrupt
context. See link:#interrupt-handlers[Interrupt Handlers] for more
information.

The manual pages in section 9F document the allowable contexts for each
function. For example, in kernel context the driver must not call
`copyin(9F)`.

[[returning-errors]]
==== Returning Errors

drivers do not usually print messages, except for unexpected errors such
as data corruption. Instead, the driver entry points should return error
codes so that the application can determine how to handle the error. Use
the `cmn++_++err(9F)` function to write messages to a system log that
can then be displayed on the console.

The format string specifier interpreted by `cmn++_++err(9F)` is similar
to the `printf(3C)` format string specifier, with the addition of the
format `%b`, which prints bit fields. The first character of the format
string can have a special meaning. Calls to `cmn++_++err(9F)` also
specify the message ++<++level++>++, which indicates the severity label
to be printed. See the `cmn++_++err(9F)` man page for more details.

The level `CE++_++PANIC` has the side effect of crashing the system.
This level should be used only if the system is in such an unstable
state that to continue would cause more problems. The level can also be
used to get a system core dump when debugging. `CE++_++PANIC` should not
be used in production device drivers.

[[dynamic-memory-allocation]]
==== Dynamic Memory Allocation

Device drivers must be prepared to
simultaneously handle all attached devices that the drivers claim to
drive. The number of devices that the driver handles should not be
limited. All per-device information must be dynamically allocated.

`void ++*++kmem++_++alloc(size++_++t size, int flag);`

standard kernel memory allocation routine is `kmem++_++alloc(9F)`.
`kmem++_++alloc` is similar to the C library routine `malloc(3C)`, with
the addition of the `flag` argument. The `flag` argument can be either
`KM++_++SLEEP` or `KM++_++NOSLEEP`, indicating whether the caller is
willing to block if the requested size is not available. If
`KM++_++NOSLEEP` is set and memory is not available,
`kmem++_++alloc(9F)` returns `NULL`.

`kmem++_++zalloc(9F)` is similar to `kmem++_++alloc(9F)`, but also
clears the contents of the allocated memory.

[NOTE]

Kernel memory is a limited resource, not pageable, and competes with
user applications and the rest of the kernel for physical memory.
Drivers that allocate a large amount of kernel memory can cause system
performance to degrade.
===

`void kmem++_++free(void ++*++cp, size++_++t size);`

Memory allocated by `kmem++_++alloc(9F)` or by `kmem++_++zalloc(9F)` is
returned to the system with `kmem++_++free(9F)`. `kmem++_++free` is
similar to the C library routine `free(3C)`, with the addition of the
`size` argument. Drivers _must_ keep track of the size of each allocated
object in order to call `kmem++_++free(9F)` later.

[[hotplugging]]
==== Hotplugging

hot-plug

hotpluggable drivers

This manual does not highlight hotplugging
information. If you follow the rules and suggestions for writing device
drivers given in this book, your driver should be able to handle
hotplugging. In particular, make sure that both autoconfiguration (see
link:#driver-autoconfiguration[Driver Autoconfiguration]) and `detach(9E)` work
correctly in your driver. In addition, if you are designing a driver
that uses power management, you should follow the information given in
link:#power-management[Power Management]. SCSI HBA drivers might need to
add a `cb++_++ops` structure to their `dev++_++ops` structure (see
link:#scsi-host-bus-adapter-drivers[SCSI Host Bus Adapter Drivers]) to take advantage of
hotplugging capabilities.

Previous versions of the Solaris OS required hotpluggable drivers to
include a DT++_++HOTPLUG property, but this property is no longer
required. Driver writers are free, however, to include and use the
DT++_++HOTPLUG property as they see fit.

[[illumos-kernel-and-device-tree]]
=== illumos Kernel and Device Tree

A device driver needs to work transparently as an integral part of the
operating system. Understanding how the kernel works is a prerequisite
for learning about device drivers. This chapter provides an overview of
the illumos kernel and device tree. For an overview of how device
drivers work, see link:#overview-of-illumos-device-drivers[Overview of illumos Device Drivers].

This chapter provides information on the following subjects:

* link:#what-is-the-kernel[What Is the Kernel?]
* link:#multithreaded-execution-environment[Multithreaded Execution Environment]
* link:#virtual-memory[Virtual Memory]
* link:#devices-as-special-files[Devices as Special Files]
* link:#ddidki-interfaces[DDI/DKI Interfaces]
* link:#device-tree-components[Device Tree Components]
* link:#displaying-the-device-tree[Displaying the Device Tree]
* link:#binding-a-driver-to-a-device[Binding a Driver to a Device]

[[what-is-the-kernel]]
=== What Is the Kernel?

The illumos kernel is a program that
manages system resources. The kernel insulates applications from the
system hardware and provides them with essential system services such as
input/output (I/O) management, virtual memory, and scheduling. The
kernel consists of object modules that are dynamically loaded into
memory when needed.

The illumos kernel can be divided logically into two parts: the first
part, referred to as the _kernel_, manages file systems, scheduling, and
virtual memory. The second part, referred to as the _I/O subsystem_,
manages the physical components.

The kernel provides a set
of interfaces for applications to use that are accessible through
_system calls_. System calls are documented in section 2 of the
Reference Manual Collection (see `Intro(2)`). Some system calls are used
to invoke device drivers to perform I/O. _Device drivers_ are loadable
kernel modules that manage data transfers while insulating the rest of
the kernel from the device hardware. To be compatible with the operating
system, device drivers need to be able to accommodate such features as
multithreading, virtual memory addressing, and both 32-bit and 64-bit
operation.

The following figure illustrates the kernel. The kernel modules handle
system calls from application programs. The I/O modules communicate with
hardware.

.illumos Kernel
[#kernelovr-fig-19]
image::figures/kernelovr-arch.png[Diagram shows calls from user-level applications to specific kernel-level modules, and calls between drivers and other modules to devices.]

The kernel provides access to device drivers through the following
features:

* *Device-to-driver mapping*. The kernel
maintains the _device tree_. Each node in the tree represents a virtual
or a physical device. The kernel binds each node to a driver by matching
the device node name with the set of drivers installed in the system.
The device is made accessible to applications only if there is a driver
binding.
* *DDI/DKI interfaces*. DDI/DKI (Device
Driver Interface/Driver-Kernel Interface) interfaces standardize
interactions between the driver and the kernel, the device hardware, and
the boot/configuration software. These interfaces keep the driver
independent from the kernel and improve the driver's portability across
successive releases of the operating system on a particular machine.
* *LDI*. The LDI (Layered Driver Interface) is an extension of the
DDI/DKI. The LDI enables a kernel module to access other devices in the
system. The LDI also enables you to determine which devices are
currently being used by the kernel. See link:#layered-driver-interface-ldi[Layered Driver
Interface (LDI)].

[[multithreaded-execution-environment]]
==== Multithreaded Execution Environment

The illumos kernel is multithreaded. On a multiprocessor
machine, multiple kernel threads can be running kernel code, and can do
so concurrently. Kernel threads can also be preempted by other kernel
threads at any time.

The multithreading of the kernel imposes some additional restrictions on
device drivers. For more information on multithreading considerations,
see link:#multithreading[Multithreading]. Device drivers must be coded to run
as needed at the request of many different threads. For each thread, a
driver must handle contention problems from overlapping I/O requests.

[[virtual-memory]]
==== Virtual Memory

A complete overview of the illumos virtual memory system is beyond the
scope of this book, but two virtual memory terms of special importance
are used when discussing device drivers: virtual address and address
space.

* *Virtual
address*. A _virtual address_ is an address that is mapped by the memory
management unit (MMU) to a physical hardware address. All addresses
directly accessible by the driver are kernel virtual addresses. Kernel
virtual addresses refer to the _kernel address space_.
* *Address
space*. An _address space_ is a set of _virtual address segments_. Each
segment is a contiguous range of virtual addresses. Each user process
has an address space called the _user address space_. The kernel has its
own address space, called the _kernel address space_.

[[devices-as-special-files]]
==== Devices as Special Files

Devices are represented in
the file system by _special files_. In illumos, these files reside in
the `/devices` directory hierarchy.

Special files can be of type _block_ or _character_. The type indicates
which kind of device driver operates the device. Drivers can be
implemented to operate on both types. For example, disk drivers export a
character interface for use by the `fsck(1)` and `mkfs(1)` utilities,
and a block interface for use by the file system.

with each special file is a _device number_ (`dev++_++t`). A device
number consists of a _major number_ and a _minor number_. The _major_
number identifies the device driver associated with the special file.
The _minor_ number is created and used by the device driver to further
identify the special file. Usually, the minor number is an encoding that
is used to identify which device instance the driver should access and
which type of access should be performed. For example, the minor number
can identify a tape device used for backup and can specify that the tape
needs to be rewound when the backup operation is complete.

[[ddidki-interfaces]]
==== DDI/DKI Interfaces

In System V Release 4 (SVR4), the interface between device drivers and
the rest of the UNIX kernel was standardized as the DDI/DKI. The DDI/DKI
is documented in section 9 of the Reference Manual Collection. Section
9E documents driver entry points, section 9F documents driver-callable
functions, and section 9S documents kernel data structures used by
device drivers. See `Intro(9E)`, `Intro(9F)`, and `Intro(9S)`.

DDI/DKI is intended to standardize and document all interfaces between
device drivers and the rest of the kernel. In addition, the DDI/DKI
enables source and binary compatibility for drivers on any machine that
runs illumos, regardless of the processor architecture, whether SPARC or
x86. Drivers that use only kernel facilities that are part of the
DDI/DKI are known as _DDI/DKI-compliant device drivers_.

The DDI/DKI enables you to write platform-independent device drivers for
any machine that runs illumos. These binary-compatible drivers enable
you to more easily integrate third-party hardware and software into any
machine that runs illumos. The DDI/DKI is architecture independent,
which enables the same driver to work across a diverse set of machine
architectures.

Platform independence is accomplished by the design of DDI in the
following areas:

* Dynamic loading and unloading of modules
* Power management
* Interrupt handling
* Accessing the device space from the kernel or a user process, that is,
register mapping and memory mapping
* Accessing kernel or user process space from the device using DMA
* Managing device properties

[[overview-of-the-device-tree]]
=== Overview of the Device Tree

Devices in illumos are represented as a tree of interconnected device
information nodes. The device tree describes the configuration of loaded
devices for a particular machine.

[[device-tree-components]]
==== Device Tree Components

system builds a tree structure that contains information about the
devices connected to the machine at boot time. The device tree can also
be modified by dynamic reconfiguration operations while the system is in
normal operation. The tree begins at the root device node, which
represents the platform.

Below the root node are the branches of the device tree. A branch
consists of one or more bus nexus devices and a terminating leaf device.

A _bus nexus device_ provides bus mapping and translation services to
subordinate devices in the device tree. PCI - PCI bridges, PCMCIA
adapters, and SCSI HBAs are all examples of nexus devices. The
discussion of writing drivers for nexus devices is limited to the
development of SCSI HBA drivers (see link:#scsi-host-bus-adapter-drivers[SCSI Host Bus
Adapter Drivers]).

_Leaf devices_ are typically peripheral devices such as disks, tapes,
network adapters, frame buffers, and so forth. Leaf device drivers
export the traditional character driver interfaces and block driver
interfaces. The interfaces enable user processes to read data from and
write data to either storage or communication devices.

The system goes through the following steps to build the tree:

[arabic]
. The CPU is initialized and searches for firmware.
. The main firmware (OpenBoot, Basic Input/Output System (BIOS), or
`Bootconf`) initializes and creates the device tree with known or
self-identifying hardware.
. When the main firmware finds compatible firmware on a device, the main
firmware initializes the device and retrieves the device's properties.
. The firmware locates and boots the operating system.
. The kernel starts at the root node of the tree, searches for a
matching device driver, and binds that driver to the device.
. If the device is a nexus, the kernel looks for child devices that have
not been detected by the firmware. The kernel adds any child devices to
the tree below the nexus node.
. The kernel repeats the process from Step 5 until no further device
nodes need to be created.

Each driver exports a device operations structure `dev++_++ops(9S)` to
define the operations that the device driver can perform. The device
operations structure contains function pointers for generic operations
such as `attach(9E)`, `detach(9E)`, and `getinfo(9E)`. The structure
also contains a pointer to a set of operations specific to bus nexus
drivers and a pointer to a set of operations specific to leaf drivers.

The tree structure creates a parent-child relationship between nodes.
This parent-child relationship is the key to architectural independence.
When a leaf or bus nexus driver requires a service that is
architecturally dependent in nature, that driver requests its parent to
provide the service. This approach enables drivers to function
regardless of the architecture of the machine or the processor. A
typical device tree is shown in the following figure.

.Example Device Tree
[#kernelovr-fig-9]
image::figures/kernelovr-devtree.png[Diagram shows leaves and nodes in a typical device tree.]

The nexus nodes can have one or more children. The leaf nodes represent
individual devices.

[[displaying-the-device-tree]]
==== Displaying the Device Tree

The device tree can be displayed in three ways:

* The `libdevinfo` library provides interfaces to access the contents of
the device tree programmatically.
* The `prtconf(8)` command displays the complete contents of the device
tree.
* The `/devices` hierarchy is a representation of the device tree. Use
the `ls(1)` command to view the hierarchy.

[NOTE]

`/devices` displays only devices that have drivers configured into the
system. The `prtconf(8)` command shows all device nodes regardless of
whether a driver for the device exists on the system.
===

[[libdevinfo-library]]
===== `libdevinfo` Library

The `libdevinfo` library provides interfaces for
accessing all public device configuration data. See the
`libdevinfo(3LIB)` man page for a list of interfaces.

[[prtconf-command]]
===== `prtconf` Command

The following excerpted `prtconf(8)` command example
displays all the devices in the system.

....
System Configuration:  Sun Microsystems  sun4u
Memory size: 128 Megabytes
System Peripherals (Software Nodes):

SUNW,Ultra-5_10
    packages (driver not attached)
        terminal-emulator (driver not attached)
        deblocker (driver not attached)
        obp-tftp (driver not attached)
        disk-label (driver not attached)
        SUNW,builtin-drivers (driver not attached)
        sun-keyboard (driver not attached)
        ufs-file-system (driver not attached)
    chosen (driver not attached)
    openprom (driver not attached)
        client-services (driver not attached)
    options, instance #0
    aliases (driver not attached)
    memory (driver not attached)
    virtual-memory (driver not attached)
    pci, instance #0
        pci, instance #0
            ebus, instance #0
                auxio (driver not attached)
                power, instance #0
                SUNW,pll (driver not attached)
                se, instance #0
                su, instance #0
                su, instance #1
                ecpp (driver not attached)
                fdthree, instance #0
                eeprom (driver not attached)
                flashprom (driver not attached)
                SUNW,CS4231 (driver not attached)
            network, instance #0
            SUNW,m64B (driver not attached)
            ide, instance #0
                disk (driver not attached)
                cdrom (driver not attached)
                dad, instance #0
                sd, instance #15
        pci, instance #1
            pci, instance #0
                pci108e,1000 (driver not attached)
                SUNW,hme, instance #1
                SUNW,isptwo, instance #0
                    sd (driver not attached)
                    st (driver not attached)
                    sd, instance #0 (driver not attached)
                    sd, instance #1 (driver not attached)
                    sd, instance #2 (driver not attached)
                    ...
    SUNW,UltraSPARC-IIi (driver not attached)
    SUNW,ffb, instance #0
    pseudo, instance #0
....

[[devices-directory]]
===== `/devices` Directory

The `/devices` hierarchy provides a namespace that
represents the device tree. Following is an abbreviated listing of the
`/devices` namespace. The sample output corresponds to the example
device tree and `prtconf(8)` output shown previously.

....
/devices
/devices/pseudo
/devices/pci@1f,0:devctl
/devices/SUNW,ffb@1e,0:ffb0
/devices/pci@1f,0
/devices/pci@1f,0/pci@1,1
/devices/pci@1f,0/pci@1,1/SUNW,m64B@2:m640
/devices/pci@1f,0/pci@1,1/ide@3:devctl
/devices/pci@1f,0/pci@1,1/ide@3:scsi
/devices/pci@1f,0/pci@1,1/ebus@1
/devices/pci@1f,0/pci@1,1/ebus@1/power@14,724000:power_button
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:a
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:b
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:0,hdlc
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:1,hdlc
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:a,cu
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:b,cu
/devices/pci@1f,0/pci@1,1/ebus@1/ecpp@14,3043bc:ecpp0
/devices/pci@1f,0/pci@1,1/ebus@1/fdthree@14,3023f0:a
/devices/pci@1f,0/pci@1,1/ebus@1/fdthree@14,3023f0:a,raw
/devices/pci@1f,0/pci@1,1/ebus@1/SUNW,CS4231@14,200000:sound,audio
/devices/pci@1f,0/pci@1,1/ebus@1/SUNW,CS4231@14,200000:sound,audioctl
/devices/pci@1f,0/pci@1,1/ide@3
/devices/pci@1f,0/pci@1,1/ide@3/sd@2,0:a
/devices/pci@1f,0/pci@1,1/ide@3/sd@2,0:a,raw
/devices/pci@1f,0/pci@1,1/ide@3/dad@0,0:a
/devices/pci@1f,0/pci@1,1/ide@3/dad@0,0:a,raw
/devices/pci@1f,0/pci@1
/devices/pci@1f,0/pci@1/pci@2
/devices/pci@1f,0/pci@1/pci@2/SUNW,isptwo@4:devctl
/devices/pci@1f,0/pci@1/pci@2/SUNW,isptwo@4:scsi
....

[[binding-a-driver-to-a-device]]
==== Binding a Driver to a Device

In addition
to constructing the device tree, the kernel determines the drivers that
are used to manage the devices.

Binding a driver to a device refers to
the process by which the system selects a driver to manage a particular
device. The binding name is the name that links a driver to a unique
device node in the device information tree. For each device in the
device tree, the system attempts to choose a driver from a list of
installed drivers.

Each device node has an
associated _name_ property. This property can be assigned either from an
external agent, such as the PROM, during system boot or from a
`driver.conf` configuration file. In any case, the `name` property
represents the `node name` assigned to a device in the device tree. The
`node name` is the name visible in `/devices` and listed in the
`prtconf(8)` output.

.Device Node Names
[#kernelovr-fig-15]
image::figures/kernelovr-devnodenames.png[Diagram shows a simple example of device node names.]

A device node can have an associated _compatible_
property as well. The _compatible_ property contains an ordered list of
one or more possible driver names or driver aliases for the device.

The system uses both the _compatible_ and the _name_ properties to
select a driver for the device. The system first attempts to match the
contents of the _compatible_ property, if the _compatible_ property
exists, to a driver on the system. Beginning with the first driver name
on the _compatible_ property list, the system attempts to match the
driver name to a known driver on the system. Each entry on the list is
processed until the system either finds a match or reaches the end of
the list.

If the contents of either the _name_ property or the _compatible_
property match a driver on the system, then that driver is bound to the
device node. If no match is found, no driver is bound to the device
node.

[[generic-device-names]]
===== Generic Device Names

Some devices specify a _generic_ device name as the
value for the _name_ property. Generic device names describe the
function of a device without actually identifying a specific driver for
the device. For example, a SCSI host bus adapter might have a generic
device name of `scsi`. An Ethernet device might have a generic device
name of `ethernet`.

The _compatible_ property enables the system to determine alternate
driver names for devices with a generic device name, for example, `glm`
for `scsi` HBA device drivers or `hme` for `ethernet` device drivers.

Devices with generic device names are required to supply a _compatible_
property.

[NOTE]

For a complete description of _generic device names_, see the IEEE 1275
Open Firmware Boot Standard.
===

The following figure shows a device node with a specific device name.
The driver binding name `SUNW,ffb` is the same name as the device node
name.

.Specific Driver Node Binding
[#kernelovr-fig-17]
image::figures/kernelovr-specdevnodebinding.png[Diagram shows a device node using a specific device name: SUNW, ffb.]

The following figure shows a device node with the generic device name
`display`. The driver binding name `SUNW,ffb` is the first name on the
_compatible_ property driver list that matches a driver on the system
driver list. In this case, `display` is a generic device name for frame
buffers.

.Generic Driver Node Binding
[#kernelovr-fig-18]
image::figures/kernelovr-gendevnodebinding.png[Diagram shows a device node using a generic device name: display.]

[[multithreading]]
=== Multithreading

This chapter describes the locking primitives and thread synchronization
mechanisms of the illumos multithreaded kernel. You should design device
drivers to take advantage of multithreading. This chapter provides
information on the following subjects:

* link:#locking-primitives[Locking Primitives]
* link:#thread-synchronization[Thread Synchronization]
* link:#choosing-a-locking-scheme[Choosing a Locking Scheme]

[[locking-primitives]]
=== Locking Primitives

traditional UNIX systems, every section of kernel code terminates either
through an explicit call to `sleep(1)` to give up the processor or
through a hardware interrupt. illumos operates differently. A kernel
thread can be preempted at any time to run another thread. Because all
kernel threads share kernel address space and often need to read and
modify the same data, the kernel provides a number of locking primitives
to prevent threads from corrupting shared data. These mechanisms include
mutual exclusion locks, which are also known as _mutexes_,
readers/writer locks, and semaphores.

[[storage-classes-of-driver-data]]
==== Storage Classes of Driver Data

The storage class of data is a
guide to whether the driver might need to take explicit steps to control
access to the data. The three data storage classes are:

* *Automatic (stack) data*. Every thread has a private stack, so drivers
never need to lock automatic variables.
* *Global static data*. Global static data can be shared by any number
of threads in the driver. The driver might need to lock this type of
data at times.
* *Kernel heap data*. Any number of threads in the driver can share
kernel heap data, such as data allocated by `kmem++_++alloc(9F)`. The
driver needs to protect shared data at all times.

[[mutual-exclusion-locks]]
==== Mutual-Exclusion Locks

thread synchronization

mutex locks

mutual-exclusion locks

A mutual-exclusion lock, or _mutex_, is
usually associated with a set of data and regulates access to that data.
Mutexes provide a way to allow only one thread at a time access to that
data. The mutex functions are:

`mutex++_++destroy(9F)`::
  Releases any associated storage.
`mutex++_++enter(9F)`::
  Acquires a mutex.
`mutex++_++exit(9F)`::
  Releases a mutex.
`mutex++_++init(9F)`::
  Initializes a mutex.
`mutex++_++owned(9F)`::
  Tests to determine whether the mutex is held by the current thread. To
  be used in `ASSERT(9F)` only.
`mutex++_++tryenter(9F)`::
  Acquires a mutex if available, but does not block.

[[setting-up-mutexes]]
===== Setting Up Mutexes

Device drivers usually
allocate a mutex for each driver data structure. The mutex is typically
a field in the structure of type `kmutex++_++t`. `mutex++_++init(9F)` is
called to prepare the mutex for use. This call is usually made at
`attach(9E)` time for per-device mutexes and `++_++init(9E)` time for
global driver mutexes.

For example,

[source,c]
----
struct xxstate *xsp;
/* ... */
mutex_init(&xsp->mu, NULL, MUTEX_DRIVER, NULL);
/* ... */
----

For a more complete example of mutex initialization, see
link:#driver-autoconfiguration[Driver Autoconfiguration].

The driver must destroy the mutex with `mutex++_++destroy(9F)` before
being unloaded. Destroying the mutex is usually done at `detach(9E)`
time for per-device mutexes and `++_++fini(9E)` time for global driver
mutexes.

[[using-mutexes]]
===== Using Mutexes

Every section of the driver code that needs to read or write the shared
data structure must do the following tasks:

* Acquire the mutex
* Access the data
* Release the mutex

The scope of a mutex, that is, the data the mutex protects, is entirely
up to the programmer. A mutex protects a data structure only if every
code path that accesses the data structure does so while holding the
mutex.

[[readerswriter-locks]]
==== Readers/Writer Locks

thread synchronization

readers/writer locks

A _readers/writer lock_
regulates access to a set of data. The readers/writer lock is so called
because many threads can hold the lock simultaneously for reading, but
only one thread can hold the lock for writing.

Most device drivers do not use readers/writer locks. These locks are
slower than mutexes. The locks provide a performance gain only when they
protect commonly read data that is not frequently written. In this case,
contention for a mutex could become a bottleneck, so using a
readers/writer lock might be more efficient. The readers/writer
functions are summarized in the following table. See the `rwlock(9F)`
man page for detailed information. The readers/writer lock functions
are:

`rw++_++destroy(9F)`::
  Destroys a readers/writer lock
`rw++_++downgrade(9F)`::
  Downgrades a readers/writer lock holder from writer to reader
`rw++_++enter(9F)`::
  Acquires a readers/writer lock
`rw++_++exit(9F)`::
  Releases a readers/writer lock
`rw++_++init(9F)`::
  Initializes a readers/writer lock
`rw++_++read++_++locked(9F)`::
  Determines whether a readers/writer lock is held for read or write
`rw++_++tryenter(9F)`::
  Attempts to acquire a readers/writer lock without waiting
`rw++_++tryupgrade(9F)`::
  Attempts to upgrade readers/writer lock holder from reader to writer

[[semaphores]]
==== Semaphores

Counting semaphores are available as an alternative primitive for
managing threads within device drivers. See the `semaphore(9F)` man page
for more information. The semaphore functions are:

`sema++_++destroy(9F)`::
  Destroys a semaphore.
`sema++_++init(9F)`::
  Initialize a semaphore.
`sema++_++p(9F)`::
  Decrement semaphore and possibly block.
`sema++_++p++_++sig(9F)`::
  Decrement semaphore but do not block if signal is pending. See
  link:#threads-unable-to-receive-signals[Threads Unable to Receive Signals].
`sema++_++tryp(9F)`::
  Attempt to decrement semaphore, but do not block.
`sema++_++v(9F)`::
  Increment semaphore and possibly unblock waiter.

[[thread-synchronization]]
=== Thread Synchronization

In addition to protecting shared data, drivers often need to synchronize
execution among multiple threads.

[[condition-variables-in-thread-synchronization]]
==== Condition Variables in Thread Synchronization

thread synchronization

condition variables

Condition variables
are a standard form of thread synchronization. They are designed to be
used with mutexes. The associated mutex is used to ensure that a
condition can be checked atomically, and that the thread can block on
the associated condition variable without missing either a change to the
condition or a signal that the condition has changed.

The `condvar(9F)` functions are:

`cv++_++broadcast(9F)`::
  Signals all threads waiting on the condition variable.
`cv++_++destroy(9F)`::
  Destroys a condition variable.
`cv++_++init(9F)`::
  Initializes a condition variable.
`cv++_++signal(9F)`::
  Signals one thread waiting on the condition variable.
`cv++_++timedwait(9F)`::
  Waits for condition, time-out, or signal. See link:#threads-unable-to-receive-signals[Threads
  Unable to Receive Signals].
`cv++_++timedwait++_++sig(9F)`::
  Waits for condition or time-out.
`cv++_++wait(9F)`::
  Waits for condition.
`cv++_++wait++_++sig(9F)`::
  Waits for condition or return zero on receipt of a signal. See
  link:#threads-unable-to-receive-signals[Threads Unable to Receive Signals].

[[initializing-condition-variables]]
===== Initializing Condition Variables

a condition variable of type `kcondvar++_++t` for each condition.
Usually, the condition variables are declared in the driver's soft-state
structure. Use `cv++_++init(9F)` to initialize each condition variable.
Similar to mutexes, condition variables are usually initialized at
`attach(9E)` time. A typical example of initializing a condition
variable is:

....
cv_init(&xsp->cv, NULL, CV_DRIVER, NULL);
....

For a more complete example of condition
variable initialization, see link:#driver-autoconfiguration[Driver
Autoconfiguration].

[[waiting-for-the-condition]]
===== Waiting for the Condition

To use condition variables, follow these steps in the code path waiting
for the condition:

[arabic]
. Acquire the mutex guarding the condition.
. Test the condition.
.  If the test results do not allow the thread
to continue, use `cv++_++wait(9F)` to block the current thread on the
condition. The `cv++_++wait(9F)` function releases the mutex before
blocking the thread and reacquires the mutex before returning. On return
from `cv++_++wait(9F)`, repeat the test.
. After the test allows the thread to continue, set the condition to its
new value. For example, set a device flag to busy.
. Release the mutex.

[[signaling-the-condition]]
===== Signaling the Condition

Follow these steps in the code path to signal the condition:

[arabic]
. Acquire the mutex guarding the condition.
. Set the condition.
. Signal the blocked thread with
`cv++_++broadcast(9F)`.
. Release the mutex.

The following example uses a busy flag along with mutex and condition
variables to force the `read(9E)` routine to wait until the device is no
longer busy before starting a transfer.

[[mt-28544]]
Using Mutexes and Condition Variables

[source,c]
----
static int
xxread(dev_t dev, struct uio *uiop, cred_t *credp)
{
        struct xxstate *xsp;
        /* ... */
        mutex_enter(&xsp->mu);
        while (xsp->busy)
                cv_wait(&xsp->cv, &xsp->mu);
        xsp->busy = 1;
        mutex_exit(&xsp->mu);
        /* perform the data access */
}

static uint_t
xxintr(caddr_t arg)
{
        struct xxstate *xsp = (struct xxstate *)arg;
        mutex_enter(&xsp->mu);
        xsp->busy = 0;
        cv_broadcast(&xsp->cv);
        mutex_exit(&xsp->mu);
}
----

[[cvwait-and-cvtimedwait-functions]]
==== `cv++_++wait` and `cv++_++timedwait` Functions

If a thread is blocked on a condition with
`cv++_++wait(9F)` and that condition does not occur, the thread would
wait forever. To avoid that situation, use `cv++_++timedwait(9F)`, which
depends upon another thread to perform a wakeup. `cv++_++timedwait`
takes an absolute wait time as an argument. `cv++_++timedwait` returns
`-1` if the time is reached and the event has not occurred.
`cv++_++timedwait` returns a positive value if the condition is met.

`cv++_++timedwait(9F)` requires an absolute wait time expressed in clock
ticks since the system was last rebooted. The wait time can be
determined by retrieving the current value with
`ddi++_++get++_++lbolt(9F)`. The driver usually has a maximum number of
seconds or microseconds to wait, so this value is converted to clock
ticks with `drv++_++usectohz(9F)` and added to the value from
`ddi++_++get++_++lbolt(9F)`.

The following example shows how to use `cv++_++timedwait(9F)` to wait up
to five seconds to access the device before returning `EIO` to the
caller.

[[mt-14239]]
Using `cv++_++timedwait`

[source,c]
----
clock_t            cur_ticks, to;
mutex_enter(&xsp->mu);
while (xsp->busy) {
        cur_ticks = ddi_get_lbolt();
        to = cur_ticks + drv_usectohz(5000000); /* 5 seconds from now */
        if (cv_timedwait(&xsp->cv, &xsp->mu, to) == -1) {
                /*
                 * The timeout time 'to' was reached without the
                 * condition being signaled.
                 */
                /* tidy up and exit */
                mutex_exit(&xsp->mu);
                return (EIO);
        }
}
xsp->busy = 1;
mutex_exit(&xsp->mu);
----

Although device driver writers generally prefer to use
`cv++_++timedwait(9F)` over `cv++_++wait(9F)`, sometimes
`cv++_++wait(9F)` is a better choice. For example, `cv++_++wait(9F)` is
better if a driver is waiting on the following conditions:

* Internal driver state changes, where such a state change might require
some command to be executed, or a set amount of time to pass
* Something the driver needs to single-thread
* Some situation that is already managing a possible timeout, as when
“A” depends on “B,” and “B” is using `cv++_++timedwait(9F)`

[[cvwaitsig-function]]
==== `cv++_++wait++_++sig` Function

A driver might be waiting for a condition that cannot occur or will not
happen for a long time. In such cases, the user can send a signal to
abort the thread. Depending on the driver design, the signal might not
cause the driver to wake up.

`cv++_++wait++_++sig(9F)` allows a signal to
unblock the thread. This capability enables the user to break out of
potentially long waits by sending a signal to the thread with `kill(1)`
or by typing the interrupt character. `cv++_++wait++_++sig(9F)` returns
zero if it is returning because of a signal, or nonzero if the condition
occurred. However, see link:#threads-unable-to-receive-signals[Threads Unable to Receive Signals]
for cases in which signals might not be received.

The following example shows how to use `cv++_++wait++_++sig(9F)` to
allow a signal to unblock the thread.

[[mt-41633]]
Using `cv++_++wait++_++sig`

[source,c]
----
mutex_enter(&xsp->mu);
while (xsp->busy) {
        if (cv_wait_sig(&xsp->cv, &xsp->mu) == 0) {
        /* Signaled while waiting for the condition */
                /* tidy up and exit */
                mutex_exit(&xsp->mu);
                return (EINTR);
        }
}
xsp->busy = 1;
mutex_exit(&xsp->mu);
----

[[cvtimedwaitsig-function]]
==== `cv++_++timedwait++_++sig` Function

`cv++_++timedwait++_++sig(9F)`
is similar to `cv++_++timedwait(9F)` and `cv++_++wait++_++sig(9F)`,
except that `cv++_++timedwait++_++sig` returns `-1` without the
condition being signaled after a timeout has been reached, or `0` if a
signal (for example, `kill(2)`) is sent to the thread.

For both `cv++_++timedwait(9F)` and `cv++_++timedwait++_++sig(9F)`, time
is measured in absolute clock ticks since the last system reboot.

[[choosing-a-locking-scheme]]
=== Choosing a Locking Scheme

The locking scheme for most device drivers
should be kept straightforward. Using additional locks allows more
concurrency but increases overhead. Using fewer locks is less time
consuming but allows less concurrency. Generally, use one mutex per data
structure, a condition variable for each event or condition the driver
must wait for, and a mutex for each major set of data global to the
driver. Avoid holding mutexes for long periods of time. Use the
following guidelines when choosing a locking scheme:

* Use the multithreading semantics of the entry point to your advantage.
* Make all entry points re-entrant. You can reduce the amount of shared
data by changing a static variable to automatic.
* If your driver acquires multiple mutexes, acquire and release the
mutexes in the same order in all code paths.
* Hold and release locks within the same functional space.
* Avoid holding driver mutexes when calling DDI interfaces that can
block, for example, `kmem++_++alloc(9F)` with `KM++_++SLEEP`.

To look at lock usage, use `lockstat(8)`. `lockstat(8)` monitors all
kernel lock events, gathers frequency and timing data about the events,
and displays the data.

See the Multithreaded Programming Guide for more details on
multithreaded operations.

[[potential-locking-pitfalls]]
==== Potential Locking Pitfalls

Mutexes are not re-entrant by the same thread. If you
already own the mutex, attempting to claim this mutex a second time
leads to the following panic:

`panic: recursive mutex++_++enter. mutex %x caller %x`

Releasing a mutex that the current thread does not hold causes this
panic:

`panic: mutex++_++adaptive++_++exit: mutex not held by thread`

The following panic occurs only on uniprocessors:

`panic: lock++_++set: lock held and only one CPU`

The `lock++_++set` panic indicates that a spin mutex is held and will
spin forever, because no other CPU can release this mutex. This
situation can happen if the driver forgets to release the mutex on one
code path or becomes blocked while holding the mutex.

A common cause of the `lock++_++set` panic occurs when a device with a
high-level interrupt calls a routine that blocks, such as
`cv++_++wait(9F)`. Another typical cause is a high-level handler
grabbing an adaptive mutex by calling `mutex++_++enter(9F)`.

[[threads-unable-to-receive-signals]]
==== Threads Unable to Receive Signals

The `sema++_++p++_++sig`, `cv++_++wait++_++sig`, and
`cv++_++timedwait++_++sig` functions can be awakened when the thread
receives a signal. A problem can arise because some threads are unable
to receive signals. For example, when `close(9E)` is called as a result
of the application calling `close(2)`, signals can be received. However,
when `close(9E)` is called from within the `exit(2)` processing that
closes all open file descriptors, the thread cannot receive signals.
When the thread cannot receive signals, `sema++_++p++_++sig` behaves as
`sema++_++p`, `cv++_++wait++_++sig` behaves as `cv++_++wait`, and
`cv++_++timedwait++_++sig` behaves as `cv++_++timedwait`.

Use caution to avoid sleeping forever on events that might never occur.
Events that never occur create unkillable (`defunct`) threads and make
the device unusable until the system is rebooted. Signals cannot be
received by defunct processes.

To detect whether the current thread is able to receive a signal, use
the `ddi++_++can++_++receive++_++sig(9F)` function. If the
`ddi++_++can++_++receive++_++sig`function returns `B++_++TRUE`, then the
above functions can wake up on a received signal. If the
`ddi++_++can++_++receive++_++sig`function returns `B++_++FALSE`, then
the above functions cannot wake up on a received signal. If the
`ddi++_++can++_++receive++_++sig`function returns `B++_++FALSE`, then
the driver should use an alternate means, such as the `timeout(9F)`
function, to reawaken.

One important case where this problem occurs is with serial ports. If
the remote system asserts flow control and the `close(9E)` function
blocks while attempting to drain the output data, a port can be stuck
until the flow control condition is resolved or the system is rebooted.
Such drivers should detect this case and set up a timer to abort the
drain operation when the flow control condition persists for an
excessive period of time.

This issue also affects the `qwait++_++sig(9F)` function, which is
described in Chapter 7, STREAMS Framework – Kernel Level, in STREAMS
Programming Guide.

[[properties]]
=== Properties

Properties are user-defined, name-value pair structures that are managed
using the DDI/DKI interfaces. This chapter provides information on the
following subjects:

* link:#device-property-names[Device Property Names]
* link:#creating-and-updating-properties[Creating and Updating Properties]
* link:#looking-up-properties[Looking Up Properties]
* link:#prop_op-entry-point[ Entry Point]

[[device-properties]]
[[device-properties-1]]
=== Device Properties

Device attribute information can be represented by a _name-value_ pair
notation called a _property_.

For example, device registers and onboard memory can be represented by
the reg property. The reg property is a software abstraction that
describes device hardware registers. The value of the reg property
encodes the device register address location and size. Drivers use the
reg property to access device registers.

Another example is the interrupt property. An interrupt property
represents the device interrupt. The value of the interrupt property
encodes the device-interrupt PIN.

Five types of values can be assigned to properties:

* *Byte array* – Series of bytes of an arbitrary length
* *Integer property* – An integer value
* *Integer array property* – An array of integers
* *String property* – A null-terminated string
* *String array property* – A list of null-terminated strings

A property that has no value
is considered to be a Boolean property. A Boolean property that exists
is true. A Boolean value that does not exist is false.

[[device-property-names]]
==== Device Property Names

Strictly speaking, DDI/DKI software property names have no restrictions.
Certain uses are recommended, however. The IEEE 1275-1994 Standard for
Boot Firmware defines properties as follows:

A property is a human readable text string consisting of from 1 to 31
printable characters. Property names cannot contain upper case
characters or the characters “/”, “++\++”, “:”, “++[++“, “++]++” and
“@”. Property names beginning with the character “{plus}” are reserved
for use by future revisions of IEEE 1275-1994.

By convention, underbars (`++_++`) are not used in property names. Use a
hyphen (`-`) instead. By convention, property names ending with the
question mark character (`?`) contain values that are strings, typically
TRUE or FALSE, for example `auto-boot?`.

Predefined property names are listed in publications of the IEEE 1275
Working Group. See http://playground.sun.com/1275/ for information about
how to obtain these publications. For a discussion of adding properties
in driver configuration files, see the `driver.conf(5)` man page. The
`pm(9P)` and `pm-components(9P)` man pages show how properties are used
in power management. Read the `sd(4D)` man page as an example of how
properties should be documented in device driver man pages.

[[creating-and-updating-properties]]
==== Creating and Updating Properties

To create a property for a driver, or to update an existing property,
use an interface from the DDI driver update interfaces such as
`ddi++_++prop++_++update++_++int(9F)` or
`ddi++_++prop++_++update++_++string(9F)` with the appropriate property
type. See link:#properties-tbl-3[Property Interface Uses] for a list of
available property interfaces. These interfaces are typically called
from the driver's `attach(9E)` entry point. In the following example,
`ddi++_++prop++_++update++_++string`creates a string property called
`pm-hardware-state` with a value of `needs-suspend-resume`.

[source,c]
----
/* The following code is to tell cpr that this device
 * needs to be suspended and resumed.
 */
(void) ddi_prop_update_string(device, dip,
    "pm-hardware-state", "needs-suspend-resume");
----

In most cases, using a `ddi++_++prop++_++update` routine is sufficient
for updating a property. Sometimes, however, the overhead of updating a
property value that is subject to frequent change can cause performance
problems. See link:#prop_op-entry-point[ Entry Point] for a description of
using a local instance of a property value to avoid using
`ddi++_++prop++_++update`.

[[looking-up-properties]]
==== Looking Up Properties

A driver can request a property from its parent, which in turn can ask
its parent. The driver can control whether the request can go higher
than its parent.

For example, the `esp` driver in the
following example maintains an integer property called
`targetx-sync-speed` for each target. The `x` in `targetx-sync-speed`
represents the target number. The `prtconf(8)` command displays driver
properties in verbose mode. The following example shows a partial
listing for the `esp` driver.

....
% prtconf -v
...
       esp, instance #0
            Driver software properties:
                name <target2-sync-speed> length <4>
                    value <0x00000fa0>.
...
....

The following table provides a summary of the property
interfaces.

.Property Interface Uses
[width="100%",cols="23%,41%,36%",options="header",]
|===
|Family |Property Interfaces |Description
|`ddi++_++prop++_++lookup` |`ddi++_++prop++_++exists(9F)` |Looks up a
property and returns successfully if the property exists. Fails if the
property does not exist

| |`ddi++_++prop++_++get++_++int(9F)` |Looks up and returns an integer

| |`ddi++_++prop++_++get++_++int64(9F)` |Looks up and returns a 64-bit
integer property

| |`ddi++_++prop++_++lookup++_++int++_++array(9F)` |Looks up and returns
an integer array property

| |`ddi++_++prop++_++lookup++_++int64++_++array(9F)` |Looks up and
returns a 64-bit integer array property

| |`ddi++_++prop++_++lookup++_++string(9F)` |Looks up and returns a
string property

| |`ddi++_++prop++_++lookup++_++string++_++array(9F)` |Looks up and
returns a string array property

| |`ddi++_++prop++_++lookup++_++byte++_++array(9F)` |Looks up and
returns a byte array property

|`ddi++_++prop++_++update` |`ddi++_++prop++_++update++_++int(9F)`
|Updates or creates an integer property

| |`ddi++_++prop++_++update++_++int64(9F)` |Updates or creates a single
64-bit integer property

| |`ddi++_++prop++_++update++_++int++_++array(9F)` |Updates or creates
an integer array property

| |`ddi++_++prop++_++update++_++string(9F)` |Updates or creates a string

| |`ddi++_++prop++_++update++_++string++_++array(9F)` |Updates or
creates a string array property

| |`ddi++_++prop++_++update++_++int64++_++array(9F)` |Updates or creates
a 64-bit integer array property

| |`ddi++_++prop++_++update++_++byte++_++array(9F)` |Updates or creates
a byte array property

|`ddi++_++prop++_++remove` |`ddi++_++prop++_++remove(9F)` |Removes a

| |`ddi++_++prop++_++remove++_++all(9F)` |Removes all properties that
are associated with a device
|===

Whenever possible, use 64-bit versions of `int` property interfaces such
as `ddi++_++prop++_++update++_++int64(9F)` instead of 32-bit versions
such as `ddi++_++prop++_++update++_++int(9F)`).

[[prop_op-entry-point]]
==== `prop++_++op` Entry Point

The `prop++_++op(9E)` entry point is generally required for reporting
device properties or driver properties to the system. If the driver does
not need to create or manage its own properties, then the
`ddi++_++prop++_++op(9F)` function can be used for this entry point.

`ddi++_++prop++_++op(9F)` can be used as the `prop++_++op(9E)` entry
point for a device driver when `ddi++_++prop++_++op` is defined in the
driver's `cb++_++ops(9S)` structure. `ddi++_++prop++_++op` enables a
leaf device to search for and obtain property values from the device's
property list.

If the driver has to maintain a property whose value changes frequently,
you should define a driver-specific `prop++_++op` routine within the
`cb++_++ops` structure instead of calling `ddi++_++prop++_++op`. This
technique avoids the inefficiency of using `ddi++_++prop++_++update`
repeatedly. The driver should then maintain a copy of the property value
either within its soft-state structure or in a driver variable.

`prop++_++op(9E)` entry point reports the values of specific driver
properties and device properties to the system. In many cases, the
`ddi++_++prop++_++op(9F)` routine can be used as the driver's
`prop++_++op` entry point in the `cb++_++ops(9S)` structure.
`ddi++_++prop++_++op` performs all of the required processing.
`ddi++_++prop++_++op` is sufficient for drivers that do not require
special processing when handling device property requests.

However, sometimes the driver must provide a `prop++_++op` entry point.
For example, if a driver maintains a property whose value changes
frequently, updating the property with `ddi++_++prop++_++update(9F)` for
each change is not efficient. Instead, the driver should maintain a
shadow copy of the property in the instance's soft state. The driver
would then update the shadow copy when the value changes without using
any of the `ddi++_++prop++_++update` routines. The `prop++_++op` entry
point must intercept requests for this property and use one of the
`ddi++_++prop++_++update` routines to update the value of the property
before passing the request to `ddi++_++prop++_++op` to process the
property request.

In the following example, `prop++_++op` intercepts requests for the
`temperature` property. The driver updates a variable in the state
structure whenever the property changes. However, the property is
updated only when a request is made. The driver then uses
`ddi++_++prop++_++op` to process the property request. If the property
request is not specific to a device, the driver does not intercept the
request. This situation is indicated when the value of the `dev`
parameter is equal to `DDI++_++DEV++_++T++_++ANY`, the wildcard device
number.

[[properties-ex-5]]
`prop++_++op` Routine

[source,c]
----
static int
xx_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
        minor_t instance;
        struct xxstate *xsp;
        if (dev != DDI_DEV_T_ANY) {
                return (ddi_prop_op(dev, dip, prop_op, flags, name,
                    valuep, lengthp));
        }

        instance = getminor(dev);
        xsp = ddi_get_soft_state(statep, instance);
        if (xsp == NULL)
                return (DDI_PROP_NOTFOUND);
        if (strcmp(name, "temperature") == 0) {
                ddi_prop_update_int(dev, dip, name, temperature);
        }

        /* other cases */    
}
----

[[managing-events-and-queueing-tasks]]
=== Managing Events and Queueing Tasks

* link:#introduction-to-events[Introduction to Events]
* link:#using-ddilogsysevent-to-log-events[Using to Log Events]
* link:#defining-event-attributes[Defining Event Attributes]

* link:#introduction-to-task-queues[Introduction to Task Queues]
* link:#task-queue-interfaces[Task Queue Interfaces]
* link:#using-task-queues[Using Task Queues]
* link:#observing-task-queues[Observing Task Queues]

[[managing-events]]
=== Managing Events

A system often needs to respond to a condition change such as a user
action or system request. For example, a device might issue a warning
when a component begins to overheat, or might start a movie player when
a DVD is inserted into a drive. Device drivers can use a special message
called an _event_ to inform the system that a change in state has taken
place.

[[introduction-to-events]]
==== Introduction to Events

An _event_ is a message that a device driver sends to interested
entities to indicate that a change of state has taken place. Events are
implemented in illumos as user-defined, name-value pair structures that
are managed using the `nvlist++*++` functions. (See the
`nvlist++_++alloc(9F)` man page.) Events are organized by vendor, class,
and subclass. For example, you could define a class for monitoring
environmental conditions. An environmental class could have subclasses
to indicate changes in temperature, fan status, and power.

When a change in state occurs, the device notifies the driver. The
driver then uses the `ddi++_++log++_++sysevent(9F)` function to log this
event in a queue called `sysevent`. The `sysevent` queue passes events
to the user level for handling by either the `syseventd` daemon or
`syseventconfd` daemon. These daemons send notifications to any
applications that have subscribed for notification of the specified
event.

Two methods for designers of user-level applications deal with events:

* An application can use the routines in `libsysevent(3LIB)` to
subscribe with the `syseventd` daemon for notification when a specific
event occurs.
* A developer can write a separate user-level application to respond to
an event. This type of application needs to be registered with
`syseventadm(8)`. When `syseventconfd` encounters the specified event,
the application is run and deals with the event accordingly.

This process is illustrated in the following figure.

.Event Plumbing
[#esbjc]
image::figures/EventPlumbing.png[Diagram shows how events are logged into the sysevent queue for notification of user-level applications.]

[[using-ddilogsysevent-to-log-events]]
==== Using `ddi++_++log++_++sysevent` to Log Events

Device drivers use the
`ddi++_++log++_++sysevent(9F)` interface to generate and log events with
the system.

[[ddilogsysevent-syntax]]
===== `ddi++_++log++_++sysevent` Syntax

`ddi++_++log++_++sysevent` uses the following syntax:

[source,c]
----
int ddi_log_sysevent(dev_info_t *dip, char *vendor, char *class, 
    char *subclass, nvlist_t *attr-list, sysevent_id_t *eidp, int sleep-flag);
----

where:

++<++dip++>++::
  A pointer to the ++<++dev++_++info++>++ node for this driver.
++<++vendor++>++::
  A pointer to a string that defines the driver's vendor. Third-party
  drivers should use their company's stock symbol or a similarly
  enduring identifier. Sun-supplied drivers use
  `DDI++_++VENDOR++_++SUNW`.
++<++class++>++::
  A pointer to a string defining the event's class. `class` is a
  driver-specific value. An example of a class might be a string that
  represents a set of environmental conditions that affect a device.
  This value must be understood by the event consumer.
++<++subclass++>++::
  A driver-specific string that represents a subset of the `class`
  argument. For example, within a class that represents environmental
  conditions, an event subclass might refer to the device's temperature.
  This value must be intelligible to the event consumer.
++<++attr-list++>++::
  A pointer to an `nvlist++_++t` structure that lists name-value
  attributes associated with the event. Name-value attributes are
  driver-defined and can refer to a specific attribute or condition of
  the device.
  +
  For example, consider a device that reads both CD-ROMs and DVDs. That
  device could have an attribute with the name `disc++_++type` and the
  value equal to either `cd++_++rom` or `dvd`.
  +
  As with `class` and `subclass`, an event consumer must be able to
  interpret the name-value pairs.
  +
  For more information on name-value pairs and the `nvlist++_++t`
  structure, see link:#defining-event-attributes[Defining Event Attributes], as well as the
  `nvlist++_++alloc(9F)` man page.
  +
  If the event has no attributes, then this argument should be set to
  `NULL`.
++<++eidp++>++::
  The address of a `sysevent++_++id++_++t` structure. The
  `sysevent++_++id++_++t` structure is used to provide a unique
  identification for the event. `ddi++_++log++_++sysevent(9F)` returns
  this structure with a system-provided event sequence number and time
  stamp. See the `ddi++_++log++_++sysevent(9F)` man page for more
  information on the `sysevent++_++id++_++t` structure.
++<++sleep-flag++>++::
  A flag that indicates how the caller wants to handle the possibility
  of resources not being available. If ++<++sleep-flag++>++ is set to
  `DDI++_++SLEEP`, the driver blocks until the resources become
  available. With `DDI++_++NOSLEEP`, an allocation will not sleep and
  cannot be guaranteed to succeed. If `DDI++_++ENOMEM` is returned, the
  driver would need to retry the operation at a later time.
  +
  Even with `DDI++_++SLEEP`, other error returns are possible with this
  interface, such as system busy, the `syseventd` daemon not responding,
  or trying to log an event in interrupt context.

[[sample-code-for-logging-events]]
===== Sample Code for Logging Events

A device driver performs the following tasks to log events:

* Allocate memory for the attribute list using `nvlist++_++alloc(9F)`
* Add name-value pairs to the attribute list
* Use the `ddi++_++log++_++sysevent(9F)` function to log the event in
the `sysevent` queue
* Call `nvlist++_++free(9F)` when the attribute list is no longer needed

The following example demonstrates how to use
`ddi++_++log++_++sysevent`.

[[esqew]]
Calling `ddi++_++log++_++sysevent`

[source,c]
----
char *vendor_name = "DDI_VENDOR_JGJG"
char *my_class = "JGJG_event";
char *my_subclass = "JGJG_alert";
nvlist_t *nvl;
/* ... */
nvlist_alloc(&nvl, nvflag, kmflag);
/* ... */
(void) nvlist_add_byte_array(nvl, propname, (uchar_t *)propval, proplen + 1); 
/* ... */
if (ddi_log_sysevent(dip, vendor_name, my_class, 
    my_subclass, nvl, NULL, DDI_SLEEP)!= DDI_SUCCESS)
    cmn_err(CE_WARN, "error logging system event"); 
nvlist_free(nvl);
----

[[defining-event-attributes]]
==== Defining Event Attributes

Event attributes are defined as a list of name-value pairs. The illumos
DDI provides routines and structures for storing information in
name-value pairs. Name-value pairs are retained in an `nvlist++_++t`
structure, which is opaque to the driver. The value for a name-value
pair can be a Boolean, an `int`, a byte, a string, an `nvlist`, or an
array of these data types. An `int` can be defined as 16 bits, 32 bits,
or 64 bits and can be signed or unsigned.

The steps in creating a list of name-value pairs are as follows.

[arabic]
. Create an `nvlist++_++t` structure with
`nvlist++_++alloc(9F)`.
+
The `nvlist++_++alloc` interface takes three arguments:
* ++<++nvlp++>++ – Pointer to a pointer to an `nvlist++_++t` structure
* ++<++nvflag++>++ – Flag to indicate the uniqueness of the names of the
pairs. If this flag is set to `NV++_++UNIQUE++_++NAME++_++TYPE`, any
existing pair that matches the name and type of a new pair is removed
from the list. If the flag is set to `NV++_++UNIQUE++_++NAME`, then any
existing pair with a duplicate name is removed, regardless of its type.
Specifying `NV++_++UNIQUE++_++NAME++_++TYPE` allows a list to contain
two or more pairs with the same name as long as their types are
different, whereas with `NV++_++UNIQUE++_++NAME` only one instance of a
pair name can be in the list. If the flag is not set, then no uniqueness
checking is done and the consumer of the list is responsible for dealing
with duplicates.
* ++<++kmflag++>++ – Flag to indicate the allocation policy for kernel
memory. If this argument is set to `KM++_++SLEEP`, then the driver
blocks until the requested memory is available for allocation.
`KM++_++SLEEP` allocations might sleep but are guaranteed to succeed.
`KM++_++NOSLEEP` allocations are guaranteed not to sleep but might
return `NULL` if no memory is currently available.
. Populate the `nvlist` with name-value pairs. For example, to add a
string, use `nvlist++_++add++_++string(9F)`. To add an array of 32-bit
integers, use `nvlist++_++add++_++int32++_++array(9F)`. The
`nvlist++_++add++_++boolean(9F)` man page contains a complete list of
interfaces for adding pairs.

To deallocate a list, use `nvlist++_++free(9F)`.

The following code sample illustrates the creation of a name-value list.

[[properties-ex-16]]
Creating and Populating a Name-Value Pair List

[source,c]
----
nvlist_t*
    {
    int err;
    char *str = "child";
    int32_t ints[] = {0, 1, 2};
    nvlist_t *nvl;

    err = nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0);    /* allocate list */
    if (err)
        return (NULL);
    if ((nvlist_add_string(nvl, "name", str) != 0) ||
        (nvlist_add_int32_array(nvl, "prop", ints, 3) != 0)) {
        nvlist_free(nvl);
        return (NULL);
    }
    return (nvl);
}
----

Drivers can retrieve the elements of an `nvlist` by using a lookup
function for that type, such as
`nvlist++_++lookup++_++int32++_++array(9F)`, which takes as an argument
the name of the pair to be searched for.

[NOTE]

These interfaces work only if either `NV++_++UNIQUE++_++NAME` or
`NV++_++UNIQUE++_++NAME++_++TYPE` is specified when
`nvlist++_++alloc(9F)` is called. Otherwise, ENOTSUP is returned,
because the list cannot contain multiple pairs with the same name.
===

A list of name-value list pairs can be placed in contiguous memory. This
approach is useful for passing the list to an entity that has subscribed
for notification. The first step is to get the size of the memory block
that is needed for the list with `nvlist++_++size(9F)`. The next step is
to pack the list into the buffer with `nvlist++_++pack(9F)`. The
consumer receiving the buffer's content can unpack the buffer with
`nvlist++_++unpack(9F)`.

The functions for manipulating name-value pairs are available to both
user-level and kernel-level developers. You can find identical man pages
for these functions in both https://illumos.org/man/3f[manual pages
section 3F: Library Interfaces and Headers] and in
https://illumos.org/man/9f[man pages section 9: DDI and DKI Kernel
Functions]. For a list of functions that operate on name-value pairs,
see the following table.

.Functions for Using Name-Value Pairs
[width="100%",cols="32%,68%",options="header",]
|===
|Man Page |Purpose / Functions
|`nvlist++_++add++_++boolean(9F)` a|
Add name-value pairs to the list. Functions include:

`nvlist++_++add++_++boolean`, `nvlist++_++add++_++boolean++_++value`,
`nvlist++_++add++_++byte`, `nvlist++_++add++_++int8`,
`nvlist++_++add++_++uint8`, `nvlist++_++add++_++int16`,
`nvlist++_++add++_++uint16`, `nvlist++_++add++_++int32`,
`nvlist++_++add++_++uint32`, `nvlist++_++add++_++int64`,
`nvlist++_++add++_++uint64`, `nvlist++_++add++_++string`,
`nvlist++_++add++_++nvlist`, `nvlist++_++add++_++nvpair`,
`nvlist++_++add++_++boolean++_++array`,
`nvlist++_++add++_++int8++_++array, nvlist++_++add++_++uint8++_++array`,
`nvlist++_++add++_++nvlist++_++array`,
`nvlist++_++add++_++byte++_++array`,
`nvlist++_++add++_++int16++_++array`,
`nvlist++_++add++_++uint16++_++array`,
`nvlist++_++add++_++int32++_++array`,
`nvlist++_++add++_++uint32++_++array`,
`nvlist++_++add++_++int64++_++array`,
`nvlist++_++add++_++uint64++_++array`,
`nvlist++_++add++_++string++_++array`

|`nvlist++_++alloc(9F)` a|
Manipulate the name-value list buffer. Functions include:

`nvlist++_++alloc`, `nvlist++_++free`, `nvlist++_++size`,
`nvlist++_++pack`, `nvlist++_++unpack`, `nvlist++_++dup`,
`nvlist++_++merge`

|`nvlist++_++lookup++_++boolean(9F)` a|
Search for name-value pairs. Functions include:

`nvlist++_++lookup++_++boolean`,
`nvlist++_++lookup++_++boolean++_++value`, `nvlist++_++lookup++_++byte`,
`nvlist++_++lookup++_++int8`, `nvlist++_++lookup++_++int16`,
`nvlist++_++lookup++_++int32`, `nvlist++_++lookup++_++int64`,
`nvlist++_++lookup++_++uint8`, `nvlist++_++lookup++_++uint16`,
`nvlist++_++lookup++_++uint32`, `nvlist++_++lookup++_++uint64`,
`nvlist++_++lookup++_++string`, `nvlist++_++lookup++_++nvlist`,
`nvlist++_++lookup++_++boolean++_++array, nvlist++_++lookup++_++byte++_++array`,
`nvlist++_++lookup++_++int8++_++array`,
`nvlist++_++lookup++_++int16++_++array`,
`nvlist++_++lookup++_++int32++_++array`,
`nvlist++_++lookup++_++int64++_++array`,
`nvlist++_++lookup++_++uint8++_++array`,
`nvlist++_++lookup++_++uint16++_++array`,
`nvlist++_++lookup++_++uint32++_++array`,
`nvlist++_++lookup++_++uint64++_++array`,
`nvlist++_++lookup++_++string++_++array`,
`nvlist++_++lookup++_++nvlist++_++array`, `nvlist++_++lookup++_++pairs`

|`nvlist++_++next++_++nvpair(9F)` a|
Get name-value pair data. Functions include:

`nvlist++_++next++_++nvpair`, `nvpair++_++name`, `nvpair++_++type`

|`nvlist++_++remove(9F)` a|
Remove name-value pairs. Functions include:

`nv++_++remove`, `nv++_++remove++_++all`

|===

[[queueing-tasks]]
=== Queueing Tasks

task queues

scheduling tasks

task queues

This section discusses how to use _task queues_ to postpone processing
of some tasks and delegate their execution to another kernel thread.

[[introduction-to-task-queues]]
==== Introduction to Task Queues

A common operation in kernel programming is to schedule a task to be
performed at a later time, by a different thread. The following examples
give some reasons that you might want a different thread to perform a
task at a later time:

* Your current code path is time critical. The additional task you want
to perform is not time critical.
* The additional task might require grabbing a lock that another thread
is currently holding.
* You cannot block in your current context. The additional task might
need to block, for example to wait for memory.
* A condition is preventing your code path from completing, but your
current code path cannot sleep or fail. You need to queue the current
task to execute after the condition disappears.
* You need to launch multiple tasks in parallel.

In each of these cases, a task is executed in a different _context_. A
different context is usually a different kernel thread with a different
set of locks held and possibly a different priority. Task queues provide
a generic kernel API for scheduling asynchronous tasks.

A _task queue_ is a list of tasks with one or more
threads to service the list. If a task queue has a single service
thread, all tasks are guaranteed to execute in the order in which they
are added to the list. If a task queue has more than one service thread,
the order in which the tasks will execute is not known.

[NOTE]

If the task queue has more than one service thread, make sure that the
execution of one task does not depend on the execution of any other
task. Dependencies between tasks can cause a deadlock to occur.
===

[[task-queue-interfaces]]
==== Task Queue Interfaces

task queues

The following DDI interfaces manage task queues. These interfaces are
defined in the `sys/sunddi.h` header file. See the `taskq(9F)` man page
for more information about these interfaces.

[width="100%",cols="38%,62%",]
|===
|`ddi++_++taskq++_++t` |Opaque handle
|`TASKQ++_++DEFAULTPRI` |System default priority
|`DDI++_++SLEEP` |Can block for memory
|`DDI++_++NOSLEEP` |Cannot block for memory
|`ddi++_++taskq++_++create` |Create a task queue
|`ddi++_++taskq++_++destroy` |Destroy a task queue
|`ddi++_++taskq++_++dispatch` |Add a task to a task queue
|`ddi++_++taskq++_++wait` |Wait for pending tasks to complete
|`ddi++_++taskq++_++suspend` |Suspend a task queue
|`ddi++_++taskq++_++suspended` |Check whether a task queue is suspended
|`ddi++_++taskq++_++resume` |Resume a suspended task queue
|===

[[using-task-queues]]
==== Using Task Queues

The typical usage in drivers is to create task queues at `attach(9E)`.
Most `taskq++_++dispatch` invocations are from interrupt context.

To study task queues used in illumos drivers, go to
http://www.opensolaris.org/os/. In the left margin menu, click Source
Browser. In the Symbol field of the search area, enter
`ddi++_++taskq++_++create`. In the Project list, select `onnv`. Click
the Search button. In your search results you should see the USB generic
serial driver (`usbser.c`), the 1394 mass storage HBA FireWire driver
(`scsa1394/hba.c`), and the SCSI HBA driver for Dell PERC
3DC/4SC/4DC/4Di RAID devices (`amr.c`).

Click the file name `amr.c`. The `ddi++_++taskq++_++create` function is
called in the `amr++_++attach` entry point. The
`ddi++_++taskq++_++destroy` function is called in the `amr++_++detach`
entry point and also in the error handling section of the
`amr++_++attach` entry point. The `ddi++_++taskq++_++dispatch` function
is called in the `amr++_++done` function, which is called in the
`amr++_++intr` function. The `amr++_++intr` function is an
interrupt-handling function that is an argument to the
`ddi++_++add++_++intr(9F)` function in the `amr++_++attach` entry point.

[[observing-task-queues]]
==== Observing Task Queues

This section describes two techniques that you can use to monitor the
system resources that are consumed by a task queue. Task queues export
statistics on the use of system time by task queue threads. Task queues
also use DTrace SDT probes to determine when a task queue starts and
finishes execution of a task.

[[task-queue-kernel-statistics-counters]]
===== Task Queue Kernel Statistics Counters

task queues

Every task queue has an associated set of `kstat` counters. Examine the
output of the following `kstat(8)` command:

....
$ kstat -c taskq
module: unix                            instance: 0     
name:   ata_nexus_enum_tq               class:    taskq
        crtime                          53.877907833
        executed                        0
        maxtasks                        0
        nactive                         1
        nalloc                          0
        priority                        60
        snaptime                        258059.249256749
        tasks                           0
        threads                         1
        totaltime                       0

module: unix                            instance: 0     
name:   callout_taskq                   class:    taskq
        crtime                          0
        executed                        13956358
        maxtasks                        4
        nactive                         4
        nalloc                          0
        priority                        99
        snaptime                        258059.24981709
        tasks                           13956358
        threads                         2
        totaltime                       120247890619
....

The `kstat` output shown above includes the following information:

* The name of the task queue and its instance number
* The number of scheduled (`tasks`) and executed (`executed`) tasks
* The number of kernel threads processing the task queue (`threads`) and
their priority (`priority`)
* The total time (in nanoseconds) spent processing all the tasks
(`totaltime`)

The following example shows how you can use the `kstat` command to
observe how a counter (number of scheduled tasks) increases over time:

....
$ kstat -p unix:0:callout_taskq:tasks 1 5
unix:0:callout_taskq:tasks      13994642

unix:0:callout_taskq:tasks      13994711

unix:0:callout_taskq:tasks      13994784

unix:0:callout_taskq:tasks      13994855

unix:0:callout_taskq:tasks      13994926
....

[[task-queue-dtrace-sdt-probes]]
===== Task Queue DTrace SDT Probes

task queues

Task queues provide several useful SDT probes. All the probes described
in this section have the following two arguments:

* The task queue pointer returned by `ddi++_++taskq++_++create`
* The pointer to the `taskq++_++ent++_++t` structure. Use this pointer
in your D script to extract the function and the argument.

You can use these probes to collect precise timing information about
individual task queues and individual tasks being executed through them.
For example, the following script prints the functions that were
scheduled through task queues for every 10 seconds:

[source,c]
----
#!/usr/sbin/dtrace -qs

sdt:genunix::taskq-enqueue
{
  this->tq  = (taskq_t *)arg0;
  this->tqe = (taskq_ent_t *) arg1;
  @[this->tq->tq_name,
    this->tq->tq_instance,
    this->tqe->tqent_func] = count();
}

tick-10s
{
  printa ("%s(%d): %a called %@d times\n", @);
  trunc(@);
}
----

On a particular machine, the above D script produced the following
output:

....
callout_taskq(1): genunix`callout_execute called 51 times
callout_taskq(0): genunix`callout_execute called 701 times
kmem_taskq(0): genunix`kmem_update_timeout called 1 times
kmem_taskq(0): genunix`kmem_hash_rescale called 4 times
callout_taskq(1): genunix`callout_execute called 40 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 256 times
callout_taskq(0): genunix`callout_execute called 702 times
kmem_taskq(0): genunix`kmem_update_timeout called 1 times
kmem_taskq(0): genunix`kmem_hash_rescale called 4 times
callout_taskq(1): genunix`callout_execute called 28 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 228 times
callout_taskq(0): genunix`callout_execute called 706 times
callout_taskq(1): genunix`callout_execute called 24 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 141 times
callout_taskq(0): genunix`callout_execute called 708 times
....

[[driver-autoconfiguration]]
=== Driver Autoconfiguration

Autoconfiguration means the driver loads code and static data into
memory. This information is then registered with the system.
Autoconfiguration also involves attaching individual device instances
that are controlled by the driver.

This chapter provides information on the following subjects:

* link:#driver-loading-and-unloading[Driver Loading and Unloading]
* link:#data-structures-required-for-drivers[Data Structures Required for Drivers]
* link:#loadable-driver-interfaces[Loadable Driver Interfaces]
* link:#device-configuration-concepts[Device Configuration Concepts]
* link:#using-device-ids[Using Device IDs]

[[driver-loading-and-unloading]]
=== Driver Loading and Unloading

The system loads driver binary modules
from the `drv` subdirectory of the kernel module directory for
autoconfiguration. See link:#copying-the-driver-to-a-module-directory[Copying the Driver to a Module
Directory].

After a module is read into memory with all symbols resolved, the system
calls the `++_++init(9E)` entry point for that module. The `++_++init`
function calls `mod++_++install(9F)`, which actually loads the module.

[NOTE]

During the call to `mod++_++install`, other threads are able to call
`attach(9E)` as soon as `mod++_++install` is called. From a programming
standpoint, all `++_++init` initialization must occur before
`mod++_++install` is called. If `mod++_++install` fails (that is a
nonzero value is returned), then the initialization must be backed out.
===

Upon successful completion of `++_++init`, the driver is properly
registered with the system. At this point, the driver is not actively
managing any device. Device management happens as part of device
configuration.

The system unloads driver binary modules either to conserve system
memory or at the explicit request of a user. Before deleting the driver
code and data from memory, the `++_++fini(9E)` entry point of the driver
is invoked. The driver is unloaded, if and only if `++_++fini` returns
success.

The following figure provides a structural overview of a device driver.
The shaded area highlights the driver data structures and entry points.
The upper half of the shaded area contains data structures and entry
points that support driver loading and unloading. The lower half is
concerned with driver configuration.

.Module Loading and Autoconfiguration Entry Points
[#autoconf-fig-4]
image::figures/autoconf-entrypoints.png[Diagram shows structures and entry points used in autoconfiguration and module loading.]

[[data-structures-required-for-drivers]]
=== Data Structures Required for Drivers

To support autoconfiguration, drivers are required to statically
initialize the following data structures:

* `modlinkage(9S)`
* `modldrv(9S)`
* `dev++_++ops(9S)`
* `cb++_++ops(9S)`

The data structures in Figure 5-1 are relied on by the driver. These
structures must be provided and be initialized correctly. Without these
data structures, the driver might not load properly. As a result, the
necessary routines might not be loaded. If an operation is not supported
by the driver, the address of the `nodev(9F)` routine can be used as a
placeholder. In some instances, the driver supports the entry point and
only needs to return success or failure. In such cases, the address of
the routine `nulldev(9F)` can be used.

[NOTE]

These structures should be initialized at compile-time. The driver
should not access or change the structures at any other time.
===

[[modlinkage-structure]]
==== `modlinkage` Structure

[source,c]
----
static struct modlinkage xxmodlinkage = {
    MODREV_1,       /* ml_rev */
    &xxmodldrv,     /* ml_linkage[] */
    NULL            /* NULL termination */
};
----

The first field is the version number of the module that loads the
subsystem. This field should be `MODREV++_++1`. The second field points
to driver's `modldrv` structure defined next. The last element of the
structure should always be `NULL`.

[[modldrv-structure]]
==== `modldrv` Structure

[source,c]
----
static struct modldrv xxmodldrv = {
    &mod_driverops,           /* drv_modops */
    "generic driver v1.1",    /* drv_linkinfo */
    &xx_dev_ops               /* drv_dev_ops */
};
----

This structure describes the module in more detail. The first field
provides information regarding installation of the module. This field
should be set to `&mod++_++driverops` for driver modules. The second
field is a string to be displayed by `modinfo(8)`. The second field
should contain sufficient information for identifying the version of
source code that generated the driver binary. The last field points to
the driver's `dev++_++ops` structure defined in the following section.

[[dev_ops-structure]]
==== `dev++_++ops` Structure

dev++_++ops

dev++_++ops

[source,c]
----
static struct dev_ops xx_dev_ops = {
    DEVO_REV,       /* devo_rev, */
    0,              /* devo_refcnt  */
    xxgetinfo,      /* getinfo(9E) */
    nulldev,        /* identify(9E) */
    xxprobe,        /* probe(9E) */
    xxattach,       /* attach(9E) */
    xxdetach,       /* detach(9E) */
    nodev,          /* devo_reset */
    &xx_cb_ops,     /* devo_cb_ops */
    NULL,           /* devo_bus_ops */
    &xxpower        /* power(9E) */
};
----

The `dev++_++ops(9S)` structure enables the kernel to find the
autoconfiguration entry points of the device driver. The `devo++_++rev`
field identifies the revision number of the structure. This field must
be set to `DEVO++_++REV`. The `devo++_++refcnt` field must be
initialized to zero. The function address fields should be filled in
with the address of the appropriate driver entry point, except in the
following cases:

* Set the `devo++_++probe` field to `nulldev(9F)` if a `probe(9E)`
routine is not needed.
* Set the `identify` field to `nulldev(9F)`. The `identify` entry point
is obsolete.
* Set the `devo++_++reset` field to `nodev(9F)`.
* Set the `power(9E)` field to `NULL` if a `power` routine is not
needed. Drivers for devices that provide Power Management functionality
must have a `power` entry point.

The `devo++_++cb++_++ops` member should include the address of the
`cb++_++ops(9S)` structure. The `devo++_++bus++_++ops` field must be set
to `NULL`.

[[cb_ops-structure]]
==== `cb++_++ops` Structure

[source,c]
----
static struct cb_ops xx_cb_ops = {
    xxopen,         /* open(9E) */
    xxclose,        /* close(9E) */
    xxstrategy,     /* strategy(9E) */
    xxprint,        /* print(9E) */
    xxdump,         /* dump(9E) */
    xxread,         /* read(9E) */
    xxwrite,        /* write(9E) */
    xxioctl,        /* ioctl(9E) */
    xxdevmap,       /* devmap(9E) */
    nodev,          /* mmap(9E) */
    xxsegmap,       /* segmap(9E) */
    xxchpoll,       /* chpoll(9E) */
    xxprop_op,      /* prop_op(9E) */
    NULL,           /* streamtab(9S) */
    D_MP | D_64BIT, /* cb_flag */
    CB_REV,         /* cb_rev */
    xxaread,        /* aread(9E) */
    xxawrite        /* awrite(9E) */
};
----

`cb++_++ops(9S)` structure contains the entry points for the character
operations and block operations of the device driver. Any entry points
that the driver does not support should be initialized to `nodev(9F)`.
For example, character device drivers should set all the block-only
fields, such as `cb++_++stategy`, to `nodev(9F)`. Note that the
`mmap(9E)` entry point is maintained for compatibility with previous
releases. Drivers should use the `devmap(9E)` entry point for device
memory mapping. If `devmap(9E)` is supported, set `mmap(9E)` to
`nodev(9F)`.

The `streamtab` field indicates whether
the driver is STREAMS-based. Only the network device drivers that are
discussed in link:#drivers-for-network-devices[Drivers for Network Devices] are STREAMS-based.
All non-STREAMS-based drivers _must_ set the `streamtab` field to
`NULL`.

The `cb++_++flag` member contains the following flags:

* The `D++_++MP` flag indicates that the
driver is safe for multithreading. illumos supports only thread-safe
drivers so `D++_++MP` must be set.
* The `D++_++64BIT` flag causes the driver to use the `uio++_++loffset`
field of the `uio(9S)` structure. The driver should set the
`D++_++64BIT` flag in the `cb++_++flag` field to handle 64-bit offsets
properly.
* The `D++_++DEVMAP` flag supports the
`devmap(9E)` entry point. For information on `devmap(9E)`, see
link:#mapping-device-and-kernel-memory[Mapping Device and Kernel Memory].

`cb++_++rev` is the `cb++_++ops` structure revision number. This field
must be set to `CB++_++REV`.

[[loadable-driver-interfaces]]
=== Loadable Driver Interfaces

Device drivers must be dynamically loadable. Drivers should also be
unloadable to help conserve memory resources. Drivers that can be
unloaded are also easier to test, debug, and patch.

Each device driver is required to
implement `++_++init(9E)`, `++_++fini(9E)`, and `++_++info(9E)` entry
points to support driver loading and unloading. The following example
shows a typical implementation of loadable driver interfaces.

[[autoconf-ex-9]]
Loadable Interface Section

[source,c]
----
static void *statep;                /* for soft state routines */
static struct cb_ops xx_cb_ops;     /* forward reference */
static struct dev_ops xx_ops = {
    DEVO_REV,
    0,
    xxgetinfo,
    nulldev,
    xxprobe,
    xxattach,
    xxdetach,
    xxreset,
    nodev,
    &xx_cb_ops,
    NULL,
};

static struct modldrv modldrv = {
    &mod_driverops,
    "xx driver v1.0",
    &xx_ops
};

static struct modlinkage modlinkage = {
    MODREV_1,
    &modldrv,
};

_init(void)
{
    int error;
    ddi_soft_state_init(&statep, sizeof (struct xxstate),
        estimated_number_of_instances);
    /* further per-module initialization if necessary */
    error = mod_install(&modlinkage);
    if (error != 0) {
        /* undo any per-module initialization done earlier */
        ddi_soft_state_fini(&statep);
    }
    return (error);
}

_fini(void)
{
    int error;
    error = mod_remove(&modlinkage);
    if (error == 0) {
        /* release per-module resources if any were allocated */
        ddi_soft_state_fini(&statep);
    }
    return (error);
}

_info(struct modinfo *modinfop)
{
    return (mod_info(&modlinkage, modinfop));
}
----

[[_init-example]]
==== `++_++init` Example

The following example shows a typical `++_++init(9E)` interface.

[[autoconf-ex-38]]
`++_++init` Function

[source,c]
----
static void *xxstatep;
_init(void)
{
    int error;
    const int max_instance = 20;    /* estimated max device instances */

    ddi_soft_state_init(&xxstatep, sizeof (struct xxstate), max_instance);
    error = mod_install(&xxmodlinkage);
    if (error != 0) {
        /*
         * Cleanup after a failure
         */
        ddi_soft_state_fini(&xxstatep);
    }
    return (error);
}
----

The driver should perform any one-time
resource allocation or data initialization during driver loading in
`++_++init`. For example, the driver should initialize any mutexes
global to the driver in this routine. The driver should not, however,
use `++_++init(9E)` to allocate or initialize anything that has to do
with a particular instance of the device. Per-instance initialization
must be done in `attach(9E)`. For example, if a driver for a printer can
handle more than one printer at the same time, that driver should
allocate resources specific to each printer instance in `attach`.

[NOTE]

Once `++_++init(9E)` has called `mod++_++install(9F)`, the driver should
not change any of the data structures attached to the `modlinkage(9S)`
structure because the system might make copies or change the data
structures.
===

[[_fini-example]]
==== `++_++fini` Example

The following example demonstrates the `++_++fini` routine.

[source,c]
----
_fini(void)
{
    int error;
    error = mod_remove(&modlinkage);
    if (error != 0) {
        return (error);
    }
    /*
     * Cleanup resources allocated in _init()
     */
    ddi_soft_state_fini(&xxstatep);
    return (0);
}
----

Similarly, in `++_++fini`, the driver should release any
resources that were allocated in `++_++init`. The driver must remove
itself from the system module list.

[NOTE]

`++_++fini` might be called when the driver is attached to hardware
instances. In this case, `mod++_++remove(9F)` returns failure.
Therefore, driver resources should not be released until
`mod++_++remove` returns success.
===

[[_info-example]]
==== `++_++info` Example

The following example demonstrates the `++_++info(9E)` routine.

[source,c]
----
_info(struct modinfo *modinfop)
{
    return (mod_info(&xxmodlinkage, modinfop));
}
----

The driver is called to return module information. The
entry point should be implemented as shown above.

[[device-configuration-concepts]]
=== Device Configuration Concepts

For each node in the kernel device tree, the system selects a driver for
the node based on the node name and the `compatible` property (see
link:#binding-a-driver-to-a-device[Binding a Driver to a Device]). The same driver might
bind to multiple device nodes. The driver can differentiate different
nodes by instance numbers assigned by the system.

After a driver is selected for a device node, the driver's `probe(9E)`
entry point is called to determine the presence of the device on the
system. If `probe` is successful, the driver's `attach(9E)` entry point
is invoked to set up and manage the device. The device can be opened if
and only if `attach` returns success (see link:#attach-entry-point[ Entry
Point]).

A device might be unconfigured to conserve system memory resources or to
enable the device to be removed while the system is still running. To
enable the device to be unconfigured, the system first checks whether
the device instance is referenced. This check involves calling the
driver's `getinfo(9E)` entry point to obtain information known only to
the driver (see link:#getinfo-entry-point[ Entry Point]). If the device
instance is not referenced, the driver's `detach(9E)` routine is invoked
to unconfigure the device (see link:#detach-entry-point[ Entry Point]).

To recap,
each driver must define the following entry points that are used by the
kernel for device configuration:

* `probe(9E)`
* `attach(9E)`
* `detach(9E)`
* `getinfo(9E)`

Note that `attach`, `detach`, and `getinfo` are required. `probe` is
only required for devices that cannot identify themselves. For
self-identifying devices, an explicit `probe` routine can be provided,
or `nulldev(9F)` can be specified in the `dev++_++ops` structure for the
`probe` entry point.

[[device-instances-and-instance-numbers]]
==== Device Instances and Instance Numbers

The system assigns an instance number to
each device. The driver might not reliably predict the value of the
instance number assigned to a particular device. The driver should
retrieve the particular instance number that has been assigned by
calling `ddi++_++get++_++instance(9F)`.

Instance numbers represent the system's notion of devices. Each
`dev++_++info`, that is, each node in the device tree, for a particular
driver is assigned an instance number by the kernel. Furthermore,
instance numbers provide a convenient mechanism for indexing data
specific to a particular physical device. The most common use of
instance numbers is `ddi++_++get++_++soft++_++state(9F)`, which uses
instance numbers to retrieve soft state data for specific physical
devices.

[CAUTION]

For pseudo devices, that is, the children of pseudo nexuses, the
instance numbers are defined in the `driver.conf(5)` file using the
`instance` property. If the `driver.conf` file does not contain the
`instance` property, the behavior is undefined. For hardware device
nodes, the system assigns instance numbers when the device is first seen
by the OS. The instance numbers persist across system reboots and OS
upgrades.
===

[[minor-nodes-and-minor-numbers]]
==== Minor Nodes and Minor Numbers

Drivers are responsible for managing their minor number namespace. For
example, the `sd` driver needs to export eight character minor nodes and
eight block minor nodes to the file system for each disk. Each minor
node represents either a block interface or a character interface to a
portion of the disk. The `getinfo(9E)` entry point informs the system
about the mapping from minor number to device instance (see
link:#getinfo-entry-point[ Entry Point]).

[[probe-entry-point]]
==== `probe` Entry Point

For non-self-identifying devices, the `probe(9E)` entry point should
determine whether the hardware device is present on the system.

For `probe` to determine whether the instance of the device is present,
`probe` needs to perform many tasks that are also commonly done by
`attach(9E)`. In particular, `probe` might need to map the device
registers.

Probing the device registers is device-specific. The driver often has to
perform a series of tests of the hardware to assure that the hardware is
really present. The test criteria must be rigorous enough to avoid
misidentifying devices. For example, a device might appear to be present
when in fact that device is not available, because a different device
seems to behave like the expected device.

The test returns the following flags:

* DDI++_++PROBE++_++SUCCESS if the probe was successful
* DDI++_++PROBE++_++FAILURE if the probe failed
* DDI++_++PROBE++_++DONTCARE if the probe was unsuccessful yet
`attach(9E)` still needs to be called
* DDI++_++PROBE++_++PARTIAL if the instance is not present now, but
might be present in the future

For a given device instance, `attach(9E)` will not be called until
`probe(9E)` has succeeded at least once on that device.

`probe(9E)` must free all the resources that `probe` has allocated,
because `probe` might be called multiple times. However, `attach(9E)` is
not necessarily called even if `probe(9E)` has succeeded

`ddi++_++dev++_++is++_++sid(9F)` can be used in a driver's `probe(9E)`
routine to determine whether the device is self-identifying.
`ddi++_++dev++_++is++_++sid` is useful in drivers written for
self-identifying and non-self-identifying versions of the same device.

The following example is a sample `probe` routine.

[[autoconf-27640]]
`probe(9E)` Routine

[source,c]
----
static int
xxprobe(dev_info_t *dip)
{
    ddi_acc_handle_t dev_hdl;
    ddi_device_acc_attr_t dev_attr;
    Pio_csr *csrp;
    uint8_t csrval;

    /*
     * if the device is self identifying, no need to probe
     */
    if (ddi_dev_is_sid(dip) == DDI_SUCCESS)
    return (DDI_PROBE_DONTCARE);

    /*
     * Initalize the device access attributes and map in
     * the devices CSR register (register 0)
     */
    dev_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
    dev_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;

    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&csrp, 0, sizeof (Pio_csr),
    &dev_attr, &dev_hdl) != DDI_SUCCESS)
    return (DDI_PROBE_FAILURE);

    /*
     * Reset the device
     * Once the reset completes the CSR should read back
     * (PIO_DEV_READY | PIO_IDLE_INTR)
     */
    ddi_put8(dev_hdl, csrp, PIO_RESET);
    csrval = ddi_get8(dev_hdl, csrp);

    /*
     * tear down the mappings and return probe success/failure
     */
    ddi_regs_map_free(&dev_hdl);
    if ((csrval & 0xff) == (PIO_DEV_READY | PIO_IDLE_INTR))
    return (DDI_PROBE_SUCCESS);
    return (DDI_PROBE_FAILURE);
}
----

When the driver's `probe(9E)` routine is called, the driver does not
know whether the device being probed exists on the bus. Therefore, the
driver might attempt to access device registers for a nonexistent
device. A bus fault might be generated on some buses as a result.

The following example shows a `probe(9E)` routine that uses
`ddi++_++poke8(9F)` to check for the existence of the device.
`ddi++_++poke8` cautiously attempts to write a value to a specified
virtual address, using the parent nexus driver to assist in the process
where necessary. If the address is not valid or the value cannot be
written without an error occurring, an error code is returned. See also
`ddi++_++peek(9F)`.

In this example, `ddi++_++regs++_++map++_++setup(9F)` is used to map the
device registers.

[[autoconf-42737]]
`probe(9E)` Routine Using `ddi++_++poke8(9F)`

[source,c]
----
static int
xxprobe(dev_info_t *dip)
{
    ddi_acc_handle_t dev_hdl;
    ddi_device_acc_attr_t dev_attr;
    Pio_csr *csrp;
    uint8_t csrval;

    /*
     * if the device is self-identifying, no need to probe
     */
    if (ddi_dev_is_sid(dip) == DDI_SUCCESS)
    return (DDI_PROBE_DONTCARE);

    /*
     * Initialize the device access attrributes and map in
     * the device's CSR register (register 0)
     */
    dev_attr.devacc_attr_version - DDI_DEVICE_ATTR_V0;
    dev_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;

    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&csrp, 0, sizeof (Pio_csr),
    &dev_attr, &dev_hdl) != DDI_SUCCESS)
    return (DDI_PROBE_FAILURE);

    /*
     * The bus can generate a fault when probing for devices that
     * do not exist.  Use ddi_poke8(9F) to handle any faults that
     * might occur.
     *
     * Reset the device.  Once the reset completes the CSR should read
     * back (PIO_DEV_READY | PIO_IDLE_INTR)
     */
    if (ddi_poke8(dip, csrp, PIO_RESET) != DDI_SUCCESS) {
    ddi_regs_map_free(&dev_hdl);
    return (DDI_FAILURE);

    csrval = ddi_get8(dev_hdl, csrp);
    /*
     * tear down the mappings and return probe success/failure
     */
    ddi_regs_map_free(&dev_hdl);
    if ((csrval & 0xff) == (PIO_DEV_READY | PIO_IDLE_INTR))
    return (DDI_PROBE_SUCCESS);
    return (DDI_PROBE_FAILURE);
}
----

[[attach-entry-point]]
==== `attach` Entry Point

The kernel calls a driver's `attach(9E)`
entry point to attach an instance of a device or to resume operation for
an instance of a device that has been suspended or has been shut down by
the power management framework. This section discusses only the
operation of attaching device instances. Power management is discussed
in link:#power-management[Power Management].

A driver's `attach(9E)` entry point is called to attach each instance of
a device that is bound to the driver. The entry point is called with the
instance of the device node to attach, with `DDI++_++ATTACH` specified
as the `cmd` argument to `attach(9E)`. The attach entry point typically
includes the following types of processing:

* Allocating a soft-state structure for the device instance
* Initializing per-instance mutexes
* Initializing condition variables
* Registering the device's interrupts
* Mapping the registers and memory of
the device instance
* Creating minor device nodes for the device instance
* Reporting that the device instance has attached

[[driver-soft-state-management]]
===== Driver Soft-State Management

To assist device driver writers in allocating state
structures, the illumos DDI/DKI provides a set of memory management
routines called _software state management routines_, which are also
known as the _soft-state routines_. These routines dynamically allocate,
retrieve, and destroy memory items of a specified size, and hide the
details of list management. An _instance number_ identifies the desired
memory item. This number is typically the instance number assigned by
the system.

Drivers typically allocate a soft-state structure for each device
instance that attaches to the driver by calling
`ddi++_++soft++_++state++_++zalloc(9F)`, passing the instance number of
the device. Because no two device nodes can have the same instance
number, `ddi++_++soft++_++state++_++zalloc(9F)` fails if an allocation
already exists for a given instance number.

A driver's character or block entry point (`cb++_++ops(9S)`) references
a particular soft state structure by first decoding the device's
instance number from the `dev++_++t` argument that is passed to the
entry point function. The driver then calls
`ddi++_++get++_++soft++_++state(9F)`, passing the per-driver soft-state
list and the instance number that was derived. A `NULL` return value
indicates that effectively the device does not exist and the appropriate
code should be returned by the driver.

See link:#creating-minor-device-nodes[Creating Minor Device Nodes] for additional
information on how instance numbers and device numbers, or
`dev++_++t`'s, are related.

[[lock-variable-and-conditional-variable-initialization]]
===== Lock Variable and Conditional Variable Initialization

Drivers should initialize any per-instance locks and condition variables
during attach. The initialization of any locks that are acquired by the
driver's interrupt handler _must_ be initialized prior to adding any
interrupt handlers. See link:#multithreading[Multithreading] for a description
of lock initialization and usage. See link:#interrupt-handlers[Interrupt
Handlers] for a discussion of interrupt handler and lock issues.

[[creating-minor-device-nodes]]
===== Creating Minor Device Nodes

An important part of the attach process
is the creation of _minor nodes_ for the device instance. A minor node
contains the information exported by the device and the DDI framework.
The system uses this information to create a _special file_ for the
minor node under `/devices`.

Minor nodes are created when the driver calls
`ddi++_++create++_++minor++_++node(9F)`. The driver supplies a _minor
number_, a _minor name_, a _minor node type_, and whether the minor node
represents a block or character device.

Drivers can create any number of minor nodes for a device. The illumos
DDI/DKI expects certain classes of devices to have minor nodes created
in a particular format. For example, disk drivers are expected to create
16 minor nodes for each physical disk instance attached. Eight minor
nodes are created, representing the `a - h` block device interfaces,
with an additional eight minor nodes for the `a,raw - h,raw` character
device interfaces.

The _minor number_ passed to `ddi++_++create++_++minor++_++node(9F)` is
defined wholly by the driver. The minor number is usually an encoding of
the instance number of the device with a minor node identifier. In the
preceding example, the driver creates minor numbers for each of the
minor nodes by shifting the instance number of the device left by three
bits and using the OR of that result with the minor node index. The
values of the minor node index range from 0 to 7. Note that minor nodes
`a` and `a,raw` share the same minor number. These minor nodes are
distinguished by the `spec++_++type` argument passed to
`ddi++_++create++_++minor++_++node`.

The _minor
node type_ passed to `ddi++_++create++_++minor++_++node(9F)` classifies
the type of device, such as disks, tapes, network interfaces, frame
buffers, and so forth.

The following table lists the types of possible nodes that might be
created.

.Possible Node Types
[width="100%",cols="29%,71%",options="header",]
|===
|Constant |Description
|`DDI++_++NT++_++SERIAL` |Serial port

|`DDI++_++NT++_++SERIAL++_++DO` |Dialout ports

|`DDI++_++NT++_++BLOCK` |Hard disks

|`DDI++_++NT++_++BLOCK++_++CHAN` |Hard disks with channel or target

|`DDI++_++NT++_++CD` |ROM drives (CD-ROM)

|`DDI++_++NT++_++CD++_++CHAN` |ROM drives with channel or target numbers

|`DDI++_++NT++_++FD` |Floppy disks

|`DDI++_++NT++_++TAPE` |Tape drives

|`DDI++_++NT++_++NET` |Network devices

|`DDI++_++NT++_++DISPLAY` |Display devices

|`DDI++_++NT++_++MOUSE` |Mouse

|`DDI++_++NT++_++KEYBOARD` |Keyboard

|`DDI++_++NT++_++AUDIO` |Audio Device

|`DDI++_++PSEUDO` |General pseudo devices
|===

The node types `DDI++_++NT++_++BLOCK`, `DDI++_++NT++_++BLOCK++_++CHAN`,
`DDI++_++NT++_++CD`, and `DDI++_++NT++_++CD++_++CHAN` cause
`devfsadm(8)` to identify the device instance as a disk and to create
names in the `/dev/dsk` or `/dev/rdsk` directory.

The node type `DDI++_++NT++_++TAPE` causes `devfsadm(8)` to identify the
device instance as a tape and to create names in the `/dev/rmt`
directory.

The node types `DDI++_++NT++_++SERIAL` and
`DDI++_++NT++_++SERIAL++_++DO` cause `devfsadm(8)` to perform these
actions:

* Identify the device instance as a serial port
* Create names in the `/dev/term` directory
* Add entries to the `/etc/inittab` file

Vendor-supplied strings should include an identifying value such as a
name or stock symbol to make the strings unique. The string can be used
in conjunction with `devfsadm(8)` and the `devlinks.tab` file (see the
`devlinks(8)` man page) to create logical names in `/dev`.

[[deferred-attach]]
===== Deferred Attach

`open(9E)` might be called on a minor device before `attach(9E)` has
succeeded on the corresponding instance. `open` must then return
`ENXIO`, which causes the system to attempt to attach the device. If the
`attach` succeeds, the `open` is retried automatically.

[[autoconf-ex-35]]
Typical `attach` Entry Point

[source,c]
----
/*
 * Attach an instance of the driver.  We take all the knowledge we
 * have about our board and check it against what has been filled in
 * for us from our FCode or from our driver.conf(4) file.
 */
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance;
    Pio *pio_p;
    ddi_device_acc_attr_t   da_attr;
    static int pio_validate_device(dev_info_t *);

    switch (cmd) {
    case DDI_ATTACH:
    /*
     * first validate the device conforms to a configuration this driver
     * supports
     */
    if (pio_validate_device(dip) == 0)
        return (DDI_FAILURE);
    /*
     * Allocate a soft state structure for this device instance
     * Store a pointer to the device node in our soft state structure
     * and a reference to the soft state structure in the device
     * node.
     */
    instance = ddi_get_instance(dip);
    if (ddi_soft_state_zalloc(pio_softstate, instance) != 0)
        return (DDI_FAILURE);
    pio_p = ddi_get_soft_state(pio_softstate, instance);
    ddi_set_driver_private(dip, (caddr_t)pio_p);
    pio_p->dip = dip;
    /*
     * Before adding the interrupt, get the interrupt block
     * cookie associated with the interrupt specification to
     * initialize the mutex used by the interrupt handler.
     */
    if (ddi_get_iblock_cookie(dip, 0, &pio_p->iblock_cookie) !=
      DDI_SUCCESS) {
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }

    mutex_init(&pio_p->mutex, NULL, MUTEX_DRIVER, pio_p->iblock_cookie);
    /*
     * Now that the mutex is initialized, add the interrupt itself.
     */
    if (ddi_add_intr(dip, 0, NULL, NULL, pio_intr, (caddr_t)instance) !=
      DDI_SUCCESS) {
        mutex_destroy(&pio_p>mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Initialize the device access attributes for the register mapping
     */
    dev_acc_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
    dev_acc_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_acc_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
    /*
     * Map in the csr register (register 0)
     */
    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&(pio_p->csr), 0,
        sizeof (Pio_csr), &dev_acc_attr, &pio_p->csr_handle) !=
        DDI_SUCCESS) {
        ddi_remove_intr(pio_p->dip, 0, pio_p->iblock_cookie);
        mutex_destroy(&pio_p->mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Map in the data register (register 1)
     */
    if (ddi_regs_map_setup(dip, 1, (caddr_t *)&(pio_p->data), 0,
        sizeof (uchar_t), &dev_acc_attr, &pio_p->data_handle) !=
        DDI_SUCCESS) {
        ddi_remove_intr(pio_p->dip, 0, pio_p->iblock_cookie);
        ddi_regs_map_free(&pio_p->csr_handle);
        mutex_destroy(&pio_p->mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Create an entry in /devices for user processes to open(2)
     * This driver will create a minor node entry in /devices
     * of the form:  /devices/..../pio@X,Y:pio
     */
    if (ddi_create_minor_node(dip, ddi_get_name(dip), S_IFCHR,
        instance, DDI_PSEUDO, 0) == DDI_FAILURE) {
        ddi_remove_intr(pio_p->dip, 0, pio_p->iblock_cookie);
        ddi_regs_map_free(&pio_p->csr_handle);
        ddi_regs_map_free(&pio_p->data_handle);
        mutex_destroy(&pio_p->mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * reset device (including disabling interrupts)
     */
    ddi_put8(pio_p->csr_handle, pio_p->csr, PIO_RESET);
    /*
     * report the name of the device instance which has attached
     */
    ddi_report_dev(dip);
    return (DDI_SUCCESS);

    case DDI_RESUME:
    return (DDI_SUCCESS);

    default:
    return (DDI_FAILURE);
    }
}
----

[NOTE]

The `attach` routine must not make any assumptions about the order of
invocations on different device instances. The system might invoke
`attach` concurrently on different device instances. The system might
also invoke `attach` and `detach` concurrently on different device
instances.
===

[[detach-entry-point]]
==== `detach` Entry Point

The kernel calls a driver's `detach(9E)`
entry point to detach an instance of a device or to suspend operation
for an instance of a device by power management. This section discusses
the operation of detaching device instances. Refer to
link:#power-management[Power Management] for a discussion of power
management issues.

A driver's `detach` entry point is called to detach an instance of a
device that is bound to the driver. The entry point is called with the
instance of the device node to be detached and with `DDI++_++DETACH`,
which is specified as the `cmd` argument to the entry point.

A driver is required to cancel or wait for any time outs or callbacks to
complete, then release any resources that are allocated to the device
instance before returning. If for some reason a driver cannot cancel
outstanding callbacks for free resources, the driver is required to
return the device to its original state and return `DDI++_++FAILURE`
from the entry point, leaving the device instance in the attached state.

There are two types of callback routines: those callbacks that can be
canceled and those that cannot be canceled. `timeout(9F)` and
`bufcall(9F)` callbacks can be atomically cancelled by the driver during
`detach(9E)`. Other types of callbacks such as
`scsi++_++init++_++pkt(9F)` and
`ddi++_++dma++_++buf++_++bind++_++handle(9F)` cannot be canceled. The
driver must either block in `detach` until the callback completes or
else fail the request to detach.

[[autoconf-ex-15]]
Typical `detach` Entry Point

[source,c]
----
/*
 * detach(9E)
 * free the resources that were allocated in attach(9E)
 */
static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    Pio     *pio_p;
    int     instance;

    switch (cmd) {
    case DDI_DETACH:

    instance = ddi_get_instance(dip);
    pio_p = ddi_get_soft_state(pio_softstate, instance);

    /*
     * turn off the device
     * free any resources allocated in attach
     */
    ddi_put8(pio_p->csr_handle, pio_p->csr, PIO_RESET);
    ddi_remove_minor_node(dip, NULL);
    ddi_regs_map_free(&pio_p->csr_handle);
    ddi_regs_map_free(&pio_p->data_handle);
    ddi_remove_intr(pio_p->dip, 0, pio_p->iblock_cookie);
    mutex_destroy(&pio_p->mutex);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_SUCCESS);

    case DDI_SUSPEND:
    default:
    return (DDI_FAILURE);
    }
}
----

[[getinfo-entry-point]]
==== `getinfo` Entry Point

The system calls `getinfo(9E)` to obtain
configuration information that only the driver knows. The mapping of
minor numbers to device instances is entirely under the control of the
driver. The system sometimes needs to ask the driver which device a
particular `dev++_++t` represents.

`getinfo` function can take either `DDI++_++INFO++_++DEVT2INSTANCE` or
`DDI++_++INFO++_++DEVT2DEVINFO` as its ++<++infocmd++>++ argument. The
`DDI++_++INFO++_++DEVT2INSTANCE` command requests the instance number of
a device. The `DDI++_++INFO++_++DEVT2DEVINFO` command requests a pointer
to the `dev++_++info` structure of a device.

In the `DDI++_++INFO++_++DEVT2INSTANCE` case, ++<++arg++>++ is a
`dev++_++t`, and `getinfo` must translate the minor number in
`dev++_++t` to an instance number. In the following example, the minor
number _is_ the instance number, so `getinfo` simply passes back the
minor number. In this case, the driver must not assume that a state
structure is available, since `getinfo` might be called before `attach`.
The mapping defined by the driver between the minor device number and
the instance number does not necessarily follow the mapping shown in the
example. In all cases, however, the mapping must be static.

In the `DDI++_++INFO++_++DEVT2DEVINFO` case, ++<++arg++>++ is again a
`dev++_++t`, so `getinfo` first decodes the instance number for the
device. `getinfo` then passes back the `dev++_++info` pointer saved in
the driver's soft state structure for the appropriate device, as shown
in the following example.

[[autoconf-16720]]
Typical `getinfo` Entry Point

[source,c]
----
/*
 * getinfo(9E)
 * Return the instance number or device node given a dev_t
 */
static int
xxgetinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
{
    int error;
    Pio *pio_p;
    int instance = getminor((dev_t)arg);

    switch (infocmd) {
    /*
     * return the device node if the driver has attached the
     * device instance identified by the dev_t value which was passed
     */
    case DDI_INFO_DEVT2DEVINFO:
    pio_p = ddi_get_soft_state(pio_softstate, instance);
    if (pio_p == NULL) {
        *result = NULL;
        error = DDI_FAILURE;
    } else {
        mutex_enter(&pio_p->mutex);
        *result = pio_p->dip;
        mutex_exit(&pio_p->mutex);
        error = DDI_SUCCESS;
    }
    break;
    /*
     * the driver can always return the instance number given a dev_t
     * value, even if the instance is not attached.
     */
    case DDI_INFO_DEVT2INSTANCE:
    *result = (void *)instance;
    error = DDI_SUCCESS;
    break;
    default:
    *result = NULL;
    error = DDI_FAILURE;
    }
    return (error);
}
----

[NOTE]

The `getinfo` routine must be kept in sync with the minor nodes that the
driver creates. If the minor nodes get out of sync, any hotplug
operations might fail and cause a system panic.
===

[[using-device-ids]]
=== Using Device IDs

The illumos DDI interfaces enable drivers to provide the _device ID_, a
persistent unique identifier for a device. The _device ID_ can be used
to identify or locate a device. The _device ID_ is independent of the
`/devices` name or device number (`dev++_++t`). Applications can use the
functions defined in `libdevid(3LIB)` to read and manipulate the device
IDs registered by the drivers.

Before a driver can export a _device ID_, the driver needs to verify the
device is capable of either providing a unique ID or of storing a
host-generated unique ID in a not normally accessible area. WWN
(world-wide number) is an example of a unique ID that is provided by the
device. Device NVRAM and reserved sectors are examples of non-accessible
areas where host-generated unique IDs can be safely stored.

[[registering-device-ids]]
==== Registering Device IDs

Drivers typically initialize and register device IDs in the driver's
`attach(9E)` handler. As mentioned above, the driver is responsible for
registering a _device ID_ that is persistent. As such, the driver might
be required to handle both devices that can provide a unique ID directly
(WWN) and devices where fabricated IDs are written to and read from
stable storage.

[[registering-a-device-supplied-id]]
===== Registering a Device-Supplied ID

If the device can supply the driver with an identifier that is unique,
the driver can simply initialize the _device ID_ with this identifier
and register the ID with the illumos DDI.

[source,c]
----
/*
 * The device provides a guaranteed unique identifier,
 * in this case a SCSI3-WWN.  The WWN for the device has been
 * stored in the device's soft state.
 */
if (ddi_devid_init(dip, DEVID_SCSI3_WWN, un->un_wwn_len, un->un_wwn,
    &un->un_devid) != DDI_SUCCESS)
    return (DDI_FAILURE);

(void) ddi_devid_register(dip, un->un_devid);
----

[[registering-a-fabricated-id]]
===== Registering a Fabricated ID

A driver might also register device IDs for devices that do not directly
supply a unique ID. Registering these IDs requires the device to be
capable of storing and retrieving a small amount of data in a reserved
area. The driver can then create a fabricated device ID and write it to
the reserved area.

[source,c]
----
/*
 * the device doesn't supply a unique ID, attempt to read
 * a fabricated ID from the device's reserved data.
 */
if (xxx_read_deviceid(un, &devid_buf) == XXX_OK) {
    if (ddi_devid_valid(devid_buf) == DDI_SUCCESS) {
        devid_sz = ddi_devi_sizeof(devid_buf);
        un->un_devid = kmem_alloc(devid_sz, KM_SLEEP);
        bcopy(devid_buf, un->un_devid, devid_sz);
        ddi_devid_register(dip, un->un_devid);
        return (XXX_OK);
    }
}
/*
 * we failed to read a valid device ID from the device
 * fabricate an ID, store it on the device, and register
 * it with the DDI
 */
if (ddi_devid_init(dip, DEVID_FAB, 0, NULL, &un->un_devid)
    == DDI_FAILURE) {
    return (XXX_FAILURE);
}
if (xxx_write_deviceid(un) != XXX_OK) {
    ddi_devid_free(un->un_devid);
    un->un_devid = NULL;
    return (XXX_FAILURE);
}
ddi_devid_register(dip, un->un_devid);
return (XXX_OK);
----

[[unregistering-device-ids]]
==== Unregistering Device IDs

Drivers typically unregister and free any _device IDs_ that are
allocated as part of the `detach(9E)` handling. The driver first calls
`ddi++_++devid++_++unregister(9F)` to unregister the _device ID_ for the
device instance. The driver must then free the _device ID_ handle itself
by calling `ddi++_++devid++_++free(9F)`, and then passing the handle
that had been returned by `ddi++_++devid++_++init(9F)`. The driver is
responsible for managing any space allocated for WWN or Serial Number
data.

[[device-access-programmed-io]]
=== Device Access: Programmed I/O

illumos provides driver developers with a comprehensive set of
interfaces for accessing device memory. These interfaces are designed to
shield the driver from platform-specific dependencies by handling
mismatches between processor and device endianness as well as enforcing
any data order dependencies the device might have. By using these
interfaces, you can develop a single-source driver that runs on both the
SPARC and x86 processor architectures as well as the various platforms
from each respective processor family.

This chapter provides information on the following subjects:

* link:#managing-differences-in-device-and-host-endianness[Managing Differences in Device and Host Endianness]
* link:#managing-data-ordering-requirements[Managing Data Ordering Requirements]
* link:#ddideviceacc_attr-structure[ Structure]
* link:#mapping-device-memory[Mapping Device Memory]
* link:#mapping-setup-example[Mapping Setup Example]
* link:#alternate-device-access-interfaces[Alternate Device Access Interfaces]

[[device-memory]]
=== Device Memory

Devices that support programmed I/O are assigned one or more regions of
bus address space that map to addressable regions of the device. These
mappings are described as pairs of values in the `reg` property
associated with the device. Each value pair describes a segment of a bus
address.

Drivers identify a particular bus address mapping by specifying the
register number, or `regspec`, which is an index into the devices' `reg`
property. The `reg` property identifies the `busaddr` and `size` for the
device. Drivers pass the register number when making calls to DDI
functions such as `ddi++_++regs++_++map++_++setup(9F)`. Drivers can
determine how many mappable regions have been assigned to the device by
calling `ddi++_++dev++_++nregs(9F)`.

[[managing-differences-in-device-and-host-endianness]]
==== Managing Differences in Device and Host Endianness

The data format of the host can have different endian characteristics
than the data format of the device. In such a case, data transferred
between the host and device would need to be byte-swapped to conform to
the data format requirements of the destination location. Devices with
the same endian characteristics of the host require no byte-swapping of
the data.

Drivers specify the endian characteristics of the device by setting the
appropriate flag in the `ddi++_++device++_++acc++_++attr(9S)` structure
that is passed to `ddi++_++regs++_++map++_++setup(9F)`. The DDI
framework then performs any required byte-swapping when the driver calls
a `ddi++_++get`_X_ routine like `ddi++_++get8(9F)` or a `ddi++_++put`_X_
routine like `ddi++_++put16(9F)` to read or write to device memory.

[[managing-data-ordering-requirements]]
==== Managing Data Ordering Requirements

Platforms can reorder loads and stores of data to optimize performance
of the platform. Because reordering might not be allowed by certain
devices, the driver is required to specify the device's ordering
requirements when setting up mappings to the device.

[[ddideviceacc_attr-structure]]
==== `ddi++_++device++_++acc++_++attr` Structure

This structure describes the endian and data order
requirements of the device. The driver is required to initialize and
pass this structure as an argument to
`ddi++_++regs++_++map++_++setup(9F)`.

[source,c]
----
typedef struct ddi_device_acc_attr {
    ushort_t    devacc_attr_version;
    uchar_t     devacc_attr_endian_flags;
    uchar_t     devacc_attr_dataorder;
} ddi_device_acc_attr_t;
----

`devacc++_++attr++_++version`::
  Specifies `DDI++_++DEVICE++_++ATTR++_++V0`
`devacc++_++attr++_++endian++_++flags`::
  Describes the endian characteristics of the device. Specified as a bit
  value whose possible values are:
  +
  * `DDI++_++NEVERSWAP++_++ACC` – Never swap data
  * `DDI++_++STRUCTURE++_++BE++_++ACC` – The device data format is
  big-endian
  * `DDI++_++STRUCTURE++_++LE++_++ACC` – The device data format is
  little-endian
`devacc++_++attr++_++dataorder`::
  Describes the order in which the CPU must reference data as required
  by the device. Specified as an enumerated value, where data access
  restrictions are ordered from most strict to least strict.
  +
  * `DDI++_++STRICTORDER++_++ACC` – The host must issue the references
  in order, as specified by the programmer. This flag is the default
  behavior.
  * `DDI++_++UNORDERED++_++OK++_++ACC` – The host is allowed to reorder
  loads and stores to device memory.
  * `DDI++_++MERGING++_++OK++_++ACC` – The host is allowed to merge
  individual stores to consecutive locations. This setting also implies
  reordering.
  * `DDI++_++LOADCACHING++_++OK++_++ACC` – The host is allowed to read
  data from the device until a store occurs.
  * `DDI++_++STORECACHING++_++OK++_++ACC` – The host is allowed to cache
  data written to the device. The host can then defer writing the data
  to the device until a future time.

[NOTE]

The system can access data more strictly than the driver specifies in
`devacc++_++attr++_++dataorder`. The restriction to the host diminishes
while moving from strict data ordering to cache storing in terms of data
accesses by the driver.
===

[[mapping-device-memory]]
==== Mapping Device Memory

Drivers typically map all regions of a device during `attach(9E)`. The
driver maps a region of device memory by calling
`ddi++_++regs++_++map++_++setup(9F)`, specifying the register number of
the region to map, the device access attributes for the region, an
offset, and size. The DDI framework sets up the mappings for the device
region and returns an opaque handle to the driver. This data access
handle is passed as an argument to the `ddi++_++get8(9F)` or
`ddi++_++put8(9F)` family of routines when reading data from or writing
data to that region of the device.

The driver verifies that the shape of the device mappings match what the
driver is expecting by checking the number of mappings exported by the
device. The driver calls `ddi++_++dev++_++nregs(9F)` and then verifies
the size of each mapping by calling `ddi++_++dev++_++regsize(9F)`.

[[mapping-setup-example]]
==== Mapping Setup Example

The following simple example demonstrates the DDI data access
interfaces. This driver is for a fictional little endian device that
accepts one character at a time and generates an interrupt when ready
for another character. This device implements two register sets: the
first is an 8-bit CSR register, and the second is an 8-bit data
register.

[[devaccess-ex-24]]
Mapping Setup

[source,c]
----
#define CSR_REG 0
#define DATA_REG 1
/*
 * Initialize the device access attributes for the register
 * mapping
 */
dev_acc_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
dev_acc_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
dev_acc_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
/*
 * Map in the csr register (register 0)
 */
if (ddi_regs_map_setup(dip, CSR_REG, (caddr_t *)&(pio_p->csr), 0,
  sizeof (Pio_csr), &dev_acc_attr, &pio_p->csr_handle) != DDI_SUCCESS) {
    mutex_destroy(&pio_p->mutex);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_FAILURE);
}
/*
 * Map in the data register (register 1)
 */
if (ddi_regs_map_setup(dip, DATA_REG, (caddr_t *)&(pio_p->data), 0,
  sizeof (uchar_t), &dev_acc_attr, &pio_p->data_handle) \
  != DDI_SUCCESS) {
    mutex_destroy(&pio_p->mutex);
    ddi_regs_map_free(&pio_p->csr_handle);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_FAILURE);
}
----

[[device-access-functions]]
=== Device Access Functions

Drivers use the `ddi++_++get8(9F)` and `ddi++_++put8(9F)` family of
routines in conjunction with the handle returned by
`ddi++_++regs++_++map++_++setup(9F)` to transfer data to and from a
device. The DDI framework automatically handles any byte-swapping that
is required to meet the endian format for the host or device, and
enforces any store-ordering constraints the device might have.

The DDI provides interfaces for transferring data in 8-bit, 16-bit,
32-bit, and 64-bit quantities, as well as interfaces for transferring
multiple values repeatedly. See the man pages for the
`ddi++_++get8(9F)`, `ddi++_++put8(9F)`, `ddi++_++rep++_++get8(9F)` and
`ddi++_++rep++_++put8(9F)` families of routines for a complete listing
and description of these interfaces.

The following example builds on link:#devaccess-ex-24[example++_++title]
where the driver mapped the device's CSR and data registers. Here, the
driver's `write(9E)` entry point, when called, writes a buffer of data
to the device one byte at a time.

[[devaccess-ex-26]]
Mapping Setup: Buffer

[source,c]
----
static  int
pio_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    int  retval;
    int  error = OK;
    Pio *pio_p = ddi_get_soft_state(pio_softstate, getminor(dev));

    if (pio_p == NULL)
        return (ENXIO);
    mutex_enter(&pio_p->mutex);
    /*
     * enable interrupts from the device by setting the Interrupt
     * Enable bit in the devices CSR register
     */
    ddi_put8(pio_p->csr_handle, pio_p->csr,
      (ddi_get8(pio_p->csr_handle, pio_p->csr) | PIO_INTR_ENABLE));

    while (uiop->uio_resid > 0) {
    /*
     * This device issues an IDLE interrupt when it is ready
     * to accept a character; the interrupt can be cleared
     * by setting PIO_INTR_CLEAR.  The interrupt is reasserted
     * after the next character is written or the next time
     * PIO_INTR_ENABLE is toggled on.
     *
     * wait for interrupt (see pio_intr)
     */
        cv_wait(&pio_p->cv, &pio_p->mutex);

    /*
     * get a character from the user's write request
     * fail the write request if any errors are encountered
     */
        if ((retval = uwritec(uiop)) == -1) {
            error = retval;
            break;
        }

    /*
     * pass the character to the device by writing it to
     * the device's data register
     */
        ddi_put8(pio_p->data_handle, pio_p->data, (uchar_t)retval);
    }

    /*
     * disable interrupts by clearing the Interrupt Enable bit
     * in the CSR
     */
    ddi_put8(pio_p->csr_handle, pio_p->csr,
      (ddi_get8(pio_p->csr_handle, pio_p->csr) & ~PIO_INTR_ENABLE));

    mutex_exit(&pio_p->mutex);
    return (error);
}
----

[[alternate-device-access-interfaces]]
==== Alternate Device Access Interfaces

In addition to implementing all device accesses through the
`ddi++_++get8(9F)` and `ddi++_++put8(9F)` families of interfaces,
illumos provides interfaces that are specific to particular bus
implementations. While these functions can be more efficient on some
platforms, use of these routines can limit the ability of the driver to
remain portable across different bus versions of the device.

[[memory-space-access]]
===== Memory Space Access

With memory mapped access, device registers appear in memory address
space. The `ddi++_++get`_X_ family of routines and the `ddi++_++put`_X_
family are available for use by drivers as an alternative to the
standard device access interfaces.

[[io-space-access]]
===== I/O Space Access

With I/O space access, the device registers appear in I/O space, where
each addressable element is called an I/O port. The
`ddi++_++io++_++get8(9F)` and `ddi++_++io++_++put8(9F)` routines are
available for use by drivers as an alternative to the standard device
access interfaces.

[[pci-configuration-space-access]]
===== PCI Configuration Space Access

To access PCI configuration space without using the normal device access
interfaces, a driver is required to map PCI configuration space by
calling `pci++_++config++_++setup(9F)` in place of
`ddi++_++regs++_++map++_++setup(9F)`. The driver can then call the
`pci++_++config++_++get8(9F)` and `pci++_++config++_++put8(9F)` families
of interfaces to access PCI configuration space.

[[interrupt-handlers]]
=== Interrupt Handlers

writing handlers

interrupt handling

This chapter describes mechanisms for handling interrupts, such as
registering, servicing, and removing interrupts. This chapter provides
information on the following subjects:

* link:#interrupt-handler-overview[Interrupt Handler Overview]
* link:#device-interrupts[Device Interrupts]
* link:#registering-interrupts[Registering Interrupts]
* link:#interrupt-handler-functionality[Interrupt Handler Functionality]
* link:#handling-high-level-interrupts[Handling High-Level Interrupts]

[[interrupt-handler-overview]]
=== Interrupt Handler Overview

An interrupt is a hardware signal from a
device to a CPU. An interrupt tells the CPU that the device needs
attention and that the CPU should stop any current activity and respond
to the device. If the CPU is not performing a task that has higher
priority than the priority of the interrupt, then the CPU suspends the
current thread. The CPU then invokes the interrupt handler for the
device that sent the interrupt signal. The job of the interrupt handler
is to service the device and stop the device from interrupting. When the
interrupt handler returns, the CPU resumes the work it was doing before
the interrupt occurred.

The illumos DDI/DKI provides interfaces for performing the following
tasks:

* Determining interrupt type and registration requirements
* Registering interrupts
* Servicing interrupts
* Masking interrupts
* Getting interrupt pending information
* Getting and setting priority information

[[device-interrupts]]
=== Device Interrupts

device interrupts

interrupts; interrupt handling

  I/O buses implement interrupts in two
common ways: _vectored_ and _polled_. Both methods commonly supply a
bus-interrupt priority level. Vectored devices also supply an interrupt
vector. Polled devices do not supply interrupt vectors.

To stay current with changing bus technologies, illumos has been
enhanced to accommodate both newer types of interrupts and more
traditional interrupts that have been in use for many years.
Specifically, the operating system now recognizes three types of
interrupts:

* *Legacy interrupts* –
_Legacy_ or _fixed interrupts_ refer to interrupts that use older bus
technologies. With these technologies, interrupts are signaled by using
one or more external pins that are wired “out-of-band,” that is,
separately from the main lines of the bus. Newer bus technologies such
as PCI Express maintain software compatibility by emulating legacy
interrupts through in-band mechanisms. These emulated interrupts are
treated as legacy interrupts by the host OS.
* *Message-signaled
interrupts* – Instead of using pins, message-signaled interrupts (MSI)
are in-band messages and can target addresses in the host bridge. (See
link:#pci-local-bus[PCI Local Bus] for more information on host bridges.)
MSIs can send data along with the interrupt message. Each MSI is
unshared so that an MSI that is assigned to a device is guaranteed to be
unique within the system. A PCI function can request up to 32 MSI
messages.
* *Extended message-signaled
interrupts* – Extended message-signaled interrupts (MSI-X) are an
enhanced version of MSIs. MSI-X interrupts have the following added
advantages:
** Support 2048 messages rather than 32 messages
** Support independent message address and message data for each message
** Support per-message masking
** Enable more flexibility when software allocates fewer vectors than
hardware requests. The software can reuse the same MSI-X address and
data in multiple MSI-X slots.

[NOTE]

Some newer bus technologies such as PCI Express require MSIs but can
accommodate legacy interrupts by using INTx emulation. INTx emulation is
used for compatibility purposes, but is not considered to be good
practice.
===

[[high-level-interrupts]]
==== High-Level Interrupts

A bus prioritizes a device interrupt at a
_bus-interrupt level_. The bus interrupt level is then mapped to a
processor-interrupt level. A bus interrupt level that maps to a CPU
interrupt priority above the scheduler priority level is called a
_high-level interrupt_. High-level interrupt handlers are restricted to
calling the following DDI interfaces:

*   `mutex++_++enter(9F)` and
`mutex++_++exit(9F)` on a mutex that is initialized with an interrupt
priority associated with the high-level interrupt
*  
`ddi++_++intr++_++trigger++_++softint(9F)`
* The following DDI `get` and `put` routines: `ddi++_++get8(9F)`,
`ddi++_++put8(9F)`, `ddi++_++get16(9F)`, `ddi++_++put16(9F)`,
`ddi++_++get32(9F)`, `ddi++_++put32(9F)`, `ddi++_++get64(9F)`, and
`ddi++_++put64(9F)`.

A bus-interrupt level by itself does not determine whether a device
interrupts at a high level. A particular bus-interrupt level can map to
a high-level interrupt on one platform, but map to an ordinary interrupt
on another platform.

A driver is not required to support
devices that have high-level interrupts. However, the driver is required
to check the interrupt level. If the interrupt priority is greater than
or equal to the highest system priority, the interrupt handler runs in
high-level interrupt context. In this case, the driver can fail to
attach, or the driver can use a two-level scheme to handle interrupts.
For more information, see link:#handling-high-level-interrupts[Handling High-Level
Interrupts].

[[legacy-interrupts]]
==== Legacy Interrupts

legacy interrupts

using legacy

The only information that the system has about a device interrupt is the
priority level of the bus interrupt and the interrupt request number. An
example of the priority level for a bus interrupt is the IPL on an SBus
in a SPARC machine. An example of an interrupt request number is the IRQ
on an ISA bus in an x86 machine.

When an interrupt handler is registered, the system adds the handler to
a list of potential interrupt handlers for each IPL or IRQ. When the
interrupt occurs, the system must determine which device actually caused
the interrupt, among all devices that are associated with a given IPL or
IRQ. The system calls all the interrupt handlers for the designated IPL
or IRQ until one handler claims the interrupt.

The following buses are capable of supporting polled interrupts:

* SBus
* ISA
* PCI

[[standard-and-extended-message-signaled-interrupts]]
==== Standard and Extended Message-Signaled Interrupts

Both standard (MSI) and extended (MSI-X) message-signaled interrupts are
implemented as in-band messages. A message-signaled interrupt is posted
as a write with an address and value that are specified by the software.

[[msi-interrupts]]
===== MSI Interrupts

Conventional PCI
specifications include optional support for Message Signaled Interrupts
(MSI). An MSI is an in-band message that is implemented as a posted
write. The address and the data for the MSI are specified by software
and are specific to the host bridge. Because the messages are in-band,
the receipt of the message can be used to “push” data that is associated
with the interrupt. By definition, MSI interrupts are unshared. Each MSI
message that is assigned to a device is guaranteed to be a unique
message in the system. PCI functions can request 1, 2, 4, 8, 16, or 32
MSI messages. Note that the system software can allocate fewer MSI
messages to a function than the function requested. The host bridge can
be limited in the number of unique MSI messages that are allocated for
devices.

[[msi-x-interrupts]]
===== MSI-X Interrupts

MSI-X interrupts are
enhanced versions of MSI interrupts that have the same features as MSI
interrupts with the following key differences:

* A maximum of 2048 MSI-X interrupt vectors are supported per device.
* Address and data entries are unique per interrupt vector.
* MSI-X supports per function masking and per vector masking.

MSI-X interrupts, an unallocated interrupt vector of a device can use a
previously added or initialized MSI-X interrupt vector to share the same
vector address, vector data, interrupt handler, and handler arguments.
Use the `ddi++_++intr++_++dup++_++handler(9F)` function to alias the
resources provided by illumos to the unallocated interrupt vectors on an
associated device. For example, if 2 MSI-X interrupts are allocated to a
driver and 32 interrupts are supported on the device, then the driver
can use `ddi++_++intr++_++dup++_++handler` to alias the 2 interrupts it
received to the 30 additional interrupts on the device.

The `ddi++_++intr++_++dup++_++handler` function can duplicate interrupts
that were added with `ddi++_++intr++_++add++_++handler(9F)` or
initialized with `ddi++_++intr++_++enable(9F)`.

A duplicated interrupt is disabled initially. Use
`ddi++_++intr++_++enable` to enable the duplicated interrupt. You cannot
remove the original MSI-X interrupt handler until all duplicated
interrupt handlers that are associated with this original interrupt
handler are removed. To remove a duplicated interrupt handler, first
call `ddi++_++intr++_++disable(9F)`, and then call
`ddi++_++intr++_++free(9F)`. When all duplicated interrupt handlers that
are associated with this original interrupt handler are removed, then
you can use `ddi++_++intr++_++remove++_++handler(9F)` to remove the
original MSI-X interrupt handler. See the
`ddi++_++intr++_++dup++_++handler(9F)` man page for examples.

[[software-interrupts]]
==== Software Interrupts

  The illumos DDI/DKI supports software
interrupts, also known as _soft interrupts_. Soft interrupts are
initiated by software rather than by a hardware device. Handlers for
these interrupts must also be added to and removed from the system. Soft
interrupt handlers run in interrupt context and therefore can be used to
do many of the tasks that belong to an interrupt handler.

Hardware interrupt handlers must perform their tasks quickly, because
the handlers might have to suspend other system activity while doing
these tasks. This requirement is particularly true for high-level
interrupt handlers, which operate at priority levels greater than the
priority level of the system scheduler. High-level interrupt handlers
mask the operations of all lower-priority interrupts, including the
interrupt operations of the system clock. Consequently, the interrupt
handler must avoid involvement in activities that might cause it to
sleep, such as acquiring a mutex.

If the handler sleeps, then the system might hang because
the clock is masked and incapable of scheduling the sleeping thread. For
this reason, high-level interrupt handlers normally perform a minimum
amount of work at high-priority levels and delegate other tasks to
software interrupts, which run below the priority level of the
high-level interrupt handler. Because software interrupt handlers run
below the priority level of the system scheduler, software interrupt
handlers can do the work that the high-level interrupt handler was
incapable of doing.

[[ddi-interrupt-functions]]
=== DDI Interrupt Functions

illumos provides a framework for registering and unregistering
interrupts and provides support for Message Signaled Interrupts (MSIs).
Interrupt management interfaces enable you to manipulate priorities,
capabilities, and interrupt masking, and to obtain pending information.

[[interrupt-capability-functions]]
==== Interrupt Capability Functions

Use the following functions to obtain interrupt
information:

`ddi++_++intr++_++get++_++navail(9F)`::
  Returns the number of interrupts available for a specified hardware
  device and interrupt type.
`ddi++_++intr++_++get++_++nintrs(9F)`::
  Returns the number of interrupts that the device supports for the
  specified interrupt type.
`ddi++_++intr++_++get++_++supported++_++types(9F)`::
  Returns the hardware interrupt types that are supported by both the
  device and the host.
`ddi++_++intr++_++get++_++cap(9F)`::
  Returns interrupt capability flags for the specified interrupt.

[[interrupt-initialization-and-destruction-functions]]
==== Interrupt Initialization and Destruction Functions

   Use the following functions
to create and remove interrupts:

`ddi++_++intr++_++alloc(9F)`::
  Allocates system resources and interrupt vectors for the specified
  type of interrupt.
`ddi++_++intr++_++free(9F)`::
  Releases the system resources and interrupt vectors for a specified
  interrupt handle.
`ddi++_++intr++_++set++_++cap(9F)`::
  Sets the capability of the specified interrupt through the use of the
  DDI++_++INTR++_++FLAG++_++LEVEL and DDI++_++INTR++_++FLAG++_++EDGE
  flags.
`ddi++_++intr++_++add++_++handler(9F)`::
  Adds an interrupt handler.
`ddi++_++intr++_++dup++_++handler(9F)`::
  Use with MSI-X only. Copies an address and data pair for an allocated
  interrupt vector to an unused interrupt vector on the same device.
`ddi++_++intr++_++remove++_++handler(9F)`::
  Removes the specified interrupt handler.
`ddi++_++intr++_++enable(9F)`::
  Enables the specified interrupt.
`ddi++_++intr++_++disable(9F)`::
  Disables the specified interrupt.
`ddi++_++intr++_++block++_++enable(9F)`::
  Use with MSI only. Enables the specified range of interrupts.
`ddi++_++intr++_++block++_++disable(9F)`::
  Use with MSI only. Disables the specified range of interrupts.
`ddi++_++intr++_++set++_++mask(9F)`::
  Sets an interrupt mask if the specified interrupt is enabled.
`ddi++_++intr++_++clr++_++mask(9F)`::
  Clears an interrupt mask if the specified interrupt is enabled.
`ddi++_++intr++_++get++_++pending(9F)`::
  Reads the interrupt pending bit if such a bit is supported by either
  the host bridge or the device.

[[priority-management-functions]]
==== Priority Management Functions

   Use the following functions
to obtain and set priority information:

`ddi++_++intr++_++get++_++pri(9F)`::
  Returns the current software priority setting for the specified
  interrupt.
`ddi++_++intr++_++set++_++pri(9F)`::
  Sets the interrupt priority level for the specified interrupt.
`ddi++_++intr++_++get++_++hilevel++_++pri(9F)`::
  Returns the minimum priority level for a high-level interrupt.

[[soft-interrupt-functions]]
==== Soft Interrupt Functions

   Use the following functions
to manipulate soft interrupts and soft interrupt handlers:

`ddi++_++intr++_++add++_++softint(9F)`::
  Adds a soft interrupt handler.
`ddi++_++intr++_++trigger++_++softint(9F)`::
  Triggers the specified soft interrupt.
`ddi++_++intr++_++remove++_++softint(9F)`::
  Removes the specified soft interrupt handler.
`ddi++_++intr++_++get++_++softint++_++pri(9F)`::
  Returns the soft interrupt priority for the specified interrupt.
`ddi++_++intr++_++set++_++softint++_++pri(9F)`::
  Changes the relative soft interrupt priority for the specified soft
  interrupt.

[[interrupt-function-examples]]
==== Interrupt Function Examples

This section provides examples for performing the
following tasks:

* Changing soft interrupt priority
* Checking for pending interrupts
* Setting interrupt masks
* Clearing interrupt masks

[[fxjor]]
Changing Soft Interrupt Priority

ddi++_++intr++_++set++_++softint++_++pri

interrupt handling

ddi++_++intr++_++set++_++softint++_++pri

interrupt handling

software interrupts

software interrupts

changing priority

Use the `ddi++_++intr++_++set++_++softint++_++pri(9F)` function to
change the soft interrupt priority to 9.

[source,c]
----
if (ddi_intr_set_softint_pri(mydev->mydev_softint_hdl, 9) != DDI_SUCCESS)
    cmn_err (CE_WARN, "ddi_intr_set_softint_pri failed");
----

[[fxjpd]]
Checking for Pending Interrupts

ddi++_++intr++_++get++_++pending

interrupt handling

ddi++_++intr++_++get++_++pending

interrupt handling

pending interrupts

Use the `ddi++_++intr++_++get++_++pending(9F)` function to check whether
an interrupt is pending.

[source,c]
----
if (ddi_intr_get_pending(mydevp->htable[0], &pending) != DDI_SUCCESS)
    cmn_err(CE_WARN, "ddi_intr_get_pending() failed");
else if (pending)
    cmn_err(CE_NOTE, "ddi_intr_get_pending(): Interrupt pending");
----

[[fxjpb]]
Setting Interrupt Masks

ddi++_++intr++_++set++_++mask

interrupt handling

ddi++_++intr++_++set++_++mask

interrupt handling

setting masks

Use the `ddi++_++intr++_++set++_++mask(9F)` function to set interrupt
masking to prevent the device from receiving interrupts.

[source,c]
----
if ((ddi_intr_set_mask(mydevp->htable[0]) != DDI_SUCCESS))
    cmn_err(CE_WARN, "ddi_intr_set_mask() failed");
----

[[fxjqj]]
Clearing Interrupt Masks

ddi++_++intr++_++clr++_++mask

interrupt handling

ddi++_++intr++_++clr++_++mask

interrupt handling

clearing masks

Use the `ddi++_++intr++_++clr++_++mask(9F)` function to clear interrupt
masking. The `ddi++_++intr++_++clr++_++mask(9F)` function fails if the
specified interrupt is not enabled. If the
`ddi++_++intr++_++clr++_++mask(9F)` function succeeds, the device starts
generating interrupts.

[source,c]
----
if (ddi_intr_clr_mask(mydevp->htable[0]) != DDI_SUCCESS)
    cmn_err(CE_WARN, "ddi_intr_clr_mask() failed");
----

[[registering-interrupts]]
=== Registering Interrupts

Before a device driver can
receive and service interrupts, the driver must call
`ddi++_++intr++_++add++_++handler(9F)` to register an interrupt handler
with the system. Registering interrupt handlers provides the system with
a way to associate an interrupt handler with an interrupt specification.
The interrupt handler is called when the device might have been
responsible for the interrupt. The handler has the responsibility of
determining whether it should handle the interrupt and, if so, of
claiming that interrupt.

[TIP]

Use the `::interrupts` command in the `mdb` or `kmdb` debugger to
retrieve the registered interrupt information of a device on supported
SPARC and x86 systems.
===

[[registering-legacy-interrupts]]
==== Registering Legacy Interrupts

registering legacy interrupts

To register a driver's interrupt handler, the driver typically performs
the following steps in its `attach(9E)` entry point:

[arabic]
. Use `ddi++_++intr++_++get++_++supported++_++types(9F)` to determine
which types of interrupts are supported.
. Use `ddi++_++intr++_++get++_++nintrs(9F)` to determine the number of
supported interrupt types.
. Use `kmem++_++zalloc(9F)` to allocate memory for DDI interrupt
handles.
. For each interrupt type that you allocate, take the following steps:
[arabic]
.. Use `ddi++_++intr++_++get++_++pri(9F)` to get the priority for the
interrupt.
.. If you need to set a new priority for the interrupt, use
`ddi++_++intr++_++set++_++pri(9F)`.
.. Use `mutex++_++init(9F)` to initialize the lock.
.. Use `ddi++_++intr++_++add++_++handler(9F)` to register the handler
for the interrupt.
.. Use `ddi++_++intr++_++enable(9F)` to enable the interrupt.
. Take the following steps to free each interrupt:
[arabic]
.. Disable each interrupt using `ddi++_++intr++_++disable(9F)`.
.. Remove the interrupt handler using
`ddi++_++intr++_++remove++_++handler(9F)`.
.. Remove the lock using `mutex++_++destroy(9F)`.
.. Free the interrupt using `ddi++_++intr++_++free(9F)` and
`kmem++_++free(9F)` to free memory that was allocated for DDI interrupt
handles.

[[fwbtg]]
Registering a Legacy Interrupt

registering legacy interrupt example

The following example shows how to install an interrupt handler for a
device called `mydev`. This example assumes that `mydev` supportsone
interrupt only.

[source,c]
----
/* Determine which types of interrupts supported */
ret = ddi_intr_get_supported_types(mydevp->mydev_dip, &type);

if ((ret != DDI_SUCCESS) || (!(type & DDI_INTR_TYPE_FIXED))) {
    cmn_err(CE_WARN, "Fixed type interrupt is not supported");
    return (DDI_FAILURE);
}

/* Determine number of supported interrupts */
ret = ddi_intr_get_nintrs(mydevp->mydev_dip, DDI_INTR_TYPE_FIXED,
    &count);

/*
 * Fixed interrupts can only have one interrupt. Check to make
 * sure that number of supported interrupts and number of
 * available interrupts are both equal to 1.
 */
if ((ret != DDI_SUCCESS) || (count != 1)) {
    cmn_err(CE_WARN, "No fixed interrupts");
    return (DDI_FAILURE);
}

/* Allocate memory for DDI interrupt handles */
mydevp->mydev_htable = kmem_zalloc(sizeof (ddi_intr_handle_t),
    KM_SLEEP);
ret = ddi_intr_alloc(mydevp->mydev_dip, mydevp->mydev_htable,
    DDI_INTR_TYPE_FIXED, 0, count, &actual, 0);

if ((ret != DDI_SUCCESS) || (actual != 1)) {
    cmn_err(CE_WARN, "ddi_intr_alloc() failed 0x%x", ret);
    kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));
    return (DDI_FAILURE);
}

/* Sanity check that count and available are the same. */
ASSERT(count == actual);

/* Get the priority of the interrupt */
if (ddi_intr_get_pri(mydevp->mydev_htable[0], &mydevp->mydev_intr_pri)) {
    cmn_err(CE_WARN, "ddi_intr_alloc() failed 0x%x", ret);

    (void) ddi_intr_free(mydevp->mydev_htable[0]);
    kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

cmn_err(CE_NOTE, "Supported Interrupt pri = 0x%x", mydevp->mydev_intr_pri);

/* Test for high level mutex */
if (mydevp->mydev_intr_pri >= ddi_intr_get_hilevel_pri()) {
    cmn_err(CE_WARN, "Hi level interrupt not supported");

    (void) ddi_intr_free(mydevp->mydev_htable[0]);
    kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

/* Initialize the mutex */
mutex_init(&mydevp->mydev_int_mutex, NULL, MUTEX_DRIVER,
    DDI_INTR_PRI(mydevp->mydev_intr_pri));

/* Register the interrupt handler */
if (ddi_intr_add_handler(mydevp->mydev_htable[0], mydev_intr, 
   (caddr_t)mydevp, NULL) !=DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_add_handler() failed");

    mutex_destroy(&mydevp->mydev_int_mutex);
    (void) ddi_intr_free(mydevp->mydev_htable[0]);
    kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

/* Enable the interrupt */
if (ddi_intr_enable(mydevp->mydev_htable[0]) != DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_enable() failed");

    (void) ddi_intr_remove_handler(mydevp->mydev_htable[0]);
    mutex_destroy(&mydevp->mydev_int_mutex);
    (void) ddi_intr_free(mydevp->mydev_htable[0]);
    kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}
return (DDI_SUCCESS);
}
----

[[fwbjs]]
Removing a Legacy Interrupt

removing legacy interrupt example

The following example shows how legacy interrupts are removed.

[source,c]
----
/* disable interrupt */
(void) ddi_intr_disable(mydevp->mydev_htable[0]);

/* Remove interrupt handler */
(void) ddi_intr_remove_handler(mydevp->mydev_htable[0]);

/* free interrupt handle */
(void) ddi_intr_free(mydevp->mydev_htable[0]);

/* free memory */
kmem_free(mydevp->mydev_htable, sizeof (ddi_intr_handle_t));
----

[[registering-msi-interrupts]]
==== Registering MSI Interrupts

registering MSI interrupts

To register a driver's interrupt handler, the driver typically performs
the following steps in its `attach(9E)` entry point:

[arabic]
. Use `ddi++_++intr++_++get++_++supported++_++types(9F)` to determine
which types of interrupts are supported.
. Use `ddi++_++intr++_++get++_++nintrs(9F)` to determine the number of
supported MSI interrupt types.
. Use `ddi++_++intr++_++alloc(9F)` to allocate memory for the MSI
interrupts.
. For each interrupt type that you allocate, take the following steps:
[arabic]
.. Use `ddi++_++intr++_++get++_++pri(9F)` to get the priority for the
interrupt.
.. If you need to set a new priority for the interrupt, use
`ddi++_++intr++_++set++_++pri(9F)`.
.. Use `mutex++_++init(9F)` to initialize the lock.
.. Use `ddi++_++intr++_++add++_++handler(9F)` to register the handler
for the interrupt.
. Use one of the following functions to enable all the interrupts:
* Use `ddi++_++intr++_++block++_++enable(9F)` to enable all the
interrupts in a block.
* Use `ddi++_++intr++_++enable(9F)` in a loop to enable each interrupt
individually.

[[fwbiz]]
Registering a Set of MSI Interrupts

registering MSI interrupts example

The following example illustrates how to register an MSI interrupt for a
device called `mydev`.

[source,c]
----
/* Get supported interrupt types */
if (ddi_intr_get_supported_types(devinfo, &intr_types) != DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_get_supported_types failed");
    goto attach_fail;
}

if (intr_types & DDI_INTR_TYPE_MSI)
    mydev_add_msi_intrs(mydevp);

/* Check count, available and actual interrupts */
static int
mydev_add_msi_intrs(mydev_t *mydevp)
{
    dev_info_t    *devinfo = mydevp->devinfo;
    int           count, avail, actual;
    int           x, y, rc, inum = 0;

    /* Get number of interrupts */
    rc = ddi_intr_get_nintrs(devinfo, DDI_INTR_TYPE_MSI, &count);
    if ((rc != DDI_SUCCESS) || (count == 0)) {
        cmn_err(CE_WARN, "ddi_intr_get_nintrs() failure, rc: %d, "
            "count: %d", rc, count);
        return (DDI_FAILURE);
    }

    /* Get number of available interrupts */
    rc = ddi_intr_get_navail(devinfo, DDI_INTR_TYPE_MSI, &avail);
    if ((rc != DDI_SUCCESS) || (avail == 0)) {
        cmn_err(CE_WARN, "ddi_intr_get_navail() failure, "
            "rc: %d, avail: %d\n", rc, avail);
        return (DDI_FAILURE);
    }
    if (avail < count) {
        cmn_err(CE_NOTE, "nitrs() returned %d, navail returned %d",
            count, avail);
    }

    /* Allocate memory for MSI interrupts */
    mydevp->intr_size = count * sizeof (ddi_intr_handle_t);
    mydevp->htable = kmem_alloc(mydevp->intr_size, KM_SLEEP);

    rc = ddi_intr_alloc(devinfo, mydevp->htable, DDI_INTR_TYPE_MSI, inum,
        count, &actual, DDI_INTR_ALLOC_NORMAL);

    if ((rc != DDI_SUCCESS) || (actual == 0)) {
        cmn_err(CE_WARN, "ddi_intr_alloc() failed: %d", rc);
        kmem_free(mydevp->htable, mydevp->intr_size);
        return (DDI_FAILURE);
    }

    if (actual < count) {
        cmn_err(CE_NOTE, "Requested: %d, Received: %d", count, actual);
    }

    mydevp->intr_cnt = actual;
    /*
     * Get priority for first msi, assume remaining are all the same
     */
    if (ddi_intr_get_pri(mydevp->htable[0], &mydev->intr_pri) !=
        DDI_SUCCESS) {
        cmn_err(CE_WARN, "ddi_intr_get_pri() failed");

        /* Free already allocated intr */
        for (y = 0; y < actual; y++) {
            (void) ddi_intr_free(mydevp->htable[y]);
        }

        kmem_free(mydevp->htable, mydevp->intr_size);
        return (DDI_FAILURE);
    }

    /* Call ddi_intr_add_handler() */
    for (x = 0; x < actual; x++) {
        if (ddi_intr_add_handler(mydevp->htable[x], mydev_intr,
           (caddr_t)mydevp, NULL) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_add_handler() failed");

            /* Free already allocated intr */
            for (y = 0; y < actual; y++) {
                (void) ddi_intr_free(mydevp->htable[y]);
            }

            kmem_free(mydevp->htable, mydevp->intr_size);
            return (DDI_FAILURE);
        }
    }

    (void) ddi_intr_get_cap(mydevp->htable[0], &mydevp->intr_cap);
    if (mydev->m_intr_cap & DDI_INTR_FLAG_BLOCK) {
        /* Call ddi_intr_block_enable() for MSI */
        (void) ddi_intr_block_enable(mydev->m_htable, mydev->m_intr_cnt);
    } else {
        /* Call ddi_intr_enable() for MSI non block enable */
        for (x = 0; x < mydev->m_intr_cnt; x++) {
            (void) ddi_intr_enable(mydev->m_htable[x]);
        }
    }
    return (DDI_SUCCESS);
}
----

[[fwbqn]]
Removing MSI Interrupts

removing MSI interrupts example

The following example shows how to remove MSI interrupts.

[source,c]
----
static void
mydev_rem_intrs(mydev_t *mydev)
{
    int    x;

    /* Disable all interrupts */
    if (mydev->m_intr_cap & DDI_INTR_FLAG_BLOCK) {
        /* Call ddi_intr_block_disable() */
        (void) ddi_intr_block_disable(mydev->m_htable, mydev->m_intr_cnt);
    } else {
        for (x = 0; x < mydev->m_intr_cnt; x++) {
            (void) ddi_intr_disable(mydev->m_htable[x]);
        }
    }

    /* Call ddi_intr_remove_handler() */
    for (x = 0; x < mydev->m_intr_cnt; x++) {
        (void) ddi_intr_remove_handler(mydev->m_htable[x]);
        (void) ddi_intr_free(mydev->m_htable[x]);
    }

    kmem_free(mydev->m_htable, mydev->m_intr_size);
}
----

[[interrupt-handler-functionality]]
=== Interrupt Handler Functionality

interrupt handlers

The driver framework and the device each place demands on the interrupt
handler. All interrupt handlers are required to do the following tasks:

* *Determine whether the device is
interrupting and possibly reject the interrupt.*
+
The interrupt handler first examines the device to determine whether
this device issued the interrupt. If this device did not issue the
interrupt, the handler must return `DDI++_++INTR++_++UNCLAIMED`. This
step enables the implementation of _device polling_. Any device at the
given interrupt priority level might have issued the interrupt. Device
polling tells the system whether this device issued the interrupt.
* *Inform the device that the device is being serviced.*
+
Informing a device about servicing is a device-specific operation that
is required for the majority of devices. For example, SBus devices are
required to interrupt until the driver tells the SBus devices to stop.
This approach guarantees that all SBus devices that interrupt at the
same priority level are serviced.
* *Perform any I/O request-related processing.*
+
Devices interrupt for different reasons, such as _transfer done_ or
_transfer error_. This step can involve using data access functions to
read the device's data buffer, examine the device's error register, and
set the status field in a data structure accordingly. Interrupt
dispatching and processing are relatively time consuming.
* *Do any additional processing that could prevent another interrupt.*
+
For example, read the next item of data from the device.
* *Return* `DDI++_++INTR++_++CLAIMED`.
* *MSI interrupts must always be claimed.*
+
Claiming an interrupt is optional for MSI-X interrupts. In either case,
the ownership of the interrupt need not be checked, because MSI and
MSI-X interrupts are not shared with other devices.
* *Drivers that support hotplugging and multiple MSI or
MSI-X interrupts should retain a separate interrupt for hotplug events
and register a separate ISR (interrupt service routine) for that
interrupt.*

The following example shows an interrupt routine
for a device called `mydev`.

[[interrupt-ex-17]]
Interrupt Example

[source,c]
----
static uint_t
mydev_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate *xsp = (struct mydevstate *)arg1;
    uint8_t     status; 
    volatile    uint8_t  temp;

    /*
     * Claim or reject the interrupt. This example assumes
     * that the device's CSR includes this information.
     */
    mutex_enter(&xsp->high_mu);

    /* use data access routines to read status */
    status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
    if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->high_mu);
        return (DDI_INTR_UNCLAIMED); /* dev not interrupting */
    }
    /*
     * Inform the device that it is being serviced, and re-enable
     * interrupts. The example assumes that writing to the
     * CSR accomplishes this. The driver must ensure that this data
     * access operation makes it to the device before the interrupt
     * service routine returns. For example, using the data access
     * functions to read the CSR, if it does not result in unwanted
     * effects, can ensure this.
     */
    ddi_put8(xsp->data_access_handle, &xsp->regp->csr,
        CLEAR_INTERRUPT | ENABLE_INTERRUPTS);

    /* flush store buffers */
    temp = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
    
    mutex_exit(&xsp->mu);
    return (DDI_INTR_CLAIMED);
}
----

Most of the steps performed by the interrupt routine depend on the
specifics of the device itself. Consult the hardware manual for the
device to determine the cause of the interrupt, detect error conditions,
and access the device data registers.

[[handling-high-level-interrupts]]
=== Handling High-Level Interrupts

High-level
interrupts are those interrupts that interrupt at the level of the
scheduler and above. This level does not allow the scheduler to run.
Therefore, high-level interrupt handlers cannot be preempted by the
scheduler. High-level interrupts cannot block because of the scheduler.
High-level interrupts can only use mutual exclusion locks for locking.

The driver must determine whether the
device is using high-level interrupts. Do this test in the driver's
`attach(9E)` entry point when you register interrupts. See
link:#high-level-interrupt-handling-example[High-Level Interrupt Handling Example].

* If the interrupt priority returned from
`ddi++_++intr++_++get++_++pri(9F)` is greater than or equal to the
priority returned from `ddi++_++intr++_++get++_++hilevel++_++pri(9F)`,
the driver can fail to attach, or the driver can implement a high-level
interrupt handler. The high-level interrupt handler uses a
lower-priority software interrupt to handle the device. To allow more
concurrency, use a separate mutex to protect data from the high-level
handler.
* If the interrupt priority returned from
`ddi++_++intr++_++get++_++pri(9F)` is less than the priority returned
from `ddi++_++intr++_++get++_++hilevel++_++pri(9F)`, the `attach(9E)`
entry point falls through to regular interrupt registration. In this
case, a soft interrupt is not necessary.

[[high-level-mutexes]]
==== High-Level Mutexes

A mutex initialized with an
interrupt priority that represents a high-level interrupt is known as a
_high-level mutex_. While holding a high-level mutex, the driver is
subject to the same restrictions as a high-level interrupt handler.

[[high-level-interrupt-handling-example]]
==== High-Level Interrupt Handling Example

handling high-level interrupts examples

In the following example, the high-level mutex (`xsp-++>++high++_++mu`)
is used only to protect data shared between the high-level interrupt
handler and the soft interrupt handler. The protected data includes a
queue used by both the high-level interrupt handler and the low-level
handler, and a flag that indicates that the low-level handler is
running. A separate low-level mutex (`xsp-++>++low++_++mu`) protects the
rest of the driver from the soft interrupt handler.

[[interrupt-ex-21]]
Handling High-Level Interrupts With `attach`

[source,c]
----
static int
mydevattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct mydevstate *xsp;
    /* ... */

    ret = ddi_intr_get_supported_types(dip, &type);
    if ((ret != DDI_SUCCESS) || (!(type & DDI_INTR_TYPE_FIXED))) {
        cmn_err(CE_WARN, "ddi_intr_get_supported_types() failed");
        return (DDI_FAILURE);
    }

    ret = ddi_intr_get_nintrs(dip, DDI_INTR_TYPE_FIXED, &count);

    /*
     * Fixed interrupts can only have one interrupt. Check to make
     * sure that number of supported interrupts and number of
     * available interrupts are both equal to 1.
     */
    if ((ret != DDI_SUCCESS) || (count != 1)) {
    cmn_err(CE_WARN, "No fixed interrupts found");
            return (DDI_FAILURE);
    }

    xsp->xs_htable = kmem_zalloc(count * sizeof (ddi_intr_handle_t),
        KM_SLEEP);

    ret = ddi_intr_alloc(dip, xsp->xs_htable, DDI_INTR_TYPE_FIXED, 0,
        count, &actual, 0);

    if ((ret != DDI_SUCCESS) || (actual != 1)) {
    cmn_err(CE_WARN, "ddi_intr_alloc failed 0x%x", ret");
        kmem_free(xsp->xs_htable, sizeof (ddi_intr_handle_t));
        return (DDI_FAILURE);
    }

    ret = ddi_intr_get_pri(xsp->xs_htable[0], &intr_pri);
    if (ret != DDI_SUCCESS) {
        cmn_err(CE_WARN, "ddi_intr_get_pri failed 0x%x", ret");
        (void) ddi_intr_free(xsp->xs_htable[0]);
        kmem_free(xsp->xs_htable, sizeof (ddi_intr_handle_t));
        return (DDI_FAILURE);
    }

    if (intr_pri >= ddi_intr_get_hilevel_pri()) {

        mutex_init(&xsp->high_mu, NULL, MUTEX_DRIVER,
            DDI_INTR_PRI(intr_pri));

        ret = ddi_intr_add_handler(xsp->xs_htable[0],
            mydevhigh_intr, (caddr_t)xsp, NULL);

        if (ret != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_add_handler failed 0x%x", ret");
            mutex_destroy(&xsp>xs_int_mutex);
                (void) ddi_intr_free(xsp->xs_htable[0]);
                kmem_free(xsp->xs_htable, sizeof (ddi_intr_handle_t));
            return (DDI_FAILURE);
        }

        /* add soft interrupt */
        if (ddi_intr_add_softint(xsp->xs_dip, &xsp->xs_softint_hdl,
            DDI_INTR_SOFTPRI_MAX, xs_soft_intr, (caddr_t)xsp) !=
            DDI_SUCCESS) {
            cmn_err(CE_WARN, "add soft interrupt failed");
            mutex_destroy(&xsp->high_mu);
            (void) ddi_intr_remove_handler(xsp->xs_htable[0]);
            (void) ddi_intr_free(xsp->xs_htable[0]);
            kmem_free(xsp->xs_htable, sizeof (ddi_intr_handle_t));
            return (DDI_FAILURE);
        }

        xsp->low_soft_pri = DDI_INTR_SOFTPRI_MAX;

        mutex_init(&xsp->low_mu, NULL, MUTEX_DRIVER,
            DDI_INTR_PRI(xsp->low_soft_pri));

    } else {
    /*
     * regular interrupt registration continues from here
     * do not use a soft interrupt
     */
    }

    return (DDI_SUCCESS);
}
----

The high-level interrupt routine services the device and queues the
data. The high-level routine triggers a software interrupt if the
low-level routine is not running, as the following example demonstrates.

[[interrupt-ex-22]]
High-level Interrupt Routine

[source,c]
----
static uint_t
mydevhigh_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate    *xsp = (struct mydevstate *)arg1;
    uint8_t    status;
    volatile  uint8_t  temp;
    int    need_softint;

    mutex_enter(&xsp->high_mu);
    /* read status */
    status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
    if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->high_mu);
        return (DDI_INTR_UNCLAIMED); /* dev not interrupting */
    }

    ddi_put8(xsp->data_access_handle,&xsp->regp->csr,
        CLEAR_INTERRUPT | ENABLE_INTERRUPTS);
    /* flush store buffers */
    temp = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);

    /* read data from device, queue data for low-level interrupt handler */
    if (xsp->softint_running)
        need_softint = 0;
    else {
        xsp->softint_count++;
        need_softint = 1;
    }
    mutex_exit(&xsp->high_mu);

    /* read-only access to xsp->id, no mutex needed */
    if (need_softint) {
        ret = ddi_intr_trigger_softint(xsp->xs_softint_hdl, NULL);
        if (ret == DDI_EPENDING) {
            cmn_err(CE_WARN, "ddi_intr_trigger_softint() soft interrupt "
                "already pending for this handler");
        } else if (ret != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_trigger_softint() failed");
        }           
    }

    return (DDI_INTR_CLAIMED);
}
----

The low-level interrupt routine is started by the
high-level interrupt routine, which triggers a software interrupt. The
low-level interrupt routine runs until there is nothing left to process,
as the following example shows.

[[interrupt-ex-23]]
Low-Level Soft Interrupt Routine

[source,c]
----
static uint_t
mydev_soft_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate *mydevp = (struct mydevstate *)arg1;
    /* ... */
    mutex_enter(&mydevp->low_mu);
    mutex_enter(&mydevp->high_mu);
    if (mydevp->softint_count > 1) {
        mydevp->softint_count--;
        mutex_exit(&mydevp->high_mu);
        mutex_exit(&mydevp->low_mu);
        return (DDI_INTR_CLAIMED);
    }

    if ( /* queue empty */ ) {
        mutex_exit(&mydevp->high_mu);
        mutex_exit(&mydevp->low_mu);
        return (DDI_INTR_UNCLAIMED);
    }

    mydevp->softint_running = 1;
    while (EMBEDDED COMMENT:data on queue) {
        ASSERT(mutex_owned(&mydevp->high_mu);
        /* Dequeue data from high-level queue. */
        mutex_exit(&mydevp->high_mu);
        /* normal interrupt processing */
        mutex_enter(&mydevp->high_mu);
    }

    mydevp->softint_running = 0;
    mydevp->softint_count = 0;
    mutex_exit(&mydevp->high_mu);
    mutex_exit(&mydevp->low_mu);
    return (DDI_INTR_CLAIMED);
}
----

[[direct-memory-access-dma]]
[[direct-memory-access-dma-1]]
=== Direct Memory Access (DMA)

Many devices can temporarily take control of the bus. These devices can
perform data transfers that involve main memory and other devices.
Because the device is doing the work without the help of the CPU, this
type of data transfer is known as _direct memory access_ (DMA). The
following types of DMA transfers can be performed:

* Between two devices
* Between a device and memory
* Between memory and memory

This chapter explains transfers between a device and memory only. The
chapter provides information on the following subjects:

* link:#dma-model[DMA Model]
* link:#types-of-device-dma[Types of Device DMA]
* link:#types-of-host-platform-dma[Types of Host Platform DMA]
* link:#dma-software-components-handles-windows-and-cookies[DMA Software Components: Handles&#44; Windows&#44; and
Cookies]
* link:#dma-operations[DMA Operations]
* link:#managing-dma-resources[Managing DMA Resources]
* link:#dma-windows[DMA Windows]

[[dma-model]]
=== DMA Model

The illumos Device Driver Interface/Driver-Kernel Interface (DDI/DKI)
provides a high-level, architecture-independent model for DMA. This
model enables the framework, that is, the DMA routines, to hide
architecture-specific details such as the following:

* Setting up DMA mappings
* Building scatter-gather lists
* Ensuring that I/O and CPU caches are consistent

Several abstractions are used in the DDI/DKI to describe aspects of a
DMA transaction:

* *DMA object* – Memory that is the source or
destination of a DMA transfer.
* *DMA handle* – An opaque object
returned from a successful `ddi++_++dma++_++alloc++_++handle(9F)` call.
The DMA handle can be used in subsequent DMA subroutine calls to refer
to such DMA objects.
* *DMA cookie* – A
`ddi++_++dma++_++cookie(9S)` structure (`ddi++_++dma++_++cookie++_++t`)
describes a contiguous portion of a DMA object that is entirely
addressable by the device. The cookie contains DMA addressing
information that is required to program the DMA engine.

Rather than map an object directly into memory, device drivers allocate
DMA _resources_ for a memory object. The DMA routines then perform any
platform-specific operations that are needed to set up the object for
DMA access. The driver receives a DMA _handle_ to identify the DMA
resources that are allocated for the object. This handle is opaque to
the device driver. The driver must save the handle and pass the handle
in subsequent calls to DMA routines. The driver should not interpret the
handle in any way.

Operations that provide the following services are defined on a DMA
handle:

* Manipulating DMA resources
* Synchronizing DMA objects
* Retrieving attributes of the allocated resources

[[types-of-device-dma]]
=== Types of Device DMA

Devices perform one of the following three types of DMA:

* Bus-master DMA
* Third-party DMA
* First-party DMA

[[bus-master-dma]]
==== Bus-Master DMA

The driver should program the device's DMA registers
directly in cases where the device acts like a true _bus master_. For
example, a device acts like a bus master when the DMA engine resides on
the device board. The transfer address and count are obtained from the
DMA cookie to be passed on to the device.

[[third-party-dma]]
==== Third-Party DMA

Third-party DMA uses a system DMA engine resident on the
main system board, which has several DMA channels that are available for
use by devices. The device relies on the system's DMA engine to perform
the data transfers between the device and memory. The driver uses DMA
engine routines (see the `ddi++_++dmae(9F)` function) to initialize and
program the DMA engine. For each DMA data transfer, the driver programs
the DMA engine and then gives the device a command to initiate the
transfer in cooperation with that engine.

[[first-party-dma]]
==== First-Party DMA

Under first-party DMA, the device uses a channel from
the system's DMA engine to drive that device's DMA bus cycles. Use the
`ddi++_++dmae++_++1stparty(9F)` function to configure this channel in a
cascade mode so that the DMA engine does not interfere with the
transfer.

[[types-of-host-platform-dma]]
=== Types of Host Platform DMA

The platform on which the device operates provides either direct memory
access (DMA) or direct virtual memory access (DVMA).

On platforms that
support DMA, the system provides the device with a physical address in
order to perform transfers. In this case, the transfer of a DMA object
can actually consist of a number of physically discontiguous transfers.
An example is when an application transfers a buffer that spans several
contiguous virtual pages that map to physically discontiguous pages. To
deal with the discontiguous memory, devices for these platforms usually
have some kind of scatter-gather DMA capability. Typically, x86 systems
provide physical addresses for direct memory transfers.

platforms that support DVMA, the system provides the device with a
virtual address to perform transfers. In this case, memory management
units (MMU) provided by the underlying platform translate device
accesses to these virtual addresses into the proper physical addresses.
The device transfers to and from a contiguous virtual image that can be
mapped to discontiguous physical pages. Devices that operate in these
platforms do not need scatter-gather DMA capability. Typically, SPARC
platforms provide virtual addresses for direct memory transfers.

[[dma-software-components-handles-windows-and-cookies]]
=== DMA Software Components: Handles, Windows, and Cookies

A DMA _handle_ is an opaque pointer that
represents an object, usually a memory buffer or address. A DMA handle
enables a device to perform DMA transfers. Several different calls to
DMA routines use the handle to identify the DMA resources that are
allocated for the object.

An object represented by a DMA handle is
completely covered by one or more _DMA cookies_. A DMA cookie represents
a contiguous piece of memory that is used in data transfers by the DMA
engine. The system divides objects into multiple cookies based on the
following information:

* The `ddi++_++dma++_++attr(9S)` attribute structure provided by the
driver
* Memory location of the target object
* Alignment of the target object

If an object does
not fit within the limitations of the DMA engine, that object must be
broken into multiple _DMA windows_. You can only activate and allocate
resources for one window at a time. Use the `ddi++_++dma++_++getwin(9F)`
function to position between windows within an object. Each DMA window
consists of one or more DMA cookies. For more information, see
link:#dma-windows[DMA Windows].

Some DMA engines can accept
more than one cookie. Such engines perform scatter-gather I/O without
the help of the system. If multiple cookies are returned from a bind,
the driver should call `ddi++_++dma++_++nextcookie(9F)` repeatedly to
retrieve each cookie. These cookies must then be programmed into the
engine. The device can then be programmed to transfer the total number
of bytes covered by the aggregate of these DMA cookies.

[[dma-operations]]
=== DMA Operations

The steps in a DMA transfer are similar among
the types of DMA. The following sections present methods for performing
DMA transfers.

[NOTE]

You do not need to ensure that the DMA object is locked in memory in
block drivers for buffers that come from the file system. The file
system has already locked the data in memory.
===

[[performing-bus-master-dma-transfers]]
==== Performing Bus-Master DMA Transfers

The driver should perform the following steps
for bus-master DMA.

[arabic]
. Describe the DMA attributes. This step enables the routines to ensure
that the device is able to access the buffer.
. Allocate a DMA handle.
. Ensure that the DMA object is locked in memory. See the `physio(9F)`
or `ddi++_++umem++_++lock(9F)` man page.
. Allocate DMA resources for the object.
. Program the DMA engine on the device.
. Start the engine.
. When the transfer is complete, continue the bus master operation.
. Perform any required object synchronizations.
. Release the DMA resources.
. Free the DMA handle.

[[performing-first-party-dma-transfers]]
==== Performing First-Party DMA Transfers

The driver should perform the following steps
for first-party DMA.

[arabic]
. Allocate a DMA channel.
. Use `ddi++_++dmae++_++1stparty(9F)` to configure the channel.
. Ensure that the DMA object is locked in memory. See the `physio(9F)`
or `ddi++_++umem++_++lock(9F)` man page.
. Allocate DMA resources for the object.
. Program the DMA engine on the device.
. Start the engine.
. When the transfer is complete, continue the bus-master operation.
. Perform any required object synchronizations.
. Release the DMA resources.
. Deallocate the DMA channel.

[[performing-third-party-dma-transfers]]
==== Performing Third-Party DMA Transfers

The driver should perform these steps for
third-party DMA.

[arabic]
. Allocate a DMA channel.
. Retrieve the system's DMA engine attributes with
`ddi++_++dmae++_++getattr(9F)`.
. Lock the DMA object in memory. See the `physio(9F)` or
`ddi++_++umem++_++lock(9F)` man page.
. Allocate DMA resources for the object.
. Use `ddi++_++dmae++_++prog(9F)` to program the system DMA engine to
perform the transfer.
. Perform any required object synchronizations.
. Use `ddi++_++dmae++_++stop(9F)` to stop the DMA engine.
. Release the DMA resources.
. Deallocate the DMA channel.

Certain hardware platforms restrict DMA capabilities in a bus-specific
way. Drivers should use `ddi++_++slaveonly(9F)` to determine whether the
device is in a slot in which DMA is possible.

[[dma-attributes]]
==== DMA Attributes

DMA attributes describe the attributes and
limits of a DMA engine, which include:

* Limits on addresses that the device can access
* Maximum transfer count
* Address alignment restrictions

A device driver must inform the system about any DMA engine limitations
through the `ddi++_++dma++_++attr(9S)` structure. This action ensures
that DMA resources that are allocated by the system can be accessed by
the device's DMA engine. The system can impose additional restrictions
on the device attributes, but the system never removes any of the
driver-supplied restrictions.

[[ddidmaattr-structure]]
===== `ddi++_++dma++_++attr` Structure

The DMA attribute structure has the following members:

[source,c]
----
typedef struct ddi_dma_attr {
    uint_t      dma_attr_version;       /* version number */
    uint64_t    dma_attr_addr_lo;       /* low DMA address range */
    uint64_t    dma_attr_addr_hi;       /* high DMA address range */
    uint64_t    dma_attr_count_max;     /* DMA counter register */
    uint64_t    dma_attr_align;         /* DMA address alignment */
    uint_t      dma_attr_burstsizes;    /* DMA burstsizes */
    uint32_t    dma_attr_minxfer;       /* min effective DMA size */
    uint64_t    dma_attr_maxxfer;       /* max DMA xfer size */
    uint64_t    dma_attr_seg;           /* segment boundary */
    int         dma_attr_sgllen;        /* s/g length */
    uint32_t    dma_attr_granular;      /* granularity of device */
    uint_t      dma_attr_flags;         /* Bus specific DMA flags */
} ddi_dma_attr_t;
----

where:

`dma++_++attr++_++version`::
  Version number of the attribute structure. `dma++_++attr++_++version`
  should be set to DMA++_++ATTR++_++V0.
`dma++_++attr++_++addr++_++lo`::
  Lowest bus address that the DMA engine can access.
`dma++_++attr++_++addr++_++hi`::
  Highest bus address that the DMA engine can access.
`dma++_++attr++_++count++_++max`::
  Specifies the maximum transfer count that the DMA engine can handle in
  one cookie. The limit is expressed as the maximum count minus one.
  This count is used as a bit mask, so the count must also be one less
  than a power of two.
`dma++_++attr++_++align`::
  Specifies alignment requirements when allocating memory from
  `ddi++_++dma++_++mem++_++alloc(9F)`. An example of an alignment
  requirement is alignment on a page boundary. The
  `dma++_++attr++_++align` field is used only when allocating memory.
  This field is ignored during bind operations. For bind operations, the
  driver must ensure that the buffer is aligned appropriately.
`dma++_++attr++_++burstsizes`::
  Specifies the _burst sizes_ that the device supports. A burst size is
  the amount of data the device can transfer before relinquishing the
  bus. This member is a binary encoding of burst sizes, which are
  assumed to be powers of two. For example, if the device is capable of
  doing 1-byte, 2-byte, 4-byte, and 16-byte bursts, this field should be
  set to 0x17. The system also uses this field to determine alignment
  restrictions.
`dma++_++attr++_++minxfer`::
  Minimum effective transfer size that the device can perform. This size
  also influences restrictions on alignment and on padding.
`dma++_++attr++_++maxxfer`::
  Describes the maximum number of bytes that the DMA engine can
  accommodate in one I/O command. This limitation is only significant if
  `dma++_++attr++_++maxxfer` is less than
  `(dma++_++attr++_++count++_++max {plus} 1) ++*++ dma++_++attr++_++sgllen`.
`dma++_++attr++_++seg`::
  Upper bound of the DMA engine's address register.
  `dma++_++attr++_++seg` is often used where the upper 8 bits of an
  address register are a latch that contains a segment number. The lower
  24 bits are used to address a segment. In this case,
  `dma++_++attr++_++seg` would be set to 0xFFFFFF, which prevents the
  system from crossing a 24-bit segment boundary when allocating
  resources for the object.
`dma++_++attr++_++sgllen`::
  Specifies the maximum number of entries in the scatter-gather list.
  `dma++_++attr++_++sgllen` is the number of cookies that the DMA engine
  can consume in one I/O request to the device. If the DMA engine has no
  scatter-gather list, this field should be set to 1.
`dma++_++attr++_++granular`::
  This field gives the granularity in bytes of the DMA transfer ability
  of the device. An example of how this value is used is to specify the
  sector size of a mass storage device. When a bind operation requires a
  partial mapping, this field is used to ensure that the sum of the
  sizes of the cookies in a DMA window is a whole multiple of
  granularity. However, if the device does not have a scatter-gather
  capability, it is impossible for the DDI to ensure the granularity.
  For this case, the value of the `dma++_++attr++_++granular` field
  should be 1.
`dma++_++attr++_++flags`::
  This field can be set to `DDI++_++DMA++_++FORCE++_++PHYSICAL`, which
  indicates that the system should return physical rather than virtual
  I/O addresses if the system supports both. If the system does not
  support physical DMA, the return value from
  `ddi++_++dma++_++alloc++_++handle(9F)` is `DDI++_++DMA++_++BADATTR`.
  In this case, the driver has to clear
  `DDI++_++DMA++_++FORCE++_++PHYSICAL` and retry the operation.

[[sbus-example]]
===== SBus Example

A DMA engine on an SBus in a SPARC machine has the following attributes:

* Access to addresses ranging from 0xFF000000 to 0xFFFFFFFF only
* 32-bit DMA counter register
* Ability to handle byte-aligned transfers
* Support for 1-byte, 2-byte, and 4-byte burst sizes
* Minimum effective transfer size of 1 byte
* 32-bit address register
* No scatter-gather list
* Operation on sectors only, for example, a disk

A DMA engine on an SBus in a SPARC machine has the following attribute
structure:

[source,c]
----
static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0xFF000000,    /* low address */
    0xFFFFFFFF,    /* high address */
    0xFFFFFFFF,    /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes: 0x1 | 0x2 | 0x4 */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0xFFFFFFFF,    /* address register max */
    1,             /* no scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};
----

[[isa-bus-example]]
===== ISA Bus Example

A DMA engine on an ISA bus in an x86 machine has the following
attributes:

* Access to the first 16 megabytes of memory only
* Inability to cross a 1-megabyte boundary in a single DMA transfer
* 16-bit counter register
* Ability to handle byte-aligned transfers
* Support for 1-byte, 2-byte, and 4-byte burst sizes
* Minimum effective transfer size of 1 byte
* Ability to hold up to 17 scatter-gather transfers
* Operation on sectors only, for example, a disk

A DMA engine on an ISA bus in an x86 machine has the following attribute
structure:

[source,c]
----
static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0x00000000,    /* low address */
    0x00FFFFFF,    /* high address */
    0xFFFF,        /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0x000FFFFF,    /* address register max */
    17,            /* scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};
----

[[managing-dma-resources]]
=== Managing DMA Resources

This section describes how to manage DMA resources.

[[object-locking]]
==== Object Locking

Before allocating
the DMA resources for a memory object, the object must be prevented from
moving. Otherwise, the system can remove the object from memory while
the device is trying to write to that object. A missing object would
cause the data transfer to fail and possibly corrupt the system. The
process of preventing memory objects from moving during a DMA transfer
is known as _locking down the object_.

* Buffers coming from the file system through `strategy(9E)`. These
buffers are already locked by the file system.
* Kernel memory allocated within the device driver, such as that
allocated by `ddi++_++dma++_++mem++_++alloc(9F)`.

For other objects such as buffers from user space, `physio(9F)` or
`ddi++_++umem++_++lock(9F)` must be used to lock down the objects.
Locking down objects with these functions is usually performed in the
`read(9E)` or `write(9E)` routines of a character device driver. See
link:#data-transfer-methods[Data Transfer Methods] for an example.

[[allocating-a-dma-handle]]
==== Allocating a DMA Handle

A DMA handle is an opaque object that is
used as a reference to subsequently allocated DMA resources. The DMA
handle is usually allocated in the driver's `attach` entry point that
uses `ddi++_++dma++_++alloc++_++handle(9F)`. The
`ddi++_++dma++_++alloc++_++handle` function takes the device information
that is referred to by ++<++dip++>++ and the device's DMA attributes
described by a `ddi++_++dma++_++attr(9S)` structure as parameters. The
`ddi++_++dma++_++alloc++_++handle` function has the following syntax:

[source,c]
----
int ddi_dma_alloc_handle(dev_info_t *dip,
    ddi_dma_attr_t *attr, int (*callback)(caddr_t),
    caddr_t arg, ddi_dma_handle_t *handlep);
----

where:

`dip`::
  Pointer to the device's `dev++_++info` structure.
`attr`::
  Pointer to a `ddi++_++dma++_++attr(9S)` structure, as described in
  link:#dma-attributes[DMA Attributes].
`callback`::
  Address of the callback function for handling resource allocation
  failures.
`arg`::
  Argument to be passed to the callback function.
`handlep`::
  Pointer to a DMA handle to store the returned handle.

[[allocating-dma-resources]]
==== Allocating DMA Resources

resource allocation

Two interfaces allocate DMA resources:

* `ddi++_++dma++_++buf++_++bind++_++handle(9F)` – Used with `buf(9S)`

* `ddi++_++dma++_++addr++_++bind++_++handle(9F)` – Used with virtual

DMA resources are usually allocated in the driver's `xxstart` routine,
if an `xxstart` routine exists. See link:#asynchronous-data-transfers-block-drivers[Asynchronous Data
Transfers (Block Drivers)] for a discussion of `xxstart`. These two
interfaces have the following syntax:

[source,c]
----
int ddi_dma_addr_bind_handle(ddi_dma_handle_t handle,
    struct as *as, caddr_t addr,
    size_t len, uint_t flags, int (*callback)(caddr_t),
    caddr_t arg, ddi_dma_cookie_t *cookiep, uint_t *ccountp);

int ddi_dma_buf_bind_handle(ddi_dma_handle_t handle,
    struct buf *bp, uint_t flags,
    int (*callback)(caddr_t), caddr_t arg,
    ddi_dma_cookie_t *cookiep, uint_t *ccountp);
----

The following arguments are common to both
`ddi++_++dma++_++addr++_++bind++_++handle(9F)` and
`ddi++_++dma++_++buf++_++bind++_++handle(9F)`:

`handle`::
  DMA handle and the object for allocating resources.
`flags`::
  Set of flags that indicate the transfer direction and other
  attributes. `DDI++_++DMA++_++READ` indicates a data transfer from
  device to memory. `DDI++_++DMA++_++WRITE` indicates a data transfer
  from memory to device. See the
  `ddi++_++dma++_++addr++_++bind++_++handle(9F)` or
  `ddi++_++dma++_++buf++_++bind++_++handle(9F)` man page for a complete
  discussion of the available flags.
`callback`::
  Address of callback function for handling resource allocation
  failures. See the `ddi++_++dma++_++alloc++_++handle(9F)` man page.
`arg`::
  Argument to pass to the callback function.
`cookiep`::
  Pointer to the first DMA cookie for this object.
`ccountp`::
  Pointer to the number of DMA cookies for this object.

For `ddi++_++dma++_++addr++_++bind++_++handle(9F)`, the object is
described by an address range with the following parameters:

`as`::
  Pointer to an address space structure. The value of `as` must be
  `NULL`.
`addr`::
  Base kernel address of the object.
`len`::
  Length of the object in bytes.

For `ddi++_++dma++_++buf++_++bind++_++handle(9F)`, the object is
described by a `buf(9S)` structure pointed to by `bp`.

[[device-register-structure]]
===== Device Register Structure

DMA-capable devices require
more registers than were used in the previous examples.

The following fields are used in the device register structure to
support DMA-capable device with no scatter-gather support:

[source,c]
----
uint32_t      dma_addr;      /* starting address for DMA */
uint32_t      dma_size;      /* amount of data to transfer */
----

The following fields are used in the device register structure to
support DMA-capable devices with scatter-gather support:

[source,c]
----
struct sglentry {
    uint32_t    dma_addr;
    uint32_t    dma_size;
} sglist[SGLLEN];

caddr_t       iopb_addr;     /* When written, informs the device of the next */
                             /* command's parameter block address. */
                             /* When read after an interrupt, contains */
                             /* the address of the completed command. */
----

[[dma-callback-example]]
===== DMA Callback Example

In link:#dma-17617[example++_++title],
`xxstart` is used as the callback function. The per-device state
structure is used as the argument to `xxstart`. The `xxstart` function
attempts to start the command. If the command cannot be started because
resources are not available, `xxstart` is scheduled to be called later
when resources are available.

Because `xxstart` is used as a DMA callback, `xxstart` must adhere to
the following rules, which are imposed on DMA callbacks:

* Resources cannot be assumed to be available. The callback must try to
allocate resources again.
* The callback must indicate to the system whether allocation succeeded.
DDI++_++DMA++_++CALLBACK++_++RUNOUT should be returned if the callback
fails to allocate resources, in which case `xxstart` needs to be called
again later. DDI++_++DMA++_++CALLBACK++_++DONE indicates success, so
that no further callback is necessary.

[[dma-17617]]
DMA Callback Example

[source,c]
----
static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct device_reg *regp;
    int flags;
    mutex_enter(&xsp->mu);
    if (xsp->busy) {
        /* transfer in progress */
        mutex_exit(&xsp->mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    xsp->busy = 1;
    regp = xsp->regp;
    if ( /* transfer is a read */ ) {
        flags = DDI_DMA_READ;
    } else {
        flags = DDI_DMA_WRITE;
    }
    mutex_exit(&xsp->mu);
    if (ddi_dma_buf_bind_handle(xsp->handle,xsp->bp,flags, xxstart,
        (caddr_t)xsp, &cookie, &ccount) != DDI_DMA_MAPPED) {
        /* really should check all return values in a switch */
        mutex_enter(&xsp->mu);
        xsp->busy=0;
        mutex_exit(&xsp->mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    /* Program the DMA engine. */
    return (DDI_DMA_CALLBACK_DONE);
}
----

[[determining-maximum-burst-sizes]]
==== Determining Maximum Burst Sizes

Drivers specify the DMA burst sizes that
their device supports in the `dma++_++attr++_++burstsizes`field of the
`ddi++_++dma++_++attr(9S)` structure. This field is a bitmap of the
supported burst sizes. However, when DMA resources are allocated, the
system might impose further restrictions on the burst sizes that might
be actually used by the device. The `ddi++_++dma++_++burstsizes(9F)`
routine can be used to obtain the allowed burst sizes. This routine
returns the appropriate burst size bitmap for the device. When DMA
resources are allocated, a driver can ask the system for appropriate
burst sizes to use for its DMA engine.

[[dma-ex-3]]
Determining Burst Size

[source,c]
----
#define BEST_BURST_SIZE 0x20 /* 32 bytes */

    if (ddi_dma_buf_bind_handle(xsp->handle,xsp->bp, flags, xxstart,
        (caddr_t)xsp, &cookie, &ccount) != DDI_DMA_MAPPED) {
        /* error handling */
    }
    burst = ddi_dma_burstsizes(xsp->handle);
    /* check which bit is set and choose one burstsize to */
    /* program the DMA engine */
    if (burst & BEST_BURST_SIZE) {
        /* program DMA engine to use this burst size */
    } else {
        /* other cases */
    }
----

[[allocating-private-dma-buffers]]
==== Allocating Private DMA Buffers

private buffer allocation

Some device drivers might need
to allocate memory for DMA transfers in addition to performing transfers
requested by user threads and the kernel. Some examples of allocating
private DMA buffers are setting up shared memory for communication with
the device and allocating intermediate transfer buffers. Use
`ddi++_++dma++_++mem++_++alloc(9F)` to allocate memory for DMA
transfers.

[source,c]
----
int ddi_dma_mem_alloc(ddi_dma_handle_t handle, size_t length,
    ddi_device_acc_attr_t *accattrp, uint_t flags,
    int (*waitfp)(caddr_t), caddr_t arg, caddr_t *kaddrp,
    size_t *real_length, ddi_acc_handle_t *handlep);
----

where:

`handle`::
  DMA handle
`length`::
  Length in bytes of the desired allocation
`accattrp`::
  Pointer to a device access attribute structure
`flags`::
  Data transfer mode flags. Possible values are
  `DDI++_++DMA++_++CONSISTENT` and `DDI++_++DMA++_++STREAMING`.
`waitfp`::
  Address of callback function for handling resource allocation
  failures. See the `ddi++_++dma++_++alloc++_++handle(9F)` man page.
`arg`::
  Argument to pass to the callback function
`kaddrp`::
  Pointer on a successful return that contains the address of the
  allocated storage
`real++_++length`::
  Length in bytes that was allocated
`handlep`::
  Pointer to a data access handle

The `flags` parameter should be set to `DDI++_++DMA++_++CONSISTENT` if
the device accesses in a nonsequential fashion. Synchronization steps
that use `ddi++_++dma++_++sync(9F)` should be as lightweight as possible
due to frequent application to small objects. This type of access is
commonly known as _consistent_ access. Consistent access is particularly
useful for I/O parameter blocks that are used for communication between
a device and the driver.

On the x86 platform, allocation of DMA memory that is physically
contiguous has these requirements:

* The length of the scatter-gather list `dma++_++attr++_++sgllen` in the
`ddi++_++dma++_++attr(9S)` structure must be set to 1.
* Do not specify `DDI++_++DMA++_++PARTIAL`. `DDI++_++DMA++_++PARTIAL`
allows partial resource allocation.

The following example shows how to allocate IOPB memory and the
necessary DMA resources to access this memory. DMA resources must still
be allocated, and the `DDI++_++DMA++_++CONSISTENT` flag must be passed
to the allocation function.

[[dma-35641]]
Using `ddi++_++dma++_++mem++_++alloc(9F)`

[source,c]
----
if (ddi_dma_mem_alloc(xsp->iopb_handle, size, &accattr,
    DDI_DMA_CONSISTENT, DDI_DMA_SLEEP, NULL, &xsp->iopb_array,
    &real_length, &xsp->acchandle) != DDI_SUCCESS) {
    /* error handling */
    goto failure;
}
if (ddi_dma_addr_bind_handle(xsp->iopb_handle, NULL,
    xsp->iopb_array, real_length,
    DDI_DMA_READ | DDI_DMA_CONSISTENT, DDI_DMA_SLEEP,
    NULL, &cookie, &count) != DDI_DMA_MAPPED) {
    /* error handling */
    ddi_dma_mem_free(&xsp->acchandle);
    goto failure;
}
----

The `flags` parameter should be set to
`DDI++_++DMA++_++STREAMING` for memory transfers that are sequential,
unidirectional, block-sized, and block-aligned. This type of access is
commonly known as _streaming_ access.

In some cases, an I/O transfer can be sped up by using an I/O cache. I/O
cache transfers one cache line at a minimum. The
`ddi++_++dma++_++mem++_++alloc(9F)` routine rounds `size` to a multiple
of the cache line to avoid data corruption.

The `ddi++_++dma++_++mem++_++alloc(9F)` function returns the actual size
of the allocated memory object. Because of padding and alignment
requirements, the actual size might be larger than the requested size.
The `ddi++_++dma++_++addr++_++bind++_++handle(9F)` function requires the
actual length.

Use the `ddi++_++dma++_++mem++_++free(9F)` function to free the memory
allocated by `ddi++_++dma++_++mem++_++alloc(9F)`.

[NOTE]

Drivers must ensure that buffers are aligned appropriately. Drivers for
devices that have alignment requirements on down bound DMA buffers might
need to copy the data into a driver intermediate buffer that meets the
requirements, and then bind that intermediate buffer to the DMA handle
for DMA. Use `ddi++_++dma++_++mem++_++alloc(9F)` to allocate the driver
intermediate buffer. Always use `ddi++_++dma++_++mem++_++alloc(9F)`
instead of `kmem++_++alloc(9F)` to allocate memory for the device to
access.
===

[[handling-resource-allocation-failures]]
==== Handling Resource Allocation Failures

The resource-allocation routines provide the driver with several options
when handling allocation failures. The `waitfp` argument indicates
whether the allocation routines block, return immediately, or schedule a
callback, as shown in the following table.

.Resource Allocation Handling
[width="100%",cols="34%,66%",options="header",]
|===
|`waitfp` value |Indicated Action
|DDI++_++DMA++_++DONTWAIT |Driver does not want to wait for resources to
become available

|DDI++_++DMA++_++SLEEP |Driver is willing to wait indefinitely for
resources to become available

|Other values |The address of a function to be called when resources are
likely to be available
|===

[[programming-the-dma-engine]]
==== Programming the DMA Engine

When the resources have been successfully allocated, the device must be
programmed. Although programming a DMA engine is device specific, all
DMA engines require a starting address and a transfer count. Device
drivers retrieve these two values from the _DMA cookie_ returned by a
successful call from `ddi++_++dma++_++addr++_++bind++_++handle(9F)`,
`ddi++_++dma++_++buf++_++bind++_++handle(9F)`, or
`ddi++_++dma++_++getwin(9F)`. These functions all return the first DMA
cookie and a cookie count indicating whether the DMA object consists of
more than one cookie. If the cookie count ++<++N++>++ is greater than 1,
`ddi++_++dma++_++nextcookie(9F)` must be called ++<++N++>++-1 times to
retrieve all the remaining cookies.

A DMA cookie is of type `ddi++_++dma++_++cookie(9S)`. This type of
cookie has the following fields:

[source,c]
----
uint64_t    _dmac_ll;       /* 64-bit DMA address */
uint32_t    _dmac_la[2];    /* 2 x 32-bit address */
size_t      dmac_size;      /* DMA cookie size */
uint_t      dmac_type;      /* bus specific type bits */
----

The `dmac++_++laddress` specifies a 64-bit I/O address that is
appropriate for programming the device's DMA engine. If a device has a
64-bit DMA address register, a driver should use this field to program
the DMA engine. The `dmac++_++address` field specifies a 32-bit I/O
address that should be used for devices that have a 32-bit DMA address
register. The `dmac++_++size` field contains the transfer count.
Depending on the bus architecture, the `dmac++_++type` field in the
cookie might be required by the driver. The driver should not perform
any manipulations, such as logical or arithmetic, on the cookie.

[[dma-ex-4]]
`ddi++_++dma++_++cookie(9S)` Example

[source,c]
----
ddi_dma_cookie_t            cookie;

     if (ddi_dma_buf_bind_handle(xsp->handle,xsp->bp, flags, xxstart,
     (caddr_t)xsp, &cookie, &xsp->ccount) != DDI_DMA_MAPPED) {
         /* error handling */
      }
     sglp = regp->sglist;
     for (cnt = 1; cnt <= SGLLEN; cnt++, sglp++) {
     /* store the cookie parms into the S/G list */
     ddi_put32(xsp->access_hdl, &sglp->dma_size,
         (uint32_t)cookie.dmac_size);
     ddi_put32(xsp->access_hdl, &sglp->dma_addr,
         cookie.dmac_address);
     /* Check for end of cookie list */
     if (cnt == xsp->ccount)
         break;
     /* Get next DMA cookie */
     (void) ddi_dma_nextcookie(xsp->handle, &cookie);
     }
     /* start DMA transfer */
     ddi_put8(xsp->access_hdl, &regp->csr,
     ENABLE_INTERRUPTS | START_TRANSFER);
----

[[freeing-the-dma-resources]]
==== Freeing the DMA Resources

freeing resources

After a DMA transfer is completed, usually in the interrupt routine, the
driver can release DMA resources by calling
`ddi++_++dma++_++unbind++_++handle(9F)`.

As described in link:#synchronizing-memory-objects[Synchronizing Memory Objects],
`ddi++_++dma++_++unbind++_++handle(9F)` calls
`ddi++_++dma++_++sync(9F)`, eliminating the need for any explicit
synchronization. After calling `ddi++_++dma++_++unbind++_++handle(9F)`,
the DMA resources become invalid, and further references to the
resources have undefined results. The following example shows how to use
`ddi++_++dma++_++unbind++_++handle(9F)`.

[[dma-34731]]
Freeing DMA Resources

[source,c]
----
static uint_t
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     uint8_t    status;
     volatile   uint8_t   temp;
     mutex_enter(&xsp->mu);
     /* read status */
     status = ddi_get8(xsp->access_hdl, &xsp->regp->csr);
     if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->mu);
        return (DDI_INTR_UNCLAIMED);
     }
     ddi_put8(xsp->access_hdl, &xsp->regp->csr, CLEAR_INTERRUPT);
     /* for store buffers */
     temp = ddi_get8(xsp->access_hdl, &xsp->regp->csr);
     ddi_dma_unbind_handle(xsp->handle);
     /* Check for errors. */
     xsp->busy = 0;
     mutex_exit(&xsp->mu);
     if ( /* pending transfers */ ) {
        (void) xxstart((caddr_t)xsp);
     }
     return (DDI_INTR_CLAIMED);
}
----

The DMA resources should be released. The DMA resources should be
reallocated if a different object is to be used in the next transfer.
However, if the same object is always used, the resources can be
allocated once. The resources can then be reused as long as intervening
calls to `ddi++_++dma++_++sync(9F)` remain.

[[freeing-the-dma-handle]]
==== Freeing the DMA Handle

When the driver is detached, the DMA
handle must be freed. The `ddi++_++dma++_++free++_++handle(9F)` function
destroys the DMA handle and destroys any residual resources that the
system is caching on the handle. Any further references of the DMA
handle will have undefined results.

[[canceling-dma-callbacks]]
==== Canceling DMA Callbacks

DMA callbacks cannot be canceled. Canceling a
DMA callback requires some additional code in the driver's `detach(9E)`
entry point. The `detach` routine must not return `DDI++_++SUCCESS` if
any outstanding callbacks exist. See link:#dma-36458[example++_++title].
When DMA callbacks occur, the `detach` routine must wait for the
callback to run. When the callback has finished, `detach` must prevent
the callback from rescheduling itself. Callbacks can be prevented from
rescheduling through additional fields in the state structure, as shown
in the following example.

[[dma-36458]]
Canceling DMA Callbacks

[source,c]
----
static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
     /* ... */
     mutex_enter(&xsp->callback_mutex);
     xsp->cancel_callbacks = 1;
     while (xsp->callback_count > 0) {
        cv_wait(&xsp->callback_cv, &xsp->callback_mutex);
     }
     mutex_exit(&xsp->callback_mutex);
     /* ... */
}

static int
xxstrategy(struct buf *bp)
{
     /* ... */
     mutex_enter(&xsp->callback_mutex);
       xsp->bp = bp;
     error = ddi_dma_buf_bind_handle(xsp->handle, xsp->bp, flags,
         xxdmacallback, (caddr_t)xsp, &cookie, &ccount);
     if (error == DDI_DMA_NORESOURCES)
       xsp->callback_count++;
     mutex_exit(&xsp->callback_mutex);
     /* ... */
}

static int
xxdmacallback(caddr_t callbackarg)
{
     struct xxstate *xsp = (struct xxstate *)callbackarg;
     /* ... */
     mutex_enter(&xsp->callback_mutex);
     if (xsp->cancel_callbacks) {
        /* do not reschedule, in process of detaching */
        xsp->callback_count--;
        if (xsp->callback_count == 0)
           cv_signal(&xsp->callback_cv);
        mutex_exit(&xsp->callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);    /* don't reschedule it */
     }
     /*
      * Presumably at this point the device is still active
      * and will not be detached until the DMA has completed.
      * A return of 0 means try again later
      */
     error = ddi_dma_buf_bind_handle(xsp->handle, xsp->bp, flags,
         DDI_DMA_DONTWAIT, NULL, &cookie, &ccount);
     if (error == DDI_DMA_MAPPED) {
        /* Program the DMA engine. */
        xsp->callback_count--;
        mutex_exit(&xsp->callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);
     }
     if (error != DDI_DMA_NORESOURCES) {
        xsp->callback_count--;
        mutex_exit(&xsp->callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);
     }
     mutex_exit(&xsp->callback_mutex);
     return (DDI_DMA_CALLBACK_RUNOUT);
}
----

[[synchronizing-memory-objects]]
==== Synchronizing Memory Objects

In the process of accessing the memory object, the driver might need to
synchronize the memory object with respect to various caches. This
section provides guidelines on when and how to synchronize memory
objects.

[[cache]]
===== Cache

CPU cache is a very high-speed memory that
sits between the CPU and the system's main memory. I/O cache sits
between the device and the system's main memory, as shown in the
following figure.

.CPU and System I/O Caches
[#dma-fig-26]
image::figures/dma-cpucache.png[Diagram shows how the cache is used to speed data transfers involving devices.]

When an attempt is made to read data from main memory, the associated
cache checks for the requested data. If the data is available, the cache
supplies the data quickly. If the cache does not have the data, the
cache retrieves the data from main memory. The cache then passes the
data on to the requester and saves the data in case of a subsequent
request.

Similarly, on a write cycle, the data is stored in the cache quickly.
The CPU or device is allowed to continue executing, that is,
transferring data. Storing data in a cache takes much less time than
waiting for the data to be written to memory.

With this model, after a device transfer is complete, the data can still
be in the I/O cache with no data in main memory. If the CPU accesses the
memory, the CPU might read the wrong data from the CPU cache. The driver
must call a synchronization routine to flush the data from the I/O cache
and update the CPU cache with the new data. This action ensures a
consistent view of the memory for the CPU. Similarly, a synchronization
step is required if data modified by the CPU is to be accessed by a
device.

You can create additional caches and buffers between the device and
memory, such as bus extenders and bridges. Use
`ddi++_++dma++_++sync(9F)` to synchronize _all_ applicable caches.

[[ddidmasync-function]]
===== `ddi++_++dma++_++sync` Function

A memory object might have multiple mappings, such as for the CPU and
for a device, by means of a DMA handle. A driver with multiple mappings
needs to call `ddi++_++dma++_++sync(9F)` if any mappings are used to
modify the memory object. Calling `ddi++_++dma++_++sync` ensures that
the modification of the memory object is complete before the object is
accessed through a different mapping. The `ddi++_++dma++_++sync`
function can also inform other mappings of the object if any cached
references to the object are now stale. Additionally,
`ddi++_++dma++_++sync` flushes or invalidates stale cache references as
necessary.

Generally, the driver must call `ddi++_++dma++_++sync` when a DMA
transfer completes. The exception to this rule is if deallocating the
DMA resources with `ddi++_++dma++_++unbind++_++handle(9F)` does an
implicit `ddi++_++dma++_++sync` on behalf of the driver. The syntax for
`ddi++_++dma++_++sync` is as follows:

[source,c]
----
int ddi_dma_sync(ddi_dma_handle_t handle, off_t off,
size_t length, uint_t type);
----

If the object is going to be read by the DMA engine of the device, the
device's view of the object must be synchronized by setting
++<++type++>++ to `DDI++_++DMA++_++SYNC++_++FORDEV`. If the DMA engine
of the device has written to the memory object and the object is going
to be read by the CPU, the CPU's view of the object must be synchronized
by setting ++<++type++>++ to `DDI++_++DMA++_++SYNC++_++FORCPU`.

The following example demonstrates synchronizing a DMA object for the
CPU:

[source,c]
----
if (ddi_dma_sync(xsp->handle, 0, length, DDI_DMA_SYNC_FORCPU)
    == DDI_SUCCESS) {
    /* the CPU can now access the transferred data */
    /* ... */
} else {
    /* error handling */
}
----

Use the flag `DDI++_++DMA++_++SYNC++_++FORKERNEL` if the only mapping is
for the kernel, as in the case of memory that is allocated by
`ddi++_++dma++_++mem++_++alloc(9F)`. The system tries to synchronize the
kernel's view more quickly than the CPU's view. If the system cannot
synchronize the kernel view faster, the system acts as if the
`DDI++_++DMA++_++SYNC++_++FORCPU` flag were set.

[[dma-windows]]
=== DMA Windows

If an object does not fit within
the limitations of the DMA engine, the transfer must be broken into a
series of smaller transfers. The driver can break up the transfer
itself. Alternatively, the driver can allow the system to allocate
resources for only part of the object, thereby creating a series of DMA
_windows_. Allowing the system to allocate resources is the preferred
solution, because the system can manage the resources more effectively
than the driver can manage the resources.

A DMA window has two attributes. The ++<++offset++>++ attribute is
measured from the beginning of the object. The ++<++length++>++
attribute is the number of bytes of memory to be allocated. After a
partial allocation, only a range of ++<++length++>++ bytes that starts
at ++<++offset++>++ has allocated resources.

A DMA window is requested by specifying the `DDI++_++DMA++_++PARTIAL`
flag as a parameter to `ddi++_++dma++_++buf++_++bind++_++handle(9F)` or
`ddi++_++dma++_++addr++_++bind++_++handle(9F)`. Both functions return
`DDI++_++DMA++_++PARTIAL++_++MAP` if a window can be established.
However, the system might allocate resources for the entire object, in
which case `DDI++_++DMA++_++MAPPED` is returned. The driver should check
the return value to determine whether DMA windows are in use. See the
following example.

[[dma-23815]]
Setting Up DMA Windows

[source,c]
----
static int
xxstart (caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct device_reg *regp = xsp->reg;
    ddi_dma_cookie_t cookie;
    int status;
    mutex_enter(&xsp->mu);
    if (xsp->busy) {
        /* transfer in progress */
        mutex_exit(&xsp->mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    xsp->busy = 1;
    mutex_exit(&xsp->mu);
    if ( /* transfer is a read */) {
        flags = DDI_DMA_READ;
    } else {
        flags = DDI_DMA_WRITE;
    }
    flags |= DDI_DMA_PARTIAL;
    status = ddi_dma_buf_bind_handle(xsp->handle, xsp->bp,
        flags, xxstart, (caddr_t)xsp, &cookie, &ccount);
    if (status != DDI_DMA_MAPPED &&
        status != DDI_DMA_PARTIAL_MAP)
        return (DDI_DMA_CALLBACK_RUNOUT);
    if (status == DDI_DMA_PARTIAL_MAP) {
        ddi_dma_numwin(xsp->handle, &xsp->nwin);
        xsp->partial = 1;
        xsp->windex = 0;
    } else {
        xsp->partial = 0;
    }
    /* Program the DMA engine. */
    return (DDI_DMA_CALLBACK_DONE);
}
----

Two functions operate with DMA windows. The first,
`ddi++_++dma++_++numwin(9F)`, returns the number of DMA windows for a
particular DMA object. The other function, `ddi++_++dma++_++getwin(9F)`,
allows repositioning within the object, that is, reallocation of system
resources. The `ddi++_++dma++_++getwin` function shifts the current
window to a new window within the object. Because
`ddi++_++dma++_++getwin` reallocates system resources to the new window,
the previous window becomes invalid.

[CAUTION]

Do not move the DMA windows with a call to `ddi++_++dma++_++getwin`
before transfers into the current window are complete. Wait until the
transfer to the current window is complete, which is when the interrupt
arrives. Then call `ddi++_++dma++_++getwin` to avoid data corruption.
===

The `ddi++_++dma++_++getwin` function is normally called from an
interrupt routine, as shown in link:#dma-41452[example++_++title]. The
first DMA transfer is initiated as a result of a call to the driver.
Subsequent transfers are started from the interrupt routine.

The interrupt routine examines the status of the device to determine
whether the device completes the transfer successfully. If not, normal
error recovery occurs. If the transfer is successful, the routine must
determine whether the logical transfer is complete. A complete transfer
includes the entire object as specified by the `buf(9S)` structure. In a
partial transfer, only one DMA window is moved. In a partial transfer,
the interrupt routine moves the window with
`ddi++_++dma++_++getwin(9F)`, retrieves a new cookie, and starts another
DMA transfer.

If the logical request has been completed, the interrupt routine checks
for pending requests. If necessary, the interrupt routine starts a
transfer. Otherwise, the routine returns without invoking another DMA
transfer. The following example illustrates the usual flow control.

[[dma-41452]]
Interrupt Handler Using DMA Windows

[source,c]
----
static uint_t
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    uint8_t    status;
    volatile   uint8_t   temp;
    mutex_enter(&xsp->mu);
    /* read status */
    status = ddi_get8(xsp->access_hdl, &xsp->regp->csr);
    if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->mu);
        return (DDI_INTR_UNCLAIMED);
    }
    ddi_put8(xsp->access_hdl,&xsp->regp->csr, CLEAR_INTERRUPT);
    /* for store buffers */
    temp = ddi_get8(xsp->access_hdl, &xsp->regp->csr);
    if ( /* an error occurred during transfer */ ) {
        bioerror(xsp->bp, EIO);
        xsp->partial = 0;
    } else {
        xsp->bp->b_resid -= /* amount transferred */ ;
    }

    if (xsp->partial && (++xsp->windex < xsp->nwin)) {
        /* device still marked busy to protect state */
        mutex_exit(&xsp->mu);
        (void) ddi_dma_getwin(xsp->handle, xsp->windex,
            &offset, &len, &cookie, &ccount);
        /* Program the DMA engine with the new cookie(s). */
        return (DDI_INTR_CLAIMED);
    }
    ddi_dma_unbind_handle(xsp->handle);
    biodone(xsp->bp);
    xsp->busy = 0;
    xsp->partial = 0;
    mutex_exit(&xsp->mu);
    if ( /* pending transfers */ ) {
        (void) xxstart((caddr_t)xsp);
    }
    return (DDI_INTR_CLAIMED);
}
----

[[mapping-device-and-kernel-memory]]
=== Mapping Device and Kernel Memory

memory mapping

device memory management

device memory

Some device drivers allow applications to access device or kernel memory
through `mmap(2)`. Frame buffer drivers, for example, enable the frame
buffer to be mapped into a user thread. Another example would be a
pseudo driver that uses a shared kernel memory pool to communicate with
an application. This chapter provides information on the following
subjects:

* link:#memory-mapping-overview[Memory Mapping Overview]
* link:#exporting-the-mapping[Exporting the Mapping]
* link:#associating-device-memory-with-user-mappings[Associating Device Memory With User Mappings]
* link:#associating-kernel-memory-with-user-mappings[Associating Kernel Memory With User Mappings]

[[memory-mapping-overview]]
=== Memory Mapping Overview

The steps that a driver must take to export device or kernel memory are
as follows:

[arabic]
. Set the `D++_++DEVMAP` flag in the `cb++_++flag` flag of the
`cb++_++ops(9S)` structure.
. Define a `devmap(9E)` driver entry point and optional `segmap(9E)`
entry point to export the mapping.
. Use `devmap++_++devmem++_++setup(9F)` to set up user mappings to a
device. To set up user mappings to kernel memory, use
`devmap++_++umem++_++setup(9F)`.

[[exporting-the-mapping]]
=== Exporting the Mapping

This section describes how to use the `segmap(9E)` and `devmap(9E)`
entry points.

[[the-segmap9e-entry-point]]
==== The `segmap`(9E) Entry Point

The `segmap(9E)` entry point is responsible for setting
up a memory mapping requested by an `mmap(2)` system call. Drivers for
many memory-mapped devices use `ddi++_++devmap++_++segmap(9F)` as the
entry point rather than defining their own `segmap(9E)` routine. By
providing a `segmap` entry point, a driver can take care of general
tasks before or after creating the mapping. For example, the driver can
check mapping permissions and allocate private mapping resources. The
driver can also make adjustments to the mapping to accommodate
non-page-aligned device buffers. The `segmap` entry point must call the
`ddi++_++devmap++_++segmap(9F)` function before returning. The
`ddi++_++devmap++_++segmap` function calls the driver's `devmap(9E)`
entry point to perform the actual mapping.

The `segmap` function has the following syntax:

[source,c]
----
int segmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp,
     off_t len, unsigned int prot, unsigned int maxprot,
     unsigned int flags, cred_t *credp);
----

where:

++<++dev++>++::
  Device whose memory is to be mapped.
++<++off++>++::
  Offset within device memory at which mapping begins.
++<++asp++>++::
  Pointer to the address space into which the device memory should be
  mapped.
  +
  Note that this argument can be either a `struct as ++*++`, as shown in
  link:#segmap-1[example++_++title], or a `ddi++_++as++_++handle++_++t`,
  as shown in link:#segmap-2[example++_++title]. This is because
  `ddidevmap.h` includes the following declaration:
  +
[source,c]
----
typedef struct as *ddi_as_handle_t
----
++<++addrp++>++::
  Pointer to the address in the address space to which the device memory
  should be mapped.
++<++len++>++::
  Length (in bytes) of the memory being mapped.
++<++prot++>++::
  A bit field that specifies the protections. Possible settings are
  PROT++_++READ, PROT++_++WRITE, PROT++_++EXEC, PROT++_++USER, and
  PROT++_++ALL. See the man page for details.
++<++maxprot++>++::
  Maximum protection flag possible for attempted mapping. The
  PROT++_++WRITE bit can be masked out if the user opened the special
  file read-only.
++<++flags++>++::
  Flags that indicate the type of mapping. Possible values include
  MAP++_++SHARED and MAP++_++PRIVATE.
++<++credp++>++::
  Pointer to the user credentials structure.

In the following example, the driver controls a frame buffer that allows
write-only mappings. The driver returns EINVAL if the application tries
to gain read access and then calls `ddi++_++devmap++_++segmap(9F)` to
set up the user mapping.

[[segmap-1]]
`segmap(9E)` Routine

[source,c]
----
static int
xxsegmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp,
    off_t len, unsigned int prot, unsigned int maxprot,
    unsigned int flags, cred_t *credp)
{
    if (prot & PROT_READ)
        return (EINVAL);
    return (ddi_devmap_segmap(dev, off, as, addrp,
        len, prot, maxprot, flags, cred));
}
----

The following example shows how to handle a device that has a buffer
that is not page-aligned in its register space. This example maps a
buffer that starts at offset 0x800, so that `mmap(2)` returns an address
that corresponds to the start of the buffer. The
`devmap++_++devmem++_++setup(9F)` function maps entire pages, requires
the mapping to be page aligned, and returns an address to the start of a
page. If this address is passed through `segmap(9E)`, or if no `segmap`
entry point is defined, `mmap` returns the address that corresponds to
the start of the page, not the address that corresponds to the start of
the buffer. In this example, the buffer offset is added to the
page-aligned address that was returned by `devmap++_++devmem++_++setup`
so that the resulting address returned is the desired start of the
buffer.

[[segmap-2]]
Using the `segmap` Function to Change the Address Returned by the `mmap`

[source,c]
----
#define BUFFER_OFFSET 0x800

xx_segmap(dev_t dev, off_t off, ddi_as_handle_t as, caddr_t *addrp, off_t len,
    uint_t prot, uint_t maxprot, uint_t flags, cred_t *credp)
{
        int rval;
        unsigned long pagemask = ptob(1L) - 1L;

        if ((rval = ddi_devmap_segmap(dev, off, as, addrp, len, prot, maxprot,
            flags, credp)) == DDI_SUCCESS) {
                /*
                 * The address returned by ddi_devmap_segmap is the start of the page
                 * that contains the buffer.  Add the offset of the buffer to get the
                 * final address.
                 */
                *addrp += BUFFER_OFFSET & pagemask);
        }
        return (rval);
}
----

[[the-devmap9e-entry-point]]
==== The `devmap`(9E) Entry Point

The `devmap(9E)` entry point is called from the
`ddi++_++devmap++_++segmap(9F)` function inside the `segmap(9E)` entry
point.

The `devmap(9E)` entry point is called as a result of the `mmap(2)`
system call. The `devmap(9E)` function is called to export device memory
or kernel memory to user applications. The `devmap` function is used for
the following operations:

* Validate the user mapping to the device or kernel memory
* Translate the logical offset within the application mapping to the
corresponding offset within the device or kernel memory
* Pass the mapping information to the system for setting up the mapping

The `devmap` function has the following syntax:

[source,c]
----
int devmap(dev_t dev, devmap_cookie_t handle, offset_t off,
     size_t len, size_t *maplen, uint_t model);
----

where:

++<++dev++>++::
  Device whose memory is to be mapped.
++<++handle++>++::
  Device-mapping handle that the system creates and uses to describe a
  mapping to contiguous memory in the device or kernel.
++<++off++>++::
  Logical offset within the application mapping that has to be
  translated by the driver to the corresponding offset within the device
  or kernel memory.
++<++len++>++::
  Length (in bytes) of the memory being mapped.
++<++maplen++>++::
  Enables driver to associate different kernel memory regions or
  multiple physically discontiguous memory regions with one contiguous
  user application mapping.
++<++model++>++::
  Data model type of the current thread.

The system creates multiple mapping
handles in one `mmap(2)` system call. For example, the mapping might
contain multiple physically discontiguous memory regions.

Initially, `devmap(9E)` is called with the parameters ++<++off++>++ and
++<++len++>++. These parameters are passed by the application to
`mmap(2)`. `devmap(9E)` sets `++*++`++<++maplen++>++ to the length from
++<++off++>++ to the end of a contiguous memory region. The
`++*++`++<++maplen++>++ value must be rounded up to a multiple of a page
size. The `++*++`++<++maplen++>++ value can be set to less than the
original mapping length `len`. If so, the system uses a new mapping
handle with adjusted ++<++off++>++ and ++<++len++>++ parameters to call
`devmap(9E)` repeatedly until the initial mapping length is satisfied.

If a driver supports multiple application data models, ++<++model++>++
must be passed to `ddi++_++model++_++convert++_++from(9F)`. The
`ddi++_++model++_++convert++_++from` function determines whether a data
model mismatch exists between the current thread and the device driver.
The device driver might have to adjust the shape of data structures
before exporting the structures to a user thread that supports a
different data model. See link:#making-a-device-driver-64-bit-ready[appendix++_++title] page for
more details.

The `devmap(9E)` entry point must return `-1` if the logical offset,
++<++off++>++, is out of the range of memory exported by the driver.

[[associating-device-memory-with-user-mappings]]
=== Associating Device Memory With User Mappings

`devmap++_++devmem++_++setup(9F)` from the driver's `devmap(9E)` entry
point to export device memory to user applications.

The `devmap++_++devmem++_++setup(9F)` function has the following syntax:

[source,c]
----
int devmap_devmem_setup(devmap_cookie_t handle, dev_info_t *dip,
    struct devmap_callback_ctl *callbackops, uint_t rnumber, 
    offset_t roff, size_t len, uint_t maxprot, uint_t flags, 
    ddi_device_acc_attr_t *accattrp);
----

where:

++<++handle++>++::
  Opaque device-mapping handle that the system uses to identify the
  mapping.
++<++dip++>++::
  Pointer to the device's `dev++_++info` structure.
++<++callbackops++>++::
  Pointer to a `devmap++_++callback++_++ctl(9S)` structure that enables
  the driver to be notified of user events on the mapping.
++<++rnumber++>++::
  Index number to the register address space set.
++<++roff++>++::
  Offset into the device memory.
++<++len++>++::
  Length in bytes that is exported.
++<++maxprot++>++::
  Allows the driver to specify different protections for different
  regions within the exported device memory.
++<++flags++>++::
  Must be set to `DEVMAP++_++DEFAULTS`.
++<++accattrp++>++::
  Pointer to a `ddi++_++device++_++acc++_++attr(9S)` structure.

The ++<++roff++>++ and ++<++len++>++ arguments describe a range within
the device memory specified by the register set ++<++rnumber++>++. The
register specifications that are referred to by ++<++rnumber++>++ are
described by the `reg` property. For devices with only one register set,
pass zero for `rnumber`. The range is defined by ++<++roff++>++ and
++<++len++>++. The range is made accessible to the user's application
mapping at the ++<++offset++>++ that is passed in by the `devmap(9E)`
entry point. Usually the driver passes the `devmap(9E)` offset directly
to `devmap++_++devmem++_++setup(9F)`. The return address of `mmap(2)`
then maps to the beginning address of the register set.

The ++<++maxprot++>++ argument enables the driver to specify different
protections for different regions within the exported device memory. For
example, to disallow write access for a region, set only `PROT++_++READ`
and `PROT++_++USER` for that region.

The following example shows how to export device memory to an
application. The driver first determines whether the requested mapping
falls within the device memory region. The size of the device memory is
determined using `ddi++_++dev++_++regsize(9F)`. The length of the
mapping is rounded up to a multiple of a page size using `ptob(9F)` and
`btopr(9F)`. Then `devmap++_++devmem++_++setup(9F)` is called to export
the device memory to the application.

[[devmap-23038]]
Using the `devmap++_++devmem++_++setup` Routine

[source,c]
----
static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off, size_t len,
    size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    int    error, rnumber;
    off_t regsize;
    
    /* Set up data access attribute structure */
    struct ddi_device_acc_attr xx_acc_attr = {
        DDI_DEVICE_ATTR_V0,
        DDI_NEVERSWAP_ACC,
    };
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (-1);
    /* use register set 0 */
    rnumber = 0;
    /* get size of register set */
    if (ddi_dev_regsize(xsp->dip, rnumber, &regsize) != DDI_SUCCESS)
        return (-1);
    /* round up len to a multiple of a page size */
       len = ptob(btopr(len));
    if (off + len > regsize)
        return (-1);
    /* Set up the device mapping */
    error = devmap_devmem_setup(handle, xsp->dip, NULL, rnumber, 
    off, len, PROT_ALL, DEVMAP_DEFAULTS, &xx_acc_attr);
    /* acknowledge the entire range */
    *maplen = len;
    return (error);
}
----

[[associating-kernel-memory-with-user-mappings]]
=== Associating Kernel Memory With User Mappings

Some device drivers might
need to allocate kernel memory that is made accessible to user programs
through `mmap(2)`. One example is setting up shared memory for
communication between two applications. Another example is sharing
memory between a driver and an application.

When exporting kernel memory to user applications, follow these steps:

[arabic]
. Use `ddi++_++umem++_++alloc(9F)` to allocate kernel memory.
. Use `devmap++_++umem++_++setup(9F)` to export the memory.
. Use `ddi++_++umem++_++free(9F)` to free the memory when the memory is
no longer needed.

[[allocating-kernel-memory-for-user-access]]
==== Allocating Kernel Memory for User Access

Use `ddi++_++umem++_++alloc(9F)` to
allocate kernel memory that is exported to applications.
`ddi++_++umem++_++alloc` uses the following syntax:

[source,c]
----
void *ddi_umem_alloc(size_t size, int flag, ddi_umem_cookie_t 
*cookiep);
----

where:

++<++size++>++::
  Number of bytes to allocate.
++<++flag++>++::
  Used to determine the sleep conditions and the memory type.
++<++cookiep++>++::
  Pointer to a kernel memory cookie.

`ddi++_++umem++_++alloc(9F)` allocates page-aligned kernel memory.
`ddi++_++umem++_++alloc` returns a pointer to the allocated memory.
Initially, the memory is filled with zeroes. The number of bytes that
are allocated is a multiple of the system page size, which is rounded up
from the ++<++size++>++ parameter. The allocated memory can be used in
the kernel. This memory can be exported to applications as well.
++<++cookiep++>++ is a pointer to the kernel memory cookie that
describes the kernel memory being allocated. ++<++cookiep++>++ is used
in `devmap++_++umem++_++setup(9F)` when the driver exports the kernel
memory to a user application.

The ++<++flag++>++ argument indicates whether
`ddi++_++umem++_++alloc(9F)` blocks or returns immediately, and whether
the allocated kernel memory is pageable. The values for the `flag`
argument as follows:

`DDI++_++UMEM++_++NOSLEEP`::
  Driver does not need to wait for memory to become available. Return
  `NULL` if memory is not available.
`DDI++_++UMEM++_++SLEEP`::
  Driver can wait indefinitely for memory to become available.
`DDI++_++UMEM++_++PAGEABLE`::
  Driver allows memory to be paged out. If not set, the memory is locked
  down.

The `ddi++_++umem++_++lock` function can perform device-locked-memory
checks. The function checks against the limit value that is specified in
`project.max-locked-memory`. If the current project locked-memory usage
is below the limit, the project's locked-memory byte count is increased.
After the limit check, the memory is locked. The
`ddi++_++umem++_++unlock` function unlocks the memory, and the project's
locked-memory byte count is decremented.

The accounting method that is used is an imprecise full price model. For
example, two callers of `umem++_++lockmemory` within the same project
with overlapping memory regions are charged twice.

For information about the `project.max-locked-memory` and
`zone.max-locked++_++memory` resource controls on illumos systems with
zones installed, see illumos Containers: Resource Management and illumos
Zones Developer’s Guide and see `resource++_++controls(7)`.

The following example shows how to allocate kernel memory for
application access. The driver exports one page of kernel memory, which
is used by multiple applications as a shared memory area. The memory is
allocated in `segmap(9E)` when an application maps the shared page the
first time. An additional page is allocated if the driver has to support
multiple application data models. For example, a 64-bit driver might
export memory both to 64-bit applications and to 32-bit applications.
64-bit applications share the first page, and 32-bit applications share
the second page.

[[devmap-25235]]
Using the `ddi++_++umem++_++alloc` Routine

[source,c]
----
static int
xxsegmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp, off_t len,
    unsigned int prot, unsigned int maxprot, unsigned int flags, 
    cred_t *credp)
{
    int error;
    minor_t instance = getminor(dev);
    struct xxstate *xsp = ddi_get_soft_state(statep, instance);

    size_t mem_size;
        /* 64-bit driver supports 64-bit and 32-bit applications */
    switch (ddi_mmap_get_model()) {
        case DDI_MODEL_LP64:
             mem_size = ptob(2);
             break;
        case DDI_MODEL_ILP32:
             mem_size = ptob(1);
             break;
    }

    mutex_enter(&xsp->mu);
    if (xsp->umem == NULL) {
        /* allocate the shared area as kernel pageable memory */
        xsp->umem = ddi_umem_alloc(mem_size,
            DDI_UMEM_SLEEP | DDI_UMEM_PAGEABLE, &xsp->ucookie);
    }
    mutex_exit(&xsp->mu);
    /* Set up the user mapping */
    error = devmap_setup(dev, (offset_t)off, asp, addrp, len,
        prot, maxprot, flags, credp);
    return (error);
}
----

[[exporting-kernel-memory-to-applications]]
==== Exporting Kernel Memory to Applications

Use `devmap++_++umem++_++setup(9F)` to
export kernel memory to user applications. `devmap++_++umem++_++setup`
must be called from the driver's `devmap(9E)` entry point. The syntax
for `devmap++_++umem++_++setup` is as follows:

[source,c]
----
int devmap_umem_setup(devmap_cookie_t handle, dev_info_t *dip,
    struct devmap_callback_ctl *callbackops, ddi_umem_cookie_t cookie,
    offset_t koff, size_t len, uint_t maxprot, uint_t flags,
    ddi_device_acc_attr_t *accattrp);
----

where:

++<++handle++>++::
  Opaque structure used to describe the mapping.
++<++dip++>++::
  Pointer to the device's `dev++_++info` structure.
++<++callbackops++>++::
  Pointer to a `devmap++_++callback++_++ctl(9S)` structure.
++<++cookie++>++::
  Kernel memory cookie returned by `ddi++_++umem++_++alloc(9F)`.
++<++koff++>++::
  Offset into the kernel memory specified by cookie.
++<++len++>++::
  Length in bytes that is exported.
++<++maxprot++>++::
  Specifies the maximum protection possible for the exported mapping.
++<++flags++>++::
  Must be set to `DEVMAP++_++DEFAULTS`.
++<++accattrp++>++::
  Pointer to a `ddi++_++device++_++acc++_++attr(9S)` structure.

++<++handle++>++ is a device-mapping handle that the system uses to
identify the mapping. ++<++handle++>++ is passed in by the `devmap(9E)`
entry point. ++<++dip++>++ is a pointer to the device's `dev++_++info`
structure. ++<++callbackops++>++ enables the driver to be notified of
user events on the mapping. Most drivers set ++<++callbackops++>++ to
`NULL` when kernel memory is exported.

++<++koff++>++ and ++<++len++>++ specify a range within the kernel
memory allocated by `ddi++_++umem++_++alloc(9F)`. This range is made
accessible to the user's application mapping at the offset that is
passed in by the `devmap(9E)` entry point. Usually, the driver passes
the `devmap(9E)` offset directly to `devmap++_++umem++_++setup(9F)`. The
return address of `mmap(2)` then maps to the kernel address returned by
`ddi++_++umem++_++alloc(9F)`. ++<++koff++>++ and ++<++len++>++ must be
page-aligned.

++<++maxprot++>++ enables the driver to specify different protections
for different regions within the exported kernel memory. For example,
one region might not allow write access by only setting `PROT++_++READ`
and `PROT++_++USER`.

The following example shows how to export kernel memory to an
application. The driver first checks whether the requested mapping falls
within the allocated kernel memory region. If a 64-bit driver receives a
mapping request from a 32-bit application, the request is redirected to
the second page of the kernel memory area. This redirection ensures that
only applications compiled to the same data model share the same page.

[[devmap-19641]]
`devmap++_++umem++_++setup(9F)` Routine

[source,c]
----
static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off, size_t len,
    size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    int    error;

    /* round up len to a multiple of a page size */
    len = ptob(btopr(len));
    /* check if the requested range is ok */
    if (off + len > ptob(1))
        return (ENXIO);
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);

    if (ddi_model_convert_from(model) == DDI_MODEL_ILP32)
        /* request from 32-bit application. Skip first page */
        off += ptob(1);

    /* export the memory to the application */
    error = devmap_umem_setup(handle, xsp->dip, NULL, xsp->ucookie,
        off, len, PROT_ALL, DEVMAP_DEFAULTS, NULL);
    *maplen = len;
    return (error);
}
----

[[freeing-kernel-memory-exported-for-user-access]]
==== Freeing Kernel Memory Exported for User Access

When the driver is unloaded, the memory
that was allocated by `ddi++_++umem++_++alloc(9F)` must be freed by
calling `ddi++_++umem++_++free(9F)`.

[source,c]
----
void ddi_umem_free(ddi_umem_cookie_t cookie);
----

++<++cookie++>++ is the kernel memory cookie returned by
`ddi++_++umem++_++alloc(9F)`.

[[device-context-management]]
=== Device Context Management

Some device drivers, such as drivers for graphics hardware, provide user
processes with direct access to the device. These devices often require
that only one process at a time accesses the device.

This chapter describes the set of interfaces that enable device drivers
to manage access to such devices. The chapter provides information on
the following subjects:

* link:#introduction-to-device-context[Introduction to Device Context]
* link:#context-management-model[Context Management Model]
* link:#context-management-operation[Context Management Operation]

[[introduction-to-device-context]]
=== Introduction to Device Context

This section introduces device context and the context management model.

[[what-is-a-device-context]]
==== What Is a Device Context?

_context_ of a device is the current state of the device hardware. The
device driver manages the device context for a process on behalf of the
process. The driver must maintain a separate device context for each
process that accesses the device. The device driver has the
responsibility to restore the correct device context when a process
accesses the device.

[[context-management-model]]
==== Context Management Model

buffers provide a good example of device context management. An
accelerated frame buffer enables user processes to directly manipulate
the control registers of the device through memory-mapped access.
Because these processes do not use traditional system calls, a process
that accesses the device need not call the device driver. However, the
device driver must be notified when a process is about to access a
device. The driver needs to restore the correct device context and needs
to provide any necessary synchronization.

To resolve this problem, the device context management interfaces enable
a device driver to be notified when a user process accesses
memory-mapped regions of the device, and to control accesses to the
device's hardware. Synchronization and management of the various device
contexts are the responsibility of the device driver. When a user
process accesses a mapping, the device driver must restore the correct
device context for that process.

A device driver is notified whenever a user process performs any of the
following actions:

* Accesses a mapping
* Duplicates a mapping
* Frees a mapping
* Creates a mapping

The following figure shows multiple user processes that have
memory-mapped a device. The driver has granted process B access to the
device, and process B no longer notifies the driver of accesses.
However, the driver _is_ still notified if either process A or process C
accesses the device.

.Device Context Management
[#devcnmgt-fig-3]
image::figures/devcnmgt-view.png[Diagram shows three processes, A, B, and C, with Process B having sole access to the device.]

At some point in the future, process A accesses the device. The device
driver is notified and blocks future access to the device by process B.
The driver then saves the device context for process B. The driver
restores the device context of process A. The driver then grants access
to process A, as illustrated in the following figure. At this point, the
device driver is notified if either process B or process C accesses the
device.

.Device Context Switched to User Process A
[#devcnmgt-fig-4]
image::figures/devcnmgt-contextswitch.png[Diagram continues example in previous figure with sole device access switched to Process A.]

On a multiprocessor machine, multiple processes could attempt to access
the device at the same time. This situation can cause thrashing. Some
devices require a longer time to restore a device context. To prevent
more CPU time from being used to restore a device context than to
actually use that device context, the minimum time that a process needs
to have access to the device can be set using
`devmap++_++set++_++ctx++_++timeout(9F)`.

The kernel guarantees that once a device driver has
granted access to a process, no other process is allowed to request
access to the same device for the time interval specified by
`devmap++_++set++_++ctx++_++timeout(9F)`.

[[context-management-operation]]
=== Context Management Operation

The general steps for performing device context
management are as follows:

[arabic]
. Define a `devmap++_++callback++_++ctl(9S)` structure.
. Allocate space to save device context if necessary.
. Set up user mappings to the device and driver notifications with
`devmap++_++devmem++_++setup(9F)`.
. Manage user access to the device with `devmap++_++load(9F)` and
`devmap++_++unload(9F)`.
. Free the device context structure, if needed.

[[devmapcallbackctl-structure]]
==== `devmap++_++callback++_++ctl` Structure

The device driver must allocate and initialize a
`devmap++_++callback++_++ctl(9S)` structure to inform the system about
the entry point routines for device context management.

This structure uses the following syntax:

[source,c]
----
struct devmap_callback_ctl {    
    int devmap_rev;
    int (*devmap_map)(devmap_cookie_t dhp, dev_t dev,
    uint_t flags, offset_t off, size_t len, void **pvtp);
    int (*devmap_access)(devmap_cookie_t dhp, void *pvtp,
    offset_t off, size_t len, uint_t type, uint_t rw);
    int (*devmap_dup)(devmap_cookie_t dhp, void *pvtp,
    devmap_cookie_t new_dhp, void **new_pvtp);
    void (*devmap_unmap)(devmap_cookie_t dhp, void *pvtp,
    offset_t off, size_t len, devmap_cookie_t new_dhp1,
    void **new_pvtp1, devmap_cookie_t new_dhp2,
    void **new_pvtp2);
};
----

`devmap++_++rev`::
  The version number of the `devmap++_++callback++_++ctl` structure. The
  version number must be set to `DEVMAP++_++OPS++_++REV`.
`devmap++_++map`::
  Must be set to the address of the driver's `devmap++_++map(9E)` entry
  point.
`devmap++_++access`::
  Must be set to the address of the driver's `devmap++_++access(9E)`
  entry point.
`devmap++_++dup`::
  Must be set to the address of the driver's `devmap++_++dup(9E)` entry
  point.
`devmap++_++unmap`::
  Must be set to the address of the driver's `devmap++_++unmap(9E)`
  entry point.

[[entry-points-for-device-context-management]]
==== Entry Points for Device Context Management

The following entry points are used to
manage device context:

* `devmap(9E)`
* `devmap++_++access(9E)`
* `devmap++_++contextmgt(9E)`
* `devmap++_++dup(9E)`
* `devmap++_++unmap(9E)`

[[devmap_map-entry-point]]
===== `devmap++_++map` Entry Point

The syntax for `devmap(9E)` is as follows:

[source,c]
----
int xxdevmap_map(devmap_cookie_t handle, dev_t dev, uint_t flags,
    offset_t offset, size_t len, void **new-devprivate);
----

The `devmap++_++map` entry point is
called after the driver returns from its `devmap` entry point and the
system has established the user mapping to the device memory. The
`devmap` entry point enables a driver to perform additional processing
or to allocate mapping specific private data. For example, in order to
support context switching, the driver has to allocate a context
structure. The driver must then associate the context structure with the
mapping.

The system expects the driver to return a pointer to the allocated
private data in ++*<++new-devprivate++>++. The driver must store
++<++offset++>++ and ++<++len++>++, which define the range of the
mapping, in its private data. Later, when the system calls
`devmap++_++unmap(9E)`, the driver uses this information to determine
how much of the mapping is being unmapped.

++<++flags++>++ indicates whether the driver should allocate a private
context for the mapping. For example, a driver can allocate a memory
region to store the device context if ++<++flags++>++ is set to
`MAP++_++PRIVATE`. If `MAP++_++SHARED` is set, the driver returns a
pointer to a shared region.

The following example shows a `devmap` entry point. The driver allocates
a new context structure. The driver then saves relevant parameters
passed in by the entry point. Next, the mapping is assigned a new
context either through allocation or by attaching the mapping to an
already existing shared context. The minimum time interval that the
mapping should have access to the device is set to one millisecond.

[[devcnmgt-15467]]
Using the `devmap` Routine

[source,c]
----
static int
int xxdevmap_map(devmap_cookie_t handle, dev_t dev, uint_t flags,
    offset_t offset, size_t len, void **new_devprivate)
{
    struct xxstate *xsp = ddi_get_soft_state(statep,
                  getminor(dev));
    struct xxctx *newctx;

    /* create a new context structure */
    newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
    newctx->xsp = xsp;
    newctx->handle = handle;
    newctx->offset = offset;
    newctx->flags = flags;
    newctx->len = len;
    mutex_enter(&xsp->ctx_lock);
    if (flags & MAP_PRIVATE) {
        /* allocate a private context and initialize it */
        newctx->context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
        xxctxinit(newctx);
    } else {
        /* set a pointer to the shared context */
        newctx->context = xsp->ctx_shared;
    }
    mutex_exit(&xsp->ctx_lock);
    /* give at least 1 ms access before context switching */
    devmap_set_ctx_timeout(handle, drv_usectohz(1000));
    /* return the context structure */
    *new_devprivate = newctx;
    return(0);
}
----

[[devmap_access-entry-point]]
===== `devmap++_++access` Entry Point

devmap++_++

devmap++_++access

The `devmap++_++access(9E)` entry point is called when an access is made
to a mapping whose translations are invalid. Mapping translations are
invalidated when the mapping is created with
`devmap++_++devmem++_++setup(9F)` in response to `mmap(2)`, duplicated
by `fork(2)`, or explicitly invalidated by a call to
`devmap++_++unload(9F)`.

The syntax for `devmap++_++access` is as follows:

[source,c]
----
int xxdevmap_access(devmap_cookie_t handle, void *devprivate,
    offset_t offset, size_t len, uint_t type, uint_t rw);
----

where:

++<++handle++>++::
  Mapping handle of the mapping that was accessed by a user process.
++<++devprivate++>++::
  Pointer to the driver private data associated with the mapping.
++<++offset++>++::
  Offset within the mapping that was accessed.
++<++len++>++::
  Length in bytes of the memory being accessed.
++<++type++>++::
  Type of access operation.
++<++rw++>++::
  Specifies the direction of access.

The system expects `devmap++_++access(9E)` to call either
`devmap++_++do++_++ctxmgt(9F)` or `devmap++_++default++_++access(9F)` to
load the memory address translations before `devmap++_++access` returns.
For mappings that support context switching, the device driver should
call `devmap++_++do++_++ctxmgt`. This routine is passed all parameters
from `devmap++_++access(9E)`, as well as a pointer to the driver entry
point `devmap++_++contextmgt(9E)`, which handles the context switching.
For mappings that do not support context switching, the driver should
call `devmap++_++default++_++access(9F)`. The purpose of
`devmap++_++default++_++access` is to call `devmap++_++load(9F)` to load
the user translation.

The following example shows a `devmap++_++access(9E)` entry point. The
mapping is divided into two regions. The region that starts at offset
`OFF++_++CTXMG` with a length of `CTXMGT++_++SIZE` bytes supports
context management. The rest of the mapping supports default access.

[[devcnmgt-20766]]
Using the `devmap++_++access` Routine

[source,c]
----
#define OFF_CTXMG      0
#define CTXMGT_SIZE    0x20000    
static int
xxdevmap_access(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, uint_t type, uint_t rw)
{
    offset_t diff;
    int    error;

    if ((diff = off - OFF_CTXMG) >= 0 && diff < CTXMGT_SIZE) {
        error = devmap_do_ctxmgt(handle, devprivate, off,
            len, type, rw, xxdevmap_contextmgt);
    } else {
        error = devmap_default_access(handle, devprivate,
            off, len, type, rw);
    }
    return (error);
}
----

[[devmap_contextmgt-entry-point]]
===== `devmap++_++contextmgt` Entry Point

The syntax for `devmap++_++contextmgt(9E)` is as follows:

[source,c]
----
int xxdevmap_contextmgt(devmap_cookie_t handle, void *devprivate,
    offset_t offset, size_t len, uint_t type, uint_t rw);
----

`devmap++_++contextmgt` should call
`devmap++_++unload(9F)` with the handle of the mapping that currently
has access to the device. This approach invalidates the translations for
that mapping. The approach ensures that a call to
`devmap++_++access(9E)` occurs for the current mapping the next time the
mapping is accessed. The mapping translations for the mapping that
caused the access event to occur need to be validated. Accordingly, the
driver must restore the device context for the process requesting
access. Furthermore, the driver must call `devmap++_++load(9F)` on the
++<++handle++>++ of the mapping that generated the call to this entry
point.

Accesses to portions of mappings that have had their mapping
translations validated by a call to `devmap++_++load` do not generate a
call to `devmap++_++access`. A subsequent call to `devmap++_++unload`
invalidates the mapping translations. This call enables
`devmap++_++access` to be called again.

If either `devmap++_++load` or `devmap++_++unload` returns an error,
`devmap++_++contextmgt` should immediately return that error. If the
device driver encounters a hardware failure while restoring a device
context, a `-1` should be returned. Otherwise, after successfully
handling the access request, `devmap++_++contextmgt` should return zero.
A return of other than zero from `devmap++_++contextmgt` causes a
`SIGBUS` or `SIGSEGV` to be sent to the process.

The following example shows how to manage a one-page device context.

[NOTE]

`xxctxsave` and `xxctxrestore` are device-dependent context save and
restore functions. `xxctxsave` reads data from the registers and saves
the data in the soft state structure. `xxctxrestore` takes data that is
saved in the soft state structure and writes the data to device
registers. Note that the read, write, and save are all performed with
the DDI/DKI data access routines.
===

[[devcnmgt-40344]]
Using the `devmap++_++contextmgt` Routine

[source,c]
----
static int
xxdevmap_contextmgt(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, uint_t type, uint_t rw)
{
    int    error;
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp->xsp;
    mutex_enter(&xsp->ctx_lock);
    /* unload mapping for current context */
    if (xsp->current_ctx != NULL) {
        if ((error = devmap_unload(xsp->current_ctx->handle,
            off, len)) != 0) {
            xsp->current_ctx = NULL;
            mutex_exit(&xsp->ctx_lock);
            return (error);
        }
    }
    /* Switch device context - device dependent */
    if (xxctxsave(xsp->current_ctx, off, len) < 0) {
        xsp->current_ctx = NULL;
        mutex_exit(&xsp->ctx_lock);
        return (-1);
    }
    if (xxctxrestore(ctxp, off, len) < 0){
        xsp->current_ctx = NULL;
        mutex_exit(&xsp->ctx_lock);
        return (-1);
    }
    xsp->current_ctx = ctxp;
    /* establish mapping for new context and return */
    error = devmap_load(handle, off, len, type, rw);
    if (error)
        xsp->current_ctx = NULL;
    mutex_exit(&xsp->ctx_lock);
    return (error);
}
----

[[devmap_dup-entry-point]]
===== `devmap++_++dup` Entry Point

devmap++_++

devmap++_++dup

The `devmap++_++dup(9E)` entry point is called when a device mapping is
duplicated, for example, by a user process that calls `fork(2)`. The
driver is expected to generate new driver private data for the new
mapping.

The syntax for `devmap++_++dup` is as follows:

[source,c]
----
int xxdevmap_dup(devmap_cookie_t handle, void *devprivate,
    devmap_cookie_t new-handle, void **new-devprivate);
----

where:

++<++handle++>++::
  Mapping handle of the mapping being duplicated.
++<++new-handle++>++::
  Mapping handle of the mapping that was duplicated.
++<++devprivate++>++::
  Pointer to the driver private data associated with the mapping being
  duplicated.
`++*++`++<++new-devprivate++>++::
  Should be set to point to the new driver private data for the new
  mapping.

Mappings that have been created with `devmap++_++dup` by default have
their mapping translations invalidated. Invalid mapping translations
force a call to the `devmap++_++access(9E)` entry point the first time
the mapping is accessed.

The following example shows a typical `devmap++_++dup` routine.

[[devcnmgt-32712]]
Using the `devmap++_++dup` Routine

[source,c]
----
static int
xxdevmap_dup(devmap_cookie_t handle, void *devprivate,
    devmap_cookie_t new_handle, void **new_devprivate)
{
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp->xsp;
    struct xxctx *newctx;
    /* Create a new context for the duplicated mapping */
    newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
    newctx->xsp = xsp;
    newctx->handle = new_handle;
    newctx->offset = ctxp->offset;
    newctx->flags = ctxp->flags;
    newctx->len = ctxp->len;
    mutex_enter(&xsp->ctx_lock);
    if (ctxp->flags & MAP_PRIVATE) {
        newctx->context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
        bcopy(ctxp->context, newctx->context, XXCTX_SIZE);
    } else {
        newctx->context = xsp->ctx_shared;
    }
    mutex_exit(&xsp->ctx_lock);
    *new_devprivate = newctx;
    return(0);
}
----

[[devmap_unmap-entry-point]]
===== `devmap++_++unmap` Entry Point

devmap++_++

devmap++_++unmap

The `devmap++_++unmap(9E)` entry point is called when a mapping is
unmapped. Unmapping can be caused by a user process exiting or by
calling the `munmap(2)` system call.

The syntax for `devmap++_++unmap` is as follows:

[source,c]
----
void xxdevmap_unmap(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, devmap_cookie_t new-handle1,
    void **new-devprivate1, devmap_cookie_t new-handle2,
    void **new-devprivate2);
----

where:

++<++handle++>++::
  Mapping handle of the mapping being freed.
++<++devprivate++>++::
  Pointer to the driver private data associated with the mapping.
++<++off++>++::
  Offset within the logical device memory at which the unmapping begins.
++<++len++>++::
  Length in bytes of the memory being unmapped.
++<++new-handle1++>++::
  Handle that the system uses to describe the new region that ends at
  ++<++off++>++ - 1. The value of ++<++new-handle1++>++ can be `NULL`.
++<++new-devprivate1++>++::
  Pointer to be filled in by the driver with the private driver mapping
  data for the new region that ends at ++<++off++>++ -1.
  ++<++new-devprivate1++>++ is ignored if ++<++new-handle1++>++ is
  `NULL`.
++<++new-handle2++>++::
  Handle that the system uses to describe the new region that begins at
  ++<++off++>++ {plus} ++<++len++>++. The value of ++<++new-handle2++>++
  can be `NULL`.
++<++new-devprivate2++>++::
  Pointer to be filled in by the driver with the driver private mapping
  data for the new region that begins at ++<++off++>++ {plus}
  ++<++len++>++. ++<++new-devprivate2++>++ is ignored if
  ++<++new-handle2++>++ is `NULL`.

The `devmap++_++unmap` routine is expected to free any driver private
resources that were allocated when this mapping was created, either by
`devmap++_++map(9E)` or by `devmap++_++dup(9E)`. If the mapping is only
partially unmapped, the driver must allocate new private data for the
remaining mapping before freeing the old private data. Calling
`devmap++_++unload(9F)` on the handle of the freed mapping is not
necessary, even if this handle points to the mapping with the valid
translations. However, to prevent future `devmap++_++access(9E)`
problems, the device driver should make sure the current mapping
representation is set to “no current mapping”.

The following example shows a typical `devmap++_++unmap` routine.

[[devcnmgt-29332]]
Using the `devmap++_++unmap` Routine

[source,c]
----
static void
xxdevmap_unmap(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, devmap_cookie_t new_handle1,
    void **new_devprivate1, devmap_cookie_t new_handle2,
    void **new_devprivate2)
{
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp->xsp;
    mutex_enter(&xsp->ctx_lock);
    /*
     * If new_handle1 is not NULL, we are unmapping
     * at the end of the mapping.
     */
    if (new_handle1 != NULL) {
        /* Create a new context structure for the mapping */
        newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
        newctx->xsp = xsp;
        if (ctxp->flags & MAP_PRIVATE) {
            /* allocate memory for the private context and copy it */
            newctx->context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
            bcopy(ctxp->context, newctx->context, XXCTX_SIZE);
        } else {
            /* point to the shared context */
            newctx->context = xsp->ctx_shared;
        }
        newctx->handle = new_handle1;
        newctx->offset = ctxp->offset;
        newctx->len = off - ctxp->offset;
        *new_devprivate1 = newctx;
    }
    /*
     * If new_handle2 is not NULL, we are unmapping
     * at the beginning of the mapping.
     */
    if (new_handle2 != NULL) {
        /* Create a new context for the mapping */
        newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
        newctx->xsp = xsp;
        if (ctxp->flags & MAP_PRIVATE) {
            newctx->context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
            bcopy(ctxp->context, newctx->context, XXCTX_SIZE);
        } else {
            newctx->context = xsp->ctx_shared;
        }
        newctx->handle = new_handle2;
        newctx->offset = off + len;
        newctx->flags = ctxp->flags;
        newctx->len = ctxp->len - (off + len - ctxp->off);
        *new_devprivate2 = newctx;
    }
    if (xsp->current_ctx == ctxp)
        xsp->current_ctx = NULL;
    mutex_exit(&xsp->ctx_lock);
    if (ctxp->flags & MAP_PRIVATE)
        kmem_free(ctxp->context, XXCTX_SIZE);
    kmem_free(ctxp, sizeof (struct xxctx));
}
----

[[associating-user-mappings-with-driver-notifications]]
==== Associating User Mappings With Driver Notifications

When a
user process requests a mapping to a device with `mmap(2)`, the
driver++`++s `segmap(9E)` entry point is called. The driver must use
`ddi++_++devmap++_++segmap(9F)` or `devmap++_++setup(9F)` when setting
up the memory mapping if the driver needs to manage device contexts.
Both functions call the driver's `devmap(9E)` entry point, which uses
`devmap++_++devmem++_++setup(9F)` to associate the device memory with
the user mapping. See link:#mapping-device-and-kernel-memory[Mapping Device and Kernel
Memory] for details on how to map device memory.

The driver must inform the system of the
`devmap++_++callback++_++ctl(9S)` entry points to get notifications of
accesses to the user mapping. The driver informs the system by providing
a pointer to a `devmap++_++callback++_++ctl(9S)` structure to
`devmap++_++devmem++_++setup(9F)`. A `devmap++_++callback++_++ctl(9S)`
structure describes a set of entry points for context management. These
entry points are called by the system to notify a device driver to
manage events on the device mappings.

The system associates each mapping with a mapping handle. This handle is
passed to each of the entry points for context management. The mapping
handle can be used to invalidate and validate the mapping translations.
If the driver _invalidates_ the mapping translations, the driver will be
notified of any future access to the mapping. If the driver _validates_
the mapping translations, the driver will no longer be notified of
accesses to the mapping. Mappings are always created with the mapping
translations invalidated so that the driver will be notified on first
access to the mapping.

The following example shows how to set up a mapping using the device
context management interfaces.

[[devcnmgt-13708]]
`devmap(9E)` Entry Point With Context Management Support

[source,c]
----
static struct devmap_callback_ctl xx_callback_ctl = {
    DEVMAP_OPS_REV, xxdevmap_map, xxdevmap_access,
    xxdevmap_dup, xxdevmap_unmap
};

static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off,
    size_t len, size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    uint_t rnumber;
    int    error;
    
    /* Setup data access attribute structure */
    struct ddi_device_acc_attr xx_acc_attr = {
        DDI_DEVICE_ATTR_V0,
        DDI_NEVERSWAP_ACC,
    };
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);
    len = ptob(btopr(len));
    rnumber = 0;
    /* Set up the device mapping */
    error = devmap_devmem_setup(handle, xsp->dip, &xx_callback_ctl,
        rnumber, off, len, PROT_ALL, 0, &xx_acc_attr);
    *maplen = len;
    return (error);
}
----

[[managing-mapping-accesses]]
==== Managing Mapping Accesses

The device driver is notified when a user process accesses an address in
the memory-mapped region that does not have valid mapping translations.
When the access event occurs, the mapping translations of the process
that currently has access to the device must be invalidated. The device
context of the process that requested access to the device must be
restored. Furthermore, the translations of the mapping of the process
requesting access must be validated.

The functions `devmap++_++load(9F)` and `devmap++_++unload(9F)` are used
to validate and invalidate mapping translations.

[[devmap_load-entry-point]]
===== `devmap++_++load` Entry Point

The syntax for `devmap++_++load(9F)` is as follows:

[source,c]
----
int devmap_load(devmap_cookie_t handle, offset_t offset,
    size_t len, uint_t type, uint_t rw);
----

`devmap++_++load` validates the mapping
translations for the pages of the mapping specified by
`handle``,``offset`, and `len`. By validating the mapping translations
for these pages, the driver is telling the system not to intercept
accesses to these pages of the mapping. Furthermore, the system must not
allow accesses to proceed without notifying the device driver.

`devmap++_++load` must be called with the offset and the handle of the
mapping that generated the access event for the access to complete. If
`devmap++_++load(9F)` is not called on this handle, the mapping
translations are not validated, and the process receives a `SIGBUS`.

[[devmap_unload-entry-point]]
===== `devmap++_++unload` Entry Point

The syntax for `devmap++_++unload(9F)` is as follows:

[source,c]
----
int devmap_unload(devmap_cookie_t handle, offset_t offset, size_t len);
----

`devmap++_++unload`
invalidates the mapping translations for the pages of the mapping
specified by ++<++handle++>++, ++<++offset++>++, and ++<++len++>++. By
invalidating the mapping translations for these pages, the device driver
is telling the system to intercept accesses to these pages of the
mapping. Furthermore, the system must notify the device driver the next
time that these mapping pages are accessed by calling the
`devmap++_++access(9E)` entry point.

For both functions, requests affect the entire page that contains the
++<++offset++>++ and all pages up to and including the entire page that
contains the last byte, as indicated by ++<++offset++>++ {plus}
++<++len++>++. The device driver must ensure that for each page of
device memory being mapped, only one process has valid translations at
any one time.

Both functions return zero if successful. If, however, an error occurred
in validating or invalidating the mapping translations, that error is
returned to the device driver. The device driver must return this error
to the system.

[[power-management]]
=== Power Management

Power management provides the ability to control and manage the
electrical power usage of a computer system or device. Power management
enables systems to conserve energy by using less power when idle and by
shutting down completely when not in use. For example, desktop computer
systems can use a significant amount of power and often are left idle,
particularly at night. Power management software can detect that the
system is not being used. Accordingly, power management can power down
the system or some of its components.

This chapter provides information on the following subjects:

* link:#power-management-framework[Power Management Framework]
* link:#device-power-management-model[Device Power Management Model]
* link:#system-power-management-model[System Power Management Model]
* link:#power-management-device-access-example[Power Management Device Access Example]
* link:#power-management-flow-of-control[Power Management Flow of Control]

[[power-management-framework]]
=== Power Management Framework

device power management

definition of

The illumos Power Management framework depends on device drivers to
implement device-specific power management functions. The framework is
implemented in two parts:

* Device power management – Automatically turns off unused devices to
reduce power consumption
* System power management – Automatically turns off the computer when
the entire system is idle

[[device-power-management]]
==== Device Power Management

The framework enables devices to reduce
their energy consumption after a specified idle time interval. As part
of power management, system software checks for idle devices. The Power
Management framework exports interfaces that enable communication
between the system software and the device driver.

The illumos Power Management framework provides the following features
for device power management:

* A device-independent model for power-manageable devices.
* `dtpower(8)`, a tool for configuring workstation power management.
Power management can also be implemented through the `power.conf(5)` and
`/etc/default/power` files.
* A set of DDI interfaces for notifying the framework about power
management compatibility and idleness state.

[[system-power-management]]
==== System Power Management

System power management involves saving the state of the
system prior to powering the system down. Thus, the system can be
returned to the same state immediately when the system is turned back
on.

To shut down an entire system with return to the state prior to the
shutdown, take the following steps:

* Stop kernel threads and user processes. Restart these threads and
processes later.
* Save the hardware state of all devices on the system to disk. Restore
the state later.

[NOTE]

System power management is currently implemented only on some SPARC
systems supported by illumos. See the `power.conf(5)` man page for more
information.
===

The System Power Management framework in illumos provides the following
features for system power management:

* A platform-independent model of system idleness.
* `pmconfig(8)`, a tool for configuring workstation power management.
Power management can also be implemented through the `power.conf(5)` and
`/etc/default/power` files.
* A set of interfaces for the device driver to override the method for
determining which drivers have hardware state.
* A set of interfaces to enable the framework to call into the driver to
save and restore the device state.
* A mechanism for notifying processes that a resume operation has
occurred.

[[device-power-management-model]]
=== Device Power Management Model

The following sections describe the details of the
device power management model. This model includes the following
elements:

* Components
* Idleness
* Power levels
* Dependency
* Policy
* Device power management interfaces
* Power management entry points

[[power-management-components]]
==== Power Management Components

A device is power manageable if the power consumption of
the device can be reduced when the device is idle. Conceptually, a
power-manageable device consists of a number of power-manageable
hardware units that are called _components_.

The device driver notifies the system about device components and their
associated power levels. Accordingly, the driver creates a
`pm-components(9P)` property in the driver's `attach(9E)` entry point as
part of driver initialization.

Most devices that are power manageable implement only a single
component. An example of a single-component, power-manageable device is
a disk whose spindle motor can be stopped to save power when the disk is
idle.

If a device has multiple power-manageable units that are separately
controllable, the device should implement multiple components.

An example of a two-component, power-manageable device is a frame buffer
card with a monitor. Frame buffer electronics is the first component
++[++component 0++]++. The frame buffer's power consumption can be
reduced when not in use. The monitor is the second component
++[++component 1++]++. The monitor can also enter a lower power mode
when the monitor is not in use. The frame buffer electronics and monitor
are considered by the system as one device with two components.

[[multiple-power-management-components]]
===== Multiple Power Management Components

device power management

pm++_++raise++_++power

To the power management framework, all components are considered equal
and completely independent of each other. If the component states are
not completely compatible, the device driver must ensure that
undesirable state combinations do not occur. For example, a frame
buffer/monitor card has the following possible states: `D0`, `D1`, `D2`,
and `D3`. The monitor attached to the card has the following potential
states: `On`, `Standby`, `Suspend`, and `Off`. These states are not
necessarily compatible with each other. For example, if the monitor is
`On`, then the frame buffer must be at `D0`, that is, full on. If the
frame buffer driver gets a request to power up the monitor to `On` while
the frame buffer is at `D3`, the driver must call
`pm++_++raise++_++power(9F)` to bring the frame buffer up before setting
the monitor `On`. System requests to lower the power of the frame buffer
while the monitor is `On` must be refused by the driver.

[[power-management-states]]
==== Power Management States

device power management

pm++_++busy++_++component

device power management

pm++_++idle++_++component

Each component of a device can be in one of two states: _busy_ or
_idle_. The device driver notifies the framework of changes in the
device state by calling `pm++_++busy++_++component(9F)` and
`pm++_++idle++_++component(9F)`. When components are initially created,
the components are considered idle.

[[power-levels]]
==== Power Levels

device power management

power levels

From the `pm-components` property exported by the device, the Device
Power Management framework knows what power levels the device supports.
Power-level values must be positive integers. The interpretation of
power levels is determined by the device driver writer. Power levels
must be listed in monotonically increasing order in the `pm-components`
property. A power level of 0 is interpreted by the framework to mean
off. When the framework must power up a device due to a dependency, the
framework sets each component at its highest power level.

The following example shows a `pm-components` entry from the `.conf`
file of a driver that implements a single power-managed component
consisting of a disk spindle motor. The disk spindle motor is component
0. The spindle motor supports two power levels. These levels represent
“stopped” and “spinning at full speed.”

[[powermgt-ex-117]]
Sample `pm-component` Entry

....
pm-components="NAME=Spindle Motor", "0=Stopped", "1=Full Speed";
....

The following example shows how link:#powermgt-ex-117[example++_++title]
could be implemented in the `attach` routine of the driver.

[[powermgt-ex-118]]
`attach(9E)` Routine With `pm-components` Property

[source,c]
----
static char *pmcomps[] = {
    "NAME=Spindle Motor",
    "0=Stopped",
    "1=Full Speed"
};
/* ... */
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    /* ... */
    if (ddi_prop_update_string_array(DDI_DEV_T_NONE, dip,
        "pm-components", &pmcomp[0],
        sizeof (pmcomps) / sizeof (char *)) != DDI_PROP_SUCCESS)
        goto failed;
    /* ... */
----

The following example shows a frame buffer that implements two
components. Component 0 is the frame buffer electronics that support
four different power levels. Component 1 represents the state of power
management of the attached monitor.

[[powermgt-ex-119]]
Multiple Component `pm-components` Entry

....
pm-components="NAME=Frame Buffer", "0=Off", "1=Suspend", \
    "2=Standby", "3=On",
    "NAME=Monitor", "0=Off", "1=Suspend", "2=Standby", "3=On";
....

When a device driver is first attached,
the framework does not know the power level of the device. A power
transition can occur when:

* The driver calls `pm++_++raise++_++power(9F)` or
`pm++_++lower++_++power(9F)`.
* The framework has lowered the power level of a component because a
time threshold has been exceeded.
* Another device has changed power and a dependency exists between the
two devices. See link:#power-management-dependencies[Power Management Dependencies].

After a power transition, the framework begins tracking the power level
of each component of the device. Tracking also occurs if the driver has
informed the framework of the power level. The driver informs the
framework of a power level change by calling
`pm++_++power++_++has++_++changed(9F)`.

The system calculates a default threshold for each potential power
transition. These thresholds are based on the system idleness threshold.
The default thresholds can be overridden using `pmconfig` or
`power.conf(5)`. Another default threshold based on the system idleness
threshold is used when the component power level is unknown.

[[power-management-dependencies]]
==== Power Management Dependencies

device power management

Some devices should be powered down only when other devices are also
powered down. For example, if a CD-ROM drive is allowed to power down,
necessary functions, such as the ability to eject a CD, might be lost.

To prevent a device from powering down independently, you can make that
device dependent on another device that is likely to remain powered on.
Typically, a device is made dependent upon a frame buffer, because a
monitor is generally on whenever a user is utilizing a system.

The `power.conf(5)`file specifies the
dependencies among devices. (A parent node in the device tree implicitly
depends upon its children. This dependency is handled automatically by
the power management framework.) You can specify a particular dependency
with a `power.conf(5)` entry of this form:

....
device-dependency dependent-phys-path phys-path
....

Where ++<++dependent-phys-path++>++ is the device that
is kept powered up, such as the CD-ROM drive. ++<++phys-path++>++
represents the device whose power state is to be depended on, such as
the frame buffer.

Adding an entry to `power.conf` for every new device
that is plugged into the system would be burdensome. The following
syntax enables you to indicate dependency in a more general fashion:

....
device-dependency-property property phys-path
....

Such an entry mandates that any device
that exports the property ++<++property++>++ must be dependent upon the
device named by ++<++phys-path++>++. Because this dependency applies
especially to removable-media devices, `/etc/power.conf` includes the
following line by default:

....
device_dependent-property  removable-media  /dev/fb
....

With this syntax, no device that exports the removable-media property
can be powered down unless the console frame buffer is also powered
down.

For more information, see the `power.conf(5)` and `removable-media(9P)`
man pages.

[[automatic-power-management-for-devices]]
==== Automatic Power Management for Devices

If automatic power management is enabled by `pmconfig` or
`power.conf(5)`, then all devices with a `pm-components(9P)` property
automatically will use power management. After a component has been idle
for a default period, the component is automatically lowered to the next
lowest power level. The default period is calculated by the power
management framework to set the entire device to its lowest power state
within the system idleness threshold.

[NOTE]

By default, automatic power management is enabled on all SPARC desktop
systems first shipped after July 1, 1999. This feature is disabled by
default for all other systems. To determine whether automatic power
management is enabled on your machine, refer to the `power.conf(5)` man
page for instructions.
===

`power.conf(5)` can be used to override the defaults calculated by the
framework.

[[device-power-management-interfaces]]
==== Device Power Management Interfaces

A device driver that supports a device with
power-manageable components must create a `pm-components(9P)` property.
This property indicates to the system that the device has
power-manageable components. `pm-components` also tells the system which
power levels are available. The driver typically informs the system by
calling `ddi++_++prop++_++update++_++string++_++array(9F)` from the
driver's `attach(9E)` entry point. An alternative means of informing the
system is from a `driver.conf(5)` file. See the `pm-components(9P)` man
page for details.

[[busy-idle-state-transitions]]
===== Busy-Idle State Transitions

The driver must keep the framework informed of device
state transitions from idle to busy or busy to idle. Where these
transitions happen is entirely device-specific. The transitions between
the busy and idle states depend on the nature of the device and the
abstraction represented by the specific component. For example, SCSI
disk target drivers typically export a single component, which
represents whether the SCSI target disk drive is spun up or not. The
component is marked busy whenever an outstanding request to the drive
exists. The component is marked idle when the last queued request
finishes. Some components are created and never marked busy. For
example, components created by `pm-components(9P)` are created in an
idle state.

The `pm++_++busy++_++component(9F)` and `pm++_++idle++_++component(9F)`
interfaces notify the power management framework of busy-idle state
transitions. The `pm++_++busy++_++component(9F)` call has the following
syntax:

[source,c]
----
int pm_busy_component(dev_info_t *dip, int component);
----

`pm++_++busy++_++component(9F)` marks ++<++component++>++ as busy. While
the component is busy, that component should not be powered off. If the
component is already powered off, then marking that component busy does
not change the power level. The driver needs to call
`pm++_++raise++_++power(9F)` for this purpose. Calls to
`pm++_++busy++_++component(9F)` are cumulative and require a
corresponding number of calls to `pm++_++idle++_++component(9F)` to idle
the component.

The `pm++_++idle++_++component(9F)` routine has the following syntax:

[source,c]
----
int pm_idle_component(dev_info_t *dip, int component);
----

 `pm++_++idle++_++component(9F)` marks ++<++component++>++
as idle. An idle component is subject to being powered off.
`pm++_++idle++_++component(9F)` must be called once for each call to
`pm++_++busy++_++component(9F)` in order to idle the component.

[[device-power-state-transitions]]
===== Device Power State Transitions

   A device driver can call
`pm++_++raise++_++power(9F)` to request that a component be set to at
least a given power level. Setting the power level in this manner is
necessary before using a component that has been powered off. For
example, the `read(9E)` routine of a SCSI disk target driver might need
to spin up the disk, if the disk has been powered off. The
`pm++_++raise++_++power(9F)` function requests the power management
framework to initiate a device power state transition to a higher power
level. Normally, reductions in component power levels are initiated by
the framework. However, a device driver should call
`pm++_++lower++_++power(9F)` when detaching, in order to reduce the
power consumption of unused devices as much as possible.

Powering down can pose risks for some devices. For example, some tape
drives damage tapes when power is removed. Similarly, some disk drives
have a limited tolerance for power cycles, because each cycle results in
a head landing. Use the `no-involuntary-power-cycles(9P)` property to
notify the system that the device driver should control all power cycles
for the device. This approach prevents power from being removed from a
device while the device driver is detached unless the device was powered
off by a driver's call to `pm++_++lower++_++power(9F)` from its
`detach(9E)` entry point.

The `pm++_++raise++_++power(9F)` function is called when the driver
discovers that a component needed for some operation is at an
insufficient power level. This interface causes the driver to raise the
current power level of the component to the needed level. All the
devices that depend on this device are also brought back to full power
by this call.

Call the `pm++_++lower++_++power(9F)` function when the device is
detaching once access to the device is no longer needed. Call
`pm++_++lower++_++power(9F)` to set each component at the lowest power
so that the device uses as little power as possible while not in use.
The `pm++_++lower++_++power` function must be called from the `detach`
entry point. The `pm++_++lower++_++power` function has no effect if it
is called from any other part of the driver.

The `pm++_++power++_++has++_++changed(9F)` function is called to notify
the framework about a power transition. The transition might be due to
the device changing its own power level. The transition might also be
due to an operation such as suspend-resume. The syntax for
`pm++_++power++_++has++_++changed(9F)` is the same as the syntax for
`pm++_++raise++_++power(9F)`.

[[power-entry-point]]
==== `power` Entry Point

   The power management
framework uses the `power(9E)` entry point.

`power` uses the following syntax:

[source,c]
----
int power(dev_info_t *dip, int component, int level);
----

When a component's power level needs to be changed, the system calls the
`power(9E)` entry point. The action taken by this entry point is device
driver-specific. In the example of the SCSI target disk driver mentioned
previously, setting the power level to 0 results in sending a SCSI
command to spin down the disk, while setting the power level to the full
power level results in sending a SCSI command to spin up the disk.

If a power transition can cause the device to lose state, the driver
must save any necessary state in memory for later restoration. If a
power transition requires the saved state to be restored before the
device can be used again, then the driver must restore that state. The
framework makes no assumptions about what power transactions cause the
loss of state or require the restoration of state for automatically
power-managed devices. The following example shows a sample `power`
routine.

[[powermgt-ex-131]]
Using the `power` Routine for a Single-Component Device

[source,c]
----
xxpower(dev_info_t *dip, int component, int level)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Make sure the request is valid
     */
    if (!xx_valid_power_level(component, level))
        return (DDI_FAILURE);
    mutex_enter(&xsp->mu);
    /*
     * If the device is busy, don't lower its power level
     */
    if (xsp->xx_busy[component] &&
        xsp->xx_power_level[component] > level) {
        mutex_exit(&xsp->mu);
        return (DDI_FAILURE);
    }

    if (xsp->xx_power_level[component] != level) {
        /*
         * device- and component-specific setting of power level
         * goes here
         */
        xsp->xx_power_level[component] = level;
    }
    mutex_exit(&xsp->mu);
    return (DDI_SUCCESS);
}
----

The following example is a `power` routine for a device with two
components, where component 0 must be on when component 1 is on.

[[powermgt-ex-132]]
`power(9E)` Routine for Multiple-Component Device

[source,c]
----
xxpower(dev_info_t *dip, int component, int level)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Make sure the request is valid
     */
    if (!xx_valid_power_level(component, level))
        return (DDI_FAILURE);
    mutex_enter(&xsp->mu);
    /*
     * If the device is busy, don't lower its power level
     */
    if (xsp->xx_busy[component] &&
        xsp->xx_power_level[component] > level) {
        mutex_exit(&xsp->mu);
        return (DDI_FAILURE);
    }
    /*
     * This code implements inter-component dependencies:
     * If we are bringing up component 1 and component 0 
     * is off, we must bring component 0 up first, and if
     * we are asked to shut down component 0 while component
     * 1 is up we must refuse
     */
    if (component == 1 && level > 0 && xsp->xx_power_level[0] == 0) {
        xsp->xx_busy[0]++;
        if (pm_busy_component(dip, 0) != DDI_SUCCESS) {
            /*
             * This can only happen if the args to 
             * pm_busy_component()
             * are wrong, or pm-components property was not
             * exported by the driver.
             */
            xsp->xx_busy[0]--;
            mutex_exit(&xsp->mu);
            cmn_err(CE_WARN, "xxpower pm_busy_component() 
                failed");
            return (DDI_FAILURE);
        }
        mutex_exit(&xsp->mu);
        if (pm_raise_power(dip, 0, XX_FULL_POWER_0) != DDI_SUCCESS)
            return (DDI_FAILURE);
        mutex_enter(&xsp->mu);
    }
    if (component == 0 && level == 0 && xsp->xx_power_level[1] != 0) {
        mutex_exit(&xsp->mu);
        return (DDI_FAILURE);
    }
    if (xsp->xx_power_level[component] != level) {
        /*
         * device- and component-specific setting of power level
         * goes here
         */
        xsp->xx_power_level[component] = level;
    }
    mutex_exit(&xsp->mu);
    return (DDI_SUCCESS);
}
----

[[system-power-management-model]]
=== System Power Management Model

This section describes the details of the System Power
Management model. The model includes the following components:

* Autoshutdown threshold
* Busy state
* Hardware state
* Policy
* Power management entry points

[[autoshutdown-threshold]]
==== Autoshutdown Threshold

The system can be shut down, that is, powered off,
automatically after a configurable period of idleness. This period is
known as the _autoshutdown threshold_. This behavior is enabled by
default for SPARC desktop systems first shipped after October 1, 1995
and before July 1, 1999. See the `power.conf(5)`man page for more
information. Autoshutdown can be overridden using `dtpower(8)` or
`power.conf(5)`.

[[busy-state]]
==== Busy State

The busy state of the system can be measured in several ways. The
currently supported built-in metric items are keyboard characters, mouse
activity, `tty` characters, load average, disk reads, and NFS requests.
Any one of these items can make the system busy. In addition to the
built-in metrics, an interface is defined for running a user-specified
process that can indicate that the system is busy.

[[hardware-state]]
==== Hardware State

Devices that export a `reg` property are
considered to have hardware state that must be saved prior to shutting
down the system. A device without the `reg` property is considered to be
stateless. However, this consideration can be overridden by the device
driver.

A device with hardware state
but no `reg` property, such as a SCSI driver, must be called to save and
restore the state if the driver exports a `pm-hardware-state` property
with the value `needs-suspend-resume`. Otherwise, the lack of a `reg`
property is taken to mean that the device has no hardware state. For
information on device properties, see link:#properties[Properties].

A device with a `reg` property and no hardware state can export a
`pm-hardware-state` property with the value `no-suspend-resume`. Using
`no-suspend-resume` with the `pm-hardware-state` property keeps the
framework from calling the driver to save and restore that state. For
more information on power management properties, see the
`pm-components(9P)` man page.

[[automatic-power-management-for-systems]]
==== Automatic Power Management for Systems

The system is shut down if the following conditions
apply:

* Autoshutdown is enabled by `dtpower(8)` or `power.conf(5)`.
* The system has been idle for _autoshutdown threshold_ minutes.
* All of the metrics that are specified in `power.conf` have been
satisfied.

[[entry-points-used-by-system-power-management]]
==== Entry Points Used by System Power Management

System power management passes the command
`DDI++_++SUSPEND` to the `detach(9E)` driver entry point to request the
driver to save the device hardware state. System power management passes
the command `DDI++_++RESUME` to the `attach(9E)` driver entry point to
request the driver to restore the device hardware state.

[[detach-entry-point]]
[[detach-entry-point-1]]
===== `detach` Entry Point

The syntax for `detach(9E)` is as follows:

[source,c]
----
int detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
----

A device with a reg property or a pm-hardware-state
property set to `needs-suspend-resume` must be able to save the hardware
state of the device. The framework calls into the driver's `detach(9E)`
entry point to enable the driver to save the state for restoration after
the system power returns. To process the `DDI++_++SUSPEND` command,
`detach(9E)` must perform the following tasks:

* Block further operations from being initiated until the device is
resumed, except for `dump(9E)` requests.
* Wait until outstanding operations have completed. If an outstanding
operation can be restarted, you can abort that operation.
* Cancel any timeouts and callbacks that are pending.
* Save any volatile hardware state to memory. The state includes the
contents of device registers, and can also include downloaded firmware.

If the driver is unable to suspend the device and save its state to
memory, then the driver must return `DDI++_++FAILURE`. The framework
then aborts the system power management operation.

In some cases, powering down a device
involves certain risks. For example, if a tape drive is powered off with
a tape inside, the tape can be damaged. In such a case, `attach(9E)`
should do the following:

* Call `ddi++_++removing++_++power(9F)` to determine whether a
`DDI++_++SUSPEND` command can cause power to be removed from the device.
* Determine whether power removal can cause problems.

If both cases are true, the `DDI++_++SUSPEND` request should be
rejected. link:#powermgt-ex-140[example++_++title] shows an `attach(9E)`
routine using `ddi++_++removing++_++power(9F)` to check whether the
`DDI++_++SUSPEND` command causes problems.

Dump requests must be honored. The framework uses the `dump(9E)` entry
point to write out the state file that contains the contents of memory.
See the `dump(9E)` man page for the restrictions that are imposed on the
device driver when using this entry point.

Calling the `detach(9E)` entry point of a power-manageable component
with the `DDI++_++SUSPEND` command should save the state when the device
is powered off. The driver should cancel pending timeouts. The driver
should also suppress any calls to `pm++_++raise++_++power(9F)` except
for `dump(9E)` requests. When the device is resumed by a call to
`attach(9E)` with a command of `DDI++_++RESUME`, timeouts and calls to
`pm++_++raise++_++power` can be resumed. The driver must keep sufficient
track of its state to be able to deal appropriately with this
possibility. The following example shows a `detach(9E)` routine with the
`DDI++_++SUSPEND` command implemented.

[[powermgt-ex-140]]
`detach(9E)` Routine Implementing `DDI++_++SUSPEND`

[source,c]
----
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);

    switch (cmd) {
    case DDI_DETACH:
        /* ... */
    case DDI_SUSPEND:
        /*
         * We do not allow DDI_SUSPEND if power will be removed and
         * we have a device that damages tape when power is removed
         * We do support DDI_SUSPEND for Device Reconfiguration.
         */
        if (ddi_removing_power(dip) && xxdamages_tape(dip))
            return (DDI_FAILURE);
        mutex_enter(&xsp->mu);
        xsp->xx_suspended = 1;  /* stop new operations */
        /*
         * Sleep waiting for all the commands to be completed
         *
         * If a callback is outstanding which cannot be cancelled
         * then either wait for the callback to complete or fail the
         * suspend request
         *
         * This section is only needed if the driver maintains a
         * running timeout
         */
        if (xsp->xx_timeout_id) {
            timeout_id_t temp_timeout_id = xsp->xx_timeout_id;
            xsp->xx_timeout_id = 0;
            mutex_exit(&xsp->mu);
            untimeout(temp_timeout_id);
            mutex_enter(&xsp->mu);
        }
        if (!xsp->xx_state_saved) {
            /*
             * Save device register contents into
             * xsp->xx_device_state
             */
        }
        mutex_exit(&xsp->mu);
        return (DDI_SUCCESS);
    default:
        return (DDI_FAILURE);
}
----

[[attach-entry-point]]
[[attach-entry-point-1]]
===== `attach` Entry Point

The syntax for `attach(9E)` is as follows:

[source,c]
----
int attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
----

When power is restored to the system, each device with a
`reg` property or with a `pm-hardware-state` property of value
`needs-suspend-resume` has its `attach(9E)` entry point called with a
command value of `DDI++_++RESUME`. If the system shutdown is aborted,
each suspended driver is called to resume even though the power has not
been shut off. Consequently, the resume code in `attach(9E)` must make
no assumptions about whether the system actually lost power.

The power management framework considers the power level of the
components to be unknown at `DDI++_++RESUME` time. Depending on the
nature of the device, the driver writer has two choices:

* If the driver can determine the actual power level of the components
of the device without powering the components up, such as by reading a
register, then the driver should notify the framework of the power level
of each component by calling `pm++_++power++_++has++_++changed(9F)`.
* If the driver cannot determine the power levels of the components,
then the driver should mark each component internally as unknown and
call `pm++_++raise++_++power(9F)` before the first access to each
component.

The following example shows an `attach(9E)` routine with the
`DDI++_++RESUME` command.

[[powermgt-ex-142]]
`attach(9E)` Routine Implementing `DDI++_++RESUME`

[source,c]
----
xxattach(devinfo_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate *xsp;
    int    instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);

    switch (cmd) {
    case DDI_ATTACH:
    /* ... */
    case DDI_RESUME:
        mutex_enter(&xsp->mu);
        if (xsp->xx_pm_state_saved) {
            /*
             * Restore device register contents from
             * xsp->xx_device_state
             */
        }
        /*
         * This section is optional and only needed if the
         * driver maintains a running timeout
         */
        xsp->xx_timeout_id = timeout( /* ... */ );

        xsp->xx_suspended = 0;        /* allow new operations */
        cv_broadcast(&xsp->xx_suspend_cv);
        /* If it is possible to determine in a device-specific 
         * way what the power levels of components are without 
         * powering the components up,
         * then the following code is recommended
         */
        for (i = 0; i < num_components; i++) {
            xsp->xx_power_level[i] = xx_get_power_level(dip, i);
            if (xsp->xx_power_level[i] != XX_LEVEL_UNKNOWN)
                (void) pm_power_has_changed(dip, i, 
                    xsp->xx_power_level[i]);
        }
        mutex_exit(&xsp->mu);
        return(DDI_SUCCESS);
    default:
        return(DDI_FAILURE);
    }
}
----

[NOTE]

The `detach(9E)` and `attach(9E)` interfaces can also be used to resume
a system that has been quiesced.
===

[[power-management-device-access-example]]
=== Power Management Device Access Example

If power management is supported, and `detach(9E)` and `attach(9E)` are
used as in link:#powermgt-ex-140[example++_++title] and
link:#powermgt-ex-142[example++_++title], then access to the device can
be made from user context, for example, from `read(2)`, `write(2)`, and
`ioctl(2)`.

The following example demonstrates this approach. The example assumes
that the operation about to be performed requires a component
`component` that is operating at power level `level`.

[[powermgt-ex-143]]
Device Access

[source,c]
----
mutex_enter(&xsp->mu);
/*
 * Block command while device is suspended by DDI_SUSPEND
 */
while (xsp->xx_suspended)
    cv_wait(&xsp->xx_suspend_cv, &xsp->mu);
/*
 * Mark component busy so xx_power() will reject attempt to lower power
 */
xsp->xx_busy[component]++;
if (pm_busy_component(dip, component) != DDI_SUCCESS) {
    xsp->xx_busy[component]--;
    /*
     * Log error and abort
     */
}
if (xsp->xx_power_level[component] < level) {
    mutex_exit(&xsp->mu);
    if (pm_raise_power(dip, component, level) != DDI_SUCCESS) {
        /*
         * Log error and abort
         */
    }
    mutex_enter(&xsp->mu);
}
----

The code fragment in the following example can be used when device
operation completes, for example, in the device's interrupt handler.

[[powermgt-ex-147]]
Device Operation Completion

[source,c]
----
/*
 * For each command completion, decrement the busy count and unstack
 * the pm_busy_component() call by calling pm_idle_component(). This
 * will allow device power to be lowered when all commands complete
 * (all pm_busy_component() counts are unstacked)
 */
xsp->xx_busy[component]--;
if (pm_idle_component(dip, component) != DDI_SUCCESS) {
    xsp->xx_busy[component]++;
    /*
     * Log error and abort
     */
}
/*
 * If no more outstanding commands, wake up anyone (like DDI_SUSPEND)
 * waiting for all commands to  be completed
 */
----

[[power-management-flow-of-control]]
=== Power Management Flow of Control

  link:#powermgt-fig-145[Power Management
Conceptual State Diagram] illustrates the flow of control in the power
management framework.

When a component's activity is complete, a driver can call
`pm++_++idle++_++component(9F)` to mark the component as idle. When the
component has been idle for its threshold time, the framework can lower
the power of the component to its next lower level. The framework calls
the `power(9E)` function to set the component's power to the next lower
supported power level, if a lower level exists. The driver's `power(9E)`
function should reject any attempt to lower the power level of a
component when that component is busy. The `power(9E)` function should
save any state that could be lost in a transition to a lower level prior
to making that transition.

When the component is needed at a higher level, the driver calls
`pm++_++busy++_++component(9F)`. This call keeps the framework from
lowering the power still further and then calls
`pm++_++raise++_++power(9F)` on the component. The framework next calls
`power(9E)` to raise the power of the component before the call to
`pm++_++raise++_++power(9F)` returns. The driver's `power(9E)` code must
restore any state that was lost in the lower level but that is needed in
the higher level.

When a driver is detaching, the driver should call
`pm++_++lower++_++power(9F)` for each component to lower its power to
its lowest level. The framework can then call the driver's `power(9E)`
routine to lower the power of the component before the call to
`pm++_++lower++_++power(9F)` returns.

.Power Management Conceptual State Diagram
[#powermgt-fig-145]
image::figures/powermgt-concept.png[Diagram shows the flow of control through power management routines.]

[[changes-to-power-management-interfaces]]
=== Changes to Power Management Interfaces

Prior to the Solaris 8 release, power management of devices was not
automatic. Developers had to add an entry to `/etc/power.conf` for each
device that was to be power-managed. The framework assumed that all
devices supported only two power levels: 0 and standard power.

Power assumed an implied dependency of all other components on component
0. When component 0 changed to level 0, a call was made into the
driver's `detach`(9E) with the `DDI++_++PM++_++SUSPEND` command to save
the hardware state. When component 0 changed from level 0, a call was
made to the `attach`(9E) routine with the command
`DDI++_++PM++_++RESUME` to restore hardware state.

The following interfaces and commands are obsolete, although they are
still supported for binary purposes:

* `ddi++_++dev++_++is++_++needed(9F)`
* `pm++_++create++_++components(9F)`
* `pm++_++destroy++_++components(9F)`
* `pm++_++get++_++normal++_++power(9F)`
* `pm++_++set++_++normal++_++power(9F)`
* `DDI++_++PM++_++SUSPEND`
* `DDI++_++PM++_++RESUME`

Since the Solaris 8 release, devices that export the `pm-components`
property automatically use power management if `autopm` is enabled.

The framework now knows from the `pm-components` property which power
levels are supported by each device.

The framework makes no assumptions about dependencies among the
different components of a device. The device driver is responsible for
saving and restoring hardware state as needed when changing power
levels.

These changes enable the power management framework to deal with
emerging device technology. Power management now results in greater
power savings. The framework can detect automatically which devices can
save power. The framework can use intermediate power states of the
devices. A system can now meet energy consumption goals without powering
down the entire system and without any functions.

.Power Management Interfaces
[width="100%",cols="50%,50%",options="header",]
|===
|Removed Interfaces |Equivalent Interfaces
|`pm++_++create++_++components`(9F) |`pm-components(9P)`
|`pm++_++set++_++normal++_++power`(9F) |`pm-components(9P)`
|`pm++_++destroy++_++components`(9F) |None
|`pm++_++get++_++normal++_++power`(9F) |None
|`ddi++_++dev++_++is++_++needed`(9F) |`pm++_++raise++_++power(9F)`
|None |`pm++_++lower++_++power(9F)`
|None |`pm++_++power++_++has++_++changed(9F)`
|DDI++_++PM++_++SUSPEND |None
|DDI++_++PM++_++RESUME |None
|===

[[hardening-illumos-drivers]]
=== Hardening illumos Drivers

Management Architecture (FMA) I/O Fault Services enable driver
developers to integrate fault management capabilities into I/O device
drivers. The illumos I/O fault services framework defines a set of
interfaces that enable all drivers to coordinate and perform basic error
handling tasks and activities. The illumos FMA as a whole provides for
error handling and fault diagnosis, in addition to response and
recovery. FMA is a component of illumos's Predictive Self-Healing
strategy.

A driver is considered hardened when it uses the defensive programming
practices described in this document in addition to the I/O fault
services framework for error handling and diagnosis. The driver
hardening test harness tests that the I/O fault services and defensive
programming requirements have been correctly fulfilled.

* link:#illumos-fault-management-architecture-io-fault-services[illumos Fault Management Architecture I/O Fault
Services] provides a reference for driver developers who want to
integrate fault management capabilities into I/O device drivers.
* link:#defensive-programming-techniques-for-illumos-device-drivers[Defensive Programming Techniques for
illumos Device Drivers] provides general information about how to
defensively write an illumos device driver.
* link:#driver-hardening-test-harness[Driver Hardening Test Harness] is a driver development
tool that injects simulated hardware faults when the driver under
development accesses its hardware.

[[illumos-fault-management-architecture-io-fault-services]]
=== illumos Fault Management Architecture I/O Fault Services

This section explains how to integrate fault management error reporting,
error handling, and diagnosis for I/O device drivers. This section
provides an in-depth examination of the I/O fault services framework and
how to utilize the I/O fault service APIs within a device driver.

* link:#what-is-predictive-self-healing[What Is Predictive Self-Healing?] provides background and
an overview of the illumos Fault Management Architecture.
* link:#illumos-fault-manager[illumos Fault Manager] describes additional background
with a focus on a high-level overview of the illumos Fault Manager,
`fmd(8)`.
* link:#error-handling[Error Handling] is the primary section for driver
developers. This section highlights the best practice coding techniques
for high-availability and the use of I/O fault services in driver code
to interact with the FMA.
* link:#diagnosing-faults[Diagnosing Faults] describes how faults are diagnosed from
the errors detected by drivers.
* link:#event-registry[Event Registry] provides information on illumos's Event
Registry.

[[what-is-predictive-self-healing]]
==== What Is Predictive Self-Healing?

Predictive Self-Healing

fault management

fault management

ereport event

fault management

ereport events

diagnosis engine

fault management

diagnosis engine

fault event

fault management

fault event

fault management

Traditionally, systems have exported hardware and software error
information directly to human administrators and to management software
in the form of syslog messages. Often, error detection, diagnosis,
reporting, and handling was embedded in the code of each driver.

A system like the illumos OS predictive self-healing system is first and
foremost self-diagnosing. Self-diagnosing means the system provides
technology to automatically diagnose problems from observed symptoms,
and the results of the diagnosis can then be used to trigger automated
response and recovery. A _fault_ in hardware or a defect in software can
be associated with a set of possible observed symptoms called _errors_.
The data generated by the system as the result of observing an error is
called an error report or _ereport_.

In a system capable of self-healing, ereports are captured by the system
and are encoded as a set of name-value pairs described by an extensible
event protocol to form an _ereport event_. Ereport events and other data
are gathered to facilitate self-healing, and are dispatched to software
components called diagnosis engines designed to diagnose the underlying
problems corresponding to the error symptoms observed by the system. A
_diagnosis engine_ runs in the background and silently consumes error
telemetry until it can produce a diagnosis or predict a fault.

After processing sufficient telemetry to reach a conclusion, a diagnosis
engine produces another event called a _fault event_. The fault event is
then broadcast to all agents that are interested in the specific fault
event. An _agent_ is a software component that initiates recovery and
responds to specific fault events. A software component known as the
illumos Fault Manager, `fmd(8)`, manages the multiplexing of events
between ereport generators, diagnosis engines, and agent software.

[[illumos-fault-manager]]
==== illumos Fault Manager

fault manager daemon

fault management

fault manager daemon

The illumos Fault Manager, `fmd(8)`, is responsible for dispatching
in-bound error telemetry events to the appropriate diagnosis engines.
The diagnosis engine is responsible for identifying the underlying
hardware faults or software defects that are producing the error
symptoms. The `fmd`(1M) daemon is the illumos implementation of a fault
manager. It starts at boot time and loads all of the diagnosis engines
and agents available on the system. The illumos Fault Manager also
provides interfaces for system administrators and service personnel to
observe fault management activity.

[[diagnosis-suspect-lists-and-fault-events]]
===== Diagnosis, Suspect Lists, and Fault Events

list suspect

fault management

list suspect

suspect list

fault management

suspect list

Once a diagnosis has been made, the diagnosis is output in the form of a
_list.suspect_ event. A list.suspect event is an event comprised of one
or more possible fault or defect events. Sometimes the diagnosis cannot
narrow the cause of errors to a single fault or defect. For example, the
underlying problem might be a broken wire connecting controllers to the
main system bus. The problem might be with a component on the bus or
with the bus itself. In this specific case, the list.suspect event will
contain multiple fault events: one for each controller attached to the
bus, and one for the bus itself.

* The _resource_ is the component that was diagnosed as faulty. The
`fmdump(8)` command shows this payload member as “Problem in.”
* The _Automated System Recovery Unit_ (ASRU) is the hardware or
software component that must be disabled to prevent further error
symptoms from occurring. The `fmdump`(1M) command shows this payload
member as “Affects.”
* The _Field Replaceable Unit_ (FRU) is the component that must be
replaced or repaired to fix the underlying problem.
* The _Label_ payload is a string that gives the location of the FRU in
the same form as it is printed on the chassis or motherboard, for
example next to a DIMM slot or PCI card slot. The `fmdump` command shows
this payload member as “Location.”

For example, after receiving a certain number of ECC correctable errors
in a given amount of time for a particular memory location, the CPU and
memory diagnosis engine issues a diagnosis (list.suspect event) for a
faulty DIMM.

....
# fmdump -v -u 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c
TIME                 UUID                                 SUNW-MSG-ID
Oct 31 13:40:18.1864 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c AMD-8000-8L
100%  fault.cpu.amd.icachetag

Problem in: hc:///motherboard=0/chip=0/cpu=0
Affects: cpu:///cpuid=0
FRU: hc:///motherboard=0/chip=0
Location: SLOT 2
....

In this example, `fmd(8)` has identified a problem in a resource,
specifically a CPU (`hc:///motherboard=0/chip=0/cpu=0`). To suppress
further error symptoms and to prevent an uncorrectable error from
occurring, an ASRU, (`cpu:///cpuid=0`), is identified for retirement.
The component that needs to be replaced is the FRU
(`hc:///motherboard=0/chip=0`).

[[response-agents]]
===== Response Agents

fault management

fault management

response agent

retire agent

fault management

retire agent

An agent is a software component that takes action in response to a
diagnosis or repair. For example, the CPU and memory retire agent is
designed to act on list.suspects that contain a fault.cpu.++*++ event.
The `cpumem-retire` agent will attempt to off-line a CPU or retire a
physical memory page from service. If the agent is successful, an entry
in the fault manager's ASRU cache is added for the page or CPU that was
successfully retired. The `fmadm(8)` utility, as shown in the example
below, shows an entry for a memory rank that has been diagnosed as
having a fault. ASRUs that the system does not have the ability to
off-line, retire, or disable, will also have an entry in the ASRU cache,
but they will be seen as degraded. Degraded means the resource
associated with the ASRU is faulty, but the ASRU is unable to be removed
from service. Currently illumos agent software cannot act upon I/O ASRUs
(device instances). All faulty I/O resource entries in the cache are in
the degraded state.

....
# fmadm faulty
   STATE RESOURCE / UUID
-------- ----------------------------------------------------------------------
degraded mem:///motherboard=0/chip=1/memory-controller=0/dimm=3/rank=0
         ccae89df-2217-4f5c-add4-d920f78b4faf
-------- ----------------------------------------------------------------------
....

The primary purpose of a _retire agent_ is to isolate (safely remove
from service) the piece of hardware or software that has been diagnosed
as faulty.

* Send alerts via SNMP traps. This can translate a diagnosis into an
alert for SNMP that plugs into existing software mechanisms.
* Post a syslog message. Message specific diagnoses (for example, syslog
message agent) can take the result of a diagnosis and translate it into
a syslog message that administrators can use to take a specific action.
* Other agent actions such as update the FRUID. Response agents can be
platform-specific.

[[message-ids-and-dictionary-files]]
===== Message IDs and Dictionary Files

fault management

fault messages

fault management

list suspect

The syslog message agent takes the output of the diagnosis (the
list.suspect event) and writes specific messages to the console or
`/var/adm/messages`. Often console messages can be difficult to
understand. FMA remedies this problem by providing a defined fault
message structure that is generated every time a list.suspect event is
delivered to a syslog message.

syslog agent generates a message identifier (MSG ID). The event registry
generates dictionary files (`.dict` files) that map a list.suspect event
to a structured message identifier that should be used to identify and
view the associated knowledge article. Message files, (`.po` files) map
the message ID to localized messages for every possible list of
suspected faults that the diagnosis engine can generate. The following
is an example of a fault message emitted on a test system.

....
SUNW-MSG-ID: AMD-8000-7U, TYPE: Fault, VER: 1, SEVERITY: Major
EVENT-TIME: Fri Jul 28 04:26:51 PDT 2006
PLATFORM: Sun Fire V40z, CSN: XG051535088, HOSTNAME: parity
SOURCE: eft, REV: 1.16
EVENT-ID: add96f65-5473-69e6-dbe1-8b3d00d5c47b
DESC: The number of errors associated with this CPU has exceeded 
acceptable levels. Refer to http://sun.com/msg/AMD-8000-7U for 
more information.
AUTO-RESPONSE: An attempt will be made to remove this CPU from service.
IMPACT: Performance of this system may be affected.
REC-ACTION: Schedule a repair procedure to replace the affected CPU. 
Use fmdump -v -u <EVENT_ID> to identify the module.
....

[[system-topology]]
===== System Topology

fault management

topology of system

fault management

fault event

To identify where a fault might have occurred, diagnosis engines need to
have the topology for a given software or hardware system represented.
The `fmd(8)` daemon provides diagnosis engines with a handle to a
topology snapshot that can be used during diagnosis. Topology
information is used to represent the resource, ASRU, and FRU found in
each fault event. The topology can also be used to store the platform
label, FRUID, and serial number identification.

The resource payload member in the fault event is always represented by
the physical path location from the platform chassis outward. For
example, a PCI controller function that is bridged from the main system
bus to a PCI local bus is represented by its `hc` scheme path name:

....
hc:///motherboard=0/hostbridge=1/pcibus=0/pcidev=13/pcifn=0
....

The ASRU payload member in the fault event is typically represented by
the illumos device tree instance name that is bound to a hardware
controller, device, or function. FMA uses the `dev` scheme to represent
the ASRU in its native format for actions that might be taken by a
future implementation of a retire agent specifically designed for I/O
devices:

....
dev:////pci@1e,600000/ide@d
....

The FRU payload representation in the fault event varies depending on
the closest replaceable component to the I/O resource that has been
diagnosed as faulty. For example, a fault event for a broken embedded
PCI controller might name the motherboard of the system as the FRU that
needs to be replaced:

....
hc:///motherboard=0
....

The label payload is a string that gives the location of the FRU in the
same form as it is printed on the chassis or motherboard, for example
next to a DIMM slot or PCI card slot:

....
Label: SLOT 2
....

[[error-handling]]
==== Error Handling

fault management

error handling

This section describes how to use I/O fault services APIs to handle
errors within a driver. This section discusses how drivers should
indicate and initialize their fault management capabilities, generate
error reports, and register the driver's error handler routine.

Excerpts are provided from source code examples that
demonstrate the use of the I/O fault services API from the Broadcom 1Gb
NIC driver, `bge`. Follow these examples as a model for how to integrate
fault management capability into your own drivers. Take the following
steps to study the complete `bge` driver code:

* Go to the http://src.illumos.org/[illumos source browser].
* Enter `bge` in the File Path field.
* Select illumos-gate in the project(s) listing.
* Click the Search button.

Drivers that have been instrumented to provide FMA error report
telemetry detect errors and determine the impact of those errors on the
services provided by the driver. Following the detection of an error,
the driver should determine when its services have been impacted and to
what degree.

* Attempt recovery
* Retry an I/O transaction
* Attempt fail-over techniques
* Report the error to the calling application/stack
* If the error cannot be constrained any other way, then panic

Errors detected by the driver are communicated to the
fault management daemon as an _ereport_. An ereport is a structured
event defined by the FMA event protocol. The event protocol is a
specification for a set of common data fields that must be used to
describe all possible error and fault events, in addition to the list of
suspected faults. Ereports are gathered into a flow of error telemetry
and dispatched to the diagnosis engine.

[[declaring-fault-management-capabilities]]
===== Declaring Fault Management Capabilities

fault management

fault management capabilities, declaring

ddi++_++fm++_++init

fault management

ddi++_++fm++_++init

A hardened device driver must declare its fault management capabilities
to the I/O Fault Management framework. Use the ddi++_++fm++_++init(9F)
function to declare the fault management capabilities of your driver.

[source,c]
----
void ddi_fm_init(dev_info_t *dip, int *fmcap, ddi_iblock_cookie_t *ibcp)
----

The `ddi++_++fm++_++init` function can be called from
kernel context in a driver `attach(9E)` or `detach(9E)` entry point. The
`ddi++_++fm++_++init` function usually is called from the `attach` entry
point. The `ddi++_++fm++_++init` function allocates and initializes
resources according to ++<++fmcap++>++. The ++<++fmcap++>++ parameter
must be set to the bitwise-inclusive-OR of the following fault
management capabilities:

* `DDI++_++FM++_++EREPORT++_++CAPABLE` - Driver is responsible for and
capable of generating FMA protocol error events (ereports) upon
detection of an error condition.
* `DDI++_++FM++_++ACCCHK++_++CAPABLE` - Driver is responsible for and
capable of checking for errors upon completion of one or more access I/O
transactions.
* `DDI++_++FM++_++DMACHK++_++CAPABLE` - Driver is responsible for and
capable of checking for errors upon completion of one or more DMA I/O
transactions.
* `DDI++_++FM++_++ERRCB++_++CAPABLE` - Driver has an error callback
function.

A hardened leaf driver generally sets all these
capabilities. However, if its parent nexus is not capable of supporting
any one of the requested capabilities, the associated bit is cleared and
returned as such to the driver. Before returning from
ddi++_++fm++_++init(9F), the I/O fault services framework creates a set
of fault management capability properties: fm-ereport-capable,
fm-accchk-capable, fm-dmachk-capable and fm-errcb-capable. The currently
supported fault management capability level is observable by using the
`prtconf(8)` command.

To make your driver support administrative selection of fault management
capabilities, export and set the fault management capability level
properties to the values described above in the `driver.conf(5)` file.
The fm-capable properties must be set and read prior to calling
`ddi++_++fm++_++init` with the desired capability list.

The following example from the `bge`
driver shows the `bge++_++fm++_++init` function, which calls the
ddi++_++fm++_++init(9F) function. The `bge++_++fm++_++init` function is
called in the `bge++_++attach` function.

[source,c]
----
static void
bge_fm_init(bge_t *bgep)
{
        ddi_iblock_cookie_t iblk;

        /* Only register with IO Fault Services if we have some capability */
        if (bgep->fm_capabilities) {
                bge_reg_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                dma_attr.dma_attr_flags = DDI_DMA_FLAGERR;
                /* 
                 * Register capabilities with IO Fault Services
                 */
                ddi_fm_init(bgep->devinfo, &bgep->fm_capabilities, &iblk);
                /*
                 * Initialize pci ereport capabilities if ereport capable
                 */
                if (DDI_FM_EREPORT_CAP(bgep->fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep->fm_capabilities))
                        pci_ereport_setup(bgep->devinfo);
                /*
                 * Register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep->fm_capabilities))
                        ddi_fm_handler_register(bgep->devinfo,
                        bge_fm_error_cb, (void*) bgep);
        } else {
                /*
                 * These fields have to be cleared of FMA if there are no
                 * FMA capabilities at runtime.
                 */
                bge_reg_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                dma_attr.dma_attr_flags = 0;
        }
}
----

[[cleaning-up-fault-management-resources]]
===== Cleaning Up Fault Management Resources

fault management

fault management resources, cleaning up

ddi++_++fm++_++fini

fault management

ddi++_++fm++_++fini

The ddi++_++fm++_++fini(9F) function cleans up resources allocated to
support fault management for ++<++dip++>++.

[source,c]
----
void ddi_fm_fini(dev_info_t *dip)
----

The `ddi++_++fm++_++fini` function can be called from kernel context in
a driver `attach(9E)` or `detach(9E)` entry point.

The following example from the `bge`
driver shows the `bge++_++fm++_++fini` function, which calls the
ddi++_++fm++_++fini(9F) function. The `bge++_++fm++_++fini` function is
called in the `bge++_++unattach` function, which is called in both the
`bge++_++attach` and `bge++_++detach` functions.

[source,c]
----
static void
bge_fm_fini(bge_t *bgep)
{
        /* Only unregister FMA capabilities if we registered some */
        if (bgep->fm_capabilities) {
                /*
                 * Release any resources allocated by pci_ereport_setup()
                 */
                if (DDI_FM_EREPORT_CAP(bgep->fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep->fm_capabilities))
                        pci_ereport_teardown(bgep->devinfo);
                /*
                 * Un-register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep->fm_capabilities))
                        ddi_fm_handler_unregister(bgep->devinfo);
                /*
                 * Unregister from IO Fault Services
                 */
                ddi_fm_fini(bgep->devinfo);
        }
}
----

[[getting-the-fault-management-capability-bit-mask]]
===== Getting the Fault Management Capability Bit Mask

fault management

fault management capability bit mask

ddi++_++fm++_++capable

fault management

ddi++_++fm++_++capable

The ddi++_++fm++_++capable(9F) function returns the capability bit mask
currently set for ++<++dip++>++.

[source,c]
----
void ddi_fm_capable(dev_info_t *dip)
----

[[reporting-errors]]
===== Reporting Errors

* link:#gemfu[Queueing an Error Event] discusses how to queue error
events.
* link:#gemfk[Detecting and Reporting PCI-Related Errors] describes how
to report PCI-related errors.
* link:#gemha[Reporting Standard I/O Controller Errors] describes how to
report standard I/O controller errors.
* link:#gemgp[Service Impact Function] discusses how to report whether
an error has impacted the services provided by a device.

[[gemfu]]
====== Queueing an Error Event

ddi++_++fm++_++ereport++_++post

fault management

ddi++_++fm++_++ereport++_++post

fault management

ereport events

ENA (Error Numeric Association)

fault management

ENA (Error Numeric Association)

The ddi++_++fm++_++ereport++_++post(9F) function causes an ereport event
to be queued for delivery to the fault manager daemon, `fmd(8)`.

[source,c]
----
void ddi_fm_ereport_post(dev_info_t *dip, 
                         const char *error_class, 
                         uint64_t ena, 
                         int sflag, ...)
----

The ++<++sflag++>++ parameter indicates whether the caller is willing to
wait for system memory and event channel resources to become available.

The ENA indicates the _Error Numeric Association_ (ENA) for this error
report. The ENA might have been initialized and obtained from another
error detecting software module such as a bus nexus driver. If the ENA
is set to 0, it will be initialized by
`ddi++_++fm++_++ereport++_++post`.

The name-value pair (++<++nvpair++>++) variable argument list contains
one or more name, type, value pointer ++<++nvpair++>++ tuples for
non-array `data++_++type++_++t` types or one or more name, type, number
of element, value pointer tuples for `data++_++type++_++t` array types.
The ++<++nvpair++>++ tuples make up the ereport event payload required
for diagnosis. The end of the argument list is specified by `NULL`.

The ereport
class names and payloads described in link:#gemha[Reporting Standard I/O
Controller Errors] for I/O controllers are used as appropriate for
++<++error++_++class++>++. Other ereport class names and payloads can be
defined, but they must be registered in the illumos _event registry_ and
accompanied by driver specific diagnosis engine software, or the
Eversholt fault tree (eft) rules. For more information about the illumos
event registry and about Eversholt fault tree rules, see the
http://www.opensolaris.org/os/community/fm/[Fault Management community]
on http://www.opensolaris.org/os/[OpenSolaris].

[source,c]
----
bge_fm_ereport(bge_t *bgep, char *detail)
{
        uint64_t ena;
        char buf[FM_MAX_CLASS];
        (void) snprintf(buf, FM_MAX_CLASS, "%s.%s", DDI_FM_DEVICE, detail);
        ena = fm_ena_generate(0, FM_ENA_FMT1);
        if (DDI_FM_EREPORT_CAP(bgep->fm_capabilities)) {
                ddi_fm_ereport_post(bgep->devinfo, buf, ena, DDI_NOSLEEP,
                    FM_VERSION, DATA_TYPE_UINT8, FM_EREPORT_VERS0, NULL);
        }
}
----

[[gemfk]]
====== Detecting and Reporting PCI-Related Errors

pci++_++ereport++_++post

fault management

pci++_++ereport++_++post

pci++_++ereport++_++setup

fault management

pci++_++ereport++_++seetup

pci++_++ereport++_++teardown

fault management

pci++_++ereport++_++teardown

PCI-related errors, including PCI, PCI-X, and PCI-E, are automatically
detected and reported when you use pci++_++ereport++_++post(9F).

[source,c]
----
void pci_ereport_post(dev_info_t *dip, ddi_fm_error_t *derr, uint16_t *xx_status)
----

Drivers do not need to generate driver-specific ereports for errors that
occur in the PCI Local Bus configuration status registers. The
`pci++_++ereport++_++post` function can report data parity errors,
master aborts, target aborts, signaled system errors, and much more.

If `pci++_++ereport++_++post` is to be used by a driver, then
pci++_++ereport++_++setup(9F) must have been previously called during
the driver's attach(9E) routine, and pci++_++ereport++_++teardown(9F)
must subsequently be called during the driver's detach(9E) routine.

The `bge` code samples below show the `bge` driver invoking the
`pci++_++ereport++_++post` function from the driver's error handler. See
also link:#registering-an-error-handler[Registering an Error Handler].

[source,c]
----
/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error 
      * in any dma or access handle, we can just return 
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err->fme_status);
}
----

[[gemha]]
====== Reporting Standard I/O Controller Errors

fault management

eft diagnosis engine

fault management

event registry

fault management

DDI++_++FM++_*++ I/O controller errors

A standard set of device ereports is defined for commonly seen errors
for I/O controllers. These ereports should be generated whenever one of
the error symptoms described in this section is detected.

The ereports described in this section are dispatched for diagnosis to
the eft diagnosis engine, which uses a common set of standard rules to
diagnose them. Any other errors detected by device drivers must be
defined as ereport events in the illumos event registry and must be
accompanied by device specific diagnosis software or eft rules.

DDI++_++FM++_++DEVICE++_++INVAL++_++STATE::
  The driver has detected that the device is in an invalid state.
  +
  A driver should post an error when it detects that the data it
  transmits or receives appear to be invalid. For example, in the `bge`
  code, the `bge++_++chip++_++reset` and `bge++_++receive++_++ring`
  routines generate the `ereport.io.device.inval++_++state` error when
  these routines detect invalid data.
  +
[source,c]
----
/*
 * The SEND INDEX registers should be reset to zero by the
 * global chip reset; if they're not, there'll be trouble
 * later on.
 */
sx0 = bge_reg_get32(bgep, NIC_DIAG_SEND_INDEX_REG(0));
if (sx0 != 0) {
    BGE_REPORT((bgep, "SEND INDEX - device didn't RESET"));
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (DDI_FAILURE);
}
/* ... */
/*
 * Sync (all) the receive ring descriptors
 * before accepting the packets they describe
 */
DMA_SYNC(rrp->desc, DDI_DMA_SYNC_FORKERNEL);
if (*rrp->prod_index_p >= rrp->desc.nslots) {
    bgep->bge_chip_state = BGE_CHIP_ERROR;
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (NULL);
}
----
DDI++_++FM++_++DEVICE++_++INTERN++_++CORR::
  The device has reported a self-corrected internal error. For example,
  a correctable ECC error has been detected by the hardware in an
  internal buffer within the device.
  +
  This error flag is not used in the `bge` driver. See the
  `nxge++_++fm.c` file on the illumos source browser for examples that
  use this error. Take the following steps to study the `nxge` driver
  code:
  +
  * Go to http://src.illumos.org[illumos source browser].
  * Enter `nxge` in the File Path field.
  * Select illumos-gate in the project(s) listing.
  * Click the Search button.
DDI++_++FM++_++DEVICE++_++INTERN++_++UNCORR::
  The device has reported an uncorrectable internal error. For example,
  an uncorrectable ECC error has been detected by the hardware in an
  internal buffer within the device.
  +
  This error flag is not used in the `bge` driver. See the
  `nxge++_++fm.c` file on the illumos source browser for examples that
  use this error.
DDI++_++FM++_++DEVICE++_++STALL::
  The driver has detected that data transfer has stalled unexpectedly.
  +
  The `bge++_++factotum++_++stall++_++check` routine provides an example
  of stall detection.
  +
[source,c]
----
dogval = bge_atomic_shl32(&bgep->watchdog, 1);
if (dogval < bge_watchdog_count)
    return (B_FALSE);

BGE_REPORT((bgep, "Tx stall detected, 
watchdog code 0x%x", dogval));
bge_fm_ereport(bgep, DDI_FM_DEVICE_STALL);
return (B_TRUE);
----
DDI++_++FM++_++DEVICE++_++NO++_++RESPONSE::
  The device is not responding to a driver command.
  +
....
bge_chip_poll_engine(bge_t *bgep, bge_regno_t regno,
        uint32_t mask, uint32_t val)
{
        uint32_t regval;
        uint32_t n;

        for (n = 200; n; --n) {
                regval = bge_reg_get32(bgep, regno);
                if ((regval & mask) == val)
                        return (B_TRUE);
                drv_usecwait(100);
        }
        bge_fm_ereport(bgep, DDI_FM_DEVICE_NO_RESPONSE);
        return (B_FALSE);
}
....
DDI++_++FM++_++DEVICE++_++BADINT++_++LIMIT::
  The device has raised too many consecutive invalid interrupts.
  +
  {empty}  The `bge++_++intr` routine within
  the `bge` driver provides an example of stuck interrupt detection. The
  `bge++_++fm++_++ereport` function is a wrapper for the
  ddi++_++fm++_++ereport++_++post(9F) function. See the
  `bge++_++fm++_++ereport` example in link:#gemfu[Queueing an Error
  Event]
  +
[source,c]
----
if (bgep->missed_dmas >= bge_dma_miss_limit) {
    /*
     * If this happens multiple times in a row,
     * it means DMA is just not working.  Maybe
     * the chip has failed, or maybe there's a
     * problem on the PCI bus or in the host-PCI
     * bridge (Tomatillo).
     *
     * At all events, we want to stop further
     * interrupts and let the recovery code take
     * over to see whether anything can be done
     * about it ...
     */
    bge_fm_ereport(bgep,
        DDI_FM_DEVICE_BADINT_LIMIT);
    goto chip_stop;
}
----

[[gemgp]]
====== Service Impact Function

ddi++_++fm++_++service++_++impact

fault management

ddi++_++fm++_++service++_++impact

fault management

access or DMA handle error

fault management

DDI++_++SERVICE++_*++ service impact values

A fault management capable driver must indicate whether or not an error
has impacted the services provided by a device. Following detection of
an error and, if necessary, a shutdown of services, the driver should
invoke the ddi++_++fm++_++service++_++impact(9F) routine to reflect the
current service state of the device instance. The service state can be
used by diagnosis and recovery software to help identify or react to the
problem.

The `ddi++_++fm++_++service++_++impact` routine should be called both
when an error has been detected by the driver itself, and when the
framework has detected an error and marked an access or DMA handle as
faulty.

[source,c]
----
void ddi_fm_service_impact(dev_info_t *dip, int svc_impact)
----

The following service impact values (++<++svc++_++impact++>++) are
accepted by `ddi++_++fm++_++service++_++impact`:

DDI++_++SERVICE++_++LOST::
  The service provided by the device is unavailable due to a device
  fault or software defect.
DDI++_++SERVICE++_++DEGRADED::
  The driver is unable to provide normal service, but the driver can
  provide a partial or degraded level of service. For example, the
  driver might have to make repeated attempts to perform an operation
  before it succeeds, or it might be running at less that its configured
  speed.
DDI++_++SERVICE++_++UNAFFECTED::
  The driver has detected an error, but the services provided by the
  device instance are unaffected.
DDI++_++SERVICE++_++RESTORED::
  All of the device's services have been restored.

The call to `ddi++_++fm++_++service++_++impact` generates the following
ereports on behalf of the driver, based on the service impact argument
to the service impact routine:

* `ereport.io.service.lost`
* `ereport.io.service.degraded`
* `ereport.io.service.unaffected`
* `ereport.io.service.restored`

In the following `bge` code, the driver determines that it is unable to
successfully restart transmitting or receiving packets as the result of
an error. The service state of the device transitions to
DDI++_++SERVICE++_++LOST.

[source,c]
----
/*
 * All OK, reinitialize hardware and kick off GLD scheduling
 */
mutex_enter(bgep->genlock);
if (bge_restart(bgep, B_TRUE) != DDI_SUCCESS) {
    (void) bge_check_acc_handle(bgep, bgep->cfg_handle);
    (void) bge_check_acc_handle(bgep, bgep->io_handle);
    ddi_fm_service_impact(bgep->devinfo, DDI_SERVICE_LOST);
    mutex_exit(bgep->genlock);
    return (DDI_FAILURE);
}
----

[NOTE]

The `ddi++_++fm++_++service++_++impact` function should not be called
from the registered callback routine.
===

[[access-attributes-structure]]
===== Access Attributes Structure

fault management

access attributes

programmed I/O access errors

ddi++_++device++_++acc++_++attr

fault management

ddi++_++device++_++acc++_++attr

A `DDI++_++FM++_++ACCCHK++_++CAPABLE` device driver must set its access
attributes to indicate that it is capable of handling programmed I/O
(PIO) access errors that occur during a register read or write. The
`devacc++_++attr++_++access` field in the
`ddi++_++device++_++acc++_++attr(9S)` structure should be set as an
indicator to the system that the driver is capable of checking for and
handling data path errors. The `ddi++_++device++_++acc++_++attr`
structure contains the following members:

[source,c]
----
ushort_t devacc_attr_version;
uchar_t devacc_attr_endian_flags;
uchar_t devacc_attr_dataorder;
uchar_t devacc_attr_access;             /* access error protection */
----

Errors detected in the data path to or from a device can be processed by
one or more of the device driver's nexus parents.

The `devacc++_++attr++_++access` field can be set to the following
values:

DDI++_++DEFAULT++_++ACC::
  This flag indicates the system will take the default action (panic if
  appropriate) when an error occurs. This attribute cannot be used by
  DDI++_++FM++_++ACCCHK++_++CAPABLE drivers.
DDI++_++FLAGERR++_++ACC::
    This flag indicates that the system will
  attempt to handle and recover from an error associated with the access
  handle. The driver should use the techniques described in
  link:#defensive-programming-techniques-for-illumos-device-drivers[Defensive Programming Techniques for
  illumos Device Drivers] and should use
  ddi++_++fm++_++acc++_++err++_++get(9F) to regularly check for errors
  before the driver allows data to be passed back to the calling
  application.
  +
  * Error notification via the driver callback
  * An error condition observable via
  ddi++_++fm++_++acc++_++err++_++get(9F)
DDI++_++CAUTIOUS++_++ACC::
   The DDI++_++CAUTIOUS++_++ACC flag provides a high level
  of protection for each Programmed I/O access made by the driver.
  +
  [NOTE]
  ====
     Use of this flag will
  cause a significant impact on the performance of the driver.
  ====
  +
  The DDI++_++CAUTIOUS++_++ACC flag signifies that an error is
  anticipated by the accessing driver. The system attempts to handle and
  recover from an error associated with this handle as gracefully as
  possible. No error reports are generated as a result, but the handle's
  `fme++_++status` flag is set to DDI++_++FM++_++NONFATAL. This flag is
  functionally equivalent to `ddi++_++peek(9F)` and `ddi++_++poke(9F)`.
  +
      The use of
  the DDI++_++CAUTIOUS++_++ACC provides:
  +
  * Exclusive access to the bus
  * On trap protection - (`ddi++_++peek` and `ddi++_++poke`)
  * Error notification through the driver callback registered with
  ddi++_++fm++_++handler++_++register(9F)
  * An error condition observable through
  ddi++_++fm++_++acc++_++err++_++get(9F)

Generally, drivers should check for data path errors at appropriate
junctures in the code path to guarantee consistent data and to ensure
that proper error status is presented in the I/O software stack.

DDI++_++FM++_++ACCCHK++_++CAPABLE device drivers must set their
`devacc++_++attr++_++access` field to DDI++_++FLAGERR++_++ACC or
DDI++_++CAUTIOUS++_++ACC.

[[dma-attributes-structure]]
===== DMA Attributes Structure

fault management

DMA errors

ddi++_++dma++_++attr

fault management

ddi++_++dma++_++attr

fault management

DDI++_++DMA++_++FLAGERR

As with access handle setup, a DDI++_++FM++_++DMACHK++_++CAPABLE device
driver must set the `dma++_++attr++_++flag` field of its
`ddi++_++dma++_++attr(9S)` structure to the DDI++_++DMA++_++FLAGERR
flag. The system attempts to recover from an error associated with a
handle that has DDI++_++DMA++_++FLAGERR set. The `ddi++_++dma++_++attr`
structure contains the following members:

[source,c]
----
uint_t          dma_attr_version;       /* version number */
uint64_t        dma_attr_addr_lo;       /* low DMA address range */
uint64_t        dma_attr_addr_hi;       /* high DMA address range */
uint64_t        dma_attr_count_max;     /* DMA counter register */
uint64_t        dma_attr_align;         /* DMA address alignment */
uint_t          dma_attr_burstsizes;    /* DMA burstsizes */
uint32_t        dma_attr_minxfer;       /* min effective DMA size */
uint64_t        dma_attr_maxxfer;       /* max DMA xfer size */
uint64_t        dma_attr_seg;           /* segment boundary */
int             dma_attr_sgllen;        /* s/g length */
uint32_t        dma_attr_granular;      /* granularity of device */
uint_t          dma_attr_flags;         /* Bus specific DMA flags */
----

  Drivers that set the
DDI++_++DMA++_++FLAGERR flag should use the techniques described in
link:#defensive-programming-techniques-for-illumos-device-drivers[Defensive Programming Techniques for illumos
Device Drivers] and should use ddi++_++fm++_++dma++_++err++_++get(9F) to
check for data path errors whenever DMA transactions are completed or at
significant points within the code path. This ensures consistent data
and proper error status presented to the I/O software stack.

* Error notification via the driver callback registered with
`ddi++_++fm++_++handler++_++register`
* An error condition observable by calling
`ddi++_++fm++_++dma++_++err++_++get`

[[getting-error-status]]
===== Getting Error Status

If a fault has occurred that affects the resource mapped by the handle,
the error status structure is updated to reflect error information
captured during error handling by a bus or other device driver in the
I/O data path.

[source,c]
----
void ddi_fm_dma_err_get(ddi_dma_handle_t handle, ddi_fm_error_t *de, int version)

void ddi_fm_acc_err_get(ddi_acc_handle_t handle, ddi_fm_error_t *de, int version)
----

The ddi++_++fm++_++acc++_++err++_++get(9F) and
ddi++_++fm++_++dma++_++err++_++get(9F) functions return the error status
for a DMA or access handle respectively. The version field should be set
to DDI++_++FME++_++VERSION.

An error for an access handle means that
an error has been detected that has affected PIO transactions to or from
the device using that access handle. Any data received by the driver,
for example via a recent `ddi++_++get8(9F)` call, should be considered
potentially corrupt. Any data sent to the device, for example via a
recent `ddi++_++put32(9F)` call might also have been corrupted or might
not have been received at all. The underlying fault might, however, be
transient, and the driver can therefore attempt to recover by calling
ddi++_++fm++_++acc++_++err++_++clear(9F), resetting the device to get it
back into a known state, and retrying any potentially failed
transactions.

If an error is indicated for a DMA handle, it implies that an error has
been detected that has (or will) affect DMA transactions between the
device and the memory currently bound to the handle (or most recently
bound, if the handle is currently unbound). Possible causes include the
failure of a component in the DMA data path, or an attempt by the device
to make an invalid DMA access. The driver might be able to continue by
retrying and reallocating memory. The contents of the memory currently
(or previously) bound to the handle should be regarded as indeterminate
and should be released back to the system. The fault indication
associated with the current transaction is lost once the handle is bound
or re-bound, but because the fault might persist, future DMA operations
might not succeed.

[[clearing-errors]]
===== Clearing Errors

These routines should be called when the driver wants to retry a request
after an error was detected by the handle without needing to free and
reallocate the handle first.

[source,c]
----
void ddi_fm_acc_err_clear(ddi_acc_handle_t handle, int version)

void ddi_fm_dma_err_clear(ddi_dma_handle_t handle, int version)
----

[[registering-an-error-handler]]
===== Registering an Error Handler

Error handling activity might begin at the time that the error is
detected by the operating system via a trap or error interrupt. If the
software responsible for handling the error (the error handler) cannot
immediately isolate the device that was involved in the failed I/O
operation, it must attempt to find a software module within the device
tree that can perform the error isolation. The illumos device tree
provides a structural means to propagate nexus driver error handling
activities to children who might have a more detailed understanding of
the error and can capture error state and isolate the problem device.

    A driver can
register an error handler callback with the I/O Fault Services
Framework. The error handler should be specific to the type of error and
subsystem where error detection has occurred. When the driver's error
handler routine is invoked, the driver must check for any outstanding
errors associated with device transactions and generate ereport events.
The driver must also return error handler status in its
`ddi++_++fm++_++error` structure. For example, if it has been determined
that the system's integrity has been compromised, the most appropriate
action might be for the error handler to panic the system.

The callback is invoked by a parent nexus driver when an error might be
associated with a particular device instance. Device drivers that
register error handlers must be DDI++_++FM++_++ERRCB++_++CAPABLE.

[source,c]
----
void ddi_fm_handler_register(dev_info_t *dip, ddi_err_func_t handler, void *impl_data)
----

ddi++_++fm++_++handler++_++register(9F) routine registers an error
handler callback with the I/O fault services framework. The
`ddi++_++fm++_++handler++_++register` function should be called in the
driver's `attach(9E)` entry point for callback registration following
driver fault management initialization (`ddi++_++fm++_++init`).

* Check for any outstanding hardware errors associated with device
transactions, and generate ereport events for diagnosis. For a PCI,
PCI-x, or PCI express device this can generally be done using
`pci++_++ereport++_++post` as described in link:#gemfk[Detecting and
Reporting PCI-Related Errors].
*   Return error handler status in its
`ddi++_++fm++_++error` structure:
** DDI++_++FM++_++OK
** DDI++_++FM++_++FATAL
** DDI++_++FM++_++NONFATAL
** DDI++_++FM++_++UNKNOWN

* A pointer to a device instance (++<++dip++>++) under the driver's
control
* A data structure (`ddi++_++fm++_++error`) that contains common fault
management data and status for error handling
* A pointer to any implementation specific data
(++<++impl++_++data++>++) specified at the time of the handler's

* Must not hold locks
* Must not sleep waiting for resources

* Isolating the device instance that might have caused errors
* Recovering transactions associated with errors
* Reporting the service impact of errors
* Scheduling device shutdown for errors considered fatal

These actions can be carried out within the error handler function.
However, because of the restrictions on locking and because the error
handler function does not always know the context of what the driver was
doing at the point where the fault occurred, it is more usual for these
actions to be carried out following inline calls to
ddi++_++fm++_++acc++_++err++_++get(9F) and
ddi++_++fm++_++dma++_++err++_++get(9F) within the normal paths of the
driver as described previously.

[source,c]
----
/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error 
      * in any dma or access handle, we can just return 
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err->fme_status);
}
----

[[fault-management-data-and-status-structure]]
===== Fault Management Data and Status Structure

fault management

ENA (Error Numeric Association)

ddi++_++fm++_++error

fault management

ddi++_++fm++_++error

Driver error handling callbacks are passed a pointer to a data structure
that contains common fault management data and status for error
handling.

The data structure `ddi++_++fm++_++error` contains an FMA protocol ENA
for the current error, the status of the error handler callback, an
error expectation flag, and any potential access or DMA handles
associated with an error detected by the parent nexus.

`fme++_++ena`::
  This field is initialized by the calling parent nexus and might have
  been incremented along the error handling propagation chain before
  reaching the driver's registered callback routine. If the driver
  detects a related error of its own, it should increment this ENA prior
  to calling `ddi++_++fm++_++ereport++_++post`.
`fme++_++acc++_++handle`, `fme++_++dma++_++handle`::
  These fields contain a valid access or DMA handle if the parent was
  able to associate an error detected at its level to a handle mapped or
  bound by the device driver.
`fme++_++flag`::
  The `fme++_++flag` is set to DDI++_++FM++_++ERR++_++EXPECTED if the
  calling parent determines the error was the result of a
  DDI++_++CAUTIOUS++_++ACC protected operation. In this case, the
  `fme++_++acc++_++handle` is valid and the driver should check for and
  report only errors not associated with the DDI++_++CAUTIOUS++_++ACC
  protected operation. Otherwise, `fme++_++flag` is set to
  DDI++_++FM++_++ERR++_++UNEXPECTED and the driver must perform the full
  range of error handling tasks.
`fme++_++status`::
  Upon return from its error handler callback, the driver must set
  `fme++_++status` to one of the following values:
  +
  * DDI++_++FM++_++OK – No errors were detected and the operational
  state of this device instance remains the same.
  *   DDI++_++FM++_++FATAL – An error has
  occurred and the driver considers it to be fatal to the system. For
  example, a call to pci++_++ereport++_++post(9F) might have detected a
  system fatal error. In this case, the driver should report any
  additional error information it might have in the context of the
  driver.
  * DDI++_++FM++_++NONFATAL – An error has been detected by the driver
  but is not considered fatal to the system. The driver has identified
  the error and has either isolated the error or is committing that it
  will isolate the error.
  * DDI++_++FM++_++UNKNOWN – An error has been detected, but the driver
  is unable to isolate the device or determine the impact of the error
  on the operational state of the system.

[[diagnosing-faults]]
==== Diagnosing Faults

fault manager daemon

fault management

fault manager daemon

DE (diagnosis engine)

fault management

DE (diagnosis engine)

Eversholt fault tree (eft) rules

fault management

Eversholt fault tree (eft) rules

eft diagnosis rules

fault management

eft diagnosis rules

The fault management daemon, `fmd(8)`, provides a programming interface
for the development of diagnosis engine (DE) plug-in modules. A DE can
be written to consume and diagnose any error telemetry or specific error
telemetries. The eft DE was designed to diagnose any number of ereport
classes based on diagnosis rules specified in the Eversholt language.

[[standard-leaf-device-diagnosis]]
===== Standard Leaf Device Diagnosis

Most I/O subsystems use the eft DE and rules sets to diagnose device and
device driver related problems. A standard set of ereports, listed in
link:#gemha[Reporting Standard I/O Controller Errors], has been
specified for PCI leaf devices. Accompanying these ereports are eft
diagnosis rules that take the telemetry and identify the associated
device fault. Drivers that generate these ereports do not need to
deliver any additional diagnosis software or eft rules.

The detection and generation of these ereports produces the following
fault events:

`fault.io.pci.bus-linkerr`::
  A hardware fault on the PCI bus
`fault.io.pci.device-interr`::
  A hardware fault within the device
`fault.io.pci.device-invreq`::
  A hardware fault in the device or a defect in the driver that causes
  the device to send an invalid request
`fault.io.pci.device-noresp`::
  A hardware fault in the device that causes the driver not to respond
  to a valid request
`fault.io.pciex.bus-linkerr`::
  A hardware fault on the link
`fault.io.pciex.bus-noresp`::
  The link going down so that a device cannot respond to a valid request
`fault.io.pciex.device-interr`::
  A hardware fault within the device
`fault.io.pciex.device-invreq`::
  A hardware fault in the device or a defect in the driver that causes
  the device to send an invalid request
`fault.io.pciex.device-noresp`::
  A hardware fault in the device causing it not to respond to a valid

[[specialized-device-diagnosis]]
===== Specialized Device Diagnosis

Driver developers who want to generate additional ereports or provide
more specialized diagnosis software or eft rules can do so by writing a
C-based DE or an eft diagnosis rules set. See the
http://www.opensolaris.org/os/community/fm/[Fault Management community]
on http://www.opensolaris.org/os/[OpenSolaris] for information.

[[event-registry]]
==== Event Registry

event registry

fault management

event registry

fault management

DE (diagnosis engine)

fault management

eft diagnosis rules

fault management

suspect list

The illumos event registry is the central repository of all class names,
ereports, faults, defects, upsets and suspect lists (list.suspect)
events. The event registry also contains the current definitions of all
event member payloads, as well as important non-payload information like
internal documentation, suspect lists, dictionaries, and knowledge
articles. For example, `ereport.io` and `fault.io` are two of the base
class names that are of particular importance to I/O driver developers.

The FMA event protocol defines a base set of payload members that is
supplied with each of the registered events. Developers can also define
additional events that help diagnosis engines (or eft rules) to narrow a
suspect list down to a specific fault.

[[glossary]]
==== Glossary

This section uses the following terms:

Agent::
  A generic term used to describe fault manager modules that subscribe
  to fault.++*++ or list.++*++ events. Agents are used to retire faulty
  resources, communicate diagnosis results to Administrators, and bridge
  to higher-level management frameworks.
ASRU (Automated System Reconfiguration Unit)::
  The ASRU is a resource that can be disabled by software or hardware in
  order to isolate a problem in the system and suppress further error
  reports.
DE (Diagnosis Engine)::
  A fault management module whose purpose is to diagnose problems by
  subscribing to one or more classes of incoming error events and using
  these events to solve cases associated with each problem on the
  system.
ENA (Error Numeric Association)::
  An Error Numeric Association (ENA) is an encoded integer that uniquely
  identifies an error report within a given fault region and time
  period. The ENA also indicates the relationship of the error to
  previous errors as a secondary effect.
Error::
  An unexpected condition, result, signal, or datum. An error is the
  symptom of a problem on the system. Each problem typically produces
  many different kinds of errors.
ereport (Error Report)::
  The data captured with a particular error. Error report formats are
  defined in advance by creating a class naming the error report and
  defining a schema using the illumos event registry.
ereport event (Error Event)::
  The data structure that represents an instance of an error report.
  Error events are represented as name-value pair lists.
Fault::
  Malfunctioning behavior of a hardware component.
Fault Boundary::
  Logical partition of hardware or software elements for which a
  specific set of faults can be enumerated.
Fault Event::
  An instance of a fault diagnosis encoded in the protocol.
Fault Manager::
  Software component responsible for fault diagnosis via one or more
  diagnosis engines and state management.
FMRI (Fault Managed Resource Identifier)::
  An FMRI is a URL-like identifier that acts as the canonical name for a
  particular resource in the fault management system. Each FMRI includes
  a scheme that identifies the type of resource, and one or more values
  that are specific to the scheme. An FMRI can be represented as
  URL-like string or as a name-value pair list data structure.
FRU (Field Replaceable Unit)::
  The FRU is a resource that can be replaced in the field by a customer
  or service provider. FRUs can be defined for hardware (for example
  system boards) or for software (for example software packages or
  patches).

[[resources]]
==== Resources

* http://www.opensolaris.org/os/community/fm/[Fault Management
OpenSolaris community]
* http://www.illumos.org/msg/[FMA Messaging web site]

[[defensive-programming-techniques-for-illumos-device-drivers]]
=== Defensive Programming Techniques for illumos Device Drivers

This section offers techniques for device drivers to avoid system panics
and hangs, wasting system resources, and spreading data corruption. A
driver is considered hardened when it uses these defensive programming
practices in addition to the I/O fault services framework for error
handling and diagnosis.

* Each piece of hardware should be controlled by a separate instance of
the device driver. See link:#device-configuration-concepts[Device Configuration
Concepts].
* Programmed I/O (PIO) must be performed _only_ through the DDI access
functions, using the appropriate data access handle. See
link:#device-access-programmed-io[Device Access: Programmed I/O].
* The device driver must assume that data that is received from the
device might be corrupted. The driver must check the integrity of the
data before the data is used.
* The driver must avoid releasing bad data to the rest of the system.
* Use only documented DDI functions and interfaces in your driver.
* The driver must ensure that the device writes only into pages of
memory in the DMA buffers (`DDI++_++DMA++_++READ`) that are controlled
entirely by the driver. This technique prevents a DMA fault from
corrupting an arbitrary part of the system's main memory.
* The device driver must not be an unlimited drain on system resources
if the device locks up. The driver should time out if a device claims to
be continuously busy. The driver should also detect a pathological
(stuck) interrupt request and take appropriate action.
* The device driver must support hotplugging in illumos.
* The device driver must use callbacks instead of waiting on resources.
* The driver must free up resources after a fault. For example, the
system must be able to close all minor devices and detach driver
instances even after the hardware fails.

[[using-separate-device-driver-instances]]
==== Using Separate Device Driver Instances

driver instances

The illumos kernel allows multiple instances of a driver. Each instance
has its own data space but shares the text and some global data with
other instances. The device is managed on a per-instance basis. Drivers
should use a separate instance for each piece of hardware unless the
driver is designed to handle any failover internally. Multiple instances
of a driver per slot can occur, for example, with multifunction cards.

[[exclusive-use-of-ddi-access-handles]]
==== Exclusive Use of DDI Access Handles

access handles

programmed I/O

use with DDI access routines

ddi++_++get

ddi++_++put

ddi++_++rep++_++get

ddi++_++rep++_++put

All PIO access by a driver must use illumos DDI access functions from
the following families of routines:

* `ddi++_++get`++<++X++>++
* `ddi++_++put`++<++X++>++
* `ddi++_++rep++_++get`++<++X++>++
* `ddi++_++rep++_++put`++<++X++>++

The driver should not directly access the mapped
registers by the address that is returned from
`ddi++_++regs++_++map++_++setup(9F)`. Avoid the `ddi++_++peek(9F)` and
`ddi++_++poke(9F)` routines because these routines do not use access
handles.

The DDI access mechanism is important because DDI access provides an
opportunity to control how data is read into the kernel.

==== Detecting Corrupted Data

data corruption

The following sections describe where data corruption can occur and how
to detect corruption.

[[corruption-of-device-management-and-control-data]]
===== Corruption of Device Management and Control Data

data corruption

device management data

data corruption

control data

The driver should assume that any data obtained from the
device, whether by PIO or DMA, could have been corrupted. In particular,
extreme care should be taken with pointers, memory offsets, and array
indexes that are based on data from the device. Such values can be
_malignant_, in that these values can cause a kernel panic if
dereferenced. All such values should be checked for range and alignment
(if required) before use.

Even a pointer that is not malignant can still be
misleading. For example, a pointer can point to a valid but not correct
instance of an object. Where possible, the driver should cross-check the
pointer with the object to which it is pointing, or otherwise validate
the data obtained through that pointer.

Other types of data can also be misleading, such as packet lengths,
status words, or channel IDs. These data types should be checked to the
extent possible. A packet length can be range-checked to ensure that the
length is neither negative nor larger than the containing buffer. A
status word can be checked for “impossible” bits. A channel ID can be
matched against a list of valid IDs.

Where a value is used to identify a stream, the driver must ensure that
the stream still exists. The asynchronous nature of processing STREAMS
means that a stream can be dismantled while device interrupts are still
outstanding.

The driver should not reread data from the device. The data should be
read once, validated, and stored in the driver's local state. This
technique avoids the hazard of data that is correct when initially read,
but is incorrect when reread later.

The driver should also ensure that all loops are bounded. For example, a
device that returns a continuous `BUSY` status should not be able to
lock up the entire system.

[[corruption-of-received-data]]
===== Corruption of Received Data

data corruption

of received data

Device errors can result in corrupted data being placed in receive
buffers. Such corruption is indistinguishable from corruption that
occurs beyond the domain of the device, for example, within a network.
Typically, existing software is already in place to handle such
corruption. One example is the integrity checks at the transport layer
of a protocol stack. Another example is integrity checks within the
application that uses the device.

If the received data is not to be checked for integrity at a higher
layer, the data can be integrity-checked within the driver itself.
Methods of detecting corruption in received data are typically
device-specific. Checksums and CRC are examples of the kinds of checks
that can be done.

==== DMA Isolation

A defective device might initiate an improper DMA transfer over the bus.
This data transfer could corrupt good data that was previously
delivered. A device that fails might generate a corrupt address that can
contaminate memory that does not even belong to its own driver.

In systems with an IOMMU, a device can write only to pages mapped as
writable for DMA. Therefore, such pages should be owned solely by one
driver instance. These pages should not be shared with any other kernel
structure. While the page in question is mapped as writable for DMA, the
driver should be suspicious of data in that page. The page must be
unmapped from the IOMMU before the page is passed beyond the driver, and
before any validation of the data.

   You can use
`ddi++_++umem++_++alloc(9F)` to guarantee that a whole aligned page is
allocated, or allocate multiple pages and ignore the memory below the
first page boundary. You can find the size of an IOMMU page by using
`ddi++_++ptob(9F)`.

Alternatively, the driver can choose to copy the data into a safe part
of memory before processing it. If this is done, the data must first be
synchronized using `ddi++_++dma++_++sync(9F)`.

Calls to `ddi++_++dma++_++sync` should specify `SYNC++_++FOR++_++DEV`
before using DMA to transfer data to a device, and
`SYNC++_++FOR++_++CPU` after using DMA to transfer data from the device
to memory.

On some PCI-based systems with an IOMMU,
devices can use PCI dual address cycles (64-bit addresses) to bypass the
IOMMU. This capability gives the device the potential to corrupt any
region of main memory. Device drivers must not attempt to use such a
mode and should disable it.

[[handling-stuck-interrupts]]
==== Handling Stuck Interrupts

The driver must identify stuck interrupts because a persistently
asserted interrupt severely affects system performance, almost certainly
stalling a single-processor machine.

Sometimes the driver might have difficulty identifying a particular
interrupt as invalid. For network drivers, if a receive interrupt is
indicated but no new buffers have been made available, no work was
needed. When this situation is an isolated occurrence, it is not a
problem, since the actual work might already have been completed by
another routine such as a read service.

On the other hand, continuous interrupts with no work for the driver to
process can indicate a stuck interrupt line. For this reason, platforms
allow a number of apparently invalid interrupts to occur before taking
defensive action.

While appearing to have work to do, a hung device might be failing to
update its buffer descriptors. The driver should defend against such
repetitive requests.

In some cases, platform-specific bus drivers might be capable of
identifying a persistently unclaimed interrupt and can disable the
offending device. However, this relies on the driver's ability to
identify the valid interrupts and return the appropriate value. The
driver should return a `DDI++_++INTR++_++UNCLAIMED` result unless the
driver detects that the device legitimately asserted an interrupt. The
interrupt is legitimate only if the device actually requires the driver
to do some useful work.

The legitimacy of other, more incidental, interrupts is much harder to
certify. An interrupt-expected flag is a useful tool for evaluating
whether an interrupt is valid. Consider an interrupt such as _descriptor
free_, which can be generated if all the device's descriptors had been
previously allocated. If the driver detects that it has taken the last
descriptor from the card, it can set an interrupt-expected flag. If this
flag is not set when the associated interrupt is delivered, the
interrupt is suspicious.

Some informative interrupts might not be predictable, such as one that
indicates that a medium has become disconnected or frame sync has been
lost. The easiest method of detecting whether such an interrupt is stuck
is to mask this particular source on first occurrence until the next
polling cycle.

If the interrupt occurs again while disabled, the interrupt should be
considered false. Some devices have interrupt status bits that can be
read even if the mask register has disabled the associated source and
might not be causing the interrupt. You can devise a more appropriate
algorithm specific to your devices.

Avoid looping on interrupt status bits indefinitely. Break such loops if
none of the status bits set at the start of a pass requires any real
work.

[[additional-programming-considerations]]
==== Additional Programming Considerations

* Thread interaction
* Threats from top-down requests
* Adaptive strategies

===== Thread Interaction

Kernel panics in a device driver
are often caused by unexpected interaction of kernel threads after a
device failure. When a device fails, threads can interact in ways that
you did not anticipate.

If processing routines terminate early, the condition variable waiters
are blocked because an expected signal is never given. Attempting to
inform other modules of the failure or handling unanticipated callbacks
can result in undesirable thread interactions. Consider the sequence of
mutex acquisition and relinquishing that can occur during device
failures.

that originate in an upstream STREAMS module can become involved in
unfortunate paradoxes if those threads are used to return to that module
unexpectedly. Consider using alternative threads to handle exception
messages. For instance, a procedure might use a read-side service
routine to communicate an `M++_++ERROR`, rather than handling the error
directly with a read-side `putnext(9F)`.

A failing STREAMS device that
cannot be quiesced during close because of a fault can generate an
interrupt after the stream has been dismantled. The interrupt handler
must not attempt to use a stale stream pointer to try to process the
message.

[[threats-from-top-down-requests]]
===== Threats From Top-Down Requests

requests from user applications

user applications

requests from

While protecting the system from defective hardware, you also need to
protect against driver misuse. Although the driver can assume that the
kernel infrastructure is always correct (a trusted core), user requests
passed to it can be potentially destructive.

For example, a user can request an action to be performed upon a
user-supplied data block (`M++_++IOCTL`) that is smaller than the block
size that is indicated in the control part of the message. The driver
should never trust a user application.

Consider the construction of each type of `ioctl` that your driver can
receive and the potential harm that the `ioctl` could cause. The driver
should perform checks to ensure that it does not process a malformed
`ioctl`.

===== Adaptive Strategies

A driver can continue to provide service using faulty hardware. The
driver can attempt to work around the identified problem by using an
alternative strategy for accessing the device. Given that broken
hardware is unpredictable and given the risk associated with additional
design complexity, adaptive strategies are not always wise. At most,
these strategies should be limited to periodic interrupt polling and
retry attempts. Periodically retrying the device tells the driver when a
device has recovered. Periodic polling can control the interrupt
mechanism after a driver has been forced to disable interrupts.

Ideally, a system always has an alternative device to provide a vital
system service. Service multiplexors in kernel or user space offer the
best method of maintaining system services when a device fails. Such
practices are beyond the scope of this section.

[[driver-hardening-test-harness]]
=== Driver Hardening Test Harness

driver hardening test harness

injecting hardware faults

hardware faults

The driver hardening test harness tests that the I/O fault services and
defensive programming requirements have been correctly fulfilled.
Hardened device drivers are resilient to potential hardware faults. You
must test the resilience of device drivers as part of the driver
development process. This type of testing requires that the driver
handle a wide range of typical hardware faults in a controlled and
repeatable way. The driver hardening test harness enables you to
simulate such hardware faults in software.

The driver hardening test harness is an illumos device
driver development tool. The test harness injects a wide range of
simulated hardware faults when the driver under development accesses its
hardware. This section describes how to configure the test harness,
create error-injection specifications (referred to as _errdefs_), and
execute the tests on your device driver.

The test harness intercepts calls from the driver to various DDI
routines, then corrupts the result of the calls as if the hardware had
caused the corruption. In addition, the harness allows for corruption of
accesses to specific registers as well as definition of more random
types of corruption.

The test harness can generate test scripts automatically by tracing all
register accesses as well as direct memory access (DMA) and interrupt
usage during the running of a specified workload. A script is generated
that reruns that workload while injecting a set of faults into each
access.

The driver tester should remove duplicate test cases from the generated
scripts.

The test harness is
implemented as a device driver called `bofi`, which stands for
bus++_++ops fault injection, and two user-level utilities,
`th++_++define(8)` and `th++_++manage(8)`.

* Validates compliant use of illumos DDI services
* Facilitates controlled corruption of programmed I/O (PIO) and DMA
requests and interference with interrupts, thus simulating faults that
occur in the hardware managed by the driver
* Facilitates simulation of failures in the data path between the CPU
and the device, which are reported from parent nexus drivers
* Monitors a driver's access during a specified workload and generates
fault-injection scripts

==== Fault Injection

fault injection

The driver hardening test harness intercepts and, when requested,
corrupts each access a driver makes to its hardware. This section
provides information you should understand to create faults to test the
resilience of your driver.

  illumos devices are managed inside a
tree-like structure called the device tree (devinfo tree). Each node of
the devinfo tree stores information that relates to a particular
instance of a device in the system. Each leaf node corresponds to a
device driver, while all other nodes are called _nexus nodes_.
Typically, a nexus represents a bus. A bus node isolates leaf drivers
from bus dependencies, which enables architecturally independent drivers
to be produced.

Many of the DDI functions, particularly the data access functions,
result in upcalls to the bus nexus drivers. When a leaf driver accesses
its hardware, it passes a handle to an access routine. The bus nexus
understands how to manipulate the handle and fulfill the request. A
DDI-compliant driver only accesses hardware through use of these DDI
access routines. The test harness intercepts these upcalls before they
reach the specified bus nexus. If the data access matches the criteria
specified by the driver tester, the access is corrupted. If the data
access does not match the criteria, it is given to the bus nexus to
handle in the usual way.

A driver obtains an access handle by using the
`ddi++_++regs++_++map++_++setup(9F)` function:

....
ddi_regs_map_setup(dip, rset, ma, offset, size, handle)
....

The arguments specify which “offboard” memory is to be mapped. The
driver must use the returned handle when it references the mapped I/O
addresses, since handles are meant to isolate drivers from the details
of bus hierarchies. Therefore, do not directly use the returned mapped
address, ++<++ma++>++. Direct use of the mapped address destroys the
current and future uses of the data access function mechanism.

* I/O to Host:
+
....
ddi_getX(handle, ma)
ddi_rep_getX(handle, buf, ma, repcnt, flag)
....
* Host to I/O:
+
....
ddi_putX(handle, ma, value)
....

++<++X++>++ and ++<++repcnt++>++ are the number of bytes to be
transferred. ++<++X++>++ is the bus transfer size of 8, 16, 32, or 64
bytes.

DMA has a similar, yet richer, set of data access functions.

[[setting-up-the-test-harness]]
==== Setting Up the Test Harness

The driver hardening test harness is part of the Solaris Developer
Cluster. If you have not installed this Solaris cluster, you must
manually install the test harness packages appropriate for your
platform.

[[installing-the-test-harness]]
===== Installing the Test Harness

To install the test harness packages (SUNWftduu and SUNWftdur), use the
`pkgadd(8)` command.

As superuser, go to the directory in which the packages are located and
type:

....
# pkgadd -d . SUNWftduu SUNWftdur
....

[[configuring-the-test-harness]]
===== Configuring the Test Harness

bofi.conf

After the test harness is installed, set the properties in the
`/kernel/drv/bofi.conf` file to configure the harness to interact with
your driver. When the harness configuration is complete, reboot the
system to load the harness driver.

The test harness behavior is controlled by boot-time properties that are
set in the `/kernel/drv/bofi.conf` configuration file.

When the harness is first installed, enable the harness to intercept the
DDI accesses to your driver by setting these properties:

bofi-nexus::
  Bus nexus type, such as the PCI bus
bofi-to-test::
  Name of the driver under test

For example, to test a PCI bus network driver called `xyznetdrv`, set
the following property values:

....
bofi-nexus="pci"
bofi-to-test="xyznetdrv"
....

Other properties relate to the use and harness checking of the illumos
DDI data access mechanisms for reading and writing from peripherals that
use PIO and transferring data to and from peripherals that use DMA.

bofi-range-check::
  When this property is set, the test harness checks the consistency of
  the arguments that are passed to PIO data access functions.
bofi-ddi-check::
  When this property is set, the test harness verifies
  that the mapped address that is returned by
  ddi++_++map++_++regs++_++setup(9F) is not used outside of the context
  of the data access functions.
bofi-sync-check::
  When this property is set, the test harness verifies
  correct usage of DMA functions and ensures that the driver makes
  compliant use of `ddi++_++dma++_++sync(9F)`.

[[testing-the-driver]]
==== Testing the Driver

injecting hardware faults

hardware faults

th++_++define

th++_++manage

This section describes how to create and inject faults by using the
`th++_++define(8)` and `th++_++manage(8)` commands.

[[creating-faults]]
===== Creating Faults

The `th++_++define` utility provides an interface to the `bofi` device
driver for defining errdefs. An _errdef_ corresponds to a specification
for how to corrupt a device driver's accesses to its hardware. The
`th++_++define` command-line arguments determine the precise nature of
the fault to be injected. If the supplied arguments define a consistent
errdef, the `th++_++define` process stores the errdef with the `bofi`
driver. The process suspends itself until the criteria given by the
errdef becomes satisfied. In practice, the suspension ends when the
access counts go to zero (0).

[[injecting-faults]]
===== Injecting Faults

fault injection

* Type of hardware being accessed (driver name)
* Instance of the hardware being accessed (driver instance)
* Register set being tested
* Subset of the register set that is targeted
* Direction of the transfer (read or write)
* Type of access (PIO or DMA)

* The driver instance and register set being tested (`n` ++<++name++>++,
`i` ++<++instance++>++, and `r` ++<++reg++_++number++>++).
* The subset of the register set eligible for corruption. This subset is
indicated by providing an offset into the register set and a length from
that offset (`l` ++<++offset++>++ `++[++`++<++len++>++`++]++`).
* The kind of access to be intercepted: `log`, `pio`, `dma`,
`pio++_++r`, `pio++_++w`, `dma++_++r`, `dma++_++w`, `intr` (`a`
++<++acc++_++types++>++).
* How many accesses should be faulted (`c` ++<++count++>++
`++[++`++<++failcount++>++`++]++`).
* The kind of corruption that should be applied to a qualifying access
(`o` ++<++operator++>++ `++[++`++<++operand++>++`++]++`).
** Replace datum with a fixed value (EQUAL)
** Perform a bitwise operation on the datum (AND, OR, XOR)
** Ignore the transfer (for host to I/O accesses NO++_++TRANSFER)
** Lose, delay, or inject spurious interrupts (LOSE, DELAY, EXTRA)

Use the `a` ++<++acc++_++chk++>++ option to simulate framework faults in
an errdef.

[[fault-injection-process]]
===== Fault-Injection Process

th++_++define

th++_++manage

[arabic]
. Use the `th++_++define(8)` command to create errdefs.
+
Create errdefs by passing test definitions to the `bofi` driver, which
stores the definitions so they can be accessed by using the
`th++_++manage(8)` command.
. Create a workload, then use the `th++_++manage` command to activate
and manage the errdef.
+
The `th++_++manage` command is a user interface to the various ioctls
that are recognized by the `bofi` harness driver. The `th++_++manage`
command operates at the level of driver names and instances and includes
these commands: `get++_++handles` to list access handles, `start` to
activate errdefs, and `stop` to deactivate errdefs.
+
The activation of an errdef results in qualifying data accesses to be
faulted. The `th++_++manage` utility supports these commands:
`broadcast` to provide the current state of the errdef and
`clear++_++errors` to clear the errdef.
+
See the `th++_++define`(1M) and `th++_++manage`(1M) man pages for more
information.

[[test-harness-warnings]]
===== Test Harness Warnings

* Write warning messages to the console
* Write warning messages to the console and then panic the system

Use the second method to help pinpoint the root cause of a problem.

When the bofi-range-check property value is set to `warn`, the harness
prints the following messages (or panics if set to panic) when it
detects a range violation of a DDI function by your driver:

[source,c]
----
ddi_getX() out of range addr %x not in %x
ddi_putX() out of range addr %x not in %x
ddi_rep_getX() out of range addr %x not in %x
ddi_rep_putX() out of range addr %x not in %x
----

++<++X++>++ is 8, 16, 32, or 64.

When the harness has been requested to insert over 1000 extra
interrupts, the following message is printed if the driver does not
detect interrupt jabber:

....
undetected interrupt jabber - %s %d
....

[[using-scripts-to-automate-the-test-process]]
==== Using Scripts to Automate the Test Process

th++_++define

You can create fault-injection test scripts by using the logging access
type of the `th++_++define(8)` utility:

....
# th_define -n name -i instance -a log [-e fixup_script]
....

The `th++_++define` command takes the instance offline and brings it
back online. Then `th++_++define` runs the workload that is described by
the ++<++fixup++_++script++>++ and logs I/O accesses that are made by
the driver instance.

The ++<++fixup++_++script++>++ is called twice with the set of optional
arguments. The script is called once just before the instance is taken
offline, and it is called again after the instance has been brought
online.

The following variables are passed into the environment of the called
executable:

DRIVER++_++PATH::
  Device path of the instance
DRIVER++_++INSTANCE::
  Instance number of the driver
DRIVER++_++UNCONFIGURE::
  Set to 1 when the instance is about to be taken offline
DRIVER++_++CONFIGURE::
  Set to 1 when the instance has just been brought online

Typically, the ++<++fixup++_++script++>++ ensures that the device under
test is in a suitable state to be taken offline (unconfigured) or in a
suitable state for error injection (for example, configured, error free,
and servicing a workload). The following script is a minimal script for
a network driver:

....
#!/bin/ksh
driver=xyznetdrv
ifnum=$driver$DRIVER_INSTANCE
 
if [[ $DRIVER_CONFIGURE = 1 ]]; then
   ifconfig $ifnum plumb    
   ifconfig $ifnum ...  
   ifworkload start $ifnum
elif [[ $DRIVER_UNCONFIGURE = 1 ]]; then    
   ifworkload stop $ifnum   
   ifconfig $ifnum down 
   ifconfig $ifnum unplumb
exit $?
....

[NOTE]

The `ifworkload` command should initiate the workload as a background
task. The fault injection occurs after the ++<++fixup++_++script++>++
configures the driver under test and brings it online
(DRIVER++_++CONFIGURE is set to 1).
===

If the `e` ++<++fixup++_++script++>++ option is present, it must be the
last option on the command line. If the `e` option is not present, a
default script is used. The default script repeatedly attempts to bring
the device under test offline and online. Thus the workload consists of
the driver's `attach` and `detach` paths.

The resulting log is converted into a set of executable scripts that are
suitable for running unassisted fault-injection tests. These scripts are
created in a subdirectory of the current directory with the name
`driver.test.id`. The scripts inject faults, one at a time, into the
driver while running the workload that is described by the
++<++fixup++_++script++>++.

The driver tester has substantial control over the
errdefs that are produced by the test automation process. See the
`th++_++define(8)` man page.

If the tester chooses a suitable range of workloads for the test
scripts, the harness gives good coverage of the hardening aspects of the
driver. However, to achieve full coverage, the tester might need to
create additional test cases manually. Add these cases to the test
scripts. To ensure that testing completes in a timely manner, you might
need to manually delete duplicate test cases.

[[automated-test-process]]
===== Automated Test Process

[arabic]
. Identify the aspects of the driver to be tested.
* Attach and detach
* Plumb and unplumb under a stack
* Normal data transfer
* Documented debug modes
+
A separate workload script (++<++fixup++_++script++>++) must be
generated for each mode of use.
. For each mode of use, prepare an executable
program(++<++fixup++_++script++>++) that configures and unconfigures the
device, and creates and terminates a workload.
. Run the `th++_++define`(1M) command with the errdefs, together with an
access type of `a` ++<++log++>++.
. Wait for the logs to fill.
+
The logs contain a dump of the `bofi` driver's internal buffers. This
data is included at the front of the script.
+
Because it can take from a few seconds to several minutes to create the
logs, use the `th++_++manage broadcast` command to check the progress.
. Change to the created test directory and run the master test script.
+
The master script runs each generated test script in sequence. Separate
test scripts are generated per register set.
. Store the results for analysis.
+
Successful test results, such as `success (corruption reported)` and
`success (corruption undetected)`, show that the driver under test is
behaving properly. The results are reported as
`failure (no service impact reported)` if the harness detects that the
driver has failed to report the service impact after reporting a fault,
or if the driver fails to detect that an access or DMA handle has been
marked as faulted.
+
It is fine for a few `test not triggered` failures to appear in the
output. However, several such failures indicate that the test is not
working properly. These failures can appear when the driver does not
access the same registers as when the test scripts were generated.
. Run the test on multiple instances of the driver concurrently to test
the multithreading of error paths.
+
For example, each `th++_++define` command creates a separate directory
that contains test scripts and a master script:
+
....
# th_define -n xyznetdrv -i 0 -a log -e script
# th_define -n xyznetdrv -i 1 -a log -e script
....
+
Once created, run the master scripts in parallel.
+
[NOTE]

The generated scripts produce only simulated fault injections that are
based on what was logged during the time the logging errdef was active.
When you define a workload, ensure that the required results are logged.
Also analyze the resulting logs and fault-injection specifications.
Verify that the hardware access coverage that the resulting test scripts
created is what is required.
===

[[layered-driver-interface-ldi]]
=== Layered Driver Interface (LDI)

Layered Driver Interface

DDI/DKI

The LDI is a set of DDI/DKI that enables a
kernel module to access other devices in the system. The LDI also
enables you to determine which devices are currently being used by
kernel modules.

This chapter covers the following topics:

* link:#kernel-interfaces[Kernel Interfaces]
* link:#user-interfaces[User Interfaces]

[[ldi-overview]]
=== LDI Overview

The LDI includes two categories of interfaces:

* *Kernel interfaces*. User applications use system calls to open, read,
and write to devices that are managed by a device driver within the
kernel. Kernel modules can use the LDI kernel interfaces to open, read,
and write to devices that are managed by another device driver within
the kernel. For example, a user application might use `read(2)` and a
kernel module might use `ldi++_++read(9F)` to read the same device. See
link:#kernel-interfaces[Kernel Interfaces].
* *User interfaces*. The LDI user interfaces can provide information to
user processes regarding which devices are currently being used by other
devices in the kernel. See link:#user-interfaces[User Interfaces].

The following
terms are commonly used in discussing the LDI:

* *Target Device*. A target device is a device within the kernel that is
managed by a device driver and is being accessed by a device consumer.
* *Device Consumer*. A device consumer is a user process or kernel
module that opens and accesses a target device. A device consumer
normally performs operations such as `open`, `read`, `write`, or `ioctl`
on a target device.
* *Kernel Device Consumer*. A kernel device consumer is a particular
kind of device consumer. A kernel device consumer is a kernel module
that accesses a target device. The kernel device consumer usually is not
the device driver that manages the target device that is being accessed.
Instead, the kernel device consumer accesses the target device
indirectly through the device driver that manages the target device.
* *Layered Driver*. A layered driver is a particular kind of kernel
device consumer. A layered driver is a kernel driver that does not
directly manage any piece of hardware. Instead, a layered driver
accesses one of more target devices indirectly through the device
drivers that manage those target devices. Volume managers and STREAMS
multiplexers are good examples of layered drivers.

[[kernel-interfaces]]
=== Kernel Interfaces

Some LDI kernel interfaces enable the LDI
to track and report kernel device usage information. See
link:#layered-identifiers-kernel-device-consumers[Layered Identifiers – Kernel Device Consumers].

Other LDI kernel interfaces enable kernel
modules to perform access operations such as `open`, `read`, and `write`
a target device. These LDI kernel interfaces also enable a kernel device
consumer to query property and event information about target devices.
See link:#layered-driver-handles-target-devices[Layered Driver Handles – Target Devices].

link:#ldi-kernel-interfaces-example[LDI Kernel Interfaces Example] shows an example driver that
uses many of these LDI interfaces.

[[layered-identifiers-kernel-device-consumers]]
==== Layered Identifiers – Kernel Device Consumers

layered identifier

layered identifier

LDI types

ldi++_++ident++_++t

LDI functions

ldi++_++ident++_++from++_++dev

LDI functions

ldi++_++ident++_++from++_++dip

LDI functions

ldi++_++ident++_++from++_++stream

LDI functions

ldi++_++ident++_++release

Layered identifiers enable the LDI to track and report kernel device
usage information. A layered identifier (`ldi++_++ident++_++t`)
identifies a kernel device consumer. Kernel device consumers must obtain
a layered identifier prior to opening a target device using the LDI.

Layered drivers are the only supported types of kernel device consumers.
Therefore, a layered driver must obtain a layered identifier that is
associated with the device number, the device information node, or the
stream of the layered driver. The layered identifier is associated with
the layered driver. The layered identifier is not associated with the
target device.

You can retrieve the kernel device usage information that is collected
by the LDI by using the `libdevinfo(3LIB)` interfaces, the `fuser(8)`
command, or the `prtconf(8)` command. For example, the `prtconf(8)`
command can show which target devices a layered driver is accessing or
which layered drivers are accessing a particular target device. See
link:#user-interfaces[User Interfaces] to learn more about how to retrieve device
usage information.

The following describes the LDI layered identifier interfaces:

`ldi++_++ident++_++t`::
  Layered identifier. An opaque type.
`ldi++_++ident++_++from++_++dev(9F)`::
  Allocate and retrieve a layered identifier that is associated with a
  `dev++_++t` device number.
`ldi++_++ident++_++from++_++dip(9F)`::
  Allocate and retrieve a layered identifier that is associated with a
  `dev++_++info++_++t` device information node.
`ldi++_++ident++_++from++_++stream(9F)`::
  Allocate and retrieve a layered identifier that is associated with a
  stream.
`ldi++_++ident++_++release(9F)`::
  Release a layered identifier that was allocated with
  `ldi++_++ident++_++from++_++dev(9F)`,
  `ldi++_++ident++_++from++_++dip(9F)`, or
  `ldi++_++ident++_++from++_++stream(9F)`.

[[layered-driver-handles-target-devices]]
==== Layered Driver Handles – Target Devices

layered driver handle

layered driver handle

LDI types

ldi++_++handle++_++t

target device

Kernel device consumers must use a layered driver handle
(`ldi++_++handle++_++t`) to access a target device through LDI
interfaces. The `ldi++_++handle++_++t` type is valid only with LDI
interfaces. The LDI allocates and returns this handle when the LDI
successfully opens a device. A kernel device consumer can then use this
handle to access the target device through the LDI interfaces. The LDI
deallocates the handle when the LDI closes the device. See
link:#ldi-kernel-interfaces-example[LDI Kernel Interfaces Example] for an example.

This section discusses how kernel device consumers can access target
devices and retrieve different types of information. See
link:#opening-and-closing-target-devices[Opening and Closing Target Devices] to learn how kernel
device consumers can open and close target devices. See
link:#accessing-target-devices[Accessing Target Devices] to learn how kernel device
consumers can perform operations such as `read`, `write`, `strategy`,
and `ioctl` on target devices. link:#retrieving-target-device-information[Retrieving Target Device
Information] describes interfaces that retrieve target device
information such as device open type and device minor name.
link:#retrieving-target-device-property-values[Retrieving Target Device Property Values] describes
interfaces that retrieve values and address of target device properties.
See link:#receiving-asynchronous-device-event-notification[Receiving Asynchronous Device Event Notification] to
learn how kernel device consumers can receive event notification from
target devices.

[[opening-and-closing-target-devices]]
===== Opening and Closing Target Devices

LDI functions

ldi++_++open++_++by++_++dev

LDI functions

ldi++_++open++_++by++_++devid

LDI functions

ldi++_++open++_++by++_++name

LDI functions

ldi++_++close

LDI functions

This section describes the LDI kernel interfaces for opening and closing
target devices. The open interfaces take a pointer to a layered driver
handle. The open interfaces attempt to open the target device specified
by the device number, device ID, or path name. If the open operation is
successful, the open interfaces allocate and return a layered driver
handle that can be used to access the target device. The close interface
closes the target device associated with the specified layered driver
handle and then frees the layered driver handle.

`ldi++_++handle++_++t`::
  Layered driver handle for target device access. An opaque data
  structure that is returned when a device is successfully opened.
`ldi++_++open++_++by++_++dev(9F)`::
  Open the device specified by the `dev++_++t` device number parameter.
`ldi++_++open++_++by++_++devid(9F)`::
  Open the device specified by the `ddi++_++devid++_++t` device ID
  parameter. You also must specify the minor node name to open.
`ldi++_++open++_++by++_++name(9F)`::
  Open a device by path name. The path name is a null-terminated string
  in the kernel address space. The path name must be an absolute path,
  beginning with a forward slash character (`/`).
`ldi++_++close(9F)`::
  Close a device that was opened with `ldi++_++open++_++by++_++dev(9F)`,
  `ldi++_++open++_++by++_++devid(9F)`, or
  `ldi++_++open++_++by++_++name(9F)`. After `ldi++_++close(9F)` returns,
  the layered driver handle of the device that was closed is no longer
  valid.

[[accessing-target-devices]]
===== Accessing Target Devices

LDI functions

ldi++_++read

LDI functions

ldi++_++aread

LDI functions

ldi++_++write

LDI functions

ldi++_++awrite

LDI functions

ldi++_++strategy

LDI functions

ldi++_++dump

LDI functions

ldi++_++poll

LDI functions

ldi++_++ioctl

LDI functions

ldi++_++devmap

LDI functions

ldi++_++getmsg

LDI functions

ldi++_++putmsg

This section describes the LDI kernel interfaces for accessing target
devices. These interfaces enable a kernel device consumer to perform
operations on the target device specified by the layered driver handle.
Kernel device consumers can perform operations such as `read`, `write`,
`strategy`, and `ioctl` on the target device.

`ldi++_++handle++_++t`::
  Layered driver handle for target device access. An opaque data
  structure.
`ldi++_++read(9F)`::
  Pass a read request to the device entry point for the target device.
  This operation is supported for block, character, and STREAMS devices.
`ldi++_++aread(9F)`::
  Pass an asynchronous read request to the device entry point for the
  target device. This operation is supported for block and character
  devices.
`ldi++_++write(9F)`::
  Pass a write request to the device entry point for the target device.
  This operation is supported for block, character, and STREAMS devices.
`ldi++_++awrite(9F)`::
  Pass an asynchronous write request to the device entry point for the
  target device. This operation is supported for block and character
  devices.
`ldi++_++strategy(9F)`::
  Pass a strategy request to the device entry point for the target
  device. This operation is supported for block and character devices.
`ldi++_++dump(9F)`::
  Pass a dump request to the device entry point for the target device.
  This operation is supported for block and character devices.
`ldi++_++poll(9F)`::
  Pass a poll request to the device entry point for the target device.
  This operation is supported for block, character, and STREAMS devices.
`ldi++_++ioctl(9F)`::
  Pass an `ioctl` request to the device entry point for the target
  device. This operation is supported for block, character, and STREAMS
  devices. The LDI supports STREAMS linking and STREAMS `ioctl`
  commands. See the “STREAM IOCTLS” section of the `ldi++_++ioctl(9F)`
  man page. See also the `ioctl` commands in the `streamio(4I)` man
  page.
`ldi++_++devmap(9F)`::
  Pass a `devmap` request to the device entry point for the target
  device. This operation is supported for block and character devices.
`ldi++_++getmsg(9F)`::
  Get a message block from a stream.
`ldi++_++putmsg(9F)`::
  Put a message block on a stream.

[[retrieving-target-device-information]]
===== Retrieving Target Device Information

device information

LDI functions

ldi++_++get++_++dev

LDI functions

ldi++_++get++_++otyp

LDI functions

ldi++_++get++_++devid

LDI functions

ldi++_++get++_++minor++_++name

LDI functions

ldi++_++get++_++size

ddi++_++devid++_++free

kmem++_++free

This section describes LDI interfaces that kernel device consumers can
use to retrieve device information about a specified target device. A
target device is specified by a layered driver handle. A kernel device
consumer can receive information such as device number, device open
type, device ID, device minor name, and device size.

`ldi++_++get++_++dev(9F)`::
  Get the `dev++_++t` device number for the target device specified by
  the layered driver handle.
`ldi++_++get++_++otyp(9F)`::
  Get the open flag that was used to open the target device specified by
  the layered driver handle. This flag tells you whether the target
  device is a character device or a block device.
`ldi++_++get++_++devid(9F)`::
  Get the `ddi++_++devid++_++t` device ID for the target device
  specified by the layered driver handle. Use
  `ddi++_++devid++_++free(9F)` to free the `ddi++_++devid++_++t` when
  you are finished using the device ID.
`ldi++_++get++_++minor++_++name(9F)`::
  Retrieve a buffer that contains the name of the minor node that was
  opened for the target device. Use `kmem++_++free(9F)` to release the
  buffer when you are finished using the minor node name.
`ldi++_++get++_++size(9F)`::
  Retrieve the partition size of the target device specified by the
  layered driver handle.

[[retrieving-target-device-property-values]]
===== Retrieving Target Device Property Values

device information

property values

LDI functions

ldi++_++prop++_++exists

LDI functions

ldi++_++prop++_++get++_++int

LDI functions

ldi++_++prop++_++get++_++int64

LDI functions

ldi++_++prop++_++lookup++_++int++_++array

LDI functions

ldi++_++prop++_++lookup++_++int64++_++array

LDI functions

ldi++_++prop++_++lookup++_++string

LDI functions

ldi++_++prop++_++lookup++_++string++_++array

LDI functions

ldi++_++prop++_++lookup++_++byte++_++array

This section describes LDI interfaces that kernel device consumers can
use to retrieve property information about a specified target device. A
target device is specified by a layered driver handle. A kernel device
consumer can receive values and addresses of properties and determine
whether a property exists.

`ldi++_++prop++_++exists(9F)`::
  Return `1` if the property exists for the target device specified by
  the layered driver handle. Return `0` if the property does not exist
  for the specified target device.
`ldi++_++prop++_++get++_++int(9F)`::
  Search for an `int` integer property that is associated with the
  target device specified by the layered driver handle. If the integer
  property is found, return the property value.
`ldi++_++prop++_++get++_++int64(9F)`::
  Search for an `int64++_++t` integer property that is associated with
  the target device specified by the layered driver handle. If the
  integer property is found, return the property value.
`ldi++_++prop++_++lookup++_++int++_++array(9F)`::
  Retrieve the address of an `int` integer array property value for the
  target device specified by the layered driver handle.
`ldi++_++prop++_++lookup++_++int64++_++array(9F)`::
  Retrieve the address of an `int64++_++t` integer array property value
  for the target device specified by the layered driver handle.
`ldi++_++prop++_++lookup++_++string(9F)`::
  Retrieve the address of a null-terminated string property value for
  the target device specified by the layered driver handle.
`ldi++_++prop++_++lookup++_++string++_++array(9F)`::
  Retrieve the address of an array of strings. The string array is an
  array of pointers to null-terminated strings of property values for
  the target device specified by the layered driver handle.
`ldi++_++prop++_++lookup++_++byte++_++array(9F)`::
  Retrieve the address of an array of bytes. The byte array is a
  property value of the target device specified by the layered driver
  handle.

[[receiving-asynchronous-device-event-notification]]
===== Receiving Asynchronous Device Event Notification

asynchronous notification

event notification interfaces

ddi++_++eventcookie++_++t

LDI types

ldi++_++callback++_++id++_++t

LDI functions

ldi++_++get++_++eventcookie

LDI functions

ldi++_++add++_++event++_++handler

LDI functions

ldi++_++remove++_++event++_++handler

The LDI enables kernel device consumers to register for event
notification and to receive event notification from target devices. A
kernel device consumer can register an event handler that will be called
when the event occurs. The kernel device consumer must open a device and
receive a layered driver handle before the kernel device consumer can
register for event notification with the LDI event notification
interfaces.

The LDI event notification interfaces enable a kernel device consumer to
specify an event name and to retrieve an associated kernel event cookie.
The kernel device consumer can then pass the layered driver handle
(`ldi++_++handle++_++t`), the cookie (`ddi++_++eventcookie++_++t`), and
the event handler to `ldi++_++add++_++event++_++handler(9F)` to register
for event notification. When registration completes successfully, the
kernel device consumer receives a unique LDI event handler identifier
(`ldi++_++callback++_++id++_++t`). The LDI event handler identifier is
an opaque type that can be used only with the LDI event notification
interfaces.

The LDI provides a framework to register for events generated by other
devices. The LDI itself does not define any event types or provide
interfaces for generating events.

The following describes the LDI asynchronous event notification
interfaces:

`ldi++_++callback++_++id++_++t`::
  Event handler identifier. An opaque type.
`ldi++_++get++_++eventcookie(9F)`::
  Retrieve an event service cookie for the target device specified by
  the layered driver handle.
`ldi++_++add++_++event++_++handler(9F)`::
  Add the callback handler specified by the
  `ldi++_++callback++_++id++_++t` registration identifier. The callback
  handler is invoked when the event specified by the
  `ddi++_++eventcookie++_++t` cookie occurs.
`ldi++_++remove++_++event++_++handler(9F)`::
  Remove the callback handler specified by the
  `ldi++_++callback++_++id++_++t` registration identifier.

[[ldi-kernel-interfaces-example]]
==== LDI Kernel Interfaces Example

This section shows an example kernel device consumer that uses some of
the LDI calls discussed in the preceding sections in this chapter. This
section discusses the following aspects of this example module:

* link:#device-configuration-file[Device Configuration File]
* link:#driver-source-file[Driver Source File]
* link:#test-the-layered-driver[Test the Layered Driver]

This example kernel device consumer is named `lyr`. The `lyr` module is
a layered driver that uses LDI calls to send data to a target device. In
its `open(9E)` entry point, the `lyr` driver opens the device that is
specified by the `lyr++_++targ` property in the `lyr.conf` configuration
file. In its `write(9E)` entry point, the `lyr` driver writes all of its
incoming data to the device specified by the `lyr++_++targ` property.

[[device-configuration-file]]
===== Device Configuration File

In the configuration file shown below, the target device that the `lyr`
driver is writing to is the console.

[[euayx]]
Configuration File

....
#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident   "%Z%%M% %I% %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";
....

[[driver-source-file]]
===== Driver Source File

state structure

soft state information

layered driver handle

layered identifier

In the driver source file shown below, the `lyr++_++state++_++t`
structure holds the soft state for the `lyr` driver. The soft state
includes the layered driver handle (`lh`) for the `lyr++_++targ` device
and the layered identifier (`li`) for the `lyr` device. For more
information on soft state, see link:#retrieving-driver-soft-state-information[Retrieving Driver Soft State
Information].

In the `lyr++_++open` entry
point, `ddi++_++prop++_++lookup++_++string(9F)` retrieves from the
`lyr++_++targ` property the name of the target device for the `lyr`
device to open. The `ldi++_++ident++_++from++_++dev(9F)` function gets
an LDI layered identifier for the `lyr` device. The
`ldi++_++open++_++by++_++name(9F)` function opens the `lyr++_++targ`
device and gets a layered driver handle for the `lyr++_++targ` device.

Note that if any failure
occurs in `lyr++_++open`, the `ldi++_++close(9F)`,
`ldi++_++ident++_++release(9F)`, and `ddi++_++prop++_++free(9F)` calls
undo everything that was done. The `ldi++_++close(9F)` function closes
the `lyr++_++targ` device. The `ldi++_++ident++_++release(9F)` function
releases the `lyr` layered identifier. The `ddi++_++prop++_++free(9F)`
function frees resources allocated when the `lyr++_++targ` device name
was retrieved. If no failure occurs, the `ldi++_++close(9F)` and
`ldi++_++ident++_++release(9F)` functions are called in the
`lyr++_++close` entry point.

In the last line of the driver module, the
`ldi++_++write(9F)` function is called. The `ldi++_++write(9F)` function
takes the data written to the `lyr` device in the `lyr++_++write` entry
point and writes that data to the `lyr++_++targ` device. The
`ldi++_++write(9F)` function uses the layered driver handle for the
`lyr++_++targ` device to write the data to the `lyr++_++targ` device.

[[euayy]]
Driver Source File

[source,c]
----
#include <sys/types.h>
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/open.h>
#include <sys/cred.h>
#include <sys/cmn_err.h>
#include <sys/modctl.h>
#include <sys/conf.h>
#include <sys/stat.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#include <sys/sunldi.h>

typedef struct lyr_state {
    ldi_handle_t    lh;
    ldi_ident_t     li;
    dev_info_t      *dip;
    minor_t     minor;
    int         flags;
    kmutex_t    lock;
} lyr_state_t;

#define LYR_OPENED      0x1     /* lh is valid */
#define LYR_IDENTED     0x2     /* li is valid */

static int lyr_info(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int lyr_attach(dev_info_t *, ddi_attach_cmd_t);
static int lyr_detach(dev_info_t *, ddi_detach_cmd_t);
static int lyr_open(dev_t *, int, int, cred_t *);
static int lyr_close(dev_t, int, int, cred_t *);
static int lyr_write(dev_t, struct uio *, cred_t *);

static void *lyr_statep;

static struct cb_ops lyr_cb_ops = {
    lyr_open,       /* open */
    lyr_close,      /* close */
    nodev,      /* strategy */
    nodev,      /* print */
    nodev,      /* dump */
    nodev,      /* read */
    lyr_write,      /* write */
    nodev,      /* ioctl */
    nodev,      /* devmap */
    nodev,      /* mmap */
    nodev,      /* segmap */
    nochpoll,       /* poll */
    ddi_prop_op,    /* prop_op */
    NULL,       /* streamtab  */
    D_NEW | D_MP,   /* cb_flag */
    CB_REV,     /* cb_rev */
    nodev,      /* aread */
    nodev       /* awrite */
};

static struct dev_ops lyr_dev_ops = {
    DEVO_REV,       /* devo_rev, */
    0,          /* refcnt  */
    lyr_info,       /* getinfo */
    nulldev,    /* identify */
    nulldev,    /* probe */
    lyr_attach,     /* attach */
    lyr_detach,     /* detach */
    nodev,      /* reset */
    &lyr_cb_ops,    /* cb_ops */
    NULL,       /* bus_ops */
    NULL        /* power */
};

static struct modldrv modldrv = {
    &mod_driverops,
    "LDI example driver",
    &lyr_dev_ops
};

static struct modlinkage modlinkage = {
    MODREV_1,
    &modldrv,
};

_init(void)
{
    int rv;

    if ((rv = ddi_soft_state_init(&lyr_statep, sizeof (lyr_state_t),
        0)) != 0) {
        cmn_err(CE_WARN, "lyr _init: soft state init failed\n");
        return (rv);
    }
    if ((rv = mod_install(&modlinkage)) != 0) {
        cmn_err(CE_WARN, "lyr _init: mod_install failed\n");
        goto FAIL;
    }
    return (rv);
    /*NOTEREACHED*/
FAIL:
    ddi_soft_state_fini(&lyr_statep);
    return (rv);
}

_info(struct modinfo *modinfop)
{
    return (mod_info(&modlinkage, modinfop));
}

_fini(void)
{
    int rv;

    if ((rv = mod_remove(&modlinkage)) != 0) {
        return(rv);
    }
    ddi_soft_state_fini(&lyr_statep);
    return (rv);
}
/*
 * 1:1 mapping between minor number and instance
 */
static int
lyr_info(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
{
    int inst;
    minor_t minor;
    lyr_state_t *statep;
    char *myname = "lyr_info";

    minor = getminor((dev_t)arg);
    inst = minor;
    switch (infocmd) {
    case DDI_INFO_DEVT2DEVINFO:
        statep = ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: get soft state "
                "failed on inst %d\n", myname, inst);
            return (DDI_FAILURE);
        }
        *result = (void *)statep->dip;
        break;
    case DDI_INFO_DEVT2INSTANCE:
        *result = (void *)inst;
        break;
    default:
        break;
    }

    return (DDI_SUCCESS);
}

static int
lyr_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_attach";

    switch (cmd) {
    case DDI_ATTACH:
        inst = ddi_get_instance(dip);

        if (ddi_soft_state_zalloc(lyr_statep, inst) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_soft_state_zallac failed "
                "on inst %d\n", myname, inst);
            goto FAIL;
        }
        statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        statep->dip = dip;
        statep->minor = inst;
        if (ddi_create_minor_node(dip, "node", S_IFCHR, statep->minor,
            DDI_PSEUDO, 0) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_create_minor_node failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        mutex_init(&statep->lock, NULL, MUTEX_DRIVER, NULL);
        return (DDI_SUCCESS);
    case DDI_RESUME:
    case DDI_PM_RESUME:
    default:
        break;
    }
    return (DDI_FAILURE);
    /*NOTREACHED*/
FAIL:
    ddi_soft_state_free(lyr_statep, inst);
    ddi_remove_minor_node(dip, NULL);
    return (DDI_FAILURE);
}

static int
lyr_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_detach";

    inst = ddi_get_instance(dip);
    statep = ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: get soft state failed on "
            "inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    if (statep->dip != dip) {
        cmn_err(CE_WARN, "%s: soft state does not match devinfo "
            "on inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    switch (cmd) {
    case DDI_DETACH:
        mutex_destroy(&statep->lock);
        ddi_soft_state_free(lyr_statep, inst);
        ddi_remove_minor_node(dip, NULL);
        return (DDI_SUCCESS);
    case DDI_SUSPEND:
    case DDI_PM_SUSPEND:
    default:
        break;
    }
    return (DDI_FAILURE);
}
/*
 * on this driver's open, we open the target specified by a property and store
 * the layered handle and ident in our soft state.  a good target would be
 * "/dev/console" or more interestingly, a pseudo terminal as specified by the
 * tty command
 */
/*ARGSUSED*/
static int
lyr_open(dev_t *devtp, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(*devtp);
    lyr_state_t *statep;
    char *myname = "lyr_open";
    dev_info_t *dip;
    char *lyr_targ = NULL;

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    dip = statep->dip;
    /*
     * our target device to open should be specified by the "lyr_targ"
     * string property, which should be set in this driver's .conf file
     */
    if (ddi_prop_lookup_string(DDI_DEV_T_ANY, dip, DDI_PROP_NOTPROM,
        "lyr_targ", &lyr_targ) != DDI_PROP_SUCCESS) {
        cmn_err(CE_WARN, "%s: ddi_prop_lookup_string failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    /*
     * since we only have one pair of lh's and li's available, we don't
     * allow multiple on the same instance
     */
    mutex_enter(&statep->lock);
    if (statep->flags & (LYR_OPENED | LYR_IDENTED)) {
        cmn_err(CE_WARN, "%s: multiple layered opens or idents "
            "from inst %d not allowed\n", myname, inst);
        mutex_exit(&statep->lock);
        ddi_prop_free(lyr_targ);
        return (EIO);
    }
    rv = ldi_ident_from_dev(*devtp, &statep->li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_ident_from_dev failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep->flags |= LYR_IDENTED;
    rv = ldi_open_by_name(lyr_targ, FREAD | FWRITE, credp, &statep->lh,
        statep->li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_open_by_name failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep->flags |= LYR_OPENED;
    cmn_err(CE_CONT, "\n%s: opened target '%s' successfully on inst %d\n",
        myname, lyr_targ, inst);
    rv = 0;

FAIL:
    /* cleanup on error */
    if (rv != 0) {
        if (statep->flags & LYR_OPENED)
            (void)ldi_close(statep->lh, FREAD | FWRITE, credp);
        if (statep->flags & LYR_IDENTED)
            ldi_ident_release(statep->li);
        statep->flags &= ~(LYR_OPENED | LYR_IDENTED);
    }
    mutex_exit(&statep->lock);
    if (lyr_targ != NULL)
        ddi_prop_free(lyr_targ);
    return (rv);
}
/*
 * on this driver's close, we close the target indicated by the lh member
 * in our soft state and release the ident, li as well.  in fact, we MUST do
 * both of these at all times even if close yields an error because the
 * device framework effectively closes the device, releasing all data
 * associated with it and simply returning whatever value the target's
 * close(9E) returned.  therefore, we must as well.
 */
/*ARGSUSED*/
static int
lyr_close(dev_t devt, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_close";
    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    mutex_enter(&statep->lock);
    rv = ldi_close(statep->lh, FREAD | FWRITE, credp);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_close failed on inst %d, but will ",
            "continue to release ident\n", myname, inst);
    }
    ldi_ident_release(statep->li);
    if (rv == 0) {
        cmn_err(CE_CONT, "\n%s: closed target successfully on "
            "inst %d\n", myname, inst);
    }
    statep->flags &= ~(LYR_OPENED | LYR_IDENTED);
    mutex_exit(&statep->lock);
    return (rv);
}
/*
 * echo the data we receive to the target
 */
/*ARGSUSED*/
static int
lyr_write(dev_t devt, struct uio *uiop, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_write";

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    return (ldi_write(statep->lh, uiop, credp));
}
----

. Compile the driver.
+
Use the `D++_++KERNEL` option to indicate that this is a kernel module.
* If you are compiling for a SPARC architecture, use the `xarch=v9`
option:
+
....
% cc -c -D_KERNEL -xarch=v9 lyr.c
....
* If you are compiling for a 32-bit x86 architecture, use the following
command:
+
....
% cc -c -D_KERNEL lyr.c
....
. Link the driver.
+
....
% ld -r -o lyr lyr.o
....
. Install the configuration file.
+
As user `root`, copy the configuration file to the kernel driver area of
the machine:
+
....
# cp lyr.conf /usr/kernel/drv
....
. Install the driver binary.
* As user `root`, copy the driver binary to the `sparcv9` driver area on
a SPARC architecture:
+
....
# cp lyr /usr/kernel/drv/sparcv9
....
* As user `root`, copy the driver binary to the `drv` driver area on a
32-bit x86 architecture:
+
....
# cp lyr /usr/kernel/drv
....
. Load the driver.
+
As user `root`, use the `add++_++drv(8)` command to load the driver.
+
....
# add_drv lyr
....
+
List the pseudo devices to confirm that the `lyr` device now exists:
+
....
# ls /devices/pseudo | grep lyr
lyr@1
lyr@1:node
....

[[test-the-layered-driver]]
===== Test the Layered Driver

To test the `lyr` driver, write a message to the `lyr` device and verify
that the message displays on the `lyr++_++targ` device.

[[exegr]]
Write a Short Message to the Layered Device

In this example, the `lyr++_++targ` device is the console of the system
where the `lyr` device is installed.

If the display you are viewing is also the display for the console
device of the system where the `lyr` device is installed, note that
writing to the console will corrupt your display. The console messages
will appear outside your window system. You will need to redraw or
refresh your display after testing the `lyr` driver.

If the display you are viewing is not the display for the console device
of the system where the `lyr` device is installed, log into or otherwise
gain a view of the display of the target console device.

The following command writes a very brief message to the `lyr` device:

....
# echo "\n\n\t===> Hello World!! <===\n" > /devices/pseudo/lyr@1:node
....

You should see the following messages displayed on the target console:

....
console login:

    ===> Hello World!! <===

lyr: 
lyr_open: opened target '/dev/console' successfully on inst 1
lyr: 
lyr_close: closed target successfully on inst 1
....

The messages from `lyr++_++open` and `lyr++_++close`
come from the `cmn++_++err(9F)` calls in the `lyr++_++open` and
`lyr++_++close` entry points.

[[exegt]]
Write a Longer Message to the Layered Device

The following command writes a longer message to the `lyr` device:

....
# cat lyr.conf > /devices/pseudo/lyr@1:node
....

You should see the following messages displayed on the target console:

....
lyr: 
lyr_open: opened target '/dev/console' successfully on inst 1
#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident   "%Z%%M% %I%     %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";
lyr: 
lyr_close: closed target successfully on inst 1
....

[[exegu]]
Change the Target Device

To change the target device, edit
`/usr/kernel/drv/lyr.conf` and change the value of the `lyr++_++targ`
property to be a path to a different target device. For example, the
target device could be the output of a `tty` command in a local
terminal. An example of such a device path is `/dev/pts/4`.

Make sure the `lyr` device is not in use before you update the driver to
use the new target device.

....
# modinfo -c | grep lyr
174          3 lyr                              UNLOADED/UNINSTALLED
....

Use the `update++_++drv(8)` command to reload the `lyr.conf`
configuration file:

....
# update_drv lyr
....

Write a message to the `lyr` device again and verify that the message
displays on the new `lyr++_++targ` device.

[[user-interfaces]]
=== User Interfaces

device layering

device layering

device usage

device information library

The LDI includes user-level library and command interfaces to report
device layering and usage information. link:#device-information-library-interfaces[Device Information
Library Interfaces] discusses the `libdevinfo(3LIB)` interfaces for
reporting device layering information. link:#print-system-configuration-command-interfaces[Print System
Configuration Command Interfaces] discusses the `prtconf(8)` interfaces
for reporting kernel device usage information. link:#device-user-command-interfaces[Device User
Command Interfaces] discusses the `fuser(8)` interfaces for reporting
device consumer information.

[[device-information-library-interfaces]]
==== Device Information Library Interfaces

device information

The LDI includes `libdevinfo(3LIB)` interfaces that report a snapshot of
device layering information. Device layering occurs when one device in
the system is a consumer of another device in the system. Device
layering information is reported only if both the consumer and the
target are bound to a device node that is contained within the snapshot.

Device layering information is reported by the `libdevinfo(3LIB)`
interfaces as a directed graph. An _lnode_ is an abstraction that
represents a vertex in the graph and is bound to a device node. You can
use `libdevinfo(3LIB)` interfaces to access properties of an lnode, such
as the name and device number of the node.

The edges in the graph are represented by a link. A link has a source
lnode that represents the device consumer. A link also has a target
lnode that represents the target device.

following describes the `libdevinfo(3LIB)` device layering information
interfaces:

`DINFOLYR`::
  Snapshot flag that enables you to capture device layering information.
`di++_++link++_++t`::
  A directed link between two endpoints. Each endpoint is a
  `di++_++lnode++_++t`. An opaque structure.
`di++_++lnode++_++t`::
  The endpoint of a link. An opaque structure. A `di++_++lnode++_++t` is
  bound to a `di++_++node++_++t`.
`di++_++node++_++t`::
  Represents a device node. An opaque structure. A `di++_++node++_++t`
  is not necessarily bound to a `di++_++lnode++_++t`.
`di++_++walk++_++link(3DEVINFO)`::
  Walk all links in the snapshot.
`di++_++walk++_++lnode(3DEVINFO)`::
  Walk all lnodes in the snapshot.
`di++_++link++_++next++_++by++_++node(3DEVINFO)`::
  Get a handle to the next link where the specified `di++_++node++_++t`
  node is either the source or the target.
`di++_++link++_++next++_++by++_++lnode(3DEVINFO)`::
  Get a handle to the next link where the specified `di++_++lnode++_++t`
  lnode is either the source or the target.
`di++_++link++_++to++_++lnode(3DEVINFO)`::
  Get the lnode that corresponds to the specified endpoint of a
  `di++_++link++_++t` link.
`di++_++link++_++spectype(3DEVINFO)`::
  Get the link spectype. The spectype indicates how the target device is
  being accessed. The target device is represented by the target lnode.
`di++_++lnode++_++next(3DEVINFO)`::
  Get a handle to the next occurrence of the specified
  `di++_++lnode++_++t` lnode associated with the specified
  `di++_++node++_++t` device node.
`di++_++lnode++_++name(3DEVINFO)`::
  Get the name that is associated with the specified lnode.
`di++_++lnode++_++devinfo(3DEVINFO)`::
  Get a handle to the device node that is associated with the specified
  lnode.
`di++_++lnode++_++devt(3DEVINFO)`::
  Get the device number of the device node that is associated with the
  specified lnode.

The device layering information returned by the LDI can be quite
complex. Therefore, the LDI provides interfaces to help you traverse the
device tree and the device usage graph. These interfaces enable the
consumer of a device tree snapshot to associate custom data pointers
with different structures within the snapshot. For example, as an
application traverses lnodes, the application can update the custom
pointer associated with each lnode to mark which lnodes already have
been seen.

The following
describes the `libdevinfo(3LIB)` node and link marking interfaces:

`di++_++lnode++_++private++_++set(3DEVINFO)`::
  Associate the specified data with the specified lnode. This
  association enables you to traverse lnodes in the snapshot.
`di++_++lnode++_++private++_++get(3DEVINFO)`::
  Retrieve a pointer to data that was associated with an lnode through a
  call to `di++_++lnode++_++private++_++set(3DEVINFO)`.
`di++_++link++_++private++_++set(3DEVINFO)`::
  Associate the specified data with the specified link. This association
  enables you to traverse links in the snapshot.
`di++_++link++_++private++_++get(3DEVINFO)`::
  Retrieve a pointer to data that was associated with a link through a
  call to `di++_++link++_++private++_++set(3DEVINFO)`.

[[print-system-configuration-command-interfaces]]
==== Print System Configuration Command Interfaces

displaying kernel device usage information

device usage

The `prtconf(8)` command is enhanced to display kernel device usage
information. The default `prtconf(8)` output is not changed. Device
usage information is displayed when you specify the verbose option (`v`)
with the `prtconf(8)` command. Usage information about a particular
device is displayed when you specify a path to that device on the
`prtconf(8)` command line.

`prtconf -v`::
  Display device minor node and device usage information. Show kernel
  consumers and the minor nodes each kernel consumer currently has open.
`prtconf` ++<++path++>++::
  Display device usage information for the device specified by
  ++<++path++>++.
`prtconf -a` ++<++path++>++::
  Display device usage information for the device specified by
  ++<++path++>++ and all device nodes that are ancestors of
  ++<++path++>++.
`prtconf -c` ++<++path++>++::
  Display device usage information for the device specified by
  ++<++path++>++ and all device nodes that are children of
  ++<++path++>++.

[[exegp]]
Device Usage Information

When you want usage information about a particular device, the value of
the ++<++path++>++ parameter can be any valid device path.

....
% prtconf /dev/cfg/c0
SUNW,isptwo, instance #0
....

[[exegs]]
Ancestor Node Usage Information

To display usage information about a particular device and all device
nodes that are ancestors of that particular device, specify the `a` flag
with the `prtconf(8)` command. Ancestors include all nodes up to the
root of the device tree. If you specify the `a` flag with the
`prtconf(8)` command, then you must also specify a device ++<++path++>++
name.

....
% prtconf -a /dev/cfg/c0
SUNW,Sun-Fire
    ssm, instance #0
        pci, instance #0
            pci, instance #0
                SUNW,isptwo, instance #0
....

[[exegw]]
Child Node Usage Information

To display usage information about a particular device and all device
nodes that are children of that particular device, specify the `c` flag
with the `prtconf(8)` command. If you specify the `c` flag with the
`prtconf(8)` command, then you must also specify a device ++<++path++>++
name.

....
% prtconf -c /dev/cfg/c0
SUNW,isptwo, instance #0
    sd (driver not attached)
    st (driver not attached)
    sd, instance #1
    sd, instance #0
    sd, instance #6
    st, instance #1 (driver not attached)
    st, instance #0 (driver not attached)
    st, instance #2 (driver not attached)
    st, instance #3 (driver not attached)
    st, instance #4 (driver not attached)
    st, instance #5 (driver not attached)
    st, instance #6 (driver not attached)
    ses, instance #0 (driver not attached)
    ...
....

[[exego]]
Layering and Device Minor Node Information – Keyboard

To display device layering and device minor node information about a
particular device, specify the `v` flag with the `prtconf(8)` command.

....
% prtconf -v /dev/kbd
conskbd, instance #0
    System properties:
        ...
    Device Layered Over:
        mod=kb8042 dev=(101,0)
            dev_path=/isa/i8042@1,60/keyboard@0
    Device Minor Nodes:
        dev=(103,0)
            dev_path=/pseudo/conskbd@0:kbd
                spectype=chr type=minor
                dev_link=/dev/kbd
        dev=(103,1)
            dev_path=/pseudo/conskbd@0:conskbd
                spectype=chr type=internal
            Device Minor Layered Under:
                mod=wc accesstype=chr
                    dev_path=/pseudo/wc@0
....

This example shows that the `/dev/kbd` device is layered on top of the
hardware keyboard device (`/isa/i8042@1,60/keyboard@0`). This example
also shows that the `/dev/kbd` device has two device minor nodes. The
first minor node has a `/dev` link that can be used to access the node.
The second minor node is an internal node that is not accessible through
the file system. The second minor node has been opened by the `wc`
driver, which is the workstation console. Compare the output from this
example to the output from link:#exegq[example++_++title].

[[exegn]]
Layering and Device Minor Node Information – Network Device

This example shows which devices are using the currently plumbed network
device.

....
% prtconf -v /dev/iprb0
pci1028,145, instance #0
    Hardware properties:
        ...
    Interrupt Specifications:
        ...
    Device Minor Nodes:
        dev=(27,1)
            dev_path=/pci@0,0/pci8086,244e@1e/pci1028,145@c:iprb0
                spectype=chr type=minor
                alias=/dev/iprb0
        dev=(27,4098)
            dev_path=<clone>
            Device Minor Layered Under:
                mod=udp6 accesstype=chr
                    dev_path=/pseudo/udp6@0
        dev=(27,4097)
            dev_path=<clone>
            Device Minor Layered Under:
                mod=udp accesstype=chr
                    dev_path=/pseudo/udp@0
        dev=(27,4096)
            dev_path=<clone>
            Device Minor Layered Under:
                mod=udp accesstype=chr
                    dev_path=/pseudo/udp@0
....

This example shows that the `iprb0` device has been linked under `udp`
and `udp6`. Notice that no paths are shown to the minor nodes that `udp`
and `udp6` are using. No paths are shown in this case because the minor
nodes were created through `clone` opens of the `iprb` driver, and
therefore there are no file system paths by which these nodes can be
accessed. Compare the output from this example to the output from
link:#exegv[example++_++title].

[[device-user-command-interfaces]]
==== Device User Command Interfaces

display device usage information

device usage

The `fuser(8)` command is enhanced to display device usage information.
The `fuser(8)` command displays device usage information only if
++<++path++>++ represents a device minor node. The `d` flag is valid for
the `fuser(8)` command only if you specify a ++<++path++>++ that
represents a device minor node.

`fuser` ++<++path++>++::
  Display information about application device consumers and kernel
  device consumers if ++<++path++>++ represents a device minor node.
`fuser -d` ++<++path++>++::
  Display all users of the underlying device that is associated with the
  device minor node represented by ++<++path++>++.

Kernel device consumers are reported in one of the following four
formats. Kernel device consumers always are surrounded by square
brackets (`++[]++`).

....
        [kernel_module_name]
        [kernel_module_name,dev_path=path]
        [kernel_module_name,dev=(major,minor)]
        [kernel_module_name,dev=(major,minor),dev_path=path]
....

When the `fuser(8)` command displays file or device users, the output
consists of a process ID on `stdout` followed by a character on
`stderr`. The character on `stderr` describes how the file or device is
being used. All kernel consumer information is displayed to `stderr`. No
kernel consumer information is displayed to `stdout`.

If you do not use the `d` flag, then the `fuser(8)` command reports
consumers of only the device minor node that is specified by
++<++path++>++. If you use the `d` flag, then the `fuser(8)` command
reports consumers of the device node that underlies the minor node
specified by ++<++path++>++. The following example illustrates the
difference in report output in these two cases.

[[exegv]]
Consumers of Underlying Device Nodes

Most network devices clone their minor node when the device is opened.
If you request device usage information for the clone minor node, the
usage information might show that no process is using the device. If
instead you request device usage information for the underlying device
node, the usage information might show that a process is using the
device. In this example, no device consumers are reported when only a
device ++<++path++>++ is passed to the `fuser(8)` command. When the `d`
flag is used, the output shows that the device is being accessed by
`udp` and `udp6`.

....
% fuser /dev/iprb0
/dev/iprb0:
% fuser -d /dev/iprb0
/dev/iprb0:  [udp,dev_path=/pseudo/udp@0] [udp6,dev_path=/pseudo/udp6@0]
....

Compare the output from this example to the output from
link:#exegn[example++_++title].

[[exegq]]
Consumer of the Keyboard Device

In this example, a kernel consumer is accessing `/dev/kbd`. The kernel
consumer that is accessing the `/dev/kbd` device is the workstation
console driver.

....
% fuser -d /dev/kbd
/dev/kbd:  [genunix] [wc,dev_path=/pseudo/wc@0]
....

Compare the output from this example to the output from
link:#exego[example++_++title].

== Designing Specific Kinds of Device Drivers

The second part of the book provides design information that is specific
to the type of driver:

* link:#drivers-for-character-devices[Drivers for Character Devices] describes drivers
for character-oriented devices.
* link:#drivers-for-block-devices[Drivers for Block Devices] describes drivers for a
block-oriented devices.
* link:#scsi-target-drivers[SCSI Target Drivers] outlines the Sun Common SCSI
Architecture (SCSA) and the requirements for SCSI target drivers.
* link:#scsi-host-bus-adapter-drivers[SCSI Host Bus Adapter Drivers] explains how to
apply SCSA to SCSI Host Bus Adapter (HBA) drivers.
* link:#drivers-for-network-devices[Drivers for Network Devices] describes the Generic LAN
driver (GLD), a illumos network driver that uses STREAMS technology and
the Data Link Provider Interface (DLPI).
* link:#usb-drivers[USB Drivers] describes how to write a client USB device
driver using the USBA 2.0 framework.

[[drivers-for-character-devices]]
=== Drivers for Character Devices

A _character device_ does not have physically addressable storage media,
such as tape drives or serial ports, where I/O is normally performed in
a byte stream. This chapter describes the structure of a character
device driver, focusing in particular on entry points for character
drivers. In addition, this chapter describes the use of `physio(9F)` and
`aphysio(9F)` in the context of synchronous and asynchronous I/O
transfers.

This chapter provides information on the following subjects:

* link:#overview-of-the-character-driver-structure[Overview of the Character Driver Structure]
* link:#character-device-autoconfiguration[Character Device Autoconfiguration]
* link:#device-access-character-drivers[Device Access (Character Drivers)]
* link:#io-request-handling[I/O Request Handling]
* link:#mapping-device-memory[Mapping Device Memory]
* link:#multiplexing-io-on-file-descriptors[Multiplexing I/O on File Descriptors]
* link:#miscellaneous-io-control[Miscellaneous I/O Control]
* link:#32-bit-and-64-bit-data-structure-macros[32-bit and 64-bit Data Structure Macros]

[[overview-of-the-character-driver-structure]]
=== Overview of the Character Driver Structure

link:#character-fig-3[Character Driver Roadmap] shows data structures
and routines that define the structure of a character device driver.
Device drivers typically include the following elements:

* Device-loadable driver section
* Device configuration section
* Character driver entry points

The shaded device access section in the following figure illustrates
character driver entry points.

.Character Driver Roadmap
[#character-fig-3]
image::figures/character-view.png[Diagram shows structures and entry points for character device drivers.]

Associated with each device driver is a `dev++_++ops(9S)` structure,
which in turn refers to a `cb++_++ops(9S)` structure. These structures
contain pointers to the driver entry points:

* `open(9E)`
* `close(9E)`
* `read(9E)`
* `write(9E)`
* `ioctl(9E)`
* `chpoll(9E)`
* `aread(9E)`
* `awrite(9E)`
* `mmap(9E)`
* `devmap(9E)`
* `segmap(9E)`
* `prop++_++op(9E)`

[NOTE]

Some
of these entry points can be replaced with `nodev(9F)` or `nulldev(9F)`
as appropriate.
===

[[character-device-autoconfiguration]]
=== Character Device Autoconfiguration

`attach(9E)` routine should perform the common initialization tasks that
all devices require, such as:

* Allocating per-instance state structures
* Registering device interrupts
* Mapping the device's registers
* Initializing mutex variables and condition variables
* Creating power-manageable components
* Creating minor nodes

See link:#attach-entry-point[ Entry Point] for code examples of these tasks.

Character device drivers create minor
nodes of type `S++_++IFCHR`. A minor node of `S++_++IFCHR` causes a
character special file that represents the node to eventually appear in
the `/devices` hierarchy.

The following example shows a typical `attach(9E)` routine for character
drivers. Properties that are associated with the device are commonly
declared in an `attach` routine. This example uses a predefined `Size`
property. `Size` is the equivalent of the `Nblocks` property for getting
the size of partition in a block device. If, for example, you are doing
character I/O on a disk device, you might use `Size` to get the size of
a partition. Since `Size` is a 64-bit property, you must use a 64-bit
property interface. In this case, you use
`ddi++_++prop++_++update++_++int64(9F)`. See link:#device-properties[Device
Properties] for more information about properties.

[[character-40982]]
Character Driver `attach` Routine

[source,c]
----
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
  int instance = ddi_get_instance(dip);
  switch (cmd) {
  case DDI_ATTACH:
      /*
       * Allocate a state structure and initialize it.
       * Map the device's registers.
       * Add the device driver's interrupt handler(s).
       * Initialize any mutexes and condition variables.
       * Create power manageable components.
       *
       * Create the device's minor node. Note that the node_type
       * argument is set to DDI_NT_TAPE.
       */
       if (ddi_create_minor_node(dip, minor_name, S_IFCHR,
           instance, DDI_NT_TAPE, 0) == DDI_FAILURE)
{
           /* Free resources allocated so far. */
           /* Remove any previously allocated minor nodes. */
           ddi_remove_minor_node(dip, NULL);
           return (DDI_FAILURE);
       }
      /*
       * Create driver properties like "Size." Use "Size"
       * instead of "size" to ensure the property works
       * for large bytecounts.
       */
       xsp->Size = size_of_device_in_bytes;
       maj_number = ddi_driver_major(dip);
       if (ddi_prop_update_int64(makedevice(maj_number, instance),
           dip, "Size", xsp->Size) != DDI_PROP_SUCCESS) {
           cmn_err(CE_CONT, "%s: cannot create Size property\n",
               ddi_get_name(dip));
               /* Free resources allocated so far. */
           return (DDI_FAILURE);
       }
      /* ... */
      return (DDI_SUCCESS);
case DDI_RESUME:
      /* See the "Power Management" chapter in this book. */
default:
      return (DDI_FAILURE);
  }
}
----

[[device-access-character-drivers]]
=== Device Access (Character Drivers)

Access to a device by one or more
application programs is controlled through the `open(9E)` and
`close(9E)` entry points. An `open(2)` system call to a special file
representing a character device always causes a call to the `open(9E)`
routine for the driver. For a particular minor device, `open(9E)` can be
called many times. The `close(9E)` routine is called only when the final
reference to a device is removed. If the device is accessed through file
descriptors, the final call to `close(9E)` can occur as a result of a
`close(2)` or `exit(2)` system call. If the device is accessed through
memory mapping, the final call to `close(9E)` can occur as a result of a
`munmap(2)` system call.

[[open-entry-point-character-drivers]]
==== `open` Entry Point (Character Drivers)

device access functions

character drivers

character device driver

The primary function of `open` is to verify that the open request is
allowed. The syntax for `open(9E)` is as follows:

[source,c]
----
int xxopen(dev_t *devp, int flag, int otyp, cred_t *credp);
----

where:

++<++devp++>++::
  Pointer to a device number. The `open` routine is passed a pointer so
  that the driver can change the minor number. With this pointer,
  drivers can dynamically create minor instances of the device. An
  example would be a pseudo terminal driver that creates a new
  pseudo-terminal whenever the driver is opened. A driver that
  dynamically chooses the minor number normally creates only one minor
  device node in `attach(9E)` with
  `ddi++_++create++_++minor++_++node(9F)`, then changes the minor number
  component of `++*++devp` using `makedevice(9F)` and `getmajor(9F)`:
  +
....
*devp = makedevice(getmajor(*devp), new_minor);
....
  +
  You do not have to call `ddi++_++create++_++minor++_++node(9F)` for
  the new minor. A driver must not change the major number of
  `++*++devp`. The driver must keep track of available minor numbers
  internally.
++<++flag++>++::
  Flag with bits to indicate whether the device is opened for reading
  (`FREAD`), writing (`FWRITE`), or both. User threads issuing the
  `open(2)` system call can also request exclusive access to the device
  (`FEXCL`) or specify that the open should not block for any reason
  (`FNDELAY`), but the driver must enforce both cases. A driver for a
  write-only device such as a printer might consider an `open(9E)` for
  reading invalid.
++<++otyp++>++::
  Integer that indicates how `open` was called. The driver must check
  that the value of ++<++otyp++>++ is appropriate for the device. For
  character drivers, ++<++otyp++>++ should be `OTYP++_++CHR` (see the
  `open(9E)` man page).
++<++credp++>++::
  Pointer to a credential structure containing information about the
  caller, such as the user ID and group IDs. Drivers should not examine
  the structure directly, but should instead use `drv++_++priv(9F)` to
  check for the common case of root privileges. In this example, only
  `root` or a user with the PRIV++_++SYS++_++DEVICES privilege is
  allowed to open the device for writing.

The following example shows a character driver `open(9E)` routine.

[[character-27851]]
Character Driver `open(9E)` Routine

[source,c]
----
static int
xxopen(dev_t *devp, int flag, int otyp, cred_t *credp)
{
    minor_t        instance;

    if (getminor(*devp)         /* if device pointer is invalid */
        return (EINVAL);
    instance = getminor(*devp); /* one-to-one example mapping */
    /* Is the instance attached? */
    if (ddi_get_soft_state(statep, instance) == NULL)
        return (ENXIO);
    /* verify that otyp is appropriate */
    if (otyp != OTYP_CHR)
        return (EINVAL);
    if ((flag & FWRITE) && drv_priv(credp) == EPERM)
        return (EPERM);
    return (0);
}
----

[[close-entry-point-character-drivers]]
==== `close` Entry Point (Character Drivers)

The syntax for `close(9E)` is as follows:

[source,c]
----
int xxclose(dev_t dev, int flag, int otyp, cred_t *credp);
----

`close`
should perform any cleanup necessary to finish using the minor device,
and prepare the device (and driver) to be opened again. For example, the
open routine might have been invoked with the exclusive access (`FEXCL`)
flag. A call to `close(9E)` would allow additional open routines to
continue. Other functions that `close(9E)` might perform are:

* Waiting for I/O to drain from output buffers before returning
* Rewinding a tape (tape device)
* Hanging up the phone line (modem device)

A driver that waits for I/O to drain could wait forever if draining
stalls due to external conditions such as flow control. See
link:#threads-unable-to-receive-signals[Threads Unable to Receive Signals] for information about how
to avoid this problem.

[[io-request-handling]]
=== I/O Request Handling

section discusses I/O request processing in detail.

[[user-addresses]]
==== User Addresses

When a user thread issues a `write(2)`
system call, the thread passes the address of a buffer in user space:

....
char buffer[] = "python";
count = write(fd, buffer, strlen(buffer) + 1);
....

The system builds a `uio(9S)` structure to describe this transfer by
allocating an `iovec(9S)` structure and setting the `iov++_++base` field
to the address passed to `write(2)`, in this case, `buffer`. The
`uio(9S)` structure is passed to the driver `write(9E)` routine. See
link:#vectored-io[Vectored I/O] for more information about the
`uio(9S)` structure.

The address in the `iovec(9S)` is in user space, not kernel space. Thus,
the address is neither guaranteed to be currently in memory nor to be a
valid address. In either case, accessing a user address directly from
the device driver or from the kernel could crash the system. Thus,
device drivers should never access user addresses directly. Instead, a
data transfer routine in the illumos DDI/DKI should be used to transfer
data into or out of the kernel. These routines can handle page faults.
The DDI/DKI routines can bring in the proper user page to continue the
copy transparently. Alternatively, the routines can return an error on
an invalid access.

`copyout(9F)`
can be used to copy data from kernel space to user space. `copyin(9F)`
can copy data from user space to kernel space. `ddi++_++copyout(9F)` and
`ddi++_++copyin(9F)` operate similarly but are to be used in the
`ioctl(9E)` routine. `copyin(9F)` and `copyout(9F)` can be used on the
buffer described by each `iovec(9S)` structure, or `uiomove(9F)` can
perform the entire transfer to or from a contiguous area of driver or
device memory.

[[vectored-io]]
==== Vectored I/O

In character drivers, transfers are described by a `uio(9S)` structure.
The `uio(9S)` structure contains information about the direction and
size of the transfer, plus an array of buffers for one end of the
transfer. The other end is the device.

The `uio(9S)` structure contains the following members:

[source,c]
----
iovec_t       *uio_iov;       /* base address of the iovec */
                              /* buffer description array */
int           uio_iovcnt;     /* the number of iovec structures */
off_t         uio_offset;     /* 32-bit offset into file where */
                              /* data is transferred from or to */
offset_t      uio_loffset;    /* 64-bit offset into file where */
                              /* data is transferred from or to */
uio_seg_t     uio_segflg;     /* identifies the type of I/O transfer */
                              /* UIO_SYSSPACE:  kernel <-> kernel */
                              /* UIO_USERSPACE: kernel <-> user */
short         uio_fmode;      /* file mode flags (not driver setTable) */
daddr_t       uio_limit;      /* 32-bit ulimit for file (maximum */
                              /* block offset). not driver settable. */
diskaddr_t    uio_llimit;     /* 64-bit ulimit for file (maximum block */
                              /* block offset). not driver settable. */
int           uio_resid;      /* amount (in bytes) not */
                              /* transferred on completion */
----

`uio(9S)` structure is passed to the driver `read(9E)` and `write(9E)`
entry points. This structure is generalized to support what is called
_gather-write_ and _scatter-read_. When writing to a device, the data
buffers to be written do not have to be contiguous in application
memory. Similarly, data that is transferred from a device into memory
comes off in a contiguous stream but can go into noncontiguous areas of
application memory. See the `readv(2)`, `writev(2)`, `pread(2)`, and
`pwrite(2)` man pages for more information on scatter-gather I/O.

Each buffer is described by an
`iovec(9S)` structure. This structure contains a pointer to the data
area and the number of bytes to be transferred.

[source,c]
----
caddr_t    iov_base;    /* address of buffer */
int        iov_len;     /* amount to transfer */
----

The `uio` structure contains a pointer to an array of `iovec(9S)`
structures. The base address of this array is held in `uio++_++iov`, and
the number of elements is stored in `uio++_++iovcnt`.

The `uio++_++offset` field contains the 32-bit offset into the device at
which the application needs to begin the transfer. `uio++_++loffset` is
used for 64-bit file offsets. If the device does not support the notion
of an offset, these fields can be safely ignored. The driver should
interpret either `uio++_++offset` or `uio++_++loffset`, but not both. If
the driver has set the `D++_++64BIT` flag in the `cb++_++ops(9S)`
structure, that driver should use `uio++_++loffset`.

The `uio++_++resid` field starts out as the number of bytes to be
transferred, that is, the sum of all the `iov++_++len` fields in
`uio++_++iov`. This field _must_ be set by the driver to the number of
bytes that were _not_ transferred before returning. The `read(2)` and
`write(2)` system calls use the return value from the `read(9E)` and
`write(9E)` entry points to determine failed transfers. If a failure
occurs, these routines return -1. If the return value indicates success,
the system calls return the number of bytes requested minus
`uio++_++resid`. If `uio++_++resid` is not changed by the driver, the
`read(2)` and `write(2)` calls return 0. A return value of 0 indicates
end-of-file, even though all the data has been transferred.

The support routines `uiomove(9F)`, `physio(9F)`, and `aphysio(9F)`
update the `uio(9S)` structure directly. These support routines update
the device offset to account for the data transfer. Neither the
`uio++_++offset` or `uio++_++loffset` fields need to be adjusted when
the driver is used with a seekable device that uses the concept of
position. I/O performed to a device in this manner is constrained by the
maximum possible value of `uio++_++offset` or `uio++_++loffset`. An
example of such a usage is raw I/O on a disk.

If the device has no concept of position, the driver can take the
following steps:

[arabic]
. Save `uio++_++offset` or `uio++_++loffset`.
. Perform the I/O operation.
. Restore `uio++_++offset` or `uio++_++loffset` to the field's initial
value.

I/O that is performed to a device in this manner is not constrained by
the maximum possible value of `uio++_++offset` or `uio++_++loffset`. An
example of this type of usage is I/O on a serial line.

The following example shows one way to preserve `uio++_++loffset` in the
`read(9E)` function.

[source,c]
----
static int
xxread(dev_t dev, struct uio *uio_p, cred_t *cred_p)
{
    offset_t off;
    /* ... */
    off = uio_p->uio_loffset;  /* save the offset */
    /* do the transfer */
    uio_p->uio_loffset = off;  /* restore it */
}
----

[[differences-between-synchronous-and-asynchronous-io]]
==== Differences Between Synchronous and Asynchronous I/O

Data transfers can be _synchronous_ or
_asynchronous_. The determining factor is whether the entry point that
schedules the transfer returns immediately or waits until the I/O has
been completed.

`read(9E)` and `write(9E)` entry points are synchronous entry points.
The transfer must not return until the I/O is complete. Upon return from
the routines, the process knows whether the transfer has succeeded.

`aread(9E)` and `awrite(9E)` entry points are asynchronous entry points.
Asynchronous entry points schedule the I/O and return immediately. Upon
return, the process that issues the request knows that the I/O is
scheduled and that the status of the I/O must be determined later. In
the meantime, the process can perform other operations.

With an asynchronous I/O request to the
kernel, the process is not required to wait while the I/O is in process.
A process can perform multiple I/O requests and allow the kernel to
handle the data transfer details. Asynchronous I/O requests enable
applications such as transaction processing to use concurrent
programming methods to increase performance or response time. Any
performance boost for applications that use asynchronous I/O, however,
comes at the expense of greater programming complexity.

[[data-transfer-methods]]
==== Data Transfer Methods

Data can be transferred using either programmed I/O or DMA. These data
transfer methods can be used either by synchronous or by asynchronous
entry points, depending on the capabilities of the device.

[[programmed-io-transfers]]
===== Programmed I/O Transfers

I/O devices rely on the CPU to perform the data transfer. Programmed I/O
data transfers are identical to other read and write operations for
device registers. Various data access routines are used to read or store
values to device memory.

`uiomove(9F)` can be used
to transfer data to some programmed I/O devices. `uiomove(9F)` transfers
data between the user space, as defined by the `uio(9S)` structure, and
the kernel. `uiomove` can handle page faults, so the memory to which
data is transferred need not be locked down. `uiomove` also updates the
`uio++_++resid` field in the `uio(9S)` structure. The following example
shows one way to write a ramdisk `read(9E)` routine. It uses synchronous
I/O and relies on the presence of the following fields in the ramdisk
state structure:

[source,c]
----
caddr_t    ram;        /* base address of ramdisk */
int        ramsize;    /* size of the ramdisk */
----

[[character-31915]]
Ramdisk `read(9E)` Routine Using `uiomove(9F)`

[source,c]
----
static int
rd_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
     rd_devstate_t     *rsp;

     rsp = ddi_get_soft_state(rd_statep, getminor(dev));
     if (rsp == NULL)
       return (ENXIO);
     if (uiop->uio_offset >= rsp->ramsize)
       return (EINVAL);
     /*
      * uiomove takes the offset into the kernel buffer,
      * the data transfer count (minimum of the requested and
      * the remaining data), the UIO_READ flag, and a pointer
      * to the uio structure.
      */
     return (uiomove(rsp->ram + uiop->uio_offset,
         min(uiop->uio_resid, rsp->ramsize - uiop->uio_offset),
         UIO_READ, uiop));
}
----

Another example of programmed I/O would be a driver that writes data one
byte at a time directly to the device's memory. Each byte is retrieved
from the `uio(9S)` structure by using `uwritec(9F)`. The byte is then
sent to the device. `read(9E)` can use `ureadc(9F)` to transfer a byte
from the device to the area described by the `uio(9S)` structure.

[[character-ex-15]]
Programmed I/O `write(9E)` Routine Using `uwritec(9F)`

[source,c]
----
static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{
    int    value;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);
    /* if the device implements a power manageable component, do this: */
    pm_busy_component(xsp->dip, 0);
    if (xsp->pm_suspended)
        pm_raise_power(xsp->dip, normal power);

    while (uiop->uio_resid > 0) {
        /*
         * do the programmed I/O access
         */
        value = uwritec(uiop);
        if (value == -1)
               return (EFAULT);
        ddi_put8(xsp->data_access_handle, &xsp->regp->data,
            (uint8_t)value);
        ddi_put8(xsp->data_access_handle, &xsp->regp->csr,
            START_TRANSFER);
        /*
         * this device requires a ten microsecond delay
         * between writes
         */
        drv_usecwait(10);
    }
    pm_idle_component(xsp->dip, 0);
    return (0);
}
----

[[dma-transfers-synchronous]]
===== DMA Transfers (Synchronous)

drivers generally use `physio(9F)` to do the setup work for DMA
transfers in `read(9E)` and `write(9E)`, as is shown in
link:#character-36010[example++_++title].

[source,c]
----
int physio(int (*strat)(struct buf *), struct buf *bp,
     dev_t dev, int rw, void (*mincnt)(struct buf *),
     struct uio *uio);
----

`physio(9F)` requires the driver to provide the address of a
`strategy(9E)` routine. `physio(9F)` ensures that memory space is locked
down, that is, memory cannot be paged out, for the duration of the data
transfer. This lock-down is necessary for DMA transfers because DMA
transfers cannot handle page faults. `physio(9F)` also provides an
automated way of breaking a larger transfer into a series of smaller,
more manageable ones. See link:#minphys-entry-point[ Entry Point] for more
information.

[[character-36010]]
`read(9E)` and `write(9E)` Routines Using `physio(9F)`

[source,c]
----
static int
xxread(dev_t dev, struct uio *uiop, cred_t *credp)
{
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_READ, xxminphys, uiop);
     return (ret);
}    

static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{     
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_WRITE, xxminphys, uiop);
     return (ret);
}
----

In the call to `physio(9F)`, `xxstrategy` is a pointer to the driver
`strategy` routine. Passing `NULL` as the `buf(9S)` structure pointer
tells `physio(9F)` to allocate a `buf(9S)` structure. If the driver must
provide `physio(9F)` with a `buf(9S)` structure, `getrbuf(9F)` should be
used to allocate the structure. `physio(9F)` returns zero if the
transfer completes successfully, or an error number on failure. After
calling `strategy(9E)`, `physio(9F)` calls `biowait(9F)` to block until
the transfer either completes or fails. The return value of `physio(9F)`
is determined by the error field in the `buf(9S)` structure set by
`bioerror(9F)`.

[[dma-transfers-asynchronous]]
===== DMA Transfers (Asynchronous)

drivers that support `aread(9E)` and `awrite(9E)` use `aphysio(9F)`
instead of `physio(9F)`.

[source,c]
----
int aphysio(int (*strat)(struct buf *), int (*cancel)(struct buf *),
     dev_t dev, int rw, void (*mincnt)(struct buf *),
     struct aio_req *aio_reqp);
----

[NOTE]

The address of `anocancel(9F)` is the only value that can currently be
passed as the second argument to `aphysio(9F)`.
===

`aphysio(9F)` requires the driver to pass the address of a
`strategy(9E)` routine. `aphysio(9F)` ensures that memory space is
locked down, that is, cannot be paged out, for the duration of the data
transfer. This lock-down is necessary for DMA transfers because DMA
transfers cannot handle page faults. `aphysio(9F)` also provides an
automated way of breaking a larger transfer into a series of smaller,
more manageable ones. See link:#minphys-entry-point[ Entry Point] for more
information.

link:#character-36010[example++_++title] and
link:#character-29697[example++_++title] demonstrate that the
`aread(9E)` and `awrite(9E)` entry points differ only slightly from the
`read(9E)` and `write(9E)` entry points. The difference is primarily in
their use of `aphysio(9F)` instead of `physio(9F)`.

[[character-29697]]
`aread(9E)` and `awrite(9E)` Routines Using `aphysio(9F)`

[source,c]
----
static int
xxaread(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_READ,
     xxminphys, aiop));
}

static int
xxawrite(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_WRITE,
     xxminphys,aiop));  
}
----

In the call to `aphysio(9F)`, `xxstrategy` is a pointer to the driver
strategy routine. ++<++aiop++>++ is a pointer to the `aio++_++req(9S)`
structure. ++<++aiop++>++ is passed to `aread(9E)` and `awrite(9E)`.
`aio++_++req(9S)` describes where the data is to be stored in user
space. `aphysio(9F)` returns zero if the I/O request is scheduled
successfully or an error number on failure. After calling
`strategy(9E)`, `aphysio(9F)` returns without waiting for the I/O to
complete or fail.

[[minphys-entry-point]]
===== `minphys` Entry Point

`minphys` entry point is a pointer to a function to be called by
`physio(9F)` or `aphysio(9F)`. The purpose of ++<++xxminphys++>++ is to
ensure that the size of the requested transfer does not exceed a
driver-imposed limit. If the user requests a larger transfer,
`strategy(9E)` is called repeatedly, requesting no more than the imposed
limit at a time. This approach is important because DMA resources are
limited. Drivers for slow devices, such as printers, should be careful
not to tie up resources for a long time.

Usually, a driver passes the address of the kernel function
`minphys(9F)`, but the driver can define its own `xxminphys` routine
instead. The job of `xxminphys` is to keep the `b++_++bcount` field of
the `buf(9S)` structure under a driver's limit. The driver should adhere
to other system limits as well. For example, the driver's `xxminphys`
routine should call the system `minphys(9F)` routine after setting the
`b++_++bcount` field and before returning.

[[character-ex-17]]
`minphys(9F)` Routine

[source,c]
----
#define XXMINVAL (512 << 10)    /* 512 KB */
static void
xxminphys(struct buf *bp)
{
    if (bp->b_bcount > XXMINVAL)
        bp->b_bcount = XXMINVAL
    minphys(bp);
}
----

[[strategy-entry-point]]
===== `strategy` Entry Point

`strategy(9E)` routine originated in block drivers. The strategy
function got its name from implementing a strategy for efficient queuing
of I/O requests to a block device. A driver for a character-oriented
device can also use a `strategy(9E)` routine. In the character I/O model
presented here, `strategy(9E)` does not maintain a queue of requests,
but rather services one request at a time.

In the following example, the `strategy(9E)` routine for a
character-oriented DMA device allocates DMA resources for synchronous
data transfer. `strategy` starts the command by programming the device
register. See link:#direct-memory-access-dma[Direct Memory Access (DMA)] for a detailed
description.

[NOTE]

`strategy(9E)` does not receive a device number (`dev++_++t`) as a
parameter. Instead, the device number is retrieved from the `b++_++edev`
field of the `buf(9S)` structure passed to `strategy(9E)`.
===

[[character-35679]]
`strategy(9E)` Routine

[source,c]
----
static int
xxstrategy(struct buf *bp)
{
     minor_t            instance;
     struct xxstate     *xsp;
     ddi_dma_cookie_t   cookie;

     instance = getminor(bp->b_edev);
     xsp = ddi_get_soft_state(statep, instance);
     /* ... */
      * If the device has power manageable components,
      * mark the device busy with pm_busy_components(9F),
      * and then ensure that the device is
      * powered up by calling pm_raise_power(9F).
      */
     /* Set up DMA resources with ddi_dma_alloc_handle(9F) and
      * ddi_dma_buf_bind_handle(9F).
      */
     xsp->bp = bp; /* remember bp */
     /* Program DMA engine and start command */
     return (0);
}
----

[NOTE]

Although `strategy` is declared to return an `int`, `strategy` must
always return zero.
===

On completion of the DMA transfer, the device generates an interrupt,
causing the interrupt routine to be called. In the following example,
`xxintr` receives a pointer to the state structure for the device that
might have generated the interrupt.

[[character-28538]]
Interrupt Routine

[source,c]
----
static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     if ( /* device did not interrupt */ ) {
        return (DDI_INTR_UNCLAIMED);
     }
     if ( /* error */ ) {
        /* error handling */
     }
     /* Release any resources used in the transfer, such as DMA resources.
      * ddi_dma_unbind_handle(9F) and ddi_dma_free_handle(9F)
      * Notify threads that the transfer is complete.
      */
     biodone(xsp->bp);
     return (DDI_INTR_CLAIMED);
}
----

The driver indicates an error by calling `bioerror(9F)`. The driver must
call `biodone(9F)` when the transfer is complete or after indicating an
error with `bioerror(9F)`.

[[mapping-device-memory]]
[[mapping-device-memory-1]]
=== Mapping Device Memory

Some devices, such as frame
buffers, have memory that is directly accessible to user threads by way
of memory mapping. Drivers for these devices typically do not support
the `read(9E)` and `write(9E)` interfaces. Instead, these drivers
support memory mapping with the `devmap(9E)` entry point. For example, a
frame buffer driver might implement the `devmap(9E)` entry point to
enable the frame buffer to be mapped in a user thread.

The `devmap(9E)` entry point is called to export device memory or kernel
memory to user applications. The `devmap` function is called from
`devmap++_++setup(9F)` inside `segmap(9E)` or on behalf of
`ddi++_++devmap++_++segmap(9F)`.

The `segmap(9E)` entry point is
responsible for setting up a memory mapping requested by an `mmap(2)`
system call. Drivers for many memory-mapped devices use
`ddi++_++devmap++_++segmap(9F)` as the entry point rather than defining
their own `segmap(9E)` routine.

See link:#mapping-device-and-kernel-memory[Mapping Device and Kernel Memory] and
link:#device-context-management[Device Context Management] for details.

[[multiplexing-io-on-file-descriptors]]
=== Multiplexing I/O on File Descriptors

A thread sometimes needs
to handle I/O on more than one file descriptor. One example is an
application program that needs to read the temperature from a
temperature-sensing device and then report the temperature to an
interactive display. A program that makes a read request with no data
available should not block while waiting for the temperature before
interacting with the user again.

The `poll(2)` system call provides
users with a mechanism for multiplexing I/O over a set of file
descriptors that reference open files. `poll(2)` identifies those file
descriptors on which a program can send or receive data without
blocking, or on which certain events have occurred.

enable a program to poll a character driver, the driver must implement
the `chpoll(9E)` entry point. The system calls `chpoll(9E)` when a user
process issues a `poll(2)` system call on a file descriptor associated
with the device. The `chpoll(9E)` entry point routine is used by
non-STREAMS character device drivers that need to support polling.

The `chpoll(9E)` function uses the following syntax:

[source,c]
----
int xxchpoll(dev_t dev, short events, int anyyet, short *reventsp,
    struct pollhead **phpp);
----

In the `chpoll(9E)` entry point, the driver must follow these rules:

* Implement the following algorithm when the `chpoll(9E)` entry point is
called:
+
[source,c]
----
if ( /* events are satisfied now */ ) {
    *reventsp = mask_of_satisfied_events
} else {
    *reventsp = 0;
    if (!anyyet)
        *phpp = &local_pollhead_structure;
}
return (0);
----
+
See the `chpoll(9E)` man page for a discussion of events to check. The
`chpoll(9E)` entry point should then return the mask of satisfied events
by setting the return events in ++<*++reventsp++>++.
+
If no events have occurred, the return field for the events is cleared.
If the ++<++anyyet++>++ field is not set, the driver must return an
instance of the `pollhead` structure. The `pollhead` structure is
usually allocated in a state structure. The `pollhead` structure should
be treated as opaque by the driver. None of the `pollhead` fields should
be referenced.
* Call `pollwakeup(9F)` whenever a device condition of type `events`,
listed in link:#character-25342[example++_++title], occurs. This
function should be called only with one event at a time. You can call
`pollwakeup(9F)` in the interrupt routine when the condition has
occurred.

link:#character-25342[example++_++title] and
link:#character-38661[example++_++title] show how to implement the
polling discipline and how to use `pollwakeup(9F)`.

The following example shows how to handle the `POLLIN` and `POLLERR`
events. The driver first reads the status register to determine the
current state of the device. The parameter `events` specifies which
conditions the driver should check. If an appropriate condition has
occurred, the driver sets that bit in ++<*++reventsp++>++. If none of
the conditions has occurred and if ++<++anyyet++>++ is not set, the
address of the `pollhead` structure is returned in ++<*++phpp++>++.

[[character-25342]]
`chpoll(9E)` Routine

[source,c]
----
static int
xxchpoll(dev_t dev, short events, int anyyet,
    short *reventsp, struct pollhead **phpp)
{
     uint8_t status;
     short revent;
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     revent = 0;
     /*
      * Valid events are:
      * POLLIN | POLLOUT | POLLPRI | POLLHUP | POLLERR
      * This example checks only for POLLIN and POLLERR.
      */
     status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
     if ((events & POLLIN) && data available to read) {
        revent |= POLLIN;
     }
     if (status & DEVICE_ERROR) {
        revent |= POLLERR;
     }
     /* if nothing has occurred */
     if (revent == 0) {
        if (!anyyet) {
        *phpp = &xsp->pollhead;
        }
     }
       *reventsp = revent;
     return (0);
}
----

The following example shows how to use the `pollwakeup(9F)` function.
The `pollwakeup(9F)` function usually is called in the interrupt routine
when a supported condition has occurred. The interrupt routine reads the
status from the status register and checks for the conditions. The
routine then calls `pollwakeup(9F)` for each event to possibly notify
polling threads that they should check again. Note that `pollwakeup(9F)`
should not be called with any locks held, since deadlock could result if
another routine tried to enter `chpoll(9E)` and grab the same lock.

[[character-38661]]
Interrupt Routine Supporting `chpoll(9E)`

[source,c]
----
static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     uint8_t    status;
     /* normal interrupt processing */
     /* ... */
     status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
     if (status & DEVICE_ERROR) {
        pollwakeup(&xsp->pollhead, POLLERR);
     }
     if ( /* just completed a read */ ) {
        pollwakeup(&xsp->pollhead, POLLIN);
     }
     /* ... */
     return (DDI_INTR_CLAIMED);
}
----

[[miscellaneous-io-control]]
=== Miscellaneous I/O Control

I/O

miscellaneous control of

`ioctl(9E)` routine is called when a user thread issues an `ioctl(2)`
system call on a file descriptor associated with the device. The I/O
control mechanism is a catchall for getting and setting device-specific
parameters. This mechanism is frequently used to set a device-specific
mode, either by setting internal driver software flags or by writing
commands to the device. The control mechanism can also be used to return
information to the user about the current device state. In short, the
control mechanism can do whatever the application and driver need to
have done.

[[ioctl-entry-point-character-drivers]]
==== `ioctl` Entry Point (Character Drivers)

character drivers

[source,c]
----
int xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
     cred_t *credp, int *rvalp);
----

The ++<++cmd++>++ parameter indicates which command `ioctl(9E)` should
perform. By convention, the driver with which an I/O control command is
associated is indicated in bits 8-15 of the command. Typically, the
ASCII code of a character represents the driver. The driver-specific
command in bits 0-7. The creation of some I/O commands is illustrated in
the following example:

[source,c]
----
#define XXIOC            (`x' << 8)   /* `x' is a character that represents device xx */
#define XX_GET_STATUS    (XXIOC | 1)  /* get status register */
#define XX_SET_CMD       (XXIOC | 2)  /* send command */
----

The interpretation of ++<++arg++>++ depends on the command. I/O control
commands should be documented in the driver documentation or a man page.
The command should also be defined in a public header file, so that
applications can determine the name of the command, what the command
does, and what the command accepts or returns as ++<++arg++>++. Any data
transfer of ++<++arg++>++ into or out of the driver must be performed by
the driver.

Certain classes of devices such as frame buffers or disks must support
standard sets of I/O control requests. These standard I/O control
interfaces are documented in the illumos Reference Manual Collection.
For example, `fbio(4I)` documents the I/O controls that frame buffers
must support, and `dkio(4I)` documents standard disk I/O controls. See
link:#miscellaneous-io-control[Miscellaneous I/O Control] for more information on
I/O controls.

Drivers must use `ddi++_++copyin(9F)` to transfer ++<++arg++>++ data
from the user-level application to the kernel level. Drivers must use
`ddi++_++copyout(9F)` to transfer data from the kernel to the user
level. Failure to use `ddi++_++copyin(9F)` or `ddi++_++copyout(9F)` can
result in panics under two conditions. A panic occurs if the
architecture separates the kernel and user address spaces, or if the
user address has been swapped out.

`ioctl(9E)` is usually a switch statement with a case for each supported
`ioctl(9E)` request.

[[character-15130]]
`ioctl(9E)` Routine

[source,c]
----
static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    uint8_t        csr;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_GET_STATUS:
        csr = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
        if (ddi_copyout(&csr, (void *)arg, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        break;
    case XX_SET_CMD:
        if (ddi_copyin((void *)arg, &csr, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        ddi_put8(xsp->data_access_handle, &xsp->regp->csr, csr);
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}
----

The ++<++cmd++>++ variable identifies a specific device control
operation. A problem can occur if ++<++arg++>++ contains a user virtual
address. `ioctl(9E)` must call `ddi++_++copyin(9F)` or
`ddi++_++copyout(9F)` to transfer data between the data structure in the
application program pointed to by ++<++arg++>++ and the driver. In
link:#character-15130[example++_++title], for the case of an
`XX++_++GET++_++STATUS` request, the contents of
++<++xsp-++>++regp-++>++csr++>++ are copied to the address in
++<++arg++>++. `ioctl(9E)` can store in ++<*++rvalp++>++ any integer
value as the return value to the `ioctl(2)` system call that makes a
successful request. Negative return values, such as -1, should be
avoided. Many application programs assume that negative values indicate
failure.

The following example demonstrates an application that uses the I/O
controls discussed in the previous paragraph.

[[character-20506]]
Using `ioctl(9E)`

[source,c]
----
#include <sys/types.h>
#include "xxio.h"     /* contains device's ioctl cmds and args */
main(void)
{
     uint8_t    status;
     /* ... */
     /*
      * read the device status
      */
     if (ioctl(fd, XX_GET_STATUS, &status) == -1) {
         /* error handling */
     }
     printf("device status %x\n", status);
     exit(0);
}
----

[[io-control-support-for-64-bit-capable-device-drivers]]
==== I/O Control Support for 64-Bit Capable Device Drivers

The illumos kernel runs
in 64-bit mode on suitable hardware, supporting both 32-bit applications
and 64-bit applications. A 64-bit device driver is required to support
I/O control commands from programs of both sizes. The difference between
a 32-bit program and a 64-bit program is the C language type model. A
32-bit program is ILP32, and a 64-bit program is LP64. See
link:#making-a-device-driver-64-bit-ready[appendix++_++title] for information on C data type
models.

If data that flows between programs and the kernel is not identical in
format, the driver must be able to handle the model mismatch. Handling a
model mismatch requires making appropriate adjustments to the data.

To determine whether a model mismatch exists, the `ioctl(9E)` mode
parameter passes the data model bits to the driver. As
link:#character-38299[example++_++title] shows, the mode parameter is
then passed to `ddi++_++model++_++convert++_++from(9F)` to determine
whether any model conversion is necessary.

A flag subfield of the mode argument is used to pass the data model to
the `ioctl(9E)` routine. The flag is set to one of the following:

* `DATAMODEL++_++ILP32`
* `DATAMODEL++_++LP64`

`FNATIVE` is conditionally defined to match the data model of the kernel
implementation. The `FMODELS` mask should be used to extract the flag
from the `mode` argument. The driver can then examine the data model
explicitly to determine how to copy the application data structure.

The DDI function `ddi++_++model++_++convert++_++from(9F)` is a
convenience routine that can assist some drivers with their `ioctl`
calls. The function takes the data type model of the user application as
an argument and returns one of the following values:

* `DDI++_++MODEL++_++ILP32` – Convert from ILP32 application
* `DDI++_++MODEL++_++NONE` – No conversion needed

`DDI++_++MODEL++_++NONE` is returned if no data conversion is necessary,
as occurs when the application and driver have the same data model.
`DDI++_++MODEL++_++ILP32` is returned to a driver that is compiled to
the LP64 model and that communicates with a 32-bit application.

In the following example, the driver copies a data structure that
contains a user address. The data structure changes size from ILP32 to
LP64. Accordingly, the 64-bit driver uses a 32-bit version of the
structure when communicating with a 32-bit application.

[[character-38299]]
`ioctl(9E)` Routine to Support 32-bit Applications and 64-bit

[source,c]
----
struct args32 {
    uint32_t    addr;    /* 32-bit address in LP64 */
    int     len;
}
struct args {
    caddr_t     addr;    /* 64-bit address in LP64 */
    int     len;
}

static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    struct  xxstate  *xsp;
    struct  args     a;
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_COPYIN_DATA:
        switch(ddi_model_convert_from(mode)) {
        case DDI_MODEL_ILP32:
        {
            struct args32 a32;

            /* copy 32-bit args data shape */
            if (ddi_copyin((void *)arg, &a32,
                sizeof (struct args32), mode) != 0) {
                return (EFAULT);
            }
            /* convert 32-bit to 64-bit args data shape */
            a.addr = a32.addr;
            a.len = a32.len;
            break;
        }
        case DDI_MODEL_NONE:
            /* application and driver have same data model. */
            if (ddi_copyin((void *)arg, &a, sizeof (struct args),
                mode) != 0) {
                return (EFAULT);
            }
        }
        /* continue using data shape in native driver data model. */
        break;

    case XX_COPYOUT_DATA:
        /* copyout handling */
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}
----

[[handling-copyout-overflow]]
==== Handling `copyout` Overflow

Sometimes a driver needs to copy out a native quantity that no longer
fits in the 32-bit sized structure. In this case, the driver should
return EOVERFLOW to the caller. EOVERFLOW serves as an indication that
the data type in the interface is too small to hold the value to be
returned, as shown in the following example.

[[character-ex-6]]
Handling `copyout(9F)` Overflow

[source,c]
----
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
 cred_t *cr, int *rval_p)
{
    struct resdata res;
    /* body of driver */
    switch (ddi_model_convert_from(mode & FMODELS)) {
    case DDI_MODEL_ILP32: {
        struct resdata32 res32;

        if (res.size > UINT_MAX)
                return (EOVERFLOW);
        res32.size = (size32_t)res.size;
        res32.flag = res.flag;
        if (ddi_copyout(&res32,
            (void *)arg, sizeof (res32), mode))
                return (EFAULT);
    }
    break;

    case DDI_MODEL_NONE:
        if (ddi_copyout(&res, (void *)arg, sizeof (res), mode))
                return (EFAULT);
        break;
    }
    return (0);
}
----

[[32-bit-and-64-bit-data-structure-macros]]
=== 32-bit and 64-bit Data Structure Macros

The method in link:#character-ex-6[example++_++title] works well for
many drivers. An alternate scheme is to use the data structure macros
that are provided in `++<++sys/model.h++>++`to move data between the
application and the kernel. These macros make the code less cluttered
and behave identically, from a functional perspective.

[[character-ex-8]]
Using Data Structure Macros to Move Data

[source,c]
----
    xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
        cred_t *cr, int *rval_p)
    {    
        STRUCT_DECL(opdata, op);

        if (cmd != OPONE)
            return (ENOTTY);

        STRUCT_INIT(op, mode);

        if (copyin((void *)arg,
            STRUCT_BUF(op), STRUCT_SIZE(op)))
                return (EFAULT);

        if (STRUCT_FGET(op, flag) != XXACTIVE ||     
            STRUCT_FGET(op, size) > XXSIZE)
                return (EINVAL);
        xxdowork(device_state, STRUCT_FGET(op, size));
        return (0);
}
----

[[how-do-the-structure-macros-work]]
==== How Do the Structure Macros Work?

In a 64-bit device driver, structure macros enable the use of the same
piece of kernel memory by data structures of both sizes. The memory
buffer holds the contents of the native form of the data structure, that
is, the LP64 form, and the ILP32 form. Each structure access is
implemented by a conditional expression. When compiled as a 32-bit
driver, only one data model, the native form, is supported. No
conditional expression is used.

The 64-bit versions of the macros depend on the definition of a shadow
version of the data structure. The shadow version describes the 32-bit
interface with fixed-width types. The name of the shadow data structure
is formed by appending “32” to the name of the native data structure.
For convenience, place the definition of the shadow structure in the
same file as the native structure to ease future maintenance costs.

The macros can take the following arguments:

++<++structname++>++::
  The structure name of the native form of the data structure as entered
  after the `struct` keyword.
++<++umodel++>++::
  A flag word that contains the user data model, such as `FILP32` or
  `FLP64`, extracted from the mode parameter of `ioctl(9E)`.
++<++handle++>++::
  The name used to refer to a particular instance of a structure that is
  manipulated by these macros.
++<++fieldname++>++::
  The name of the field within the structure.

[[when-to-use-structure-macros]]
==== When to Use Structure Macros

Macros enable you to make in-place references only to the fields of a
data item. Macros do not provide a way to take separate code paths that
are based on the data model. Macros should be avoided if the number of
fields in the data structure is large. Macros should also be avoided if
the frequency of references to these fields is high.

Macros hide many of the differences between data models in the
implementation of the macros. As a result, code written with this
interface is generally easier to read. When compiled as a 32-bit driver,
the resulting code is compact without needing clumsy `#ifdefs`, but
still preserves type checking.

[[declaring-and-initializing-structure-handles]]
==== Declaring and Initializing Structure Handles

`STRUCT++_++DECL(9F)` and `STRUCT++_++INIT(9F)` can be used to declare
and initialize a handle and space for decoding an `ioctl` on the stack.
`STRUCT++_++HANDLE(9F)` and `STRUCT++_++SET++_++HANDLE(9F)` declare and
initialize a handle without allocating space on the stack. The latter
macros can be useful if the structure is very large, or is contained in
some other data structure.

[NOTE]

Because the `STRUCT++_++DECL(9F)` and `STRUCT++_++HANDLE(9F)` macros
expand to data structure declarations, these macros should be grouped
with such declarations in C code.
===

The macros for declaring and initializing structures are as follows:

`STRUCT++_++DECL(`++<++structname++>++`,` ++<++handle++>++`)`::
  Declares a __structure handle__that is called `handle` for a
  ++<++structname++>++ data structure. `STRUCT++_++DECL` allocates space
  for its native form on the stack. The native form is assumed to be
  larger than or equal to the ILP32 form of the structure.
`STRUCT++_++INIT(`++<++handle++>++`,` ++<++umodel++>++`)`::
  Initializes the data model for ++<++handle++>++ to `umodel`. This
  macro must be invoked before any access is made to a structure handle
  declared with `STRUCT++_++DECL(9F)`.
`STRUCT++_++HANDLE(`++<++structname++>++`,` ++<++handle++>++`)`::
  Declares a _structure handle_ that is called `handle`. Contrast with
  `STRUCT++_++DECL(9F)`.
`STRUCT++_++SET++_++HANDLE(`++<++handle++>++`,` ++<++umodel++>++`,`
++<++addr++>++`)`::
  Initializes the data model for ++<++handle++>++ to ++<++umodel++>++,
  and sets ++<++addr++>++ as the buffer used for subsequent
  manipulation. Invoke this macro before accessing a structure handle
  declared with `STRUCT++_++DECL(9F)`.

[[operations-on-structure-handles]]
==== Operations on Structure Handles

The macros for performing operations on structures are as follows:

`size++_++t STRUCT++_++SIZE(`++<++handle++>++`)`::
  Returns the size of the structure referred to by ++<++handle++>++,
  according to its embedded data model.
`typeof` ++<++fieldname++>++ `STRUCT++_++FGET(`++<++handle++>++`,`
++<++fieldname++>++`)`::
  Returns the indicated field in the data structure referred to by
  ++<++handle++>++. This field is a non-pointer type.
`typeof` ++<++fieldname++>++ `STRUCT++_++FGETP(`++<++handle++>++`,`
++<++fieldname++>++`)`::
  Returns the indicated field in the data structure referred to by
  ++<++handle++>++. This field is a pointer type.
`STRUCT++_++FSET(`++<++handle++>++`,` ++<++fieldname++>++`,`
++<++val++>++`)`::
  Sets the indicated field in the data structure referred to by
  ++<++handle++>++ to value ++<++val++>++. The type of ++<++val++>++
  should match the type of ++<++fieldname++>++. The field is a
  non-pointer type.
`STRUCT++_++FSETP(`++<++handle++>++`,` ++<++fieldname++>++`,`
++<++val++>++`)`::
  Sets the indicated field in the data structure referred to by
  ++<++handle++>++ to value ++<++val++>++. The field is a pointer type.
`typeof` ++<++fieldname++>++ `++*++STRUCT++_++FADDR(`++<++handle++>++`,`
++<++fieldname++>++`)`::
  Returns the address of the indicated field in the data structure
  referred to by ++<++handle++>++.
`struct structname ++*++STRUCT++_++BUF(`++<++handle++>++`)`::
  Returns a pointer to the native structure described by
  ++<++handle++>++.

[[other-operations]]
==== Other Operations

Some miscellaneous structure macros follow:

`size++_++t SIZEOF++_++STRUCT(`++<++struct++_++name++>++`,`
++<++datamodel++>++`)`::
  Returns the size of ++<++struct++_++name++>++, which is based on the
  given data model.
`size++_++t SIZEOF++_++PTR(`++<++datamodel++>++`)`::
  Returns the size of a pointer based on the given data model.

[[drivers-for-block-devices]]
=== Drivers for Block Devices

This chapter describes the structure of block device drivers. The kernel
views a block device as a set of randomly accessible logical blocks. The
file system uses a list of `buf(9S)` structures to buffer the data
blocks between a block device and the user space. Only block devices can
support a file system.

This chapter provides information on the following subjects:

* link:#block-driver-structure-overview[Block Driver Structure Overview]
* link:#file-io[File I/O]
* link:#block-device-autoconfiguration[Block Device Autoconfiguration]
* link:#controlling-device-access[Controlling Device Access]
* link:#synchronous-data-transfers-block-drivers[Synchronous Data Transfers (Block Drivers)]
* link:#asynchronous-data-transfers-block-drivers[Asynchronous Data Transfers (Block Drivers)]
* link:#dump-and-print-entry-points[ and Entry Points]
* link:#disk-device-drivers[Disk Device Drivers]

[[block-driver-structure-overview]]
=== Block Driver Structure Overview

link:#block-fig-3[Block Driver Roadmap] shows data structures and
routines that define the structure of a block device driver. Device
drivers typically include the following elements:

* Device-loadable driver section
* Device configuration section
* Device access section

The shaded device access section in the following figure illustrates
entry points for block drivers.

.Block Driver Roadmap
[#block-fig-3]
image::figures/block-view.png[Diagram shows structures and entry points for block device drivers.]

with each device driver is a `dev++_++ops(9S)` structure, which in turn
refers to a `cb++_++ops(9S)` structure. See link:#driver-autoconfiguration[Driver
Autoconfiguration] for details on driver data structures.

Block device drivers provide these entry points:

* `open(9E)`
* `close(9E)`
* `strategy(9E)`
* `print(9E)`

[NOTE]

Some of the entry points can be replaced by `nodev(9F)` or `nulldev(9F)`
as appropriate.
===

[[file-io]]
=== File I/O

file system I/O

I/O

file system structure

A file system is a tree-structured hierarchy of directories and files.
Some file systems, such as the UNIX File System (UFS), reside on
block-oriented devices. File systems are created by `format(8)` and
`newfs(8)`.

When an application issues a `read(2)` or `write(2)` system call to an
ordinary file on the UFS file system, the file system can call the
device driver `strategy(9E)` entry point for the block device on which
the file system resides. The file system code can call `strategy(9E)`
several times for a single `read(2)` or `write(2)` system call.

The file system code determines the logical device address, or _logical
block number_, for each ordinary file block. A block I/O request is then
built in the form of a `buf(9S)` structure directed at the block device.
The driver `strategy(9E)` entry point then interprets the `buf(9S)`
structure and completes the request.

[[block-device-autoconfiguration]]
=== Block Device Autoconfiguration

of block devices

`attach(9E)` should perform the common initialization tasks for each
instance of a device:

* Allocating per-instance state structures
* Mapping the device's registers
* Registering device interrupts
* Initializing mutex and condition variables
* Creating power manageable components
* Creating minor nodes

Block device drivers create minor nodes of type `S++_++IFBLK`. As a
result, a block special file that represents the node appears in the
`/devices` hierarchy.

device names for block devices appear in the `/dev/dsk` directory, and
consist of a controller number, bus-address number, disk number, and
slice number. These names are created by the `devfsadm(8)` program if
the node type is set to `DDI++_++NT++_++BLOCK` or
`DDI++_++NT++_++BLOCK++_++CHAN`. `DDI++_++NT++_++BLOCK++_++CHAN` should
be specified if the device communicates on a channel, that is, a bus
with an additional level of addressability. SCSI disks are a good
example. `DDI++_++NT++_++BLOCK++_++CHAN` causes a bus-address field
(t__N__) to appear in the logical name. `DDI++_++NT++_++BLOCK` should be
used for most other devices.

A minor device
refers to a partition on the disk. For each minor device, the driver
must create an `nblocks` or `Nblocks` property. This integer property
gives the number of blocks supported by the minor device expressed in
units of `DEV++_++BSIZE`, that is, 512 bytes. The file system uses the
`nblocks` and `Nblocks` properties to determine device limits. `Nblocks`
is the 64-bit version of `nblocks`. `Nblocks` should be used with
storage devices that can hold over 1 Tbyte of storage per disk. See
link:#device-properties[Device Properties] for more information.

link:#block-29600[example++_++title] shows a typical `attach(9E)` entry
point with emphasis on creating the device's minor node and the
`Nblocks` property. Note that because this example uses `Nblocks` and
not `nblocks`, `ddi++_++prop++_++update++_++int64(9F)` is called instead
of `ddi++_++prop++_++update++_++int(9F)`.

a side note, this example shows the use of `makedevice(9F)` to create a
device number for `ddi++_++prop++_++update++_++int64`. The `makedevice`
function makes use of `ddi++_++driver++_++major(9F)`, which generates a
major number from a pointer to a `dev++_++info++_++t` structure. Using
`ddi++_++driver++_++major` is similar to using `getmajor(9F)`, which
gets a `dev++_++t` structure pointer.

[[block-29600]]
Block Driver `attach` Routine

[source,c]
----
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
      /*
       * allocate a state structure and initialize it
       * map the devices registers
       * add the device driver's interrupt handler(s)
       * initialize any mutexes and condition variables
       * read label information if the device is a disk
       * create power manageable components
       *
       * Create the device minor node. Note that the node_type
       * argument is set to DDI_NT_BLOCK.
       */
      if (ddi_create_minor_node(dip, "minor_name", S_IFBLK,
          instance, DDI_NT_BLOCK, 0) == DDI_FAILURE) {
          /* free resources allocated so far */
          /* Remove any previously allocated minor nodes */
          ddi_remove_minor_node(dip, NULL);
          return (DDI_FAILURE);
      }
      /*
       * Create driver properties like "Nblocks". If the device
       * is a disk, the Nblocks property is usually calculated from
       * information in the disk label.  Use "Nblocks" instead of
       * "nblocks" to ensure the property works for large disks.
       */
      xsp->Nblocks = size;
      /* size is the size of the device in 512 byte blocks */
      maj_number = ddi_driver_major(dip);
      if (ddi_prop_update_int64(makedevice(maj_number, instance), dip, 
          "Nblocks", xsp->Nblocks) != DDI_PROP_SUCCESS) {
          cmn_err(CE_CONT, "%s: cannot create Nblocks property\n",
              ddi_get_name(dip));
          /* free resources allocated so far */
          return (DDI_FAILURE);
      }
      xsp->open = 0;
      xsp->nlayered = 0;
      /* ... */
      return (DDI_SUCCESS);

      case DDI_RESUME:
          /* For information, see Chapter 12, "Power Management," in this book. */
      default:
          return (DDI_FAILURE);
    }
}
----

[[controlling-device-access]]
=== Controlling Device Access

This section describes the entry points for `open` and `close` functions
in block device drivers. See link:#drivers-for-character-devices[Drivers for Character
Devices] for more information on `open(9E)` and `close(9E)`.

[[open-entry-point-block-drivers]]
==== `open` Entry Point (Block Drivers)

`open(9E)` entry point is used to gain access to a given device. The
`open(9E)` routine of a block driver is called when a user thread issues
an `open(2)` or `mount(2)` system call on a block special file
associated with the minor device, or when a layered driver calls
`open(9E)`. See link:#file-io[File I/O] for more information.

The `open` entry point should check for the following conditions:

* The device can be opened, that is, the device is online and ready.
* The device can be opened as requested. The device supports the
operation. The device's current state does not conflict with the
request.
* The caller has permission to open the device.

The following example demonstrates a block driver `open(9E)` entry
point.

[[block-40232]]
Block Driver `open(9E)` Routine

[source,c]
----
static int
xxopen(dev_t *devp, int flags, int otyp, cred_t *credp)
{
    minor_t         instance;
    struct xxstate        *xsp;

    instance = getminor(*devp);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&xsp->mu);
    /*
     * only honor FEXCL. If a regular open or a layered open
     * is still outstanding on the device, the exclusive open
     * must fail.
     */
    if ((flags & FEXCL) && (xsp->open || xsp->nlayered)) {
        mutex_exit(&xsp->mu);
        return (EAGAIN);
    }
    switch (otyp) {
      case OTYP_LYR:
          xsp->nlayered++;
          break;
      case OTYP_BLK:
          xsp->open = 1;
          break;
      default:
          mutex_exit(&xsp->mu);
          return (EINVAL);
    }
    mutex_exit(&xsp->mu);
    return (0);
}
----

The `otyp` argument is used to specify the type of open on the device.
`OTYP++_++BLK` is the typical open type for a block device. A device can
be opened several times with `otyp` set to `OTYP++_++BLK`. `close(9E)`
is called only once when the final close of type `OTYP++_++BLK` has
occurred for the device. `otyp` is set to `OTYP++_++LYR` if the device
is being used as a layered device. For every open of type
`OTYP++_++LYR`, the layering driver issues a corresponding close of type
`OTYP++_++LYR`. The example keeps track of each type of open so the
driver can determine when the device is not being used in `close(9E)`.

[[close-entry-point-block-drivers]]
==== `close` Entry Point (Block Drivers)

The `close(9E)`
entry point uses the same arguments as `open(9E)` with one exception.
`dev` is the device number rather than a pointer to the device number.

The `close` routine should verify `otyp` in the same way as was
described for the `open(9E)` entry point. In the following example,
`close` must determine when the device can really be closed. Closing is
affected by the number of block opens and layered opens.

[[block-15508]]
Block Device `close(9E)` Routine

[source,c]
----
static int
xxclose(dev_t dev, int flag, int otyp, cred_t *credp)
{
    minor_t instance;
    struct xxstate *xsp;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&xsp->mu);
    switch (otyp) {
      case OTYP_LYR:
          xsp->nlayered--;
          break;
      case OTYP_BLK:
          xsp->open = 0;
          break;
      default:
          mutex_exit(&xsp->mu);
         return (EINVAL);
    }

    if (xsp->open || xsp->nlayered) {
        /* not done yet */
        mutex_exit(&xsp->mu);
        return (0);
    }
    /* cleanup (rewind tape, free memory, etc.) */
    /* wait for I/O to drain */
    mutex_exit(&xsp->mu);

    return (0);
}
----

[[strategy-entry-point]]
[[strategy-entry-point-1]]
==== `strategy` Entry Point

The `strategy(9E)` entry point is used to read and write
data buffers to and from a block device. The name _strategy_ refers to
the fact that this entry point might implement some optimal strategy for
ordering requests to the device.

`strategy(9E)` can be written to process one request at a
time, that is, a synchronous transfer. `strategy` can also be written to
queue multiple requests to the device, as in an asynchronous transfer.
When choosing a method, the abilities and limitations of the device
should be taken into account.

The `strategy(9E)` routine is passed a pointer to a `buf(9S)` structure.
This structure describes the transfer request, and contains status
information on return. `buf(9S)` and `strategy(9E)` are the focus of
block device operations.

[[buf-structure]]
==== `buf` Structure

The following `buf` structure members are
important to block drivers:

[source,c]
----
int           b_flags;       /* Buffer Status */
struct buf    *av_forw;      /* Driver work list link */
struct buf    *av_back;      /* Driver work list link */
size_t        b_bcount;      /* # of bytes to transfer */
union {
    caddr_t   b_addr;        /* Buffer's virtual address */
} b_un;
daddr_t       b_blkno;       /* Block number on device */
diskaddr_t    b_lblkno;      /* Expanded block number on device */
size_t        b_resid;       /* # of bytes not transferred after error */
int           b_error;       /* Expanded error field */
void          *b_private;    /* “opaque” driver private area */
dev_t         b_edev;        /* expanded dev field */
----

where:

`av++_++forw` and `av++_++back`::
  Pointers that the driver can use to manage a list of buffers by the
  driver. See link:#asynchronous-data-transfers-block-drivers[Asynchronous Data Transfers (Block
  Drivers)] for a discussion of the `av++_++forw` and `av++_++back`
  pointers.
`b++_++bcount`::
  Specifies the number of bytes to be transferred by the device.
`b++_++un.b++_++addr`::
  The kernel virtual address of the data buffer. Only valid after
  `bp++_++mapin(9F)` call.
`b++_++blkno`::
  The starting 32-bit logical block number on the device for the data
  transfer, which is expressed in 512-byte `DEV++_++BSIZE` units. The
  driver should use either `b++_++blkno` or `b++_++lblkno` but not both.
`b++_++lblkno`::
  The starting 64-bit logical block number on the device for the data
  transfer, which is expressed in 512-byte `DEV++_++BSIZE` units. The
  driver should use either `b++_++blkno` or `b++_++lblkno` but not both.
`b++_++resid`::
  Set by the driver to indicate the number of bytes that were not
  transferred because of an error. See
  link:#block-33565[example++_++title] for an example of setting
  `b++_++resid`. The `b++_++resid` member is overloaded. `b++_++resid`
  is also used by `disksort(9F)`.
`b++_++error`::
  Set to an error number by the driver when a transfer error occurs.
  `b++_++error` is set in conjunction with the `b++_++flags`
  `B++_++ERROR` bit. See the `Intro(9E)` man page for details about
  error values. Drivers should use `bioerror(9F)` rather than setting
  `b++_++error` directly.
`b++_++flags`::
  Flags with status and transfer attributes of the `buf` structure. If
  `B++_++READ` is set, the `buf` structure indicates a transfer from the
  device to memory. Otherwise, this structure indicates a transfer from
  memory to the device. If the driver encounters an error during data
  transfer, the driver should set the `B++_++ERROR` field in the
  `b++_++flags` member. In addition, the driver should provide a more
  specific error value in `b++_++error`. Drivers should use
  `bioerror(9F)` rather than setting `B++_++ERROR`.
  +
  [CAUTION]
  ====
  Drivers should never clear `b++_++flags`.
  ====
`b++_++private`::
  For exclusive use by the driver to store driver-private data.
`b++_++edev`::
  Contains the device number of the device that was used in the
  transfer.

[[bp_mapin-structure]]
===== `bp++_++mapin` Structure

A `buf` structure pointer can be passed into the device driver's
`strategy(9E)` routine. However, the data buffer referred to by
`b++_++un.b++_++addr` is not necessarily mapped in the kernel's address
space. Therefore, the driver cannot directly access the data. Most
block-oriented devices have DMA capability and therefore do not need to
access the data buffer directly. Instead, these devices use the DMA
mapping routines to enable the device's DMA engine to do the data
transfer. For details about using DMA, see link:#direct-memory-access-dma[Direct Memory
Access (DMA)].

If a driver needs to access the data buffer directly, that driver must
first map the buffer into the kernel's address space by using
`bp++_++mapin(9F)`. `bp++_++mapout(9F)` should be used when the driver
no longer needs to access the data directly.

[CAUTION]

`bp++_++mapout(9F)` should only be called on buffers that have been
allocated and are owned by the device driver. `bp++_++mapout` must not
be called on buffers that are passed to the driver through the
`strategy(9E)` entry point, such as a file system. `bp++_++mapin(9F)`
does not keep a reference count. `bp++_++mapout(9F)` removes any kernel
mapping on which a layer over the device driver might rely.
===

[[synchronous-data-transfers-block-drivers]]
=== Synchronous Data Transfers (Block Drivers)

This section presents a
simple method for performing synchronous I/O transfers. This method
assumes that the hardware is a simple disk device that can transfer only
one data buffer at a time by using DMA. Another assumption is that the
disk can be spun up and spun down by software command. The device
driver's `strategy(9E)` routine waits for the current request to be
completed before accepting a new request. The device interrupts when the
transfer is complete. The device also interrupts if an error occurs.

The steps for performing a synchronous data transfer for a block driver
are as follows:

[arabic]
. Check for invalid `buf(9S)` requests.
+
Check the `buf(9S)` structure that is passed to `strategy(9E)` for
validity. All drivers should check the following conditions:
* The request begins at a valid block. The driver converts the
`b++_++blkno` field to the correct device offset and then determines
whether the offset is valid for the device.
* The request does not go beyond the last block on the device.
* Device-specific requirements are met.
+
If an error is encountered, the driver
should indicate the appropriate error with `bioerror(9F)`. The driver
should then complete the request by calling `biodone(9F)`. `biodone`
notifies the caller of `strategy(9E)` that the transfer is complete. In
this case, the transfer has stopped because of an error.
. Check whether the device is busy.
+
Synchronous data transfers allow single-threaded access to the device.
The device driver enforces this access in two ways:
* The driver maintains a busy flag that is guarded by a mutex.
* The driver waits on a condition variable with `cv++_++wait(9F)`, when
the device is busy.
+
If the device is busy, the thread waits until the interrupt handler
indicates that the device is not longer busy. The available status can
be indicated by either the `cv++_++broadcast(9F)` or the
`cv++_++signal(9F)` function. See link:#multithreading[Multithreading] for
details on condition variables.
+
When the device is no longer busy, the `strategy(9E)` routine marks the
device as available. `strategy` then prepares the buffer and the device
for the transfer.
. Set up the buffer for DMA.
+
Prepare the data buffer for a DMA transfer by using
`ddi++_++dma++_++alloc++_++handle(9F)` to allocate a DMA handle. Use
`ddi++_++dma++_++buf++_++bind++_++handle(9F)` to bind the data buffer to
the handle. For information on setting up DMA resources and related data
structures, see link:#direct-memory-access-dma[Direct Memory Access (DMA)].
. Begin the transfer.
+
At this point, a pointer to the `buf(9S)` structure is saved in the
state structure of the device. The interrupt routine can then complete
the transfer by calling `biodone(9F)`.
+
The device driver then accesses device registers to initiate a data
transfer. In most cases, the driver should protect the device registers
from other threads by using mutexes. In this case, because
`strategy(9E)` is single-threaded, guarding the device registers is not
necessary. See link:#multithreading[Multithreading] for details about data
locks.
+
When the executing thread has started the device's DMA engine, the
driver can return execution control to the calling routine, as follows:
+
[source,c]
----
static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    struct device_reg *regp;
    minor_t instance;
    ddi_dma_cookie_t cookie;
    instance = getminor(bp->b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL) {
        bioerror(bp, ENXIO);
        biodone(bp);
        return (0);
    }
    /* validate the transfer request */
    if ((bp->b_blkno >= xsp->Nblocks) || (bp->b_blkno < 0)) {
        bioerror(bp, EINVAL);    
        biodone(bp);
        return (0);
    }
    /*
     * Hold off all threads until the device is not busy.
     */
    mutex_enter(&xsp->mu);
    while (xsp->busy) {
        cv_wait(&xsp->cv, &xsp->mu);
    }
    xsp->busy = 1;
    mutex_exit(&xsp->mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp->bp = bp;
    regp = xsp->regp;
    ddi_put32(xsp->data_access_handle, &regp->dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp->data_access_handle, &regp->dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp->data_access_handle, &regp->csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}
----
. Handle the interrupting device.
+
When the device finishes the data transfer, the driver generates an
interrupt, which eventually results in the driver's interrupt routine
being called. Most drivers specify the state structure of the device as
the argument to the interrupt routine when registering interrupts. See
the `ddi++_++add++_++intr(9F)` man page and
link:#registering-interrupts[Registering Interrupts]. The interrupt routine can
then access the `buf(9S)` structure being transferred, plus any other
information that is available from the state structure.
+
The interrupt handler should check the device's status register to
determine whether the transfer completed without error. If an error
occurred, the handler should indicate the appropriate error with
`bioerror(9F)`. The handler should also clear the pending interrupt for
the device and then complete the transfer by calling `biodone(9F)`.
+
As the final task, the handler clears the busy flag. The handler then
calls `cv++_++signal(9F)` or `cv++_++broadcast(9F)` on the condition
variable, signaling that the device is no longer busy. This notification
enables other threads waiting for the device in `strategy(9E)` to
proceed with the next data transfer.
+
The following example shows a synchronous interrupt routine.

[[block-ex-19]]
Synchronous Interrupt Routine for Block Drivers

[source,c]
----
static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&xsp->mu);
    status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
    if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp->bp;
    xsp->bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status & DEVICE_ERROR) {
        /* failure */
        bp->b_resid = bp->b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp->b_resid = 0;
    }
    ddi_put8(xsp->data_access_handle, &xsp->regp->csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp->busy = 0;
    cv_signal(&xsp->cv);
    mutex_exit(&xsp->mu);
    return (DDI_INTR_CLAIMED);
}
----

[[asynchronous-data-transfers-block-drivers]]
=== Asynchronous Data Transfers (Block Drivers)

This section presents a
method for performing asynchronous I/O transfers. The driver queues the
I/O requests and then returns control to the caller. Again, the
assumption is that the hardware is a simple disk device that allows one
transfer at a time. The device interrupts when a data transfer has
completed. An interrupt also takes place if an error occurs. The basic
steps for performing asynchronous data transfers are:

[arabic]
. Check for invalid `buf(9S)` requests.
. Enqueue the request.
. Start the first transfer.
. Handle the interrupting device.

[[checking-for-invalid-buf-requests]]
==== Checking for Invalid `buf` Requests

As in the synchronous case, the device driver should check the `buf(9S)`
structure passed to `strategy(9E)` for validity. See
link:#synchronous-data-transfers-block-drivers[Synchronous Data Transfers (Block Drivers)] for more
details.

[[enqueuing-the-request]]
==== Enqueuing the Request

Unlike synchronous data transfers, a driver does not wait for an
asynchronous request to complete. Instead, the driver adds the request
to a queue. The head of the queue can be the current transfer. The head
of the queue can also be a separate field in the state structure for
holding the active request, as in link:#fblfb[example++_++title].

If the queue is initially empty, then the hardware is not busy and
`strategy(9E)` starts the transfer before returning. Otherwise, if a
transfer completes with a non-empty queue, the interrupt routine begins
a new transfer. link:#fblfb[example++_++title] places the decision of
whether to start a new transfer into a separate routine for convenience.

The driver can use the `av++_++forw` and the `av++_++back` members of
the `buf(9S)` structure to manage a list of transfer requests. A single
pointer can be used to manage a singly linked list, or both pointers can
be used together to build a doubly linked list. The device hardware
specification specifies which type of list management, such as insertion
policies, is used to optimize the performance of the device. The
transfer list is a per-device list, so the head and tail of the list are
stored in the state structure.

The following example provides multiple threads with access to the
driver shared data, such as the transfer list. You must identify the
shared data and must protect the data with a mutex. See
link:#multithreading[Multithreading] for more details about mutex locks.

[[fblfb]]
Enqueuing Data Transfer Requests for Block Drivers

[source,c]
----
static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    minor_t instance;
    instance = getminor(bp->b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /* ... */
    /* validate transfer request */
    /* ... */
    /*
     * Add the request to the end of the queue. Depending on the device, a sorting
     * algorithm, such as disksort(9F) can be used if it improves the
     * performance of the device.
     */
    mutex_enter(&xsp->mu);
    bp->av_forw = NULL;
    if (xsp->list_head) {
        /* Non-empty transfer list */
        xsp->list_tail->av_forw = bp;
        xsp->list_tail = bp;
    } else {
        /* Empty Transfer list */
        xsp->list_head = bp;
        xsp->list_tail = bp;
    }
    mutex_exit(&xsp->mu);
    /* Start the transfer if possible */
    (void) xxstart((caddr_t)xsp);
    return (0);
}
----

[[starting-the-first-transfer]]
==== Starting the First Transfer

Device drivers that implement queuing usually have a `start` routine.
`start` dequeues the next request and starts the data transfer to or
from the device. In this example, `start` processes all requests
regardless of the state of the device, whether busy or free.

[NOTE]

`start` must be written to be called from any context. `start` can be
called by both the strategy routine in kernel context and the interrupt
routine in interrupt context.
===

`start` is called by `strategy(9E)` every time `strategy` queues a
request so that an idle device can be started. If the device is busy,
`start` returns immediately.

`start` is also called by the interrupt handler before the handler
returns from a claimed interrupt so that a nonempty queue can be
serviced. If the queue is empty, `start` returns immediately.

Because `start` is a private driver routine, `start` can take any
arguments and can return any type. The following code sample is written
to be used as a DMA callback, although that portion is not shown.
Accordingly, the example must take a `caddr++_++t` as an argument and
return an `int`. See link:#handling-resource-allocation-failures[Handling Resource Allocation
Failures] for more information about DMA callback routines.

[[fblfa]]
Starting the First Data Request for a Block Driver

[source,c]
----
static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;

    mutex_enter(&xsp->mu);
    /*
     * If there is nothing more to do, or the device is
     * busy, return.
     */
    if (xsp->list_head == NULL || xsp->busy) {
       mutex_exit(&xsp->mu);
       return (0);
    }
    xsp->busy = 1;
    /* Get the first buffer off the transfer list */
    bp = xsp->list_head;
    /* Update the head and tail pointer */
    xsp->list_head = xsp->list_head->av_forw;
    if (xsp->list_head == NULL)
       xsp->list_tail = NULL;
    bp->av_forw = NULL;
    mutex_exit(&xsp->mu);
    /* 
     * If the device has power manageable components, 
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device 
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp->bp = bp;
    ddi_put32(xsp->data_access_handle, &xsp->regp->dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp->data_access_handle, &xsp->regp->dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp->data_access_handle, &xsp->regp->csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}
----

[[handling-the-interrupting-device]]
==== Handling the Interrupting Device

The interrupt routine is similar to the asynchronous version, with the
addition of the call to `start` and the removal of the call to
`cv++_++signal(9F)`.

[[block-33565]]
Block Driver Routine for Asynchronous Interrupts

[source,c]
----
static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&xsp->mu);
    status = ddi_get8(xsp->data_access_handle, &xsp->regp->csr);
    if (!(status & INTERRUPTING)) {
        mutex_exit(&xsp->mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp->bp;
    xsp->bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status & DEVICE_ERROR) {
        /* failure */
        bp->b_resid = bp->b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp->b_resid = 0;
    }
    ddi_put8(xsp->data_access_handle, &xsp->regp->csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources (ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F)).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp->busy = 0;
    mutex_exit(&xsp->mu);
    (void) xxstart((caddr_t)xsp);
    return (DDI_INTR_CLAIMED);
}
----

[[dump-and-print-entry-points]]
=== `dump` and `print` Entry Points

This section discusses the `dump(9E)` and `print(9E)` entry points.

[[dump-entry-point-block-drivers]]
==== `dump` Entry Point (Block Drivers)

The `dump(9E)` entry point is used to copy
a portion of virtual address space directly to the specified device in
the case of a system failure. `dump` is also used to copy the state of
the kernel out to disk during a checkpoint operation. See the `cpr(4)`
and `dump(9E)` man pages for more information. The entry point must be
capable of performing this operation without the use of interrupts,
because interrupts are disabled during the checkpoint operation.

[source,c]
----
int dump(dev_t dev, caddr_t addr, daddr_t blkno, int nblk)
----

where:

++<++dev++>++::
  Device number of the device to receive the dump.
++<++addr++>++::
  Base kernel virtual address at which to start the dump.
++<++blkno++>++::
  Block at which the dump is to start.
++<++nblk++>++::
  Number of blocks to dump.

The dump depends upon the existing driver working properly.

[[print-entry-point-block-drivers]]
==== `print` Entry Point (Block Drivers)

[source,c]
----
int print(dev_t dev, char *str)
----

`print(9E)` entry point is called by the system to display a message
about an exception that has been detected. `print(9E)` should call
`cmn++_++err(9F)` to post the message to the console on behalf of the
system. The following example demonstrates a typical `print` entry
point.

[source,c]
----
static int
xxprint(dev_t dev, char *str)
{
    cmn_err(CE_CONT, “xx: %s\n”, str);
    return (0);
}
----

[[disk-device-drivers]]
=== Disk Device Drivers

Disk devices represent an important class of block device drivers.

[[disk-ioctls]]
==== Disk `ioctl`s

illumos disk drivers need to
support a minimum set of `ioctl` commands specific to illumos disk
drivers. These I/O controls are specified in the `dkio(4I)` manual page.
Disk I/O controls transfer disk information to or from the device
driver. An illumos disk device is supported by disk utility commands
such as `format(8)` and `newfs(8)`. The mandatory illumos disk I/O
controls are as follows:

DKIOCINFO::
  Returns information that describes the disk controller
DKIOCGAPART::
  Returns a disk's partition map
DKIOCSAPART::
  Sets a disk's partition map
DKIOCGGEOM::
  Returns a disk's geometry
DKIOCSGEOM::
  Sets a disk's geometry
DKIOCGVTOC::
  Returns a disk's Volume Table of Contents
DKIOCSVTOC::
  Sets a disk's Volume Table of Contents

[[disk-performance]]
==== Disk Performance

illumos DDI/DKI provides facilities to optimize I/O transfers for
improved file system performance. A mechanism manages the list of I/O
requests so as to optimize disk access for a file system. See
link:#asynchronous-data-transfers-block-drivers[Asynchronous Data Transfers (Block Drivers)] for a
description of enqueuing an I/O request.

The `diskhd` structure is used to manage a linked list of I/O requests.

[source,c]
----
struct diskhd {
    long     b_flags;         /* not used, needed for consistency*/
    struct   buf *b_forw,     *b_back;     /* queue of unit queues */
    struct   buf *av_forw,    *av_back;    /* queue of bufs for this unit */
    long     b_bcount;        /* active flag */
};
----

The `diskhd` data structure has two `buf` pointers that the driver can
manipulate. The `av++_++forw` pointer points to the first active I/O
request. The second pointer, `av++_++back`, points to the last active
request on the list.

A pointer to this structure is passed as an argument to `disksort(9F)`,
along with a pointer to the current `buf` structure being processed. The
`disksort` routine sorts the `buf` requests to optimize disk seek. The
routine then inserts the `buf` pointer into the `diskhd` list. The
`disksort` program uses the value that is in `b++_++resid` of the `buf`
structure as a sort key. The driver is responsible for setting this
value. Most illumos disk drivers use the cylinder group as the sort key.
This approach optimizes the file system read-ahead accesses.

When data has been added to the `diskhd` list, the device needs to
transfer the data. If the device is not busy processing a request, the
`xxstart` routine pulls the first `buf` structure off the `diskhd` list
and starts a transfer.

If the device is busy, the driver should return from the `xxstrategy`
entry point. When the hardware is done with the data transfer, an
interrupt is generated. The driver's interrupt routine is then called to
service the device. After servicing the interrupt, the driver can then
call the `start` routine to process the next `buf` structure in the
`diskhd` list.

[[scsi-target-drivers]]
=== SCSI Target Drivers

The illumos DDI/DKI divides the software interface to SCSI devices into
two major parts: _target_ drivers and _host bus adapter (HBA)_ drivers.
_Target_ refers to a driver for a device on a SCSI bus, such as a disk
or a tape drive. _Host bus adapter_ refers to the driver for the SCSI
controller on the host machine. SCSA defines the interface between these
two components. This chapter discusses target drivers only. See
link:#scsi-host-bus-adapter-drivers[SCSI Host Bus Adapter Drivers] for information on
host bus adapter drivers.

[NOTE]

The terms “host bus adapter” and “HBA” are equivalent to “host adapter,”
which is defined in SCSI specifications.
===

This chapter provides information on the following subjects:

* link:#introduction-to-target-drivers[Introduction to Target Drivers]
* link:#sun-common-scsi-architecture-overview[Sun Common SCSI Architecture Overview]
* link:#hardware-configuration-file[Hardware Configuration File]
* link:#declarations-and-data-structures[Declarations and Data Structures]
* link:#autoconfiguration-for-scsi-target-drivers[Autoconfiguration for SCSI Target Drivers]
* link:#resource-allocation[Resource Allocation]
* link:#building-and-transporting-a-command[Building and Transporting a Command]
* link:#scsi-options[SCSI Options]

[[introduction-to-target-drivers]]
=== Introduction to Target Drivers

Target drivers can be either character or
block device drivers, depending on the device. Drivers for tape drives
are usually character device drivers, while disks are handled by block
device drivers. This chapter describes how to write a SCSI target
driver. The chapter discusses the additional requirements that SCSA
places on block and character drivers for SCSI target devices.

The following reference documents provide supplemental information
needed by the designers of target drivers and host bus adapter drivers.

Small Computer System Interface 2 (SCSI-2), ANSI/NCITS X3.131-1994,
Global Engineering Documents, 1998. ISBN 1199002488.

_The Basics of SCSI_, Fourth Edition, ANCOT Corporation, 1998. ISBN
0963743988.

Refer also to the SCSI command specification
for the target device, provided by the hardware vendor.

[[sun-common-scsi-architecture-overview]]
=== Sun Common SCSI Architecture Overview

The Sun Common SCSI Architecture (SCSA) is
the illumos DDI/DKI programming interface for the transmission of SCSI
commands from a target driver to a host bus adapter driver. This
interface is independent of the type of host bus adapter hardware, the
platform, the processor architecture, and the SCSI command being
transported across the interface.

Conforming to the SCSA enables the target driver to pass SCSI commands
to target devices without knowledge of the hardware implementation of
the host bus adapter.

The SCSA conceptually separates building the SCSI command from
transporting the command with data across the SCSI bus. The architecture
defines the software interface between high-level and low-level software
components. The higher level software component consists of one or more
SCSI target drivers, which translate I/O requests into SCSI commands
appropriate for the peripheral device. The following example illustrates
the SCSI architecture.

.SCSA Block Diagram
[#scsi-fig-4]
image::figures/scsi-scsadiagram.png[Diagram shows the role of the Sun Common SCSI Architecture in relation to SCSI drivers in the operating system.]

The lower-level software component consists of a SCSA interface layer
and one or more host bus adapter drivers. The target driver is
responsible for the generation of the proper SCSI commands required to
execute the desired function and for processing the results.

[[general-flow-of-control]]
==== General Flow of Control

Assuming no transport errors occur, the following steps describe the
general flow of control for a read or write request.

[arabic]
. The target driver's `read(9E)` or `write(9E)` entry point is invoked.
`physio(9F)` is used to lock down memory, prepare a `buf` structure, and
call the strategy routine.
. The target driver's `strategy(9E)` routine checks the request.
`strategy` then allocates a `scsi++_++pkt(9S)` by using
`scsi++_++init++_++pkt(9F)`. The target driver initializes the packet
and sets the SCSI command descriptor block (CDB) using the
`scsi++_++setup++_++cdb(9F)` function. The target driver also specifies
a timeout. Then, the driver provides a pointer to a callback function.
The callback function is called by the host bus adapter driver on
completion of the command. The `buf(9S)` pointer should be saved in the
SCSI packet's target-private space.
. The target driver submits the packet to the host bus adapter driver by
using `scsi++_++transport(9F)`. The target driver is then free to accept
other requests. The target driver should not access the packet while the
packet is in transport. If either the host bus adapter driver or the
target supports queueing, new requests can be submitted while the packet
is in transport.
. As soon as the SCSI bus is free and the target not busy, the host bus
adapter driver selects the target and passes the CDB. The target driver
executes the command. The target then performs the requested data
transfers.
. After the target sends completion status and the command completes,
the host bus adapter driver notifies the target driver. To perform the
notification, the host calls the completion function that was specified
in the SCSI packet. At this time the host bus adapter driver is no
longer responsible for the packet, and the target driver has regained
ownership of the packet.
. The SCSI packet's completion routine analyzes the returned
information. The completion routine then determines whether the SCSI
operation was successful. If a failure has occurred, the target driver
retries the command by calling `scsi++_++transport(9F)` again. If the
host bus adapter driver does not support auto request sense, the target
driver must submit a request sense packet to retrieve the sense data in
the event of a check condition.
. After successful completion or if the command cannot be retried, the
target driver calls `scsi++_++destroy++_++pkt(9F)`.
`scsi++_++destroy++_++pkt` synchronizes the data.
`scsi++_++destroy++_++pkt` then frees the packet. If the target driver
needs to access the data before freeing the packet,
`scsi++_++sync++_++pkt(9F)` is called.
. Finally, the target driver notifies the requesting application that
the read or write transaction is complete. This notification is made by
returning from the `read(9E)` entry point in the driver for character
devices. Otherwise, notification is made indirectly through
`biodone(9F)`.

SCSA allows the execution of many of such operations, both overlapped
and queued, at various points in the process. The model places the
management of system resources on the host bus adapter driver. The
software interface enables the execution of target driver functions on
host bus adapter drivers by using SCSI bus adapters of varying degrees
of sophistication.

[[scsa-functions]]
==== SCSA Functions

SCSA defines functions to
manage the allocation and freeing of resources, the sensing and setting
of control states, and the transport of SCSI commands. These functions
are listed in the following table.

.Standard SCSA Functions
[width="100%",cols="56%,44%",options="header",]
|===
|Function Name |Category
|`scsi++_++abort(9F)` |Error handling
|`scsi++_++alloc++_++consistent++_++buf(9F)` |
|`scsi++_++destroy++_++pkt(9F)` |
|`scsi++_++dmafree(9F)` |
|`scsi++_++free++_++consistent++_++buf(9F)` |
|`scsi++_++ifgetcap(9F)` |Transport information and control
|`scsi++_++ifsetcap(9F)` |
|`scsi++_++init++_++pkt(9F)` |Resource management
|`scsi++_++poll(9F)` |Polled I/O
|`scsi++_++probe(9F)` |Probe functions
|`scsi++_++reset(9F)` |
|`scsi++_++setup++_++cdb(9F)` |CDB initialization function
|`scsi++_++sync++_++pkt(9F)` |
|`scsi++_++transport(9F)` |Command transport
|`scsi++_++unprobe(9F)` |
|===

[NOTE]

If your driver needs to work with a SCSI-1 device, use the
`makecom(9F)`.
===

[[hardware-configuration-file]]
=== Hardware Configuration File

Because SCSI devices are not
self-identifying, a hardware configuration file is required for a target
driver. See the `driver.conf(5)` and
`scsi++_++free++_++consistent++_++buf(9F)` man pages for details. The
following is a typical configuration file:

....
name="xx" class="scsi" target=2 lun=0;
....

The system reads
the file during autoconfiguration. The system uses the ++<++class++>++
property to identify the driver's possible parent. Then, the system
attempts to attach the driver to any parent driver that is of class
_scsi_. All host bus adapter drivers are of this class. Using the
++<++class++>++ property rather than the ++<++parent++>++ property is
preferred. This approach enables any host bus adapter driver that finds
the expected device at the specified ++<++target++>++ and ++<++lun++>++
IDs to attach to the target. The target driver is responsible for
verifying the class in its `probe(9E)` routine.

[[declarations-and-data-structures]]
=== Declarations and Data Structures

Target drivers must include the header file
`++<++sys/scsi/scsi.h++>++`.

SCSI target drivers must use the following command to generate a binary
module:

....
ld -r xx xx.o -N"misc/scsi"
....

[[scsi_device-structure]]
==== `scsi++_++device` Structure

The host bus adapter driver
allocates and initializes a `scsi++_++device(9S)` structure for the
target driver before either the `probe(9E)` or `attach(9E)` routine is
called. This structure stores information about each SCSI logical unit,
including pointers to information areas that contain both generic and
device-specific information. One `scsi++_++device(9S)` structure exists
for each logical unit that is attached to the system. The target driver
can retrieve a pointer to this structure by calling
`ddi++_++get++_++driver++_++private(9F)`.

[CAUTION]

Because the host bus adapter driver uses the private
field in the target device's `dev++_++info` structure, target drivers
must not use `ddi++_++set++_++driver++_++private(9F)`.
===

The `scsi++_++device(9S)` structure contains the following fields:

[source,c]
----
struct scsi_device {
    struct scsi_address           sd_address;    /* opaque address */
    dev_info_t                    *sd_dev;       /* device node */
    kmutex_t                      sd_mutex;
    void                          *sd_reserved;
    struct scsi_inquiry           *sd_inq;
    struct scsi_extended_sense    *sd_sense;
    caddr_t                       sd_private;
};
----

where:

`sd++_++address`::
  Data structure that is passed to the routines for SCSI resource
  allocation.
`sd++_++dev`::
  Pointer to the target's `dev++_++info` structure.
`sd++_++mutex`::
  Mutex for use by the target driver. This mutex is initialized by the
  host bus adapter driver and can be used by the target driver as a
  per-device mutex. Do not hold this mutex across a call to
  `scsi++_++transport(9F)` or `scsi++_++poll(9F)`. See
  link:#multithreading[Multithreading] for more information on mutexes.
`sd++_++inq`::
  Pointer for the target device's SCSI inquiry data. The
  `scsi++_++probe(9F)` routine allocates a buffer, fills the buffer in
  with inquiry data, and attaches the buffer to this field.
`sd++_++sense`::
  Pointer to a buffer to contain SCSI request sense data from the
  device. The target driver must allocate and manage this buffer. See
  link:#attach-entry-point-scsi-target-drivers[ Entry Point (SCSI Target Drivers)].
`sd++_++private`::
  Pointer field for use by the target driver. This field is commonly
  used to store a pointer to a private target driver state structure.

[[scsi_pkt-structure-target-drivers]]
==== `scsi++_++pkt` Structure (Target Drivers)

The `scsi++_++pkt` structure contains the
following fields:

[source,c]
----
struct scsi_pkt {
    opaque_t  pkt_ha_private;         /* private data for host adapter */
    struct scsi_address pkt_address;  /* destination packet is for */
    opaque_t  pkt_private;            /* private data for target driver */
    void     (*pkt_comp)(struct scsi_pkt *);  /* completion routine */
    uint_t   pkt_flags;               /* flags */
    int      pkt_time;                /* time allotted to complete command */
    uchar_t  *pkt_scbp;               /* pointer to status block */
    uchar_t  *pkt_cdbp;               /* pointer to command block */
    ssize_t  pkt_resid;               /* data bytes not transferred */
    uint_t   pkt_state;               /* state of command */
    uint_t   pkt_statistics;          /* statistics */
    uchar_t  pkt_reason;              /* reason completion called */
};
----

where:

`pkt++_++address`::
  Target device's address set by `scsi++_++init++_++pkt(9F)`.
`pkt++_++private`::
  Place to store private data for the target driver.
  ++<++pkt++_++private++>++ is commonly used to save the `buf(9S)`
  pointer for the command.
`pkt++_++comp`::
  Address of the completion routine. The host bus adapter driver calls
  this routine when the driver has transported the command. Transporting
  the command does not mean that the command succeeded. The target might
  have been busy. Another possibility is that the target might not have
  responded before the time out period elapsed. See the description for
  `pkt++_++time` field. The target driver must supply a valid value in
  this field. This value can be `NULL` if the driver does not want to be
  notified.

[NOTE]

Two different SCSI callback routines are provided. The `pkt++_++comp`
field identifies a _completion callback_ routine, which is called when
the host bus adapter completes its processing. A__resource callback__
routine is also available, which is called when currently unavailable
resources are likely to be available. See the
`scsi++_++init++_++pkt(9F)` man page.
===

`pkt++_++flags`::
  Provides additional control information, for example, to transport the
  command without disconnect privileges (`FLAG++_++NODISCON`) or to
  disable callbacks (`FLAG++_++NOINTR`). See the `scsi++_++pkt(9S)` man
  page for details.
`pkt++_++time`::
  Time out value in seconds. If the command is not completed within this
  time, the host bus adapter calls the completion routine with
  `pkt++_++reason` set to `CMD++_++TIMEOUT`. The target driver should
  set this field to longer than the maximum time the command might take.
  If the timeout is zero, no timeout is requested. Timeout starts when
  the command is transmitted on the SCSI bus.
`pkt++_++scbp`::
  Pointer to the block for SCSI status completion. This field is filled
  in by the host bus adapter driver.
`pkt++_++cdbp`::
  Pointer to the SCSI command descriptor block, the actual command to be
  sent to the target device. The host bus adapter driver does not
  interpret this field. The target driver must fill the field in with a
  command that the target device can process.
`pkt++_++resid`::
  Residual of the operation. The `pkt++_++resid` field has two different
  uses depending on how `pkt++_++resid` is used. When `pkt++_++resid` is
  used to allocate DMA resources for a command
  `scsi++_++init++_++pkt(9F)`, `pkt++_++resid` indicates the number of
  unallocable bytes. DMA resources might _not_ be allocated due to DMA
  hardware scatter-gather or other device limitations. After command
  transport, `pkt++_++resid` indicates the number of non-transferable
  data bytes. The field is filled in by the host bus adapter driver
  before the completion routine is called.
`pkt++_++state`::
  Indicates the state of the command. The host bus adapter driver fills
  in this field as the command progresses. One bit is set in this field
  for each of the five following command states:
  +
  * `STATE++_++GOT++_++BUS` – Acquired the bus
  * `STATE++_++GOT++_++TARGET` – Selected the target
  * `STATE++_++SENT++_++CMD` – Sent the command
  * `STATE++_++XFERRED++_++DATA` – Transferred data, if appropriate
  * `STATE++_++GOT++_++STATUS` – Received status from the device
`pkt++_++statistics`::
  Contains transport-related statistics set by the host bus adapter
  driver.
`pkt++_++reason`::
  Gives the reason the completion routine was called. The completion
  routine decodes this field. The routine then takes the appropriate
  action. If the command completes, that is, no transport errors occur,
  this field is set to `CMD++_++CMPLT`. Other values in this field
  indicate an error. After a command is completed, the target driver
  should examine the `pkt++_++scbp` field for a check condition status.
  See the `scsi++_++pkt(9S)` man page for more information.

[[autoconfiguration-for-scsi-target-drivers]]
=== Autoconfiguration for SCSI Target Drivers

  SCSI target
drivers must implement the standard autoconfiguration routines
`++_++init(9E)`, `++_++fini(9E)`, and `++_++info(9E)`. See for more
information.

The following routines are also required, but these routines must
perform specific SCSI and SCSA processing:

* `probe(9E)`
* `attach(9E)`
* `detach(9E)`
* `getinfo(9E)`

[[probe-entry-point-scsi-target-drivers]]
==== `probe` Entry Point (SCSI Target Drivers)

SCSI target devices are not self-identifying,
so target drivers must have a `probe(9E)` routine. This routine must
determine whether the expected type of device is present and responding.

The general structure and the return codes of the `probe(9E)` routine
are the same as the structure and return codes for other device drivers.
SCSI target drivers must use the `scsi++_++probe(9F)` routine in their
`probe(9E)` entry point. `scsi++_++probe(9F)` sends a SCSI inquiry
command to the device and returns a code that indicates the result. If
the SCSI inquiry command is successful, `scsi++_++probe(9F)` allocates a
`scsi++_++inquiry(9S)` structure and fills the structure in with the
device's inquiry data. Upon return from `scsi++_++probe(9F)`, the
`sd++_++inq` field of the `scsi++_++device(9S)` structure points to this
`scsi++_++inquiry(9S)` structure.

Because `probe(9E)` must be stateless, the target driver must call
`scsi++_++unprobe(9F)` before `probe(9E)` returns, even if
`scsi++_++probe(9F)` fails.

shows a typical `probe(9E)` routine. The routine in the example
retrieves the `scsi++_++device(9S)` structure from the private field of
its `dev++_++info` structure. The routine also retrieves the device's
SCSI target and logical unit numbers for printing in messages. The
`probe(9E)` routine then calls `scsi++_++probe(9F)` to verify that the
expected device, a printer in this case, is present.

If successful, `scsi++_++probe(9F)` attaches the device's SCSI inquiry
data in a `scsi++_++inquiry(9S)` structure to the `sd++_++inq` field of
the `scsi++_++device(9S)` structure. The driver can then determine
whether the device type is a printer, which is reported in the
`inq++_++dtype` field. If the device is a printer, the type is reported
with `scsi++_++log(9F)`, using `scsi++_++dname(9F)` to convert the
device type into a string.

[[scsi-14215]]
SCSI Target Driver `probe(9E)` Routine

[source,c]
----
static int
xxprobe(dev_info_t *dip)
{
    struct scsi_device *sdp;
    int rval, target, lun;
    /*
     * Get a pointer to the scsi_device(9S) structure
     */
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);

    target = sdp->sd_address.a_target;
    lun = sdp->sd_address.a_lun;
    /*
     * Call scsi_probe(9F) to send the Inquiry command. It will
     * fill in the sd_inq field of the scsi_device structure.
     */
    switch (scsi_probe(sdp, NULL_FUNC)) {
    case SCSIPROBE_FAILURE:
    case SCSIPROBE_NORESP:
    case SCSIPROBE_NOMEM:
        /*
         * In these cases, device might be powered off,
         * in which case we might be able to successfully
         * probe it at some future time - referred to
         * as `deferred attach'.
         */
        rval = DDI_PROBE_PARTIAL;
        break;
    case SCSIPROBE_NONCCS:
    default:
        /*
         * Device isn't of the type we can deal with,
         * and/or it will never be usable.
         */
        rval = DDI_PROBE_FAILURE;
        break;
    case SCSIPROBE_EXISTS:
        /*
         * There is a device at the target/lun address. Check
         * inq_dtype to make sure that it is the right device
         * type. See scsi_inquiry(9S)for possible device types.
         */
        switch (sdp->sd_inq->inq_dtype) {
        case DTYPE_PRINTER:
        scsi_log(sdp, "xx", SCSI_DEBUG,
            "found %s device at target%d, lun%d\n",
            scsi_dname((int)sdp->sd_inq->inq_dtype),
            target, lun);
        rval = DDI_PROBE_SUCCESS;
        break;
        case DTYPE_NOTPRESENT:
        default:
        rval = DDI_PROBE_FAILURE;
        break;     
        }    
    }
    scsi_unprobe(sdp);
    return (rval);
}
----

A more thorough `probe(9E)` routine could check `scsi++_++inquiry(9S)`
to make sure that the device is of the type expected by a particular
driver.

[[attach-entry-point-scsi-target-drivers]]
==== `attach` Entry Point (SCSI Target Drivers)

After the `probe(9E)` routine has verified that the expected device is
present, `attach(9E)` is called. `attach` performs these tasks:

* Allocates and initializes any per-instance data.
* Creates minor device node information.
* Restores the hardware state of a device after a suspension of the
device or the system. See link:#attach-entry-point[ Entry Point] for
details.

A SCSI target driver needs to call `scsi++_++probe(9F)` again to
retrieve the device's inquiry data. The driver must also create a SCSI
request sense packet. If the attach is successful, the `attach` function
should not call `scsi++_++unprobe(9F)`.

Three routines are used to create the request sense packet:
`scsi++_++alloc++_++consistent++_++buf(9F)`,
`scsi++_++init++_++pkt(9F)`, and `scsi++_++setup++_++cdb(9F)`.
`scsi++_++alloc++_++consistent++_++buf(9F)` allocates a buffer that is
suitable for consistent DMA. `scsi++_++alloc++_++consistent++_++buf`
then returns a pointer to a `buf(9S)` structure. The advantage of a
consistent buffer is that no explicit synchronization of the data is
required. In other words, the target driver can access the data after
the callback. The `sd++_++sense` element of the device's
`scsi++_++device(9S)` structure must be initialized with the address of
the sense buffer. `scsi++_++init++_++pkt(9F)` creates and partially
initializes a `scsi++_++pkt(9S)` structure. `scsi++_++setup++_++cdb(9F)`
creates a SCSI command descriptor block, in this case by creating a SCSI
request sense command.

  Note that a SCSI
device is not self-identifying and does not have a `reg` property. As a
result, the driver must set the `pm-hardware-state` property. Setting
`pm-hardware-state` informs the framework that this device needs to be
suspended and then resumed.

The following example shows the SCSI target driver's `attach` routine.

[[scsi-42148]]
SCSI Target Driver `attach(9E)` Routine

[source,c]
----
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate         *xsp;
    struct scsi_pkt        *rqpkt = NULL;
    struct scsi_device     *sdp;
    struct buf         *bp = NULL;
    int            instance;
    instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
          break;
      case DDI_RESUME:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
    /*
     * Allocate a state structure and initialize it.
     */
    xsp = ddi_get_soft_state(statep, instance);
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);
    /*
     * Cross-link the state and scsi_device(9S) structures.
     */
    sdp->sd_private = (caddr_t)xsp;
    xsp->sdp = sdp;
    /*
     * Call scsi_probe(9F) again to get and validate inquiry data.
     * Allocate a request sense buffer. The buf(9S) structure
     * is set to NULL to tell the routine to allocate a new one.
     * The callback function is set to NULL_FUNC to tell the
     * routine to return failure immediately if no
     * resources are available.
     */
    bp = scsi_alloc_consistent_buf(&sdp->sd_address, NULL,
    SENSE_LENGTH, B_READ, NULL_FUNC, NULL);
    if (bp == NULL)
        goto failed;
    /*
     * Create a Request Sense scsi_pkt(9S) structure.
     */
    rqpkt = scsi_init_pkt(&sdp->sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, PKT_CONSISTENT, NULL_FUNC, NULL);
    if (rqpkt == NULL)
        goto failed;
    /*
     * scsi_alloc_consistent_buf(9F) returned a buf(9S) structure.
     * The actual buffer address is in b_un.b_addr.
     */
    sdp->sd_sense = (struct scsi_extended_sense *)bp->b_un.b_addr;
    /*
     * Create a Group0 CDB for the Request Sense command
     */
    if (scsi_setup_cdb((union scsi_cdb *)rqpkt->pkt_cdbp,
        SCMD_REQUEST_SENSE, 0, SENSE__LENGTH, 0) == 0)
        goto failed;;
    /*
     * Fill in the rest of the scsi_pkt structure.
     * xxcallback() is the private command completion routine.
     */
    rqpkt->pkt_comp = xxcallback;
    rqpkt->pkt_time = 30; /* 30 second command timeout */
    rqpkt->pkt_flags |= FLAG_SENSING;
    xsp->rqs = rqpkt;
    xsp->rqsbuf = bp;
    /*
     * Create minor nodes, report device, and do any other initialization. */
     * Since the device does not have the 'reg' property,
     * cpr will not call its DDI_SUSPEND/DDI_RESUME entries.
     * The following code is to tell cpr that this device
     * needs to be suspended and resumed.
     */
    (void) ddi_prop_update_string(device, dip,
        "pm-hardware-state", "needs-suspend-resume");
    xsp->open = 0;
    return (DDI_SUCCESS);
failed:
    if (bp)
        scsi_free_consistent_buf(bp);
    if (rqpkt)
        scsi_destroy_pkt(rqpkt);
    sdp->sd_private = (caddr_t)NULL;
    sdp->sd_sense = NULL;
    scsi_unprobe(sdp);
    /* Free any other resources, such as the state structure. */
    return (DDI_FAILURE);
}
----

[[detach-entry-point-scsi-target-drivers]]
==== `detach` Entry Point (SCSI Target Drivers)

The `detach(9E)` entry point is the inverse of `attach(9E)`. `detach`
must free all resources that were allocated in `attach`. If successful,
the detach should call `scsi++_++unprobe(9F)`. The following example
shows a target driver `detach` routine.

[[scsi-42748]]
SCSI Target Driver `detach(9E)` Routine

[source,c]
----
static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    struct xxstate *xsp;
    switch (cmd) {
      case DDI_DETACH:
          /*
           * Normal detach(9E) operations, such as getting a
           * pointer to the state structure
           */
          scsi_free_consistent_buf(xsp->rqsbuf);
          scsi_destroy_pkt(xsp->rqs);
          xsp->sdp->sd_private = (caddr_t)NULL;
          xsp->sdp->sd_sense = NULL;
          scsi_unprobe(xsp->sdp);
          /*
           * Remove minor nodes.
           * Free resources, such as the state structure and properties.
           */
          return (DDI_SUCCESS);
      case DDI_SUSPEND:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
}
----

[[getinfo-entry-point-scsi-target-drivers]]
==== `getinfo` Entry Point (SCSI Target Drivers)

The `getinfo(9E)` routine for SCSI target drivers is much the same as
for other drivers (see link:#getinfo-entry-point[ Entry Point] for more
information on `DDI++_++INFO++_++DEVT2INSTANCE` case). However, in the
`DDI++_++INFO++_++DEVT2DEVINFO` case of the `getinfo` routine, the
target driver must return a pointer to its `dev++_++info` node. This
pointer can be saved in the driver state structure or can be retrieved
from the `sd++_++dev` field of the `scsi++_++device(9S)` structure. The
following example shows an alternative SCSI target driver `getinfo` code
fragment.

[[scsi-17982]]
Alternative SCSI Target Driver `getinfo` Code Fragment

[source,c]
----
case DDI_INFO_DEVT2DEVINFO:
    dev = (dev_t)arg;
    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (DDI_FAILURE);
    *result = (void *)xsp->sdp->sd_dev;
    return (DDI_SUCCESS);
----

[[resource-allocation]]
=== Resource Allocation

To send a SCSI command to the device, the
target driver must create and initialize a `scsi++_++pkt(9S)` structure.
This structure must then be passed to the host bus adapter driver.

[[scsiinitpkt-function]]
==== `scsi++_++init++_++pkt` Function

The `scsi++_++init++_++pkt(9F)` routine
allocates and zeroes a `scsi++_++pkt(9S)` structure.
`scsi++_++init++_++pkt` also sets pointers to `pkt++_++private`,
`++*++pkt++_++scbp`, and `++*++pkt++_++cdbp`. Additionally,
`scsi++_++init++_++pkt` provides a callback mechanism to handle the case
where resources are not available. This function has the following
syntax:

[source,c]
----
struct scsi_pkt *scsi_init_pkt(struct scsi_address *ap,
     struct scsi_pkt *pktp, struct buf *bp, int cmdlen,
     int statuslen, int privatelen, int flags,
     int (*callback)(caddr_t), caddr_t arg)
----

where:

++<++ap++>++::
  Pointer to a `scsi++_++address` structure. `ap` is the
  `sd++_++address` field of the device's `scsi++_++device(9S)`
  structure.
++<++pktp++>++::
  Pointer to the `scsi++_++pkt(9S)` structure to be initialized. If this
  pointer is set to `NULL`, a new packet is allocated.
++<++bp++>++::
  Pointer to a `buf(9S)` structure. If this pointer is not null and has
  a valid byte count, DMA resources are allocated.
++<++cmdlen++>++::
  Length of the SCSI command descriptor block in bytes.
++<++statuslen++>++::
  Required length of the SCSI status completion block in bytes.
++<++privatelen++>++::
  Number of bytes to allocate for the `pkt++_++private` field.
++<++flags++>++::
  Set of flags:
  +
  * `PKT++_++CONSISTENT` – This bit must be set if the DMA buffer was
  allocated using `scsi++_++alloc++_++consistent++_++buf(9F)`. In this
  case, the host bus adapter driver guarantees that the data transfer is
  properly synchronized before performing the target driver's command
  completion callback.
  * `PKT++_++DMA++_++PARTIAL` – This bit can be set if the driver
  accepts a partial DMA mapping. If set, `scsi++_++init++_++pkt(9F)`
  allocates DMA resources with the `DDI++_++DMA++_++PARTIAL` flag set.
  The `pkt++_++resid` field of the `scsi++_++pkt(9S)` structure can be
  returned with a nonzero residual. A nonzero value indicates the number
  of bytes for which `scsi++_++init++_++pkt(9F)` was unable to allocate
  DMA resources.
++<++callback++>++::
  Specifies the action to take if resources are not available. If set to
  `NULL++_++FUNC`, `scsi++_++init++_++pkt(9F)` returns the value `NULL`
  immediately. If set to `SLEEP++_++FUNC`, `scsi++_++init++_++pkt` does
  not return until resources are available. Any other valid kernel
  address is interpreted as the address of a function to be called when
  resources are likely to be available.
++<++arg++>++::
  Parameter to pass to the callback function.

The `scsi++_++init++_++pkt` routine synchronizes the data prior to
transport. If the driver needs to access the data after transport, the
driver should call `scsi++_++sync++_++pkt(9F)` to flush any intermediate
caches. The `scsi++_++sync++_++pkt` routine can be used to synchronize
any cached data.

[[scsisyncpkt-function]]
==== `scsi++_++sync++_++pkt` Function

If the target driver needs to resubmit the packet after
changing the data, `scsi++_++sync++_++pkt(9F)` must be called before
calling `scsi++_++transport(9F)`. However, if the target driver does not
need to access the data, `scsi++_++sync++_++pkt` does not need to be
called after the transport.

[[scsidestroypkt-function]]
==== `scsi++_++destroy++_++pkt` Function

The `scsi++_++destroy++_++pkt(9F)` routine synchronizes
any remaining cached data that is associated with the packet, if
necessary. The routine then frees the packet and associated command,
status, and target driver-private data areas. This routine should be
called in the command completion routine.

[[scsiallocconsistent_buf-function]]
==== `scsi++_++alloc++_++consistent++_++buf` Function

For most I/O requests, the data buffer
passed to the driver entry points is not accessed directly by the
driver. The buffer is just passed on to `scsi++_++init++_++pkt(9F)`. If
a driver sends SCSI commands that operate on buffers that the driver
itself examines, the buffers should be DMA consistent. The SCSI request
sense command is a good example. The
`scsi++_++alloc++_++consistent++_++buf(9F)` routine allocates a
`buf(9S)` structure and a data buffer that is suitable for
DMA-consistent operations. The HBA performs any necessary
synchronization of the buffer before performing the command completion
callback.

[NOTE]

`scsi++_++alloc++_++consistent++_++buf(9F)` uses scarce system
resources. Thus, you should use `scsi++_++alloc++_++consistent++_++buf`
sparingly.
===

[[scsifreeconsistent_buf-function]]
==== `scsi++_++free++_++consistent++_++buf` Function

`scsi++_++free++_++consistent++_++buf(9F)` releases a
`buf(9S)` structure and the associated data buffer allocated with
`scsi++_++alloc++_++consistent++_++buf(9F)`. See link:#attach-entry-point-scsi-target-drivers[ Entry
Point (SCSI Target Drivers)] and link:#detach-entry-point-scsi-target-drivers[ Entry Point (SCSI
Target Drivers)] for examples.

[[building-and-transporting-a-command]]
=== Building and Transporting a Command

The host bus adapter driver is responsible for transmitting the command
to the device. Furthermore, the driver is responsible for handling the
low-level SCSI protocol. The `scsi++_++transport(9F)` routine hands a
packet to the host bus adapter driver for transmission. The target
driver has the responsibility to create a valid `scsi++_++pkt(9S)`
structure.

[[building-a-command]]
==== Building a Command

The routine `scsi++_++init++_++pkt(9F)`
allocates space for a SCSI CDB, allocates DMA resources if necessary,
and sets the `pkt++_++flags` field, as shown in this example:

....
pkt = scsi_init_pkt(&sdp->sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, 0, SLEEP_FUNC, NULL);
....

This example creates a new packet along with allocating DMA resources as
specified in the passed `buf(9S)` structure pointer. A SCSI CDB is
allocated for a Group 0 (6-byte) command. The `pkt++_++flags` field is
set to zero, but no space is allocated for the `pkt++_++private` field.
This call to `scsi++_++init++_++pkt(9F)`, because of the
`SLEEP++_++FUNC` parameter, waits indefinitely for resources if no
resources are currently available.

The next step is
to initialize the SCSI CDB, using the `scsi++_++setup++_++cdb(9F)`
function:

....
if (scsi_setup_cdb((union scsi_cdb *)pkt->pkt_cdbp,
    SCMD_READ, bp->b_blkno, bp->b_bcount >> DEV_BSHIFT, 0) == 0)
    goto failed;
....

This example builds a Group 0 command descriptor block. The example
fills in the `pkt++_++cdbp` field as follows:

* The command itself is in byte 0. The command is set from the parameter
`SCMD++_++READ`.
* The address field is in bits 0-4 of byte 1 and bytes 2 and 3. The
address is set from `bp-++>++b++_++blkno`.
* The count field is in byte 4. The count is set from the last
parameter. In this case, `count` is set to `bp-++>++b++_++bcount`
`++>>++` `DEV++_++BSHIFT`, where `DEV++_++BSHIFT` is the byte count of
the transfer converted to the number of blocks.

[NOTE]

`scsi++_++setup++_++cdb(9F)` does not support setting a
target device's logical unit number (LUN) in bits 5-7 of byte 1 of the
SCSI command block. This requirement is defined by SCSI-1. For SCSI-1
devices that require the LUN bits set in the command block, use
`makecom++_++g0(9F)` or some equivalent rather than
`scsi++_++setup++_++cdb(9F)`.
===

After initializing the SCSI CDB, initialize three other fields in the
packet and store as a pointer to the packet in the state structure.

....
pkt->pkt_private = (opaque_t)bp;
pkt->pkt_comp = xxcallback;
pkt->pkt_time = 30;
xsp->pkt = pkt;
....

The `buf(9S)` pointer is saved in the `pkt++_++private` field for later
use in the completion routine.

[[setting-target-capabilities]]
==== Setting Target Capabilities

The target
drivers use `scsi++_++ifsetcap(9F)` to set the capabilities of the host
adapter driver. A _cap_ is a name-value pair, consisting of a
null-terminated character string and an integer value. The current value
of a capability can be retrieved using `scsi++_++ifgetcap(9F)`.
`scsi++_++ifsetcap(9F)` allows capabilities to be set for all targets on
the bus.

In general, however, setting capabilities of targets that are not owned
by the target driver is not recommended. This practice is not
universally supported by HBA drivers. Some capabilities, such as
disconnect and synchronous, can be set by default by the HBA driver.
Other capabilities might need to be set explicitly by the target driver.
Wide-xfer and tagged-queueing must be set by the target drive, for
example.

[[transporting-a-command]]
==== Transporting a Command

After the `scsi++_++pkt(9S)` structure is
filled in, use `scsi++_++transport(9F)` to hand the structure to the bus
adapter driver:

[source,c]
----
if (scsi_transport(pkt) != TRAN_ACCEPT) {
    bp->b_resid = bp->b_bcount;
    bioerror(bp, EIO);
    biodone(bp);
}
----

The other return values from
`scsi++_++transport(9F)` are as follows:

* TRAN++_++BUSY – A command for the specified target is already in
progress.
* TRAN++_++BADPKT – The DMA count in the packet was too large, or the
host adapter driver rejected this packet for other reasons.

* TRAN++_++FATAL++_++ERROR – The host adapter driver is unable to accept
this packet.

[NOTE]

The mutex `sd++_++mutex` in the `scsi++_++device(9S)` structure must not
be held across a call to `scsi++_++transport(9F)`.
===

If `scsi++_++transport(9F)` returns TRAN++_++ACCEPT, the packet becomes
the responsibility of the host bus adapter driver. The packet should not
be accessed by the target driver until the command completion routine is
called.

[[synchronous-scsi_transport-function]]
===== Synchronous `scsi++_++transport` Function

If `FLAG++_++NOINTR` is set in the packet, then `scsi++_++transport(9F)`
does not return until the command is complete. No callback is performed.

[NOTE]

Do not use `FLAG++_++NOINTR` in interrupt context.
===

[[command-completion]]
==== Command Completion

When the host bus adapter driver is through
with the command, the driver invokes the packet's completion callback
routine. The driver then passes a pointer to the `scsi++_++pkt(9S)`
structure as a parameter. After decoding the packet, the completion
routine takes the appropriate action.

link:#scsi-35252[example++_++title] presents a simple completion
callback routine. This code checks for transport failures. In case of
failure, the routine gives up rather than retrying the command. If the
target is busy, extra code is required to resubmit the command at a
later time.

If the command results in a check condition, the target driver needs to
send a request sense command unless auto request sense has been enabled.

Otherwise, the command succeeded. At the end of processing for the
command, the command destroys the packet and calls `biodone(9F)`.

In the event of a transport error, such as a bus reset or parity
problem, the target driver can resubmit the packet by using
`scsi++_++transport(9F)`. No values in the packet need to be changed
prior to resubmitting.

The following example does not attempt to retry incomplete commands.

[NOTE]

Normally, the target driver's callback function is called in interrupt
context. Consequently, the callback function should never sleep.
===

[[scsi-35252]]
Completion Routine for a SCSI Driver

[source,c]
----
static void
xxcallback(struct scsi_pkt *pkt)
{
    struct buf        *bp;
    struct xxstate    *xsp;
    minor_t           instance;
    struct scsi_status *ssp;
    /*
     * Get a pointer to the buf(9S) structure for the command
     * and to the per-instance data structure.
     */
    bp = (struct buf *)pkt->pkt_private;
    instance = getminor(bp->b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Figure out why this callback routine was called
     */
    if (pkt->pkt_reason != CMP_CMPLT) {
        bp->b_resid = bp->b_bcount;
        bioerror(bp, EIO);
        scsi_destroy_pkt(pkt);          /* Release resources */
        biodone(bp);                    /* Notify waiting threads */ ;
    } else {
        /*
         * Command completed, check status.
         * See scsi_status(9S)
         */
        ssp = (struct scsi_status *)pkt->pkt_scbp;
        if (ssp->sts_busy) {
            /* error, target busy or reserved */
        } else if (ssp->sts_chk) {
            /* Send a request sense command. */
        } else {
            bp->b_resid = pkt->pkt_resid;  /* Packet completed OK */
            scsi_destroy_pkt(pkt);
            biodone(bp);
       }
    }
}
----

[[reuse-of-packets]]
==== Reuse of Packets

A target driver can reuse packets in the
following ways:

* Resubmit the packet unchanged.
*  Use `scsi++_++sync++_++pkt(9F)` to
synchronize the data. Then, process the data in the driver. Finally,
resubmit the packet.
*  Free DMA resources, using
`scsi++_++dmafree(9F)`, and pass the `pkt` pointer to
`scsi++_++init++_++pkt(9F)` for binding to a new `bp`. The target driver
is responsible for reinitializing the packet. The CDB has to have the
same length as the previous CDB.
* If only partial DMA is allocated during the first call to
`scsi++_++init++_++pkt(9F)`, subsequent calls to
`scsi++_++init++_++pkt(9F)` can be made for the same packet. Calls can
be made to `bp` as well to adjust the DMA resources to the next portion
of the transfer.

[[auto-request-sense-mode]]
==== Auto-Request Sense Mode

Auto-request sense mode is
most desirable if queuing is used, whether the queuing is tagged or
untagged. A contingent allegiance condition is cleared by any subsequent
command and, consequently, the sense data is lost. Most HBA drivers
start the next command before performing the target driver callback.
Other HBA drivers can use a separate, lower-priority thread to perform
the callbacks. This approach might increase the time needed to notify
the target driver that the packet completed with a check condition. In
this case, the target driver might not be able to submit a request sense
command in time to retrieve the sense data.

To avoid this loss of sense data, the HBA driver, or controller, should
issue a request sense command if a check condition has been detected.
This mode is known as auto-request sense mode. Note that not all HBA
drivers are capable of auto-request sense mode, and some drivers can
only operate with auto-request sense mode enabled.

A target driver enables auto-request-sense mode by using
`scsi++_++ifsetcap(9F)`. The following example shows auto-request sense
enabling.

[[scsi-73381]]
Enabling Auto-Request Sense Mode

[source,c]
----
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate *xsp;
    struct scsi_device *sdp = (struct scsi_device *)
    ddi_get_driver_private(dip);
    /*
     * Enable auto-request-sense; an auto-request-sense cmd might
     * fail due to a BUSY condition or transport error. Therefore,
     * it is recommended to allocate a separate request sense
     * packet as well.
     * Note that scsi_ifsetcap(9F) can return -1, 0, or 1
     */
    xsp->sdp_arq_enabled =
    ((scsi_ifsetcap(ROUTE, “auto-rqsense”, 1, 1) == 1) ? 1 : 0);
    /*
     * If the HBA driver supports auto request sense then the
     * status blocks should be sizeof (struct scsi_arq_status);
     * else
     * One byte is sufficient
     */
    xsp->sdp_cmd_stat_size =  (xsp->sdp_arq_enabled ?
    sizeof (struct scsi_arq_status) : 1);
    /* ... */
}
----

If a packet is allocated using `scsi++_++init++_++pkt(9F)` and
auto-request sense is desired on this packet, additional space is
needed. The target driver must request this space for the status block
to hold the auto-request sense structure. The sense length used in the
request sense command is `sizeof`, from `struct`
`scsi++_++extended++_++sense`. Auto-request sense can be disabled per
individual packet by allocating `sizeof`, from `struct`
`scsi++_++status`, for the status block.

The packet is submitted using `scsi++_++transport(9F)` as usual. When a
check condition occurs on this packet, the host adapter driver takes the
following steps:

* Issues a request sense command if the controller does not have
auto-request sense capability
* Obtains the sense data
* Fills in the `scsi++_++arq++_++status` information in the packet's
status block
* Sets `STATE++_++ARQ++_++DONE` in the packet's `pkt++_++state` field
* Calls the packet's callback handler (`pkt++_++comp`)

The target driver's callback routine should verify that sense data is
available by checking the `STATE++_++ARQ++_++DONE` bit in
`pkt++_++state`. `STATE++_++ARQ++_++DONE` implies that a check condition
has occurred and that a request sense has been performed. If
auto-request sense has been temporarily disabled in a packet, subsequent
retrieval of the sense data cannot be guaranteed.

The target driver should then verify whether the auto-request sense
command completed successfully and decode the sense data.

[[dump-handling]]
==== Dump Handling

The `dump(9E)` entry point copies a portion of virtual address space
directly to the specified device in the case of system failure or
checkpoint operation. See the `cpr(4)` and `dump(9E)` man pages. The
`dump(9E)` entry point must be capable of performing this operation
without the use of interrupts.

The arguments for `dump` are as follows:

++<++dev++>++::
  Device number of the dump device
++<++addr++>++::
  Kernel virtual address at which to start the dump
++<++blkno++>++::
  First destination block on the device
++<++nblk++>++::
  Number of blocks to dump

[[scsi-ex-3]]
`dump(9E)` Routine

[source,c]
----
static int
xxdump(dev_t dev, caddr_t addr, daddr_t blkno, int nblk)
{
    struct xxstate     *xsp;
    struct buf         *bp;
    struct scsi_pkt    *pkt;
    int    rval;
    int    instance;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);

    if (tgt->suspended) {
        (void) pm_raise_power(DEVINFO(tgt), 0, 1);
    }

    bp = getrbuf(KM_NOSLEEP);
    if (bp == NULL) {
        return (EIO);
    }

/* Calculate block number relative to partition. */
    bp->b_un.b_addr = addr;
    bp->b_edev = dev;
    bp->b_bcount = nblk * DEV_BSIZE;
    bp->b_flags = B_WRITE | B_BUSY;
    bp->b_blkno = blkno;

    pkt = scsi_init_pkt(ROUTE(tgt), NULL, bp, CDB_GROUP1,
    sizeof (struct scsi_arq_status),
    sizeof (struct bst_pkt_private), 0, NULL_FUNC, NULL);
    if (pkt == NULL) {
        freerbuf(bp);
        return (EIO);
    }
    (void) scsi_setup_cdb((union scsi_cdb *)pkt->pkt_cdbp,
        SCMD_WRITE_G1, blkno, nblk, 0);
    /*
     * While dumping in polled mode, other cmds might complete
     * and these should not be resubmitted. we set the
     * dumping flag here which prevents requeueing cmds.
     */
    tgt->dumping = 1;
    rval = scsi_poll(pkt);
    tgt->dumping = 0;

    scsi_destroy_pkt(pkt);
    freerbuf(bp);

    if (rval != DDI_SUCCESS) {
        rval = EIO;
    }
    return (rval);
}
----

[[scsi-options]]
=== SCSI Options

SCSA defines a global variable,
++<++scsi++_++options++>++, for control and debugging. The defined bits
in ++<++scsi++_++options++>++ can be found in the file
`++<++sys/scsi/conf/autoconf.h++>++`. The ++<++scsi++_++options++>++
uses the bits as follows:

`SCSI++_++OPTIONS++_++DR`::
  Enables global disconnect or reconnect.
`SCSI++_++OPTIONS++_++FAST`::
  Enables global FAST SCSI support: 10 Mbytes/sec transfers. The HBA
  should not operate in FAST SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST (0x100) bit is set.
`SCSI++_++OPTIONS++_++FAST20`::
  Enables global FAST20 SCSI support: 20 Mbytes/sec transfers. The HBA
  should not operate in FAST20 SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST20 (0x400) bit is set.
`SCSI++_++OPTIONS++_++FAST40`::
  Enables global FAST40 SCSI support: 40 Mbytes/sec transfers. The HBA
  should not operate in FAST40 SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST40 (0x800) bit is set.
`SCSI++_++OPTIONS++_++FAST80`::
  Enables global FAST80 SCSI support: 80 Mbytes/sec transfers. The HBA
  should not operate in FAST80 SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST80 (0x1000) bit is set.
`SCSI++_++OPTIONS++_++FAST160`::
  Enables global FAST160 SCSI support: 160 Mbytes/sec transfers. The HBA
  should not operate in FAST160 SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST160 (0x2000) bit is set.
`SCSI++_++OPTIONS++_++FAST320`::
  Enables global FAST320 SCSI support: 320 Mbytes/sec transfers. The HBA
  should not operate in FAST320 SCSI mode unless the
  SCSI++_++OPTIONS++_++FAST320 (0x4000) bit is set.
`SCSI++_++OPTIONS++_++LINK`::
  Enables global link support.
`SCSI++_++OPTIONS++_++PARITY`::
  Enables global parity support.
`SCSI++_++OPTIONS++_++QAS`::
  Enables the Quick Arbitration Select feature. QAS is used to decrease
  protocol overhead when devices arbitrate for and access the bus. QAS
  is only supported on Ultra4 (FAST160) SCSI devices, although not all
  such devices support QAS. The HBA should not operate in QAS SCSI mode
  unless the SCSI++_++OPTIONS++_++QAS (0x100000) bit is set. Consult the
  appropriate Sun hardware documentation to determine whether your
  machine supports QAS.
`SCSI++_++OPTIONS++_++SYNC`::
  Enables global synchronous transfer capability.
`SCSI++_++OPTIONS++_++TAG`::
  Enables global tagged queuing support.
`SCSI++_++OPTIONS++_++WIDE`::
  Enables global WIDE SCSI.

[NOTE]

The setting of ++<++scsi++_++options++>++ affects _all_ host bus adapter
drivers and all target drivers that are present on the system. Refer to
the `scsi++_++hba++_++attach(9F)` man page for information on
controlling these options for a particular host adapter.
===

[[scsi-host-bus-adapter-drivers]]
=== SCSI Host Bus Adapter Drivers

This chapter contains information on creating SCSI host bus adapter
(HBA) drivers. The chapter provides sample code illustrating the
structure of a typical HBA driver. The sample code shows the use of the
HBA driver interfaces that are provided by the Sun Common SCSI
Architecture (SCSA). This chapter provides information on the following
subjects:

* link:#introduction-to-host-bus-adapter-drivers[Introduction to Host Bus Adapter Drivers]
* link:#scsi-interface[SCSI Interface]
* link:#scsa-hba-interfaces[SCSA HBA Interfaces]
* link:#hba-driver-dependency-and-configuration-issues[HBA Driver Dependency and Configuration Issues]
* link:#entry-points-for-scsa-hba-drivers[Entry Points for SCSA HBA Drivers]
* link:#scsi-hba-driver-specific-issues[SCSI HBA Driver Specific Issues]
* link:#support-for-queuing[Support for Queuing]

[[introduction-to-host-bus-adapter-drivers]]
=== Introduction to Host Bus Adapter Drivers

As described in link:#scsi-target-drivers[SCSI Target Drivers], the DDI/DKI
divides the software interface to SCSI devices into two major parts:

* Target devices and drivers
* Host bus adapter devices and drivers

_Target_ _device_ refers to a device on a SCSI bus, such as a disk or a
tape drive. _Target_ _driver_ refers to a software component installed
as a device driver. Each target device on a SCSI bus is controlled by
one instance of the target driver.

_Host bus adapter_ _device_ refers to HBA hardware, such as an SBus or
PCI SCSI adapter card. _Host bus adapter_ _driver_ refers to a software
component that is installed as a device driver. Some examples are the
`esp` driver on a SPARC machine, the `ncrs` driver on an x86 machine,
and the `isp` driver, which works on both architectures. An instance of
the HBA driver controls each of its host bus adapter devices that are
configured in the system.

The Sun Common SCSI Architecture (SCSA) defines the interface between
the target and HBA components.

[NOTE]

Understanding SCSI target drivers is an essential prerequisite to
writing effective SCSI HBA drivers. For information on SCSI target
drivers, see link:#scsi-target-drivers[SCSI Target Drivers]. Target driver
developers can also benefit from reading this chapter.
===

The host bus adapter driver is responsible for performing the following
tasks:

* Managing host bus adapter hardware
* Accepting SCSI commands from the SCSI target driver
* Transporting the commands to the specified SCSI target device
* Performing any data transfers that the command requires
* Collecting status
* Handling auto-request sense (optional)
* Informing the target driver of command completion or failure

[[scsi-interface]]
=== SCSI Interface

SCSI HBA driver

HBA driver

SCSI HBA driver

SCSA is the DDI/DKI programming interface for the
transmission of SCSI commands from a target driver to a host adapter
driver. By conforming to the SCSA, the target driver can easily pass any
combination of SCSI commands and sequences to a target device. Knowledge
of the hardware implementation of the host adapter is not necessary.
Conceptually, SCSA separates the building of a SCSI command from the
transporting of the command with data to the SCSI bus. SCSA manages the
connections between the target and HBA drivers through an HBA
__transport__layer, as shown in the following figure.

.SCSA Interface
[#scsihba-fig-11]
image::figures/scsihba-scsadiagram.png[Diagram shows the host bus adapter transport layer between a target driver and SCSI devices.]

   The _HBA transport layer_
is a software and hardware layer that is responsible for transporting a
SCSI command to a SCSI target device. The HBA driver provides resource
allocation, DMA management, and transport services in response to
requests made by SCSI target drivers through SCSA. The host adapter
driver also manages the host adapter hardware and the SCSI protocols
necessary to perform the commands. When a command has been completed,
the HBA driver calls the target driver's SCSI `pkt` command completion
routine.

The following example illustrates this flow, with emphasis on the
transfer of information from target drivers to SCSA to HBA drivers. The
figure also shows typical transport entry points and function calls.

.Transport Layer Flow
[#scsihba-fig-14]
image::figures/scsihba-translayerflow.png[Diagram shows how commands flow through the HBA transport layer.]

[[scsa-hba-interfaces]]
=== SCSA HBA Interfaces

SCSA HBA interfaces include HBA entry points, HBA data structures, and
an HBA framework.

[[scsa-hba-entry-point-summary]]
==== SCSA HBA Entry Point Summary

SCSA defines a number of HBA
driver entry points. These entry points are listed in the following
table. The entry points are called by the system when a target driver
instance connected to the HBA driver is configured. The entry points are
also called when the target driver makes a SCSA request. See
link:#entry-points-for-scsa-hba-drivers[Entry Points for SCSA HBA Drivers] for more
information.

.SCSA HBA Entry Point Summary
[width="100%",cols="45%,55%",options="header",]
|===
|Function Name |Called as a Result of
|`tran++_++abort(9E)` |Target driver calling `scsi++_++abort(9F)`

|`tran++_++bus++_++reset(9E)` |System resetting bus

|`tran++_++destroy++_++pkt(9E)` |Target driver calling
`scsi++_++destroy++_++pkt(9F)`

|`tran++_++dmafree(9E)` |Target driver calling `scsi++_++dmafree(9F)`

|`tran++_++getcap(9E)` |Target driver calling `scsi++_++ifgetcap(9F)`

|`tran++_++init++_++pkt(9E)` |Target driver calling
`scsi++_++init++_++pkt(9F)`

|`tran++_++quiesce(9E)` |System quiescing bus

|`tran++_++reset(9E)` |Target driver calling `scsi++_++reset(9F)`

|`tran++_++reset++_++notify(9E)` |Target driver calling
`scsi++_++reset++_++notify(9F)`

|`tran++_++setcap(9E)` |Target driver calling `scsi++_++ifsetcap(9F)`

|`tran++_++start(9E)` |Target driver calling `scsi++_++transport(9F)`

|`tran++_++sync++_++pkt(9E)` |Target driver calling
`scsi++_++sync++_++pkt(9F)`

|`tran++_++tgt++_++free(9E)` |System detaching target device instance

|`tran++_++tgt++_++init(9E)` |System attaching target device instance

|`tran++_++tgt++_++probe(9E)` |Target driver calling
`scsi++_++probe(9F)`

|`tran++_++unquiesce(9E)` |System resuming activity on bus
|===

[[scsa-hba-data-structures]]
==== SCSA HBA Data Structures

SCSA defines data structures to enable the exchange of
information between the target and HBA drivers. The following data
structures are included:

* `scsi++_++hba++_++tran(9S)`
* `scsi++_++address(9S)`
* `scsi++_++device(9S)`
* `scsi++_++pkt(9S)`

[[scsihbatran-structure]]
===== `scsi++_++hba++_++tran` Structure

Each instance of an HBA driver must allocate a
`scsi++_++hba++_++tran(9S)` structure by using the
`scsi++_++hba++_++tran++_++alloc(9F)` function in the `attach(9E)` entry
point. The `scsi++_++hba++_++tran++_++alloc` function initializes the
`scsi++_++hba++_++tran` structure. The HBA driver must initialize
specific vectors in the transport structure to point to entry points
within the HBA driver. After the `scsi++_++hba++_++tran` structure is
initialized, the HBA driver exports the transport structure to SCSA by
calling the `scsi++_++hba++_++attach++_++setup(9F)` function.

[CAUTION]

Because SCSA keeps a pointer to the transport structure in the
driver-private field on the `devinfo` node, HBA drivers must not use
`ddi++_++set++_++driver++_++private(9F)`. HBA drivers can, however, use
`ddi++_++get++_++driver++_++private(9F)` to retrieve the pointer to the
transport structure.
===

The SCSA interfaces require the HBA driver to supply a number of entry
points that are callable through the `scsi++_++hba++_++tran` structure.
See link:#entry-points-for-scsa-hba-drivers[Entry Points for SCSA HBA Drivers] for more
information.

The `scsi++_++hba++_++tran` structure contains the following fields:

[source,c]
----
struct scsi_hba_tran {
    dev_info_t          *tran_hba_dip;          /* HBAs dev_info pointer */
    void                *tran_hba_private;      /* HBA softstate */
    void                *tran_tgt_private;      /* HBA target private pointer */
    struct scsi_device  *tran_sd;               /* scsi_device */
    int                 (*tran_tgt_init)();     /* Transport target */
                                                /* Initialization */
    int                 (*tran_tgt_probe)();    /* Transport target probe */
    void                (*tran_tgt_free)();     /* Transport target free */
    int                 (*tran_start)();        /* Transport start */
    int                 (*tran_reset)();        /* Transport reset */
    int                 (*tran_abort)();        /* Transport abort */
    int                 (*tran_getcap)();       /* Capability retrieval */
    int                 (*tran_setcap)();       /* Capability establishment */
    struct scsi_pkt     *(*tran_init_pkt)();    /* Packet and DMA allocation */
    void                (*tran_destroy_pkt)();  /* Packet and DMA */
                                                /* Deallocation */
    void                (*tran_dmafree)();      /* DMA deallocation */
    void                (*tran_sync_pkt)();     /* Sync DMA */
    void                (*tran_reset_notify)(); /* Bus reset notification */
    int                 (*tran_bus_reset)();    /* Reset bus only */
    int                 (*tran_quiesce)();      /* Quiesce a bus */
    int                 (*tran_unquiesce)();    /* Unquiesce a bus */
    int                 tran_interconnect_type; /* transport interconnect */
};
----

The following descriptions give more information about these
`scsi++_++hba++_++tran` structure fields:

`tran++_++hba++_++dip`::
  Pointer to the HBA device instance `dev++_++info` structure. The
  function `scsi++_++hba++_++attach++_++setup(9F)` sets this field.
`tran++_++hba++_++private`::
  Pointer to private data maintained by the HBA driver. Usually,
  `tran++_++hba++_++private` contains a pointer to the state structure
  of the HBA driver.
`tran++_++tgt++_++private`::
  Pointer to private data maintained by the HBA driver when using
  cloning. By specifying `SCSI++_++HBA++_++TRAN++_++CLONE` when calling
  `scsi++_++hba++_++attach++_++setup(9F)`, the
  `scsi++_++hba++_++tran(9S)` structure is cloned once per target. This
  approach enables the HBA to initialize this field to point to a
  per-target instance data structure in the `tran++_++tgt++_++init(9E)`
  entry point. If `SCSI++_++HBA++_++TRAN++_++CLONE` is not specified,
  `tran++_++tgt++_++private` is `NULL`, and `tran++_++tgt++_++private`
  must not be referenced. See link:#transport-structure-cloning[Transport Structure
  Cloning] for more information.
`tran++_++sd`::
  Pointer to a per-target instance `scsi++_++device(9S)` structure used
  when cloning. If `SCSI++_++HBA++_++TRAN++_++CLONE` is passed to
  `scsi++_++hba++_++attach++_++setup(9F)`, `tran++_++sd` is initialized
  to point to the per-target `scsi++_++device` structure. This
  initialization takes place before any HBA functions are called on
  behalf of that target. If `SCSI++_++HBA++_++TRAN++_++CLONE` is not
  specified, `tran++_++sd` is `NULL`, and `tran++_++sd` must not be
  referenced. See link:#transport-structure-cloning[Transport Structure Cloning] for more
  information.
`tran++_++tgt++_++init`::
  Pointer to the HBA driver entry point that is called when initializing
  a target device instance. If no per-target initialization is required,
  the HBA can leave `tran++_++tgt++_++init` set to `NULL`.
`tran++_++tgt++_++probe`::
  Pointer to the HBA driver entry point that is called when a target
  driver instance calls `scsi++_++probe(9F)`. This routine is called to
  probe for the existence of a target device. If no target probing
  customization is required for this HBA, the HBA should set
  `tran++_++tgt++_++probe` to `scsi++_++hba++_++probe(9F)`.
`tran++_++tgt++_++free`::
  Pointer to the HBA driver entry point that is called when a target
  device instance is destroyed. If no per-target deallocation is
  necessary, the HBA can leave `tran++_++tgt++_++free` set to `NULL`.
`tran++_++start`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++transport(9F)`.
`tran++_++reset`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++reset(9F)`.
`tran++_++abort`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++abort(9F)`.
`tran++_++getcap`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++ifgetcap(9F)`.
`tran++_++setcap`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++ifsetcap(9F)`.
`tran++_++init++_++pkt`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++init++_++pkt(9F)`.
`tran++_++destroy++_++pkt`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++destroy++_++pkt(9F)`.
`tran++_++dmafree`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++dmafree(9F)`.
`tran++_++sync++_++pkt`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `scsi++_++sync++_++pkt(9F)`.
`tran++_++reset++_++notify`::
  Pointer to the HBA driver entry point that is called when a target
  driver calls `tran++_++reset++_++notify(9E)`.
`tran++_++bus++_++reset`::
  The function entry that resets the SCSI bus without resetting targets.
`tran++_++quiesce`::
  The function entry that waits for all outstanding commands to complete
  and blocks (or queues) any I/O requests issued.
`tran++_++unquiesce`::
  The function entry that allows I/O activities to resume on the SCSI
  bus.
`tran++_++interconnect++_++type`::
  Integer value denoting interconnect type of the transport as defined
  in the `services.h` header file.

[[scsi_address-structure]]
===== `scsi++_++address` Structure

The `scsi++_++address(9S)` structure provides transport
and addressing information for each SCSI command that is allocated and
transported by a target driver instance.

The `scsi++_++address` structure contains the following fields:

[source,c]
----
struct scsi_address {
    struct scsi_hba_tran    *a_hba_tran;    /* Transport vectors */
    ushort_t                a_target;       /* Target identifier */
    uchar_t                 a_lun;          /* LUN on that target */
    uchar_t                 a_sublun;       /* Sub LUN on that LUN */
                                            /* Not used */
};
----

`a++_++hba++_++tran`::
  Pointer to the `scsi++_++hba++_++tran(9S)` structure, as allocated and
  initialized by the HBA driver. If `SCSI++_++HBA++_++TRAN++_++CLONE`
  was specified as the flag to `scsi++_++hba++_++attach++_++setup(9F)`,
  `a++_++hba++_++tran` points to a copy of that structure.
`a++_++target`::
  Identifies the SCSI target on the SCSI bus.
`a++_++lun`::
  Identifies the SCSI logical unit on the SCSI target.

[[scsi_device-structure]]
[[scsi_device-structure-1]]
===== `scsi++_++device` Structure

The HBA framework allocates and initializes a
`scsi++_++device(9S)` structure for each instance of a target device.
The allocation and initialization occur before the framework calls the
HBA driver's `tran++_++tgt++_++init(9E)` entry point. This structure
stores information about each SCSI logical unit, including pointers to
information areas that contain both generic and device-specific
information. One `scsi++_++device(9S)` structure exists for each target
device instance that is attached to the system.

If the per-target initialization is successful, the HBA framework sets
the target driver's per-instance private data to point to the
`scsi++_++device(9S)` structure, using
`ddi++_++set++_++driver++_++private(9F)`. Note that an initialization is
successful if `tran++_++tgt++_++init` returns success or if the vector
is null.

The `scsi++_++device(9S)` structure contains the following fields:

[source,c]
----
struct scsi_device {
    struct scsi_address           sd_address;    /* routing information */
    dev_info_t                    *sd_dev;       /* device dev_info node */
    kmutex_t                      sd_mutex;      /* mutex used by device */
    void                          *sd_reserved;
    struct scsi_inquiry           *sd_inq;
    struct scsi_extended_sense    *sd_sense;
    caddr_t                       sd_private;    /* for driver's use */
};
----

where:

`sd++_++address`::
  Data structure that is passed to the routines for SCSI resource
  allocation.
`sd++_++dev`::
  Pointer to the target's `dev++_++info` structure.
`sd++_++mutex`::
  Mutex for use by the target driver. This mutex is initialized by the
  HBA framework. The mutex can be used by the target driver as a
  per-device mutex. This mutex should not be held across a call to
  `scsi++_++transport(9F)` or `scsi++_++poll(9F)`. See
  link:#multithreading[Multithreading] for more information on mutexes.
`sd++_++inq`::
  Pointer for the target device's SCSI inquiry data. The
  `scsi++_++probe(9F)` routine allocates a buffer, fills the buffer in,
  and attaches the buffer to this field.
`sd++_++sense`::
  Pointer to a buffer to contain request sense data from the device. The
  target driver must allocate and manage this buffer itself. See the
  target driver's `attach(9E)` routine in link:#attach-entry-point[ Entry
  Point] for more information.
`sd++_++private`::
  Pointer field for use by the target driver. This field is commonly
  used to store a pointer to a private target driver state structure.

[[scsi_pkt-structure-hba]]
===== `scsi++_++pkt` Structure (HBA)

To execute SCSI commands, a target driver must first
allocate a `scsi++_++pkt(9S)` structure for the command. The target
driver must then specify its own private data area length, the command
status, and the command length. The HBA driver is responsible for
implementing the packet allocation in the `tran++_++init++_++pkt(9E)`
entry point. The HBA driver is also responsible for freeing the packet
in its `tran++_++destroy++_++pkt(9E)` entry point. See link:#scsi_pkt-structure-target-drivers[
Structure (Target Drivers)] for more information.

The `scsi++_++pkt(9S)` structure contains these fields:

[source,c]
----
struct scsi_pkt {
    opaque_t pkt_ha_private;             /* private data for host adapter */
    struct scsi_address pkt_address;     /* destination address */
    opaque_t pkt_private;                /* private data for target driver */
    void (*pkt_comp)(struct scsi_pkt *); /* completion routine */
    uint_t  pkt_flags;                   /* flags */
    int     pkt_time;                    /* time allotted to complete command */
    uchar_t *pkt_scbp;                   /* pointer to status block */
    uchar_t *pkt_cdbp;                   /* pointer to command block */
    ssize_t pkt_resid;                   /* data bytes not transferred */
    uint_t  pkt_state;                   /* state of command */
    uint_t  pkt_statistics;              /* statistics */
    uchar_t pkt_reason;                  /* reason completion called */
};
----

where:

`pkt++_++ha++_++private`::
  Pointer to per-command HBA-driver private data.
`pkt++_++address`::
  Pointer to the `scsi++_++address(9S)` structure providing address
  information for this command.
`pkt++_++private`::
  Pointer to per-packet target-driver private data.
`pkt++_++comp`::
  Pointer to the target-driver completion routine called by the HBA
  driver when the transport layer has completed this command.
`pkt++_++flags`::
  Flags for the command.
`pkt++_++time`::
  Specifies the completion timeout in seconds for the command.
`pkt++_++scbp`::
  Pointer to the status completion block for the command.
`pkt++_++cdbp`::
  Pointer to the command descriptor block (CDB) for the command.
`pkt++_++resid`::
  Count of the data bytes that were _not_ transferred when the command
  completed. This field can also be used to specify the amount of data
  for which resources have not been allocated. The HBA must modify this
  field during transport.
`pkt++_++state`::
  State of the command. The HBA must modify this field during transport.
`pkt++_++statistics`::
  Provides a history of the events that the command experienced while in
  the transport layer. The HBA must modify this field during transport.
`pkt++_++reason`::
  Reason for command completion. The HBA must modify this field during
  transport.

[[per-target-instance-data]]
==== Per-Target Instance Data

An HBA driver must allocate a
`scsi++_++hba++_++tran(9S)` structure during `attach(9E)`. The HBA
driver must then initialize the vectors in this transport structure to
point to the required entry points for the HBA driver. This
`scsi++_++hba++_++tran` structure is then passed into
`scsi++_++hba++_++attach++_++setup(9F)`.

The `scsi++_++hba++_++tran` structure contains a
`tran++_++hba++_++private` field, which can be used to refer to the HBA
driver's per-instance state.

Each `scsi++_++address(9S)` structure contains a pointer to the
`scsi++_++hba++_++tran` structure. In addition, the `scsi++_++address`
structure provides the target, that is, `a++_++target`, and logical unit
(`a++_++lun`) addresses for the particular target device. Each entry
point for the HBA driver is passed a pointer to the `scsi++_++address`
structure, either directly or indirectly through the
`scsi++_++device(9S)` structure. As a result, the HBA driver can
reference its own state. The HBA driver can also identify the target
device that is addressed.

The following figure illustrates the HBA data structures for transport
operations.

.HBA Transport Structures
[#scsihba-fig-25]
image::figures/scsihba-transportstructs.png[Diagram shows the relationships of structures involved in the HBA transport layer.]

[[transport-structure-cloning]]
==== Transport Structure Cloning

Cloning can be useful if an HBA driver
needs to maintain per-target private data in the
`scsi++_++hba++_++tran(9S)` structure. Cloning can also be used to
maintain a more complex address than is provided in the
`scsi++_++address(9S)` structure.

In the cloning process, the HBA driver must still allocate a
`scsi++_++hba++_++tran` structure at `attach(9E)` time. The HBA driver
must also initialize the `tran++_++hba++_++private` soft state pointer
and the entry point vectors for the HBA driver. The difference occurs
when the framework begins to connect an instance of a target driver to
the HBA driver. Before calling the HBA driver's
`tran++_++tgt++_++init(9E)` entry point, the framework clones the
`scsi++_++hba++_++tran` structure that is associated with that instance
of the HBA. Accordingly, each `scsi++_++address` structure that is
allocated and initialized for a particular target device instance points
to a per-target instance _copy_ of the `scsi++_++hba++_++tran`
structure. The `scsi++_++address` structures do not point to the
`scsi++_++hba++_++tran` structure that is allocated by the HBA driver at
`attach` time.

An HBA driver can use two important pointers when cloning is specified.
These pointers are contained in the `scsi++_++hba++_++tran` structure.
The first pointer is the `tran++_++tgt++_++private` field, which the
driver can use to point to per-target HBA private data. The
`tran++_++tgt++_++private` pointer is useful, for example, if an HBA
driver needs to maintain a more complex address than `a++_++target` and
`a++_++lun` provide. The second pointer is the `tran++_++sd` field,
which is a pointer to the `scsi++_++device(9S)` structure referring to
the particular target device.

When specifying cloning, the HBA driver must allocate and initialize the
per-target data. The HBA driver must then initialize the
`tran++_++tgt++_++private` field to point to this data during its
`tran++_++tgt++_++init(9E)` entry point. The HBA driver must free this
per-target data during its `tran++_++tgt++_++free(9E)` entry point.

When cloning, the framework initializes the `tran++_++sd` field to point
to the `scsi++_++device` structure before the HBA driver
`tran++_++tgt++_++init` entry point is called. The driver requests
cloning by passing the `SCSI++_++HBA++_++TRAN++_++CLONE` flag to
`scsi++_++hba++_++attach++_++setup(9F)`. The following figure
illustrates the HBA data structures for cloning transport operations.

.Cloning Transport Operation
[#scsihba-fig-28]
image::figures/scsihba-cloningtransportop.png[Diagram shows an example of cloned HBA structures.,width=100]

[[scsa-hba-functions]]
==== SCSA HBA Functions

SCSA also provides a number of functions. The functions
are listed in the following table, for use by HBA drivers.

.SCSA HBA Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Function Name |Called by Driver Entry Point
|`scsi++_++hba++_++init(9F)` |`++_++init(9E)`

|`scsi++_++hba++_++fini(9F)` |`++_++fini(9E)`

|`scsi++_++hba++_++attach++_++setup(9F)` |`attach(9E)`

|`scsi++_++hba++_++detach(9F)` |`detach(9E)`

|`scsi++_++hba++_++tran++_++alloc(9F)` |`attach(9E)`

|`scsi++_++hba++_++tran++_++free(9F)` |`detach(9E)`

|`scsi++_++hba++_++probe(9F)` |`tran++_++tgt++_++probe(9E)`

|`scsi++_++hba++_++pkt++_++alloc(9F)` |`tran++_++init++_++pkt(9E)`

|`scsi++_++hba++_++pkt++_++free(9F)` |`tran++_++destroy++_++pkt(9E)`

|`scsi++_++hba++_++lookup++_++capstr(9F)` |`tran++_++getcap(9E)` and
`tran++_++setcap(9E)`
|===

[[hba-driver-dependency-and-configuration-issues]]
=== HBA Driver Dependency and Configuration Issues

In addition to incorporating SCSA HBA entry points, structures, and
functions into a driver, a developer must deal with driver dependency
and configuration issues. These issues involve configuration properties,
dependency declarations, state structure and per-command structure,
entry points for module initialization, and autoconfiguration entry
points.

[[declarations-and-structures]]
==== Declarations and Structures

HBA drivers must include the following header files:

[source,c]
----
#include <sys/scsi/scsi.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
----

To inform the system that the module depends on SCSA routines, the
driver binary must be generated with the following command. See
link:#scsa-hba-interfaces[SCSA HBA Interfaces] for more information on SCSA
routines.

....
% ld -r xx.o -o xx -N "misc/scsi"
....

The code samples are derived from a simplified `isp` driver for the
QLogic Intelligent SCSI Peripheral device. The `isp` driver supports
WIDE SCSI, with up to 15 target devices and 8 logical units (LUNs) per
target.

[[per-command-structure]]
===== Per-Command Structure

An HBA driver usually needs to define a structure to
maintain state for each command submitted by a target driver. The layout
of this per-command structure is entirely up to the device driver
writer. The layout needs to reflect the capabilities and features of the
hardware and the software algorithms that are used in the driver.

The following structure is an example of a per-command structure. The
remaining code fragments of this chapter use this structure to
illustrate the HBA interfaces.

[source,c]
----
struct isp_cmd {
     struct isp_request     cmd_isp_request;
     struct isp_response    cmd_isp_response;
     struct scsi_pkt        *cmd_pkt;
     struct isp_cmd         *cmd_forw;
     uint32_t               cmd_dmacount;
     ddi_dma_handle_t       cmd_dmahandle;
     uint_t                 cmd_cookie;
     uint_t                 cmd_ncookies;
     uint_t                 cmd_cookiecnt;
     uint_t                 cmd_nwin;
     uint_t                 cmd_curwin;
     off_t                  cmd_dma_offset;
     uint_t                 cmd_dma_len;
     ddi_dma_cookie_t       cmd_dmacookies[ISP_NDATASEGS];
     u_int                  cmd_flags;
     u_short                cmd_slot;
     u_int                  cmd_cdblen;
     u_int                  cmd_scblen;
};
----

[[entry-points-for-module-initialization]]
==== Entry Points for Module Initialization

This section describes the entry points for operations that are
performed by SCSI HBA drivers.

The following code for a SCSI HBA driver illustrates a representative
`dev++_++ops(9S)` structure. The driver must initialize the
`devo++_++bus++_++ops` field in this structure to `NULL`. A SCSI HBA
driver can provide leaf driver interfaces for special purposes, in which
case the `devo++_++cb++_++ops` field might point to a `cb++_++ops(9S)`
structure. In this example, no leaf driver interfaces are exported, so
the `devo++_++cb++_++ops` field is initialized to `NULL`.

[[_init-entry-point-scsi-hba-drivers]]
===== `++_++init` Entry Point (SCSI HBA Drivers)

The `++_++init(9E)` function initializes a loadable module. `++_++init`
is called before any other routine in the loadable module.

In a SCSI HBA, the `++_++init` function must call
`scsi++_++hba++_++init(9F)` to inform the framework of the existence of
the HBA driver before calling `mod++_++install(9F)`. If
`scsi++_++hba++__++init` returns a nonzero value, `++_++init` should
return this value. Otherwise, `++_++init` must return the value returned
by `mod++_++install(9F)`.

The driver should initialize any required global state before calling
`mod++_++install(9F)`.

If `mod++_++install` fails, the `++_++init` function must free any
global resources allocated. `++_++init` must call
`scsi++_++hba++_++fini(9F)` before returning.

The following example uses a global mutex to show how to allocate data
that is global to all instances of a driver. The code declares global
mutex and soft-state structure information. The global mutex and soft
state are initialized during `++_++init`.

[[_fini-entry-point-scsi-hba-drivers]]
===== `++_++fini` Entry Point (SCSI HBA Drivers)

The `++_++fini(9E)` function is called when the system is about to try
to unload the SCSI HBA driver. The `++_++fini` function must call
`mod++_++remove(9F)` to determine whether the driver can be unloaded. If
`mod++_++remove` returns 0, the module can be unloaded. The HBA driver
must deallocate any global resources allocated in `++_++init(9E)`. The
HBA driver must also call `scsi++_++hba++_++fini(9F)`.

`++_++fini` must return the value returned by `mod++_++remove`.

[NOTE]

The HBA driver must not free any resources or call
`scsi++_++hba++_++fini(9F)` unless `mod++_++remove(9F)` returns 0.
===

link:#scsihba-ex-38[example++_++title] shows module initialization for
SCSI HBA.

[[scsihba-ex-38]]
Module Initialization for SCSI HBA

[source,c]
----
static struct dev_ops isp_dev_ops = {
    DEVO_REV,       /* devo_rev */
    0,              /* refcnt  */
    isp_getinfo,    /* getinfo */
    nulldev,        /* probe */
    isp_attach,     /* attach */
    isp_detach,     /* detach */
    nodev,          /* reset */
    NULL,           /* driver operations */
    NULL,           /* bus operations */
    isp_power,      /* power management */
};

/*
 * Local static data
 */
static kmutex_t      isp_global_mutex;
static void          *isp_state;

_init(void)
{
    int     err;
    
    if ((err = ddi_soft_state_init(&isp_state,
        sizeof (struct isp), 0)) != 0) {
        return (err);
    }
    if ((err = scsi_hba_init(&modlinkage)) == 0) {
        mutex_init(&isp_global_mutex, "isp global mutex",
        MUTEX_DRIVER, NULL);
        if ((err = mod_install(&modlinkage)) != 0) {
            mutex_destroy(&isp_global_mutex);
            scsi_hba_fini(&modlinkage);
            ddi_soft_state_fini(&isp_state);    
        }
    }
    return (err);
}

_fini(void)
{
    int     err;
    
    if ((err = mod_remove(&modlinkage)) == 0) {
        mutex_destroy(&isp_global_mutex);
        scsi_hba_fini(&modlinkage);
        ddi_soft_state_fini(&isp_state);
    }
    return (err);
}
----

[[autoconfiguration-entry-points]]
[[autoconfiguration-entry-points-1]]
==== Autoconfiguration Entry Points

Associated with each device driver is a
`dev++_++ops(9S)` structure, which enables the kernel to locate the
autoconfiguration entry points of the driver. A complete description of
these autoconfiguration routines is given in link:#driver-autoconfiguration[Driver
Autoconfiguration]. This section describes only those entry points
associated with operations performed by SCSI HBA drivers. These entry
points include `attach(9E)` and `detach(9E)`.

[[attach-entry-point-scsi-hba-drivers]]
===== `attach` Entry Point (SCSI HBA Drivers)

The `attach(9E)` entry point for a SCSI HBA driver performs several
tasks when configuring and attaching an instance of the driver for the
device. For a typical driver of real devices, the following operating
system and hardware concerns must be addressed:

* Soft-state structure
* DMA
* Transport structure
* Attaching an HBA driver
* Register mapping
* Interrupt specification
* Interrupt handling
* Create power manageable components
* Report attachment status

[[scsihba-41]]
====== Soft-State Structure

When allocating the per-device-instance soft-state structure, a driver
must clean up carefully if an error occurs.

[[scsihba-42]]
====== DMA

The HBA driver must describe the attributes of its DMA engine by
properly initializing the `ddi++_++dma++_++attr++_++t` structure.

[source,c]
----
static ddi_dma_attr_t isp_dma_attr = {
     DMA_ATTR_V0,        /* ddi_dma_attr version */
     0,                  /* low address */
     0xffffffff,         /* high address */
     0x00ffffff,         /* counter upper bound */
     1,                  /* alignment requirements */
     0x3f,               /* burst sizes */
     1,                  /* minimum DMA access */
     0xffffffff,         /* maximum DMA access */
     (1<<24)-1,          /* segment boundary restrictions */
     1,                  /* scatter-gather list length */
     512,                /* device granularity */
     0                   /* DMA flags */
};
----

The driver, if providing DMA, should also check that its hardware is
installed in a DMA-capable slot:

[source,c]
----
if (ddi_slaveonly(dip) == DDI_SUCCESS) {
    return (DDI_FAILURE);
}
----

[[scsihba-43]]
====== Transport Structure

The driver should further allocate and initialize a
transport structure for this instance. The `tran++_++hba++_++private`
field is set to point to this instance's soft-state structure. The
`tran++_++tgt++_++probe` field can be set to `NULL` to achieve the
default behavior, if no special probe customization is needed.

....
tran = scsi_hba_tran_alloc(dip, SCSI_HBA_CANSLEEP);

isp->isp_tran                   = tran;
isp->isp_dip                    = dip;

tran->tran_hba_private          = isp;
tran->tran_tgt_private          = NULL;
tran->tran_tgt_init             = isp_tran_tgt_init;
tran->tran_tgt_probe            = scsi_hba_probe;
tran->tran_tgt_free             = (void (*)())NULL;

tran->tran_start                = isp_scsi_start;
tran->tran_abort                = isp_scsi_abort;
tran->tran_reset                = isp_scsi_reset;
tran->tran_getcap               = isp_scsi_getcap;
tran->tran_setcap               = isp_scsi_setcap;
tran->tran_init_pkt             = isp_scsi_init_pkt;
tran->tran_destroy_pkt          = isp_scsi_destroy_pkt;
tran->tran_dmafree              = isp_scsi_dmafree;
tran->tran_sync_pkt             = isp_scsi_sync_pkt;
tran->tran_reset_notify         = isp_scsi_reset_notify;
tran->tran_bus_quiesce          = isp_tran_bus_quiesce
tran->tran_bus_unquiesce        = isp_tran_bus_unquiesce
tran->tran_bus_reset            = isp_tran_bus_reset
tran->tran_interconnect_type    = isp_tran_interconnect_type
....

[[scsihba-44]]
====== Attaching an HBA Driver

The driver should attach this instance of the device, and perform error
cleanup if necessary.

[source,c]
----
i = scsi_hba_attach_setup(dip, &isp_dma_attr, tran, 0);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}
----

[[scsihba-45]]
====== Register Mapping

The driver should map in its device's registers. The driver need to
specify the following items:

* Register set index
* Data access characteristics of the device
* Size of the register to be mapped

[source,c]
----
ddi_device_acc_attr_t    dev_attributes;

     dev_attributes.devacc_attr_version = DDI_DEVICE_ATTR_V0;
     dev_attributes.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
     dev_attributes.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;

     if (ddi_regs_map_setup(dip, 0, (caddr_t *)&isp->isp_reg,
     0, sizeof (struct ispregs), &dev_attributes,
     &isp->isp_acc_handle) != DDI_SUCCESS) {
        /* do error recovery */
        return (DDI_FAILURE);
     }
----

[[scsihba-46]]
====== Adding an Interrupt Handler

The driver must first obtain the _iblock cookie_ to initialize any
mutexes that are used in the driver handler. Only after those mutexes
have been initialized can the interrupt handler be added.

[source,c]
----
i = ddi_get_iblock_cookie(dip, 0, &isp->iblock_cookie};
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}

mutex_init(&isp->mutex, "isp_mutex", MUTEX_DRIVER,
(void *)isp->iblock_cookie);
i = ddi_add_intr(dip, 0, &isp->iblock_cookie,
0, isp_intr, (caddr_t)isp);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}
----

If a high-level handler is required, the driver should be coded to
provide such a handler. Otherwise, the driver must be able to fail the
attach. See link:#handling-high-level-interrupts[Handling High-Level Interrupts] for a
description of high-level interrupt handling.

[[scsihba-104]]
====== Create Power Manageable Components

With power management, if the host bus adapter only needs to power down
when all target adapters are at power level 0, the HBA driver only needs
to provide a `power(9E)` entry point. Refer to
link:#power-management[Power Management]. The HBA driver also needs to
create a `pm-components(9P)` property that describes the components that
the device implements.

Nothing more is necessary, since the components will default to idle,
and the power management framework's default dependency processing will
ensure that the host bus adapter will be powered up whenever an target
adapter is powered up. Provided that automatic power management is
enabled automatically, the processing will also power down the host bus
adapter when all target adapters are powered down ().

[[scsihba-47]]
====== Report Attachment Status

Finally, the driver should report that this instance of the device is
attached and return success.

[source,c]
----
ddi_report_dev(dip);
return (DDI_SUCCESS);
----

[[detach-entry-point-scsi-hba-drivers]]
===== `detach` Entry Point (SCSI HBA Drivers)

The driver should perform standard detach operations, including calling
`scsi++_++hba++_++detach(9F)`.

[[entry-points-for-scsa-hba-drivers]]
=== Entry Points for SCSA HBA Drivers

An HBA driver can work with target drivers through the SCSA interface.
The SCSA interfaces require the HBA driver to supply a number of entry
points that are callable through the `scsi++_++hba++_++tran(9S)`
structure.

These entry points fall into five functional groups:

* Target driver instance initialization
* Resource allocation and deallocation
* Command transport
* Capability management
* Abort and reset handling
* Dynamic reconfiguration

The following table lists the entry points for SCSA HBA
by function groups.

.SCSA Entry Points
[width="100%",cols="30%,30%,40%",options="header",]
|===
|Function Groups |Entry Points Within Group |Description
|Target Driver Instance Initialization |`tran++_++tgt++_++init(9E)`
|Performs per-target initialization (optional)

| |`tran++_++tgt++_++probe(9E)` |Probes SCSI bus for existence of a
target (optional)

| |`tran++_++tgt++_++free(9E)` |Performs per-target deallocation
(optional)

|Resource Allocation |`tran++_++init++_++pkt(9E)` |Allocates SCSI packet
and DMA resources

| |`tran++_++destroy++_++pkt(9E)` |Frees SCSI packet and DMA resources

| |`tran++_++sync++_++pkt(9E)` |Synchronizes memory before and after DMA

| |`tran++_++dmafree(9E)` |Frees DMA resources

|Command Transport |`tran++_++start(9E)` |Transports a SCSI command

|Capability Management |`tran++_++getcap(9E)` |Inquires about a
capability's value

| |`tran++_++setcap(9E)` |Sets a capability's value

|Abort and Reset |`tran++_++abort(9E)` |Aborts outstanding SCSI commands

| |`tran++_++reset(9E)` |Resets a target device or the SCSI bus

| |`tran++_++bus++_++reset(9E)` |Resets the SCSI bus

| |`tran++_++reset++_++notify(9E)` |Request to notify target of bus
reset (optional)

|Dynamic Reconfiguration |`tran++_++quiesce(9E)` |Stops activity on the

| |`tran++_++unquiesce(9E)` |Resumes activity on the bus
|===

[[target-driver-instance-initialization]]
==== Target Driver Instance Initialization

The following sections describe target entry points.

[[trantgtinit-entry-point]]
===== `tran++_++tgt++_++init` Entry Point

The `tran++_++tgt++_++init(9E)` entry
point enables the HBA to allocate and initialize any per-target
resources. `tran++_++tgt++_++init` also enables the HBA to qualify the
device's address as valid and supportable for that particular HBA. By
returning `DDI++_++FAILURE`, the instance of the target driver for that
device is not probed or attached.

`tran++_++tgt++_++init` is not required. If `tran++_++tgt++_++init` is
not supplied, the framework attempts to probe and attach all possible
instances of the appropriate target drivers.

[source,c]
----
static int
isp_tran_tgt_init(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *tran,
    struct scsi_device    *sd)
{
    return ((sd->sd_address.a_target < N_ISP_TARGETS_WIDE &&
        sd->sd_address.a_lun < 8) ? DDI_SUCCESS : DDI_FAILURE);
}
----

[[trantgtprobe-entry-point]]
===== `tran++_++tgt++_++probe` Entry Point

The `tran++_++tgt++_++probe(9E)` entry point enables the
HBA to customize the operation of `scsi++_++probe(9F)`, if necessary.
This entry point is called only when the target driver calls
`scsi++_++probe`.

The HBA driver can retain the normal
operation of `scsi++_++probe` by calling `scsi++_++hba++_++probe(9F)`
and returning its return value.

This entry point is not required, and if not needed, the HBA driver
should set the `tran++_++tgt++_++probe` vector in the
`scsi++_++hba++_++tran(9S)` structure to point to
`scsi++_++hba++_++probe`.

`scsi++_++probe` allocates a `scsi++_++inquiry(9S)`
structure and sets the `sd++_++inq` field of the `scsi++_++device(9S)`
structure to point to the data in `scsi++_++inquiry`.
`scsi++_++hba++_++probe` handles this task automatically.
`scsi++_++unprobe(9F)` then frees the `scsi++_++inquiry` data.

Except for the allocation of `scsi++_++inquiry` data,
`tran++_++tgt++_++probe` must be stateless, because the same SCSI device
might call `tran++_++tgt++_++probe` several times. Normally, allocation
of `scsi++_++inquiry` data is handled by `scsi++_++hba++_++probe`.

[NOTE]

The allocation of the `scsi++_++inquiry(9S)` structure is handled
automatically by `scsi++_++hba++_++probe`. This information is only of
concern if you want custom `scsi++_++probe` handling.
===

[source,c]
----
static int
isp_tran_tgt_probe(
    struct scsi_device    *sd,
    int                   (*callback)())
{
    /*
     * Perform any special probe customization needed.
     * Normal probe handling.
     */
    return (scsi_hba_probe(sd, callback));
}
----

[[trantgtfree-entry-point]]
===== `tran++_++tgt++_++free` Entry Point

The `tran++_++tgt++_++free(9E)` entry point enables the
HBA to perform any deallocation or clean-up procedures for an instance
of a target. This entry point is optional.

[source,c]
----
static void
isp_tran_tgt_free(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *hba_tran,
    struct scsi_device    *sd)
{
    /*
     * Undo any special per-target initialization done
     * earlier in tran_tgt_init(9F) and tran_tgt_probe(9F)
     */
}
----

[[resource-allocation]]
[[resource-allocation-1]]
==== Resource Allocation

The following sections discuss resource allocation.

[[traninitpkt-entry-point]]
===== `tran++_++init++_++pkt` Entry Point

`tran++_++init++_++pkt(9E)` entry point allocates and initializes a
`scsi++_++pkt(9S)` structure and DMA resources for a target driver
request.

The `tran++_++init++_++pkt(9E)` entry point is called when the target
driver calls the SCSA function `scsi++_++init++_++pkt(9F)`.

Each call of the `tran++_++init++_++pkt(9E)` entry point is a request to
perform one or more of three possible services:

* Allocation and initialization of a `scsi++_++pkt(9S)` structure
* Allocation of DMA resources for data transfer
* Reallocation of DMA resources for the next portion of the data

[[allocation-and-initialization-of-a-scsi_pkt9s-structure]]
===== Allocation and Initialization of a `scsi++_++pkt(9S)` Structure

The `tran++_++init++_++pkt(9E)` entry point must allocate a
`scsi++_++pkt(9S)` structure through
`scsi++_++hba++_++pkt++_++alloc(9F)` if `pkt` is `NULL`.

`scsi++_++hba++_++pkt++_++alloc(9F)` allocates space for
the following items:

* `scsi++_++pkt(9S)`
* SCSI CDB of length `cmdlen`
* Completion area for SCSI status of length `statuslen`
* Per-packet target driver private data area of length `tgtlen`
* Per-packet HBA driver private data area of length `hbalen`

The `scsi++_++pkt(9S)` structure members, including `pkt`, must be
initialized to zero except for the following members:

* `pkt++_++scbp` – Status completion
* `pkt++_++cdbp` – CDB
* `pkt++_++ha++_++private` – HBA driver private data
* `pkt++_++private` – Target driver private data

These members are pointers to memory space where the values of the
fields are stored, as shown in the following figure. For more
information, refer to link:#scsi_pkt-structure-hba[ Structure (HBA)].

.`scsi++_++pkt(9S)` Structure Pointers
[#scsihba-fig-59]
image::figures/scsihba-structptrs.png[Diagram shows the scsi++_++pkt structure with those members that point to values rather than being
initialized to zero.]

The following example shows allocation and initialization of a
`scsi++_++pkt` structure.

[[scsihba-ex-61]]
HBA Driver Initialization of a SCSI Packet Structure

[source,c]
----
static struct scsi_pkt *
isp_scsi_init_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt,
    struct buf             *bp,
    int                    cmdlen,
    int                    statuslen,
    int                    tgtlen,
    int                    flags,
    int                    (*callback)(),
    caddr_t                arg)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct scsi_pkt        *new_pkt;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    isp = (struct isp *)ap->a_hba_tran->tran_hba_private;
    /*
     * First step of isp_scsi_init_pkt:  pkt allocation
     */
    if (pkt == NULL) {
        pkt = scsi_hba_pkt_alloc(isp->isp_dip, ap, cmdlen,
            statuslen, tgtlen, sizeof (struct isp_cmd),
            callback, arg);
        if (pkt == NULL) {
            return (NULL);
        }

        sp = (struct isp_cmd *)pkt->pkt_ha_private;
        /*
         * Initialize the new pkt
         */
        sp->cmd_pkt         = pkt;
        sp->cmd_flags       = 0;
        sp->cmd_scblen      = statuslen;
        sp->cmd_cdblen      = cmdlen;
        sp->cmd_dmahandle   = NULL;
        sp->cmd_ncookies    = 0;
        sp->cmd_cookie      = 0; 
        sp->cmd_cookiecnt   = 0;
        sp->cmd_nwin        = 0;
        pkt->pkt_address    = *ap;
        pkt->pkt_comp       = (void (*)())NULL;
        pkt->pkt_flags      = 0;
        pkt->pkt_time       = 0;
        pkt->pkt_resid      = 0;
        pkt->pkt_statistics = 0;
        pkt->pkt_reason     = 0;
        new_pkt = pkt;
    } else {
        sp = (struct isp_cmd *)pkt->pkt_ha_private;
        new_pkt = NULL;
    }
    /*
     * Second step of isp_scsi_init_pkt:  dma allocation/move
     */
    if (bp && bp->b_bcount != 0) {
        if (sp->cmd_dmahandle == NULL) {
            if (isp_i_dma_alloc(isp, pkt, bp, flags, callback) == 0) {
                if (new_pkt) {
                    scsi_hba_pkt_free(ap, new_pkt);
                }
                return ((struct scsi_pkt *)NULL);
            }
        } else {
            ASSERT(new_pkt == NULL);
            if (isp_i_dma_move(isp, pkt, bp) == 0) {
                return ((struct scsi_pkt *)NULL);
            }
        }
    }
    return (pkt);
}
----

[[allocation-of-dma-resources]]
===== Allocation of DMA Resources

The `tran++_++init++_++pkt(9E)` entry point must allocate DMA resources
for a data transfer if the following conditions are true:

* `bp` is not null.
* `bp-++>++b++_++bcount` is not zero.
* DMA resources have not yet been allocated for this `scsi++_++pkt(9S)`.

The HBA driver needs to track how DMA resources are
allocated for a particular command. This allocation can take place with
a flag bit or a DMA handle in the per-packet HBA driver private data.

The `PKT++_++DMA++_++PARTIAL` flag in the `pkt` enables the target
driver to break up a data transfer into multiple SCSI commands to
accommodate the complete request. This approach is useful when the HBA
hardware scatter-gather capabilities or system DMA resources cannot
complete a request in a single SCSI command.

The `PKT++_++DMA++_++PARTIAL` flag enables the HBA driver to set the
`DDI++_++DMA++_++PARTIAL` flag. The `DDI++_++DMA++_++PARTIAL` flag is
useful when the DMA resources for this SCSI command are allocated. For
example the `ddi++_++dma++_++buf++_++bind++_++handle(9F)`) command can
be used to allocate DMA resources. The DMA attributes used when
allocating the DMA resources should accurately describe any constraints
placed on the ability of the HBA hardware to perform DMA. If the system
can only allocate DMA resources for part of the request,
`ddi++_++dma++_++buf++_++bind++_++handle(9F)` returns
`DDI++_++DMA++_++PARTIAL++_++MAP`.

The `tran++_++init++_++pkt(9E)` entry point must return the amount of
DMA resources not allocated for this transfer in the field
`pkt++_++resid`.

A target driver can make one request to `tran++_++init++_++pkt(9E)` to
simultaneously allocate both a `scsi++_++pkt(9S)` structure and DMA
resources for that `pkt`. In this case, if the HBA driver is unable to
allocate DMA resources, that driver must free the allocated
`scsi++_++pkt(9S)` before returning. The `scsi++_++pkt(9S)` must be
freed by calling `scsi++_++hba++_++pkt++_++free(9F)`.

The target driver might first allocate the `scsi++_++pkt(9S)` and
allocate DMA resources for this `pkt` at a later time. In this case, if
the HBA driver is unable to allocate DMA resources, the driver must
_not_ free `pkt`. The target driver in this case is responsible for
freeing the `pkt`.

[[scsihba-ex-63]]
HBA Driver Allocation of DMA Resources

[source,c]
----
static int
isp_i_dma_alloc(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp,
    int                flags,
    int                (*callback)())
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt->pkt_ha_private;
    int                dma_flags;
    ddi_dma_attr_t     tmp_dma_attr;
    int                (*cb)(caddr_t);
    int                i;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    if (bp->b_flags & B_READ) {
        sp->cmd_flags &= ~CFLAG_DMASEND;
        dma_flags = DDI_DMA_READ;
    } else {
        sp->cmd_flags |= CFLAG_DMASEND;
        dma_flags = DDI_DMA_WRITE;
    }
    if (flags & PKT_CONSISTENT) {
        sp->cmd_flags |= CFLAG_CMDIOPB;
        dma_flags |= DDI_DMA_CONSISTENT;
    }
    if (flags & PKT_DMA_PARTIAL) {
        dma_flags |= DDI_DMA_PARTIAL;
    }

    tmp_dma_attr = isp_dma_attr;
    tmp_dma_attr.dma_attr_burstsizes = isp->isp_burst_size;

    cb = (callback == NULL_FUNC) ? DDI_DMA_DONTWAIT : DDI_DMA_SLEEP;

    if ((i = ddi_dma_alloc_handle(isp->isp_dip, &tmp_dma_attr,
      cb, 0, &sp->cmd_dmahandle)) != DDI_SUCCESS) {
        switch (i) {
          case DDI_DMA_BADATTR:
              bioerror(bp, EFAULT);
              return (0);
          case DDI_DMA_NORESOURCES:
              bioerror(bp, 0);
              return (0);
        }
    }

    i = ddi_dma_buf_bind_handle(sp->cmd_dmahandle, bp, dma_flags,
    cb, 0, &sp->cmd_dmacookies[0], &sp->cmd_ncookies);

    switch (i) {
      case DDI_DMA_PARTIAL_MAP:
          if (ddi_dma_numwin(sp->cmd_dmahandle, &sp->cmd_nwin) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_numwin() failed\n");
          }

          if (ddi_dma_getwin(sp->cmd_dmahandle, sp->cmd_curwin,
            &sp->cmd_dma_offset, &sp->cmd_dma_len, &sp->cmd_dmacookies[0], 
            &sp->cmd_ncookies) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_getwin() failed\n");
          }
          goto get_dma_cookies;

      case DDI_DMA_MAPPED:
          sp->cmd_nwin = 1;
          sp->cmd_dma_len = 0;
          sp->cmd_dma_offset = 0;

      get_dma_cookies:
          i = 0;
          sp->cmd_dmacount = 0;
          for (;;) {
              sp->cmd_dmacount += sp->cmd_dmacookies[i++].dmac_size;
              if (i == ISP_NDATASEGS || i == sp->cmd_ncookies)
                  break;
              ddi_dma_nextcookie(sp->cmd_dmahandle,
              &sp->cmd_dmacookies[i]);
          }
          sp->cmd_cookie = i;
          sp->cmd_cookiecnt = i;
          sp->cmd_flags |= CFLAG_DMAVALID;
          pkt->pkt_resid = bp->b_bcount - sp->cmd_dmacount;
          return (1);

      case DDI_DMA_NORESOURCES:
          bioerror(bp, 0);
          break;

      case DDI_DMA_NOMAPPING:
          bioerror(bp, EFAULT);
          break;

      case DDI_DMA_TOOBIG:
          bioerror(bp, EINVAL);
          break;

      case DDI_DMA_INUSE:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " DDI_DMA_INUSE impossible\n");

      default:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " 0x%x impossible\n", i);
    }
    ddi_dma_free_handle(&sp->cmd_dmahandle);
    sp->cmd_dmahandle = NULL;
    sp->cmd_flags &= ~CFLAG_DMAVALID;
    return (0);
}
----

[[reallocation-of-dma-resources-for-data-transfer]]
===== Reallocation of DMA Resources for Data Transfer

For a previously allocated packet with data remaining to be transferred,
the `tran++_++init++_++pkt(9E)` entry point must reallocate DMA
resources when the following conditions apply:

* Partial DMA resources have already been allocated.
* A non-zero pkt++_++resid was returned in the previous call to
`tran++_++init++_++pkt(9E)`.
* `bp` is not null.
* `bp-++>++b++_++bcount` is not zero.

When reallocating DMA resources to the next portion of the transfer,
`tran++_++init++_++pkt(9E)` must return the amount of DMA resources not
allocated for this transfer in the field `pkt++_++resid`.

If an error occurs while attempting to move DMA resources,
`tran++_++init++_++pkt(9E)` must not free the `scsi++_++pkt(9S)`. The
target driver in this case is responsible for freeing the packet.

If the callback parameter is `NULL++_++FUNC`, the
`tran++_++init++_++pkt(9E)` entry point must not sleep or call any
function that might sleep. If the callback parameter is `SLEEP++_++FUNC`
and resources are not immediately available, the
`tran++_++init++_++pkt(9E)` entry point should sleep. Unless the request
is impossible to satisfy, `tran++_++init++_++pkt` should sleep until
resources become available.

[[scsihba-ex-65]]
DMA Resource Reallocation for HBA Drivers

[source,c]
----
static int
isp_i_dma_move(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp)
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt->pkt_ha_private;
    int                i;

    ASSERT(sp->cmd_flags & CFLAG_COMPLETED);
    sp->cmd_flags &= ~CFLAG_COMPLETED;
    /*
     * If there are no more cookies remaining in this window,
     * must move to the next window first.
     */
    if (sp->cmd_cookie == sp->cmd_ncookies) {
        /*
         * For small pkts, leave things where they are
         */
        if (sp->cmd_curwin == sp->cmd_nwin && sp->cmd_nwin == 1)
            return (1);
        /*
         * At last window, cannot move
         */
        if (++sp->cmd_curwin >= sp->cmd_nwin)
            return (0);
        if (ddi_dma_getwin(sp->cmd_dmahandle, sp->cmd_curwin,
          &sp->cmd_dma_offset, &sp->cmd_dma_len,
          &sp->cmd_dmacookies[0], &sp->cmd_ncookies) == DDI_FAILURE)
            return (0);
        sp->cmd_cookie = 0;
    } else {
        /*
         * Still more cookies in this window - get the next one
         */
        ddi_dma_nextcookie(sp->cmd_dmahandle, &sp->cmd_dmacookies[0]);
    }
    /*
     * Get remaining cookies in this window, up to our maximum
     */
    i = 0;
    for (;;) {
        sp->cmd_dmacount += sp->cmd_dmacookies[i++].dmac_size;
        sp->cmd_cookie++;
        if (i == ISP_NDATASEGS || sp->cmd_cookie == sp->cmd_ncookies)
            break;
        ddi_dma_nextcookie(sp->cmd_dmahandle, &sp->cmd_dmacookies[i]);
    }
    sp->cmd_cookiecnt = i;
    pkt->pkt_resid = bp->b_bcount - sp->cmd_dmacount;
    return (1);
}
----

[[trandestroypkt-entry-point]]
===== `tran++_++destroy++_++pkt` Entry Point

The `tran++_++destroy++_++pkt(9E)` entry point is the
HBA driver function that deallocates `scsi++_++pkt(9S)` structures. The
`tran++_++destroy++_++pkt` entry point is called when the target driver
calls `scsi++_++destroy++_++pkt(9F)`.

The `tran++_++destroy++_++pkt` entry point must free any
DMA resources that have been allocated for the packet. An implicit DMA
synchronization occurs if the DMA resources are freed and any cached
data remains after the completion of the transfer. The
`tran++_++destroy++_++pkt` entry point frees the SCSI packet by calling
`scsi++_++hba++_++pkt++_++free(9F)`.

[[scsihba-ex-67]]
HBA Driver `tran++_++destroy++_++pkt(9E)` Entry Point

[source,c]
----
static void
isp_scsi_destroy_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt    *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt->pkt_ha_private;
    /*
     * Free the DMA, if any
     */
    if (sp->cmd_flags & CFLAG_DMAVALID) {
        sp->cmd_flags &= ~CFLAG_DMAVALID;
        (void) ddi_dma_unbind_handle(sp->cmd_dmahandle);
        ddi_dma_free_handle(&sp->cmd_dmahandle);
        sp->cmd_dmahandle = NULL;
    }
    /*
     * Free the pkt
     */
    scsi_hba_pkt_free(ap, pkt);
}
----

[[transyncpkt-entry-point]]
===== `tran++_++sync++_++pkt` Entry Point

The `tran++_++sync++_++pkt(9E)` entry
point synchronizes the DMA object allocated for the `scsi++_++pkt(9S)`
structure before or after a DMA transfer. The `tran++_++sync++_++pkt`
entry point is called when the target driver calls
`scsi++_++sync++_++pkt(9F)`.

If the data transfer direction is a DMA read from device to memory,
`tran++_++sync++_++pkt` must synchronize the CPU's view of the data. If
the data transfer direction is a DMA write from memory to device,
`tran++_++sync++_++pkt` must synchronize the device's view of the data.

[[scsihba-ex-69]]
HBA Driver `tran++_++sync++_++pkt(9E)` Entry Point

[source,c]
----
static void
isp_scsi_sync_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt->pkt_ha_private;

    if (sp->cmd_flags & CFLAG_DMAVALID) {
        (void)ddi_dma_sync(sp->cmd_dmahandle, sp->cmd_dma_offset,
        sp->cmd_dma_len,
        (sp->cmd_flags & CFLAG_DMASEND) ?
        DDI_DMA_SYNC_FORDEV : DDI_DMA_SYNC_FORCPU);
    }
}
----

[[tran_dmafree-entry-point]]
===== `tran++_++dmafree` Entry Point

The `tran++_++dmafree(9E)` entry point
deallocates DMA resources that have been allocated for a
`scsi++_++pkt(9S)` structure. The `tran++_++dmafree` entry point is
called when the target driver calls `scsi++_++dmafree(9F)`.

`tran++_++dmafree` must free only DMA resources allocated for a
`scsi++_++pkt(9S)` structure, not the `scsi++_++pkt(9S)` itself. When
DMA resources are freed, a DMA synchronization is implicitly performed.

[NOTE]

The `scsi++_++pkt(9S)` is freed in a separate request to
`tran++_++destroy++_++pkt(9E)`. Because `tran++_++destroy++_++pkt` must
also free DMA resources, the HBA driver must keep accurate note of
whether `scsi++_++pkt` structures have DMA resources allocated.
===

[[scsihba-ex-71]]
HBA Driver `tran++_++dmafree(9E)` Entry Point

[source,c]
----
static void
isp_scsi_dmafree(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd    *sp = (struct isp_cmd *)pkt->pkt_ha_private;

    if (sp->cmd_flags & CFLAG_DMAVALID) {
        sp->cmd_flags &= ~CFLAG_DMAVALID;
        (void)ddi_dma_unbind_handle(sp->cmd_dmahandle);
        ddi_dma_free_handle(&sp->cmd_dmahandle);
        sp->cmd_dmahandle = NULL;
    }
}
----

[[command-transport]]
==== Command Transport

An HBA driver goes through the following steps as part of command
transport:

[arabic]
. Accept a command from the target driver.
. Issue the command to the device hardware.
. Service any interrupts that occur.
. Manage time outs.

[[tran_start-entry-point]]
===== `tran++_++start` Entry Point

The `tran++_++start(9E)` entry point for a
SCSI HBA driver is called to transport a SCSI command to the addressed
target. The SCSI command is described entirely within the
`scsi++_++pkt(9S)` structure, which the target driver allocated through
the HBA driver's `tran++_++init++_++pkt(9E)` entry point. If the command
involves a data transfer, DMA resources must also have been allocated
for the `scsi++_++pkt(9S)` structure.

The `tran++_++start` entry point is called when a target driver calls
`scsi++_++transport(9F)`.

`tran++_++start` should perform basic error checking along with any
initialization that is required by the command. The `FLAG++_++NOINTR`
flag in the `pkt++_++flags` field of the `scsi++_++pkt(9S)` structure
can affect the behavior of `tran++_++start`. If `FLAG++_++NOINTR` is not
set, `tran++_++start` must queue the command for execution on the
hardware and return immediately. Upon completion of the command, the HBA
driver should call the `pkt` completion routine.

If the `FLAG++_++NOINTR` is set, then the HBA driver should not call the
`pkt` completion routine.

The following example demonstrates how to handle the
`tran++_++start(9E)` entry point. The ISP hardware provides a queue
per-target device. For devices that can manage only one active
outstanding command, the driver is typically required to manage a
per-target queue. The driver then starts up a new command upon
completion of the current command in a round-robin fashion.

[[scsihba-ex-74]]
HBA Driver `tran++_++start(9E)` Entry Point

[source,c]
----
static int
isp_scsi_start(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct isp_request     *req;
    u_long                 cur_lbolt;
    int                    xfercount;
    int                    rval = TRAN_ACCEPT;
    int                    i;

    sp = (struct isp_cmd *)pkt->pkt_ha_private;
    isp = (struct isp *)ap->a_hba_tran->tran_hba_private;

    sp->cmd_flags = (sp->cmd_flags & ~CFLAG_TRANFLAG) |
                CFLAG_IN_TRANSPORT;
    pkt->pkt_reason = CMD_CMPLT;
    /*
     * set up request in cmd_isp_request area so it is ready to
     * go once we have the request mutex
     */
    req = &sp->cmd_isp_request;

    req->req_header.cq_entry_type = CQ_TYPE_REQUEST;
    req->req_header.cq_entry_count = 1;
    req->req_header.cq_flags        = 0;
    req->req_header.cq_seqno = 0;
    req->req_reserved = 0;
    req->req_token = (opaque_t)sp;
    req->req_target = TGT(sp);
    req->req_lun_trn = LUN(sp);
    req->req_time = pkt->pkt_time;
    ISP_SET_PKT_FLAGS(pkt->pkt_flags, req->req_flags);
    /*
     * Set up data segments for dma transfers.
     */
    if (sp->cmd_flags & CFLAG_DMAVALID) {
        if (sp->cmd_flags & CFLAG_CMDIOPB) {
            (void) ddi_dma_sync(sp->cmd_dmahandle,
            sp->cmd_dma_offset, sp->cmd_dma_len,
            DDI_DMA_SYNC_FORDEV);
        }

        ASSERT(sp->cmd_cookiecnt > 0 &&
            sp->cmd_cookiecnt <= ISP_NDATASEGS);

        xfercount = 0;
        req->req_seg_count = sp->cmd_cookiecnt;
        for (i = 0; i < sp->cmd_cookiecnt; i++) {
            req->req_dataseg[i].d_count =
            sp->cmd_dmacookies[i].dmac_size;
            req->req_dataseg[i].d_base =
            sp->cmd_dmacookies[i].dmac_address;
            xfercount +=
            sp->cmd_dmacookies[i].dmac_size;
        }

        for (; i < ISP_NDATASEGS; i++) {
            req->req_dataseg[i].d_count = 0;
            req->req_dataseg[i].d_base = 0;
        }

        pkt->pkt_resid = xfercount;

        if (sp->cmd_flags & CFLAG_DMASEND) {
            req->req_flags |= ISP_REQ_FLAG_DATA_WRITE;
        } else {
            req->req_flags |= ISP_REQ_FLAG_DATA_READ;
        }
    } else {
        req->req_seg_count = 0;
        req->req_dataseg[0].d_count = 0;
    }
    /*
     * Set up cdb in the request
     */
    req->req_cdblen = sp->cmd_cdblen;
    bcopy((caddr_t)pkt->pkt_cdbp, (caddr_t)req->req_cdb,
    sp->cmd_cdblen);
    /*
     * Start the cmd.  If NO_INTR, must poll for cmd completion.
     */
    if ((pkt->pkt_flags & FLAG_NOINTR) == 0) {
        mutex_enter(ISP_REQ_MUTEX(isp));
        rval = isp_i_start_cmd(isp, sp);
        mutex_exit(ISP_REQ_MUTEX(isp));
    } else {
        rval = isp_i_polled_cmd_start(isp, sp);
    }
    return (rval);
}
----

[[interrupt-handler-and-command-completion]]
===== Interrupt Handler and Command Completion

The interrupt handler must check the status of the
device to be sure the device is generating the interrupt in question.
The interrupt handler must also check for any errors that have occurred
and service any interrupts generated by the device.

If data is transferred, the hardware should be checked to determine how
much data was actually transferred. The `pkt++_++resid` field in the
`scsi++_++pkt(9S)` structure should be set to the residual of the
transfer.

Commands that are marked with the `PKT++_++CONSISTENT` flag when DMA
resources are allocated through `tran++_++init++_++pkt(9E)` take special
handling. The HBA driver must ensure that the data transfer for the
command is correctly synchronized before the target driver's command
completion callback is performed.

Once a command has completed, you need to act on two requirements:

* If a new command is queued up, start the command on the hardware as
quickly as possible.
* Call the command completion callback. The callback has been set up in
the `scsi++_++pkt(9S)` structure by the target driver to notify the
target driver when the command is complete.

Start a new command on the hardware, if possible, before calling the
`PKT++_++COMP` command completion callback. The command completion
handling can take considerable time. Typically, the target driver calls
functions such as `biodone(9F)` and possibly `scsi++_++transport(9F)` to
begin a new command.

The interrupt handler must return DDI++_++INTR++_++CLAIMED if this
interrupt is claimed by this driver. Otherwise, the handler returns
DDI++_++INTR++_++UNCLAIMED.

The following example shows an interrupt handler for the SCSI HBA `isp`
driver. The `caddr++_++t` parameter is set up when the interrupt handler
is added in `attach(9E)`. This parameter is typically a pointer to the
state structure, which is allocated on a per instance basis.

[[scsihba-ex-76]]
HBA Driver Interrupt Handler

[source,c]
----
static u_int
isp_intr(caddr_t arg)
{
    struct isp_cmd         *sp;
    struct isp_cmd         *head, *tail;
    u_short                response_in;
    struct isp_response    *resp;
    struct isp             *isp = (struct isp *)arg;
    struct isp_slot        *isp_slot;
    int                    n;

    if (ISP_INT_PENDING(isp) == 0) {
        return (DDI_INTR_UNCLAIMED);
    }

    do {
again:
        /*
         * head list collects completed packets for callback later
         */
        head = tail = NULL;
        /*
         * Assume no mailbox events (e.g., mailbox cmds, asynch
         * events, and isp dma errors) as common case.
         */
        if (ISP_CHECK_SEMAPHORE_LOCK(isp) == 0) {
            mutex_enter(ISP_RESP_MUTEX(isp));
            /*
             * Loop through completion response queue and post
             * completed pkts.  Check response queue again
             * afterwards in case there are more.
             */
            isp->isp_response_in =
            response_in = ISP_GET_RESPONSE_IN(isp);
            /*
             * Calculate the number of requests in the queue
             */
            n = response_in - isp->isp_response_out;
            if (n < 0) {
                n = ISP_MAX_REQUESTS -
                isp->isp_response_out + response_in;
            }
            while (n-- > 0) {
                ISP_GET_NEXT_RESPONSE_OUT(isp, resp);
                sp = (struct isp_cmd *)resp->resp_token;
                /*
                 * Copy over response packet in sp
                 */
                isp_i_get_response(isp, resp, sp);
            }
            if (head) {
                tail->cmd_forw = sp;
                tail = sp;
                tail->cmd_forw = NULL;
            } else {
                tail = head = sp;
                sp->cmd_forw = NULL;
            }
            ISP_SET_RESPONSE_OUT(isp);
            ISP_CLEAR_RISC_INT(isp);
            mutex_exit(ISP_RESP_MUTEX(isp));

            if (head) {
                isp_i_call_pkt_comp(isp, head);
            }
        } else {
            if (isp_i_handle_mbox_cmd(isp) != ISP_AEN_SUCCESS) {
                return (DDI_INTR_CLAIMED);
            }
            /*
             * if there was a reset then check the response
             * queue again
             */
            goto again;    
        }

    } while (ISP_INT_PENDING(isp));

    return (DDI_INTR_CLAIMED);
}

static void
isp_i_call_pkt_comp(
    struct isp             *isp,
    struct isp_cmd         *head)
{
    struct isp             *isp;
    struct isp_cmd         *sp;
    struct scsi_pkt        *pkt;
    struct isp_response    *resp;
    u_char                 status;

    while (head) {
        sp = head;
        pkt = sp->cmd_pkt;
        head = sp->cmd_forw;

        ASSERT(sp->cmd_flags & CFLAG_FINISHED);

        resp = &sp->cmd_isp_response;

        pkt->pkt_scbp[0] = (u_char)resp->resp_scb;
        pkt->pkt_state = ISP_GET_PKT_STATE(resp->resp_state);
        pkt->pkt_statistics = (u_long)
            ISP_GET_PKT_STATS(resp->resp_status_flags);
        pkt->pkt_resid = (long)resp->resp_resid;
        /*
         * If data was xferred and this is a consistent pkt,
         * do a dma sync
         */
        if ((sp->cmd_flags & CFLAG_CMDIOPB) &&
            (pkt->pkt_state & STATE_XFERRED_DATA)) {
                (void) ddi_dma_sync(sp->cmd_dmahandle,
                sp->cmd_dma_offset, sp->cmd_dma_len,
                DDI_DMA_SYNC_FORCPU);
        }

        sp->cmd_flags = (sp->cmd_flags & ~CFLAG_IN_TRANSPORT) |
            CFLAG_COMPLETED;
        /*
         * Call packet completion routine if FLAG_NOINTR is not set.
         */
        if (((pkt->pkt_flags & FLAG_NOINTR) == 0) &&
            pkt->pkt_comp) {
                (*pkt->pkt_comp)(pkt);
        }
    }
}
----

[[timeout-handler]]
===== Timeout Handler

The HBA driver is responsible for enforcing time outs. A
command must be complete within a specified time unless a zero time out
has been specified in the `scsi++_++pkt(9S)` structure.

When a command times out, the HBA driver should mark the
`scsi++_++pkt(9S)` with `pkt++_++reason` set to `CMD++_++TIMEOUT` and
`pkt++_++statistics` OR'd with `STAT++_++TIMEOUT`. The HBA driver should
also attempt to recover the target and bus. If this recovery can be
performed successfully, the driver should mark the `scsi++_++pkt(9S)`
using `pkt++_++statistics` OR'd with either `STAT++_++BUS++_++RESET` or
`STAT++_++DEV++_++RESET`.

After the recovery attempt has completed, the HBA driver should call the
command completion callback.

[NOTE]

If recovery was unsuccessful or not attempted, the target driver might
attempt to recover from the timeout by calling `scsi++_++reset(9F)`.
===

The ISP hardware manages command timeout directly and returns timed-out
commands with the necessary status. The timeout handler for the `isp`
sample driver checks active commands for the time out state only once
every 60 seconds.

The `isp` sample driver uses the `timeout(9F)` facility to arrange for
the kernel to call the timeout handler every 60 seconds. The
`caddr++_++t` argument is the parameter set up when the timeout is
initialized at `attach(9E)` time. In this case, the `caddr++_++t`
argument is a pointer to the state structure allocated per driver
instance.

If timed-out commands have not been returned as timed-out by the ISP
hardware, a problem has occurred. The hardware is not functioning
correctly and needs to be reset.

[[capability-management]]
==== Capability Management

The following sections discuss capability management.

[[tran_getcap-entry-point]]
===== `tran++_++getcap` Entry Point

The `tran++_++getcap(9E)`
entry point for a SCSI HBA driver is called by `scsi++_++ifgetcap(9F)`.
The target driver calls `scsi++_++ifgetcap` to determine the current
value of one of a set of SCSA-defined capabilities.

The target driver can request the current setting of the capability for
a particular target by setting the `whom` parameter to nonzero. A `whom`
value of zero indicates a request for the current setting of the general
capability for the SCSI bus or for adapter hardware.

The `tran++_++getcap` entry point should return `-1` for undefined
capabilities or the current value of the requested capability.

The HBA driver can use the function
`scsi++_++hba++_++lookup++_++capstr(9F)` to compare the capability
string against the canonical set of defined capabilities.

[[scsihba-ex-80]]
HBA Driver `tran++_++getcap(9E)` Entry Point

[source,c]
----
static int
isp_scsi_getcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap->a_target;
    /*
      * We don't allow getting capabilities for other targets
    */
    if (cap == NULL || whom  == 0) {
        return (-1);
    }
    isp = (struct isp *)ap->a_hba_tran->tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
          rval = 1 << 24; /* Limit to 16MB max transfer */
          break;
      case SCSI_CAP_MSG_OUT:
          rval = 1;
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_DR) == 0) {
              break;
          } else if (
              (isp->isp_cap[tgt] & ISP_CAP_DISCONNECT) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_SYNC) == 0) {
              break;
          } else if (
              (isp->isp_cap[tgt] & ISP_CAP_SYNC) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_WIDE) == 0) {
              break;
          } else if (
              (isp->isp_cap[tgt] & ISP_CAP_WIDE) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_DR) == 0 ||
            (isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_TAG) == 0) {
              break;
          } else if (
              (isp->isp_cap[tgt] & ISP_CAP_TAG) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_UNTAGGED_QING:
          rval = 1;
          break;
      case SCSI_CAP_PARITY:
          if (isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_PARITY) {
              rval = 1;
          }
          break;
      case SCSI_CAP_INITIATOR_ID:
          rval = isp->isp_initiator_id;
          break;
      case SCSI_CAP_ARQ:
          if (isp->isp_cap[tgt] & ISP_CAP_AUTOSENSE) {
              rval = 1;
          }
          break;
      case SCSI_CAP_LINKED_CMDS:
          break;
      case SCSI_CAP_RESET_NOTIFICATION:
         rval = 1;
          break;
      case SCSI_CAP_GEOMETRY:
          rval = (64 << 16) | 32;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}
----

[[tran_setcap-entry-point]]
===== `tran++_++setcap` Entry Point

The `tran++_++setcap(9E)` entry point for
a SCSI HBA driver is called by `scsi++_++ifsetcap(9F)`. A target driver
calls `scsi++_++ifsetcap` to change the current one of a set of
SCSA-defined capabilities.

The target driver might request that the new value be set for a
particular target by setting the `whom` parameter to nonzero. A `whom`
value of zero means the request is to set the new value for the SCSI bus
or for adapter hardware in general.

`tran++_++setcap` should return the following values as appropriate:

* `-1` for undefined capabilities
* `0` if the HBA driver cannot set the capability to the requested value
* `1` if the HBA driver is able to set the capability to the requested

The HBA driver can use the function
`scsi++_++hba++_++lookup++_++capstr(9F)` to compare the capability
string against the canonical set of defined capabilities.

[[scsihba-ex-82]]
HBA Driver `tran++_++setcap(9E)` Entry Point

[source,c]
----
static int
isp_scsi_setcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    value,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap->a_target;
    int                    update_isp = 0;
    /*
     * We don't allow setting capabilities for other targets
     */
    if (cap == NULL || whom == 0) {
        return (-1);
    }

    isp = (struct isp *)ap->a_hba_tran->tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
      case SCSI_CAP_MSG_OUT:
      case SCSI_CAP_PARITY:
      case SCSI_CAP_UNTAGGED_QING:
      case SCSI_CAP_LINKED_CMDS:
      case SCSI_CAP_RESET_NOTIFICATION:
          /*
           * None of these are settable through
           * the capability interface.
           */
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_DR) == 0) {
                break;
          } else {
              if (value) {
                  isp->isp_cap[tgt] |= ISP_CAP_DISCONNECT;
              } else {
                isp->isp_cap[tgt] &= ~ISP_CAP_DISCONNECT;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_SYNC) == 0) {
                break;
          } else {
              if (value) {
                  isp->isp_cap[tgt] |= ISP_CAP_SYNC;
              } else {
                  isp->isp_cap[tgt] &= ~ISP_CAP_SYNC;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_DR) == 0 ||
            (isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_TAG) == 0) {
                break;
          } else {
              if (value) {
                  isp->isp_cap[tgt] |= ISP_CAP_TAG;
              } else {
                  isp->isp_cap[tgt] &= ~ISP_CAP_TAG;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp->isp_target_scsi_options[tgt] &
            SCSI_OPTIONS_WIDE) == 0) {
                break;
          } else {
              if (value) {
                  isp->isp_cap[tgt] |= ISP_CAP_WIDE;
              } else {
                  isp->isp_cap[tgt] &= ~ISP_CAP_WIDE;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_INITIATOR_ID:
          if (value < N_ISP_TARGETS_WIDE) {
              struct isp_mbox_cmd mbox_cmd;
              isp->isp_initiator_id = (u_short) value;
              /*
               * set Initiator SCSI ID
               */
              isp_i_mbox_cmd_init(isp, &mbox_cmd, 2, 2,
                ISP_MBOX_CMD_SET_SCSI_ID,
                isp->isp_initiator_id,
                0, 0, 0, 0);
              if (isp_i_mbox_cmd_start(isp, &mbox_cmd) == 0) {
                  rval = 1;
              }
          }
          break;
      case SCSI_CAP_ARQ:
          if (value) {
              isp->isp_cap[tgt] |= ISP_CAP_AUTOSENSE;
          } else {
              isp->isp_cap[tgt] &= ~ISP_CAP_AUTOSENSE;
          }
          rval = 1;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}
----

[[abort-and-reset-management]]
==== Abort and Reset Management

The following sections discuss the abort and reset entry points for SCSI
HBA.

[[tran_abort-entry-point]]
===== `tran++_++abort` Entry Point

The `tran++_++abort(9E)`
entry point for a SCSI HBA driver is called to abort any commands that
are currently in transport for a particular target. This entry point is
called when a target driver calls `scsi++_++abort(9F)`.

The `tran++_++abort` entry point should attempt to abort the command
denoted by the `pkt` parameter. If the `pkt` parameter is `NULL`,
`tran++_++abort` should attempt to abort all outstanding commands in the
transport layer for the particular target or logical unit.

Each command successfully aborted must be marked with `pkt++_++reason`
`CMD++_++ABORTED` and `pkt++_++statistics` OR'd with `STAT++_++ABORTED`.

[[tran_reset-entry-point]]
===== `tran++_++reset` Entry Point

The `tran++_++reset(9E)` entry point for a
SCSI HBA driver is called to reset either the SCSI bus or a particular
SCSI target device. This entry point is called when a target driver
calls `scsi++_++reset(9F)`.

The `tran++_++reset` entry point must reset the SCSI bus if level is
`RESET++_++ALL`. If level is `RESET++_++TARGET`, just the particular
target or logical unit must be reset.

Active commands affected by the reset must be marked with
`pkt++_++reason` `CMD++_++RESET`. The type of reset determines whether
`STAT++_++BUS++_++RESET` or `STAT++_++DEV++_++RESET` should be used to
OR `pkt++_++statistics`.

Commands in the transport layer, but not yet active on the target, must
be marked with `pkt++_++reason` `CMD++_++RESET`, and
`pkt++_++statistics` OR'd with `STAT++_++ABORTED`.

[[tranbusreset-entry-point]]
===== `tran++_++bus++_++reset` Entry Point

`tran++_++bus++_++reset(9E)` must reset the SCSI bus without resetting
targets.

[source,c]
----
#include <sys/scsi/scsi.h>

int tran_bus_reset(dev_info_t *hba-dip, int level);
----

where:

++<*++hba-dip++>++::
  Pointer associated with the SCSI HBA
++<++level++>++::
  Must be set to `RESET++_++BUS` so that only the SCSI bus is reset, not
  the targets

The `tran++_++bus++_++reset` vector in the `scsi++_++hba++_++tran(9S)`
structure should be initialized during the HBA driver's `attach(9E)`.
The vector should point to an HBA entry point that is to be called when
a user initiates a bus reset.

Implementation is hardware specific. If the HBA driver cannot reset the
SCSI bus without affecting the targets, the driver should fail
`RESET++_++BUS` or not initialize this vector.

[[tranresetnotify-entry-point]]
===== `tran++_++reset++_++notify` Entry Point

Use the `tran++_++reset++_++notify(9E)`
entry point when a SCSI bus reset occurs. This function requests the
SCSI HBA driver to notify the target driver by callback.

[[scsihba-ex-87]]
HBA Driver `tran++_++reset++_++notify(9E)` Entry Point

[source,c]
----
isp_scsi_reset_notify(
    struct scsi_address    *ap,
    int                    flag,
    void                   (*callback)(caddr_t),
    caddr_t                arg)
{
    struct isp                       *isp;
    struct isp_reset_notify_entry    *p, *beforep;
    int                              rval = DDI_FAILURE;

    isp = (struct isp *)ap->a_hba_tran->tran_hba_private;
    mutex_enter(ISP_REQ_MUTEX(isp));
    /*
     * Try to find an existing entry for this target
     */
    p = isp->isp_reset_notify_listf;
    beforep = NULL;

    while (p) {
        if (p->ap == ap)
            break;
        beforep = p;
        p = p->next;
    }

    if ((flag & SCSI_RESET_CANCEL) && (p != NULL)) {
        if (beforep == NULL) {
            isp->isp_reset_notify_listf = p->next;
        } else {
            beforep->next = p->next;
        }
        kmem_free((caddr_t)p, sizeof (struct isp_reset_notify_entry));
        rval = DDI_SUCCESS;
    } else if ((flag & SCSI_RESET_NOTIFY) && (p == NULL)) {
        p = kmem_zalloc(sizeof (struct isp_reset_notify_entry),
          KM_SLEEP);
        p->ap = ap;
        p->callback = callback;
        p->arg = arg;
        p->next = isp->isp_reset_notify_listf;
        isp->isp_reset_notify_listf = p;
        rval = DDI_SUCCESS;
    }
    mutex_exit(ISP_REQ_MUTEX(isp));
    return (rval);
}
----

[[dynamic-reconfiguration]]
==== Dynamic Reconfiguration

SCSI HBA driver

and hotplugging

and SCSI HBA driver

To support the minimal set of hot-plugging operations, drivers might
need to implement support for bus _quiesce_, bus _unquiesce_, and bus
_reset_. The `scsi++_++hba++_++tran(9S)` structure supports these
operations. If quiesce, unquiesce, or reset are not required by
hardware, no driver changes are needed.

The `scsi++_++hba++_++tran` structure includes the following fields:

[source,c]
----
int (*tran_quiesce)(dev_info_t *hba-dip);
int (*tran_unquiesce)(dev_info_t *hba-dip);
int (*tran_bus_reset)(dev_info_t *hba-dip, int level);
----

These interfaces quiesce and unquiesce a SCSI bus.

[source,c]
----
#include <sys/scsi/scsi.h>

int prefixtran_quiesce(dev_info_t *hba-dip);
int prefixtran_unquiesce(dev_info_t *hba-dip);
----

`tran++_++quiesce(9E)` and `tran++_++unquiesce(9E)` are used for SCSI
devices that are not designed for hot-plugging. These functions must be
implemented by an HBA driver to support dynamic reconfiguration (DR).

The `tran++_++quiesce` and `tran++_++unquiesce` vectors in the
`scsi++_++hba++_++tran(9S)` structure should be initialized to point to
HBA entry points during `attach(9E)`. These functions are called when a
user initiates quiesce and unquiesce operations.

The `tran++_++quiesce` entry point stops all activity on a SCSI bus
prior to and during the reconfiguration of devices that are attached to
the SCSI bus. The `tran++_++unquiesce` entry point is called by the SCSA
framework to resume activity on the SCSI bus after the reconfiguration
operation has been completed.

HBA drivers are required to handle `tran++_++quiesce` by waiting for all
outstanding commands to complete before returning success. After the
driver has quiesced the bus, any new I/O requests must be queued until
the SCSA framework calls the corresponding `tran++_++unquiesce` entry
point.

HBA drivers handle calls to `tran++_++unquiesce` by starting any target
driver I/O requests in the queue.

[[scsi-hba-driver-specific-issues]]
=== SCSI HBA Driver Specific Issues

The section covers issues specific to SCSI HBA drivers.

[[installing-hba-drivers]]
==== Installing HBA Drivers

A SCSI HBA driver is installed in similar fashion to a leaf driver. See
link:#compiling-loading-packaging-and-testing-drivers[Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers]. The difference is that the `add++_++drv(8)` command
must specify the driver class as SCSI, such as:

....
# add_drv -m" * 0666 root root" -i'"pci1077,1020"' -c scsi isp
....

[[hba-configuration-properties]]
==== HBA Configuration Properties

When attaching an instance of an HBA
device, `scsi++_++hba++_++attach++_++setup(9F)` creates a number of SCSI
configuration properties for that HBA instance. A particular property is
created only if no existing property of the same name is already
attached to the HBA instance. This restriction avoids overriding any
default property values in an HBA configuration file.

An HBA driver must use
`ddi++_++prop++_++get++_++int(9F)` to retrieve each property. The HBA
driver then modifies or accepts the default value of the properties to
configure its specific operation.

[[scsi-reset-delay-property]]
===== `scsi-reset-delay` Property

The `scsi-reset-delay` property is an integer specifying the recovery
time in milliseconds for a reset delay by either a SCSI bus or SCSI
device.

[[scsi-options-property]]
===== `scsi-options` Property

The `scsi-options` property is an integer specifying a number of options
through individually defined bits:

* `SCSI++_++OPTIONS++_++DR (0x008)` – If not set, the HBA should not
grant disconnect privileges to a target device.
* `SCSI++_++OPTIONS++_++LINK (0x010)` – If not set, the HBA should not
enable linked commands.
* `SCSI++_++OPTIONS++_++SYNC (0x020)` – If not set, the HBA driver must
not negotiate synchronous data transfer. The driver should reject any
attempt to negotiate synchronous data transfer initiated by a target.
* `SCSI++_++OPTIONS++_++PARITY (0x040)` – If not set, the HBA should run
the SCSI bus without parity.
* `SCSI++_++OPTIONS++_++TAG (0x080)` – If not set, the HBA should not
operate in Command Tagged Queuing mode.
* `SCSI++_++OPTIONS++_++FAST (0x100)` – If not set, the HBA should not
operate the bus in FAST SCSI mode.
* `SCSI++_++OPTIONS++_++WIDE (0x200)` – If not set, the HBA should not
operate the bus in WIDE SCSI mode.

[[per-target-scsi-options]]
===== Per-Target `scsi-options`

An HBA driver might support a per-target `scsi`-`options` feature in the
following format:

....
target<n>-scsi-options=<hex value>
....

In this example, ++<++ __n__++>++ is the target ID. If the per-target
`scsi-options` property is defined, the HBA driver uses that value
rather than the per-HBA driver instance `scsi-options` property. This
approach can provide more precise control if, for example, synchronous
data transfer needs to be disabled for just one particular target
device. The per-target `scsi-options` property can be defined in the
`driver.conf(5)` file.

The following example shows a per-target `scsi-options` property
definition to disable synchronous data transfer for target device 3:

....
target3-scsi-options=0x2d8
....

[[x86-target-driver-configuration-properties]]
==== x86 Target Driver Configuration Properties

  Some x86 SCSI target drivers, such as the
driver for `cmdk` disk, use the following configuration properties:

* `disk`
* `queue`
* `flow++_++control`

If you use the `cmdk` sample driver to write an HBA
driver for an x86 platform, any appropriate properties must be defined
in the `driver.conf(5)` file.

[NOTE]

These property definitions should appear only in an HBA driver's
`driver.conf(5)` file. The HBA driver itself should not inspect or
attempt to interpret these properties in any way. These properties are
advisory only and serve as an adjunct to the `cmdk` driver. The
properties should not be relied upon in any way. The property
definitions might not be used in future releases.
===

The `disk` property can be used to define the type of disk supported by
`cmdk`. For a SCSI HBA, the only possible value for the `disk` property
is:

* `disk="scdk"` – Disk type is a SCSI disk

The `queue` property defines how the disk driver sorts the queue of
incoming requests during `strategy(9E)`. Two values are possible:

* `queue="qsort"` – One-way elevator queuing model, provided by
`disksort(9F)`
* `queue="qfifo"` – FIFO, that is, first in, first out queuing model

The `flow++_++control` property defines how commands are transported to
the HBA driver. Three values are possible:

* `flow++_++control="dsngl"` – Single command per HBA driver
* `flow++_++control="dmult"` – Multiple commands per HBA driver. When
the HBA queue is full, the driver returns TRAN++_++BUSY.
* `flow++_++control="duplx"` – The HBA can support separate read and
write queues, with multiple commands per queue. FIFO ordering is used
for the write queue. The queuing model that is used for the read queue
is described by the _queue_ property. When an HBA queue is full, the
driver returns TRAN++_++BUSY

The following example is a `driver.conf(5)` file for use with an x86 HBA
PCI device that has been designed for use with the `cmdk` sample driver:

....
#
# config file for ISP 1020 SCSI HBA driver     
#
       flow_control="dsngl" queue="qsort" disk="scdk"
       scsi-initiator-id=7;
....

[[support-for-queuing]]
=== Support for Queuing

For a definition of _tagged queuing_,
refer to the SCSI-2 specification. To support tagged queuing, first
check the ++<++scsi++_++options++>++ flag `SCSI++_++OPTIONS++_++TAG` to
see whether tagged queuing is enabled globally. Next, check to see
whether the target is a SCSI-2 device and whether the target has tagged
queuing enabled. If these conditions are all true, attempt to enable
tagged queuing by using `scsi++_++ifsetcap(9F)`.

If tagged queuing fails, you can attempt to set
_untagged queuing_. In this mode, you submit as many commands as you
think necessary or optimal to the host adapter driver. Then the host
adapter queues the commands to the target one command at a time, in
contrast to tagged queuing. In tagged queuing, the host adapter submits
as many commands as possible until the target indicates that the queue
is full.

[[drivers-for-network-devices]]
=== Drivers for Network Devices

device drivers

network drivers

network drivers

using GLD

illumos network drivers are STREAMS-based. These types of drivers are
covered in depth in the STREAMS Programming Guide. This chapter
discusses the Generic LAN driver (GLD), which is a kernel module
encapsulating features common to most network drivers. The GLD
implements much of the STREAMS and Data Link Provider Interface (DLPI)
functionality for an illumos network driver.

The GLD module is available for illumos network drivers for the SPARC
platform and for both 32-bit and 64-bit x86 platforms.

This chapter provides information on the following subjects:

* link:#generic-lan-driver-overview[Generic LAN Driver Overview]
* link:#declarations-and-data-structures[Declarations and Data Structures]
* link:#gld-arguments[GLD Arguments]
* link:#gld-entry-points[GLD Entry Points]
* link:#gld-service-routines[GLD Service Routines]

For more information on GLDs, see the `gld(4D)`, `dlpi(4P)`, `gld(9E)`,
`gld(9F)`, `gld++_++mac++_++info(9S)`, and `gld++_++stats(9S)` man
pages.

[[generic-lan-driver-overview]]
=== Generic LAN Driver Overview

GLD is a multi-threaded, clonable, loadable kernel
module providing support to device drivers for local area networks.
Local area network (LAN) device drivers in illumos are STREAMS-based
drivers that use DLPI to communicate with network protocol stacks. These
protocol stacks use the network drivers to send and receive packets on a
local area network.

A network device driver must implement and conform to these
requirements:

* DDI/DKI specification
* STREAMS specification
* DLPI specification
* programmatic interface for the device

GLD implements most STREAMS and DLPI functionality required of an
illumos LAN driver. Several illumos network drivers are implemented
using GLD.

An illumos
network driver that is implemented using GLD is made up of two distinct
parts: a generic component that deals with STREAMS and DLPI interfaces,
and a device-specific component that deals with the particular hardware
device. The device-specific module indicates its dependency on the GLD
module, which is found at `/kernel/misc/gld`. The device-specific module
then registers with GLD from within the driver's `attach(9E)` function.
After the device-specific module is successfully loaded, the driver is
DLPI-compliant. The device-specific part of the driver calls `gld(9F)`
functions when that part receives data or needs some service from GLD.
When the device-specific driver registers with the GLD, the driver
provides pointers to the entry points for later use by GLD. GLD makes
calls into the `gld(9E)` using these pointers. The
`gld++_++mac++_++info(9S)` structure is the main data interface between
GLD and the device-specific driver.

The GLD facility currently supports the following types of devices:

* `DL++_++ETHER`, that is, ISO 8802-3, IEEE 802.3 protocol
* `DL++_++TPR`, that is, IEEE 802.5, Token Passing Ring
* `DL++_++FDDI`, that is, ISO 9314-2, Fibre Distributed Data Interface

drivers are expected to process fully formed MAC-layer packets and
should not perform logical link control (LLC) handling.

In some cases, a full DLPI-compliant driver can be implemented without
using the GLD facility. One case would be devices that are not ISO
8802-style, that is, IEEE 802, LAN devices. Another case would be
devices or services that are not supported by GLD.

[[type-dl_ether-ethernet-v2-and-iso-8802-3-ieee-8023]]
==== Type `DL++_++ETHER`: Ethernet V2 and ISO 8802-3 (IEEE 802.3)

DL++_++ETHER

GLD support

DL++_++ETHER

Ethernet V2 packet processing

packet processing

Ethernet V2

DL++_++ETHER

ISO 8802-3 (IEEE 802.3) packet processing

packet processing

ISO 8802-3 (IEEE 802.3)

For devices designated type `DL++_++ETHER`, GLD provides
support for both Ethernet V2 and ISO 8802-3 (IEEE 802.3) packet
processing. Ethernet V2 enables a user to access a conforming provider
of data link services without special knowledge of the provider's
protocol. A service access point (SAP) is the point through which the
user communicates with the service provider.

Streams bound to SAP values in the range ++[++0-255++]++ are treated as
equivalent and denote that the user wants to use 8802-3 mode. If the SAP
value of the `DL++_++BIND++_++REQ` is within this range, GLD computes
the length of each subsequent `DL++_++UNITDATA++_++REQ` message on that
stream. The length does not include the 14-byte media access control
(MAC) header. GLD then transmits 8802-3 frames that have those lengths
in the MAC frame header `type` fields. Such lengths never exceed 1500.

All frames that are received from the media that have a `type` field in
the range ++[++0-1500++]++ are assumed to be 8802-3 frames. These frames
are routed up all open streams in 8802-3 mode. Those streams with SAP
values in the ++[++0-255++]++ range are considered to be in 8802-3 mode.
If more than one stream is in 8802-3 mode, the incoming frame is
duplicated and routed up these streams.

Those streams that are bound to SAP values that are greater than 1500
are assumed to be in Ethernet V2 mode. These streams receive incoming
packets whose Ethernet MAC header `type` value exactly matches the value
of the SAP to which the stream is bound.

[[types-dltpr-and-dlfddi-snap-processing]]
==== Types `DL++_++TPR` and `DL++_++FDDI`: SNAP Processing

DL++_++TPR

GLD support

DL++_++FDDI

GLD support

DL++_++TPR

SNAP processing

DL++_++FDDI

SNAP processing

For media types `DL++_++TPR`
and `DL++_++FDDI`, GLD implements minimal SNAP (Sub-Net Access Protocol)
processing. This processing is for any stream that is bound to a SAP
value that is greater than 255. SAP values in the range ++[++0-255++]++
are LLC SAP values. Such values are carried naturally by the media
packet format. SAP values that are greater than 255 require a SNAP
header, subordinate to the LLC header, to carry the 16-bit Ethernet
V2-style SAP value.

SNAP headers are carried under LLC headers with destination SAP 0xAA.
Outbound packets with SAP values that are greater than 255 require an
LLC{plus}SNAP header take the following form:

....
AA AA 03 00 00 00 XX XX
....

++``++XX XX'' represents the 16-bit SAP, corresponding to the Ethernet
V2 style ++``++type.'' This header is unique in supporting non-zero
organizational unique identifier fields. LLC control fields other than
03 are considered to be LLC packets with SAP 0xAA. Clients wanting to
use SNAP formats other than this format must use LLC and bind to SAP
0xAA.

Incoming packets are checked for conformance with the above format.
Packets that conform are matched to any streams that have been bound to
the packet's 16-bit SNAP type. In addition, these packets are considered
to match the LLC SNAP SAP 0xAA.

Packets received for any LLC SAP are passed up all streams that are
bound to an LLC SAP, as described for media type `DL++_++ETHER`.

[[type-dl_tpr-source-routing]]
==== Type `DL++_++TPR`: Source Routing

DL++_++TPR

GLD support

DL++_++TPR

source routing

For type `DL++_++TPR` devices, GLD implements minimal support for source
routing. Source routing support includes the following items:

* Specify routing information for a packet to be sent across a bridged
medium. The routing information is stored in the MAC header. This
information is used to determine the route.
* Learn routes.
* Solicit and respond to requests for information about possible
multiple routes
* Select among available routes.

Source routing adds routing information fields to the MAC headers of
outgoing packets. In addition, this support recognizes such fields in
incoming packets.

GLD's source routing support does not implement the full route
determination entity (RDE) specified in Section 9 of ISO 8802-2 (IEEE
802.2). However, this support can interoperate with any RDE
implementations that might exist in the same or a bridged network.

[[style-1-and-style-2-dlpi-providers]]
==== Style 1 and Style 2 DLPI Providers

DLPI providers

Style 1 DLPI provider

Style 2 DLPI provider

GLD implements both Style 1 and Style 2
DLPI providers. A physical point of attachment (PPA) is the point at
which a system attaches itself to a physical communication medium. All
communication on that physical medium funnels through the PPA. The Style
1 provider attaches the streams to a particular PPA based on the major
or minor device that has been opened. The Style 2 provider requires the
DLS, that is, the data link service, user to explicitly identify the
desired PPA using `DL++_++ATTACH++_++REQ`. In this case, `open(9E)`
creates a stream between the user and GLD, and `DL++_++ATTACH++_++REQ`
subsequently associates a particular PPA with that stream. Style 2 is
denoted by a minor number of zero. If a device node whose minor number
is not zero is opened, Style 1 is indicated and the associated PPA is
the minor number minus 1. In both Style 1 and Style 2 `open`s, the
device is cloned.

[[implemented-dlpi-primitives]]
==== Implemented DLPI Primitives

DLPI primitives

GLD implements several DLPI primitives.
The `DL++_++INFO++_++REQ` primitive requests information about the DLPI
streams. The message consists of one `M++_++PROTO` message block. GLD
returns device-dependent values in the `DL++_++INFO++_++ACK` response to
this request. These values are based on information that the GLD-based
driver specified in the `gldm++_++mac++_++info(9S)` structure that was
passed to `gld++_++register`.

GLD returns the following values on behalf of all GLD-based drivers:

* Version is `DL++_++VERSION++_++2`
* Service mode is `DL++_++CLDLS`, GLD
implements connectionless-mode service.
* Provider
style is `DL++_++STYLE1` or `DL++_++STYLE2`, depending on how the stream
was opened.
* No optional Quality of Service (QOS) support is present. The QOS
fields are zero.

[NOTE]

Contrary to the DLPI specification, GLD returns the device's correct
address length and broadcast address in `DL++_++INFO++_++ACK` even
before the stream has been attached to a PPA.
===

The `DL++_++ATTACH++_++REQ` primitive is
used to associate a PPA with a stream. This request is needed for Style
2 DLS providers to identify the physical medium over which the
communication is sent. Upon completion, the state changes from
`DL++_++UNATTACHED` to `DL++_++UNBOUND`. The message consists of one
`M++_++PROTO` message block. This request is not allowed when Style 1
mode is used. Streams that are opened using Style 1 are already attached
to a PPA by the time the open completes.

The `DL++_++DETACH++_++REQ` primitive
requests to detach the PPA from the stream. This detachment is allowed
only if the stream was opened using Style 2.

`DL++_++BIND++_++REQ` and `DL++_++UNBIND++_++REQ` primitives bind and
unbind a DLSAP (data link service access point) to the stream. The PPA
that is associated with a stream completes initialization before the
completion of the processing of the `DL++_++BIND++_++REQ` on that
stream. You can bind multiple streams to the same SAP. Each stream in
this case receives a copy of any packets that were received for that
SAP.

`DL++_++ENABMULTI++_++REQ` and `DL++_++DISABMULTI++_++REQ` primitives
enable and disable reception of individual multicast group addresses.
Through iterative use of these primitives, an application or other DLS
user can create or modify a set of multicast addresses. The streams must
be attached to a PPA for these primitives to be accepted.

`DL++_++PROMISCON++_++REQ` and `DL++_++PROMISCOFF++_++REQ` primitives
turn promiscuous mode on or off on a per-stream basis. These controls
operate at either at a physical level or at the SAP level. The DL
Provider routes all received messages on the media to the DLS user.
Routing continues until a `DL++_++DETACH++_++REQ` is received, a
`DL++_++PROMISCOFF++_++REQ` is received, or the stream is closed. You
can specify physical level promiscuous reception of all packets on the
medium or of multicast packets only.

[NOTE]

The streams must be attached to a PPA for these promiscuous mode
primitives to be accepted.
===

The `DL++_++UNITDATA++_++REQ` primitive is used to send
data in a connectionless transfer. Because this service is not
acknowledged, delivery is not guaranteed. The message consists of one
`M++_++PROTO` message block followed by one or more `M++_++DATA` blocks
containing at least one byte of data.

The `DL++_++UNITDATA++_++IND` type is used when a packet
is to be passed on upstream. The packet is put into an `M++_++PROTO`
message with the primitive set to `DL++_++UNITDATA++_++IND`.

The `DL++_++PHYS++_++ADDR++_++REQ`
primitive requests the MAC address currently associated with the PPA
attached to the streams. The address is returned by the
`DL++_++PHYS++_++ADDR++_++ACK` primitive. When using Style 2, this
primitive is only valid following a successful `DL++_++ATTACH++_++REQ`.

The `DL++_++SET++_++PHYS++_++ADDR++_++REQ`
primitive changes the MAC address currently associated with the PPA
attached to the streams. This primitive affects all other current and
future streams attached to this device. Once changed, all streams
currently or subsequently opened and attached to this device obtain this
new physical address. The new physical address remains in effect until
this primitive changes the physical address again or the driver is
reloaded.

[NOTE]

The superuser is allowed to change the physical address of a PPA while
other streams are bound to the same PPA.
===

`DL++_++GET++_++STATISTICS++_++REQ` primitive requests a
`DL++_++GET++_++STATISTICS++_++ACK` response containing statistics
information associated with the PPA attached to the stream. Style 2
Streams must be attached to a particular PPA using
`DL++_++ATTACH++_++REQ` before this primitive can succeed.

[[implemented-ioctl-functions]]
==== Implemented `ioctl` Functions

GLD implements the `ioctl` ++<++ioc++_++cmd++>++ function described
below. If GLD receives an unrecognizable `ioctl` command, GLD passes the
command to the device-specific driver's `gldm++_++ioctl` routine, as
described in `gld(9E)`.

The `DLIOCRAW` `ioctl`
function is used by some DLPI applications, most notably the `snoop(8)`
command. The `DLIOCRAW` command puts the stream into a raw mode. In raw
mode, the driver passes full MAC-level incoming packets upstream in
`M++_++DATA` messages instead of transforming the packets into the
`DL++_++UNITDATA++_++IND` form. The `DL++_++UNITDATA++_++IND` form is
normally used for reporting incoming packets. Packet SAP filtering is
still performed on streams that are in raw mode. If a stream user wants
to receive all incoming packets, the user must also select the
appropriate promiscuous modes. After successfully selecting raw mode,
the application is also allowed to send fully formatted packets to the
driver as `M++_++DATA` messages for transmission. `DLIOCRAW` takes no
arguments. Once enabled, the stream remains in this mode until closed.

[[gld-driver-requirements]]
==== GLD Driver Requirements

GLD-based drivers must include the header file `++<++sys/gld.h++>++`.

GLD-based drivers must be linked with the `N``“misc/gld”` option:

....
%ld -r -N"misc/gld" xx.o -o xx
....

GLD implements the following functions on behalf of the device-specific
driver:

* `open(9E)`
* `close(9E)`
* `put(9E)`, required for STREAMS
* `srv(9E)`, required for STREAMS
* `getinfo(9E)`

The `mi++_++idname` element of the `module++_++info(9S)`
structure is a string that specifies the name of the driver. This string
must exactly match the name of the driver module as defined in the file
system.

The read-side `qinit(9S)` structure should specify the following
elements:

`qi++_++putp`::
  `NULL`
`qi++_++srvp`::
  `gld++_++rsrv`
`qi++_++qopen`::
  `gld++_++open`
`qi++_++qclose`::
  `gld++_++close`

The write-side `qinit(9S)` structure should specify these elements:

`qi++_++putp`::
  `gld++_++wput`
`qi++_++srvp`::
  `gld++_++wsrv`
`qi++_++qopen`::
  `NULL`
`qi++_++qclose`::
  `NULL`

The `devo++_++getinfo` element of the `dev++_++ops(9S)` structure should
specify `gld++_++getinfo` as the `getinfo(9E)` routine.

The driver's `attach(9E)` function associates the hardware-specific
device driver with the GLD facility. `attach` then prepares the device
and driver for use.

The `attach(9E)` function allocates a
`gld++_++mac++_++info(9S)` structure using `gld++_++mac++_++alloc`. The
driver usually needs to save more information per device than is defined
in the `macinfo` structure. The driver should allocate the additional
required data structure and save a pointer to the structure in the
`gldm++_++private` member of the `gld++_++mac++_++info(9S)` structure.

The `attach(9E)` routine must initialize the `macinfo` structure as
described in the `gld++_++mac++_++info(9S)` man page. The `attach`
routine should then call `gld++_++register` to link the driver with the
GLD module. The driver should map registers if necessary and be fully
initialized and prepared to accept interrupts before calling
`gld++_++register`. The `attach(9E)` function should add interrupts but
should not enable the device to generate these interrupts. The driver
should reset the hardware before calling `gld++_++register` to ensure
the hardware is quiescent. A device must not be put into a state where
the device might generate an interrupt before `gld++_++register` is
called. The device is started later when GLD calls the driver's
`gldm++_++start` entry point, which is described in the `gld(9E)` man
page. After `gld++_++register` succeeds, the `gld(9E)` entry points
might be called by GLD at any time.

The `attach(9E)` routine should return `DDI++_++SUCCESS` if
`gld++_++register` succeeds. If `gld++_++register` fails,
`DDI++_++FAILURE` is returned. If a failure occurs, the `attach(9E)`
routine should deallocate any resources that were allocated before
`gld++_++register` was called. The attach routine should then also
return `DDI++_++FAILURE`. A failed `macinfo` structure should never be
reused. Such a structure should be deallocated using
`gld++_++mac++_++free`.

The `detach(9E)`function should attempt to
unregister the driver from GLD by calling `gld++_++unregister`. For more
information about `gld++_++unregister`, see the `gld(9F)` man page. The
`detach(9E)` routine can get a pointer to the needed
`gld++_++mac++_++info(9S)` structure from the device's private data
using `ddi++_++get++_++driver++_++private(9F)`. `gld++_++unregister`
checks certain conditions that could require that the driver not be
detached. If the checks fail, `gld++_++unregister` returns
`DDI++_++FAILURE`, in which case the driver's `detach(9E)` routine must
leave the device operational and return `DDI++_++FAILURE`.

If the checks succeed, `gld++_++unregister` ensures that the device
interrupts are stopped. The driver's `gldm++_++stop` routine is called
if necessary. The driver is unlinked from the GLD framework.
`gld++_++unregister` then returns `DDI++_++SUCCESS`. In this case, the
`detach(9E)` routine should remove interrupts and use
`gld++_++mac++_++free` to deallocate any `macinfo` data structures that
were allocated in the `attach(9E)` routine. The `detach` routine should
then return `DDI++_++SUCCESS`. The routine must remove the interrupt
++<++before++>++ calling `gld++_++mac++_++free`.

[[network-statistics]]
==== Network Statistics

GLD network statistics

illumos network drivers must
implement statistics variables. GLD tallies some network statistics, but
other statistics must be counted by each GLD-based driver. GLD provides
support for GLD-based drivers to report a standard set of network driver
statistics. Statistics are reported by GLD using the `kstat(4D)` and
`kstat(9S)` mechanisms. The `DL++_++GET++_++STATISTICS++_++REQ` DLPI
command can also be used to retrieve the current statistics counters.
All statistics are maintained as unsigned. The statistics are 32 bits
unless otherwise noted.

GLD maintains and reports the following statistics.

`rbytes64`::
  Total bytes successfully received on the interface. Stores 64-bit
  statistics.
`rbytes`::
  Total bytes successfully received on the interface
`obytes64`::
  Total bytes that have requested transmission on the interface. Stores
  64-bit statistics.
`obytes`::
  Total bytes that have requested transmission on the interface.
`ipackets64`::
  Total packets successfully received on the interface. Stores 64-bit
  statistics.
`ipackets`::
  Total packets successfully received on the interface.
`opackets64`::
  Total packets that have requested transmission on the interface.
  Stores 64-bit statistics.
`opackets`::
  Total packets that have requested transmission on the interface.
`multircv`::
  Multicast packets successfully received, including group and
  functional addresses (`long`).
`multixmt`::
  Multicast packets requested to be transmitted, including group and
  functional addresses (`long`).
`brdcstrcv`::
  Broadcast packets successfully received (`long`).
`brdcstxmt`::
  Broadcast packets that have requested transmission (`long`).
`unknowns`::
  Valid received packets not accepted by any stream (`long`).
`noxmtbuf`::
  Packets discarded on output because transmit buffer was busy, or no
  buffer could be allocated for transmit (`long`).
`blocked`::
  Number of times a received packet could not be put up a stream because
  the queue was flow-controlled (`long`).
`xmtretry`::
  Times transmit was retried after having been delayed due to lack of
  resources (`long`).
`promisc`::
  Current “promiscuous” state of the interface (string).

device-dependent driver tracks the following statistics in a private
per-instance structure. To report statistics, GLD calls the driver's
`gldm++_++get++_++stats` entry point. `gldm++_++get++_++stats` then
updates device-specific statistics in the `gld++_++stats(9S)` structure.
See the `gldm++_++get++_++stats(9E)` man page for more information. GLD
then reports the updated statistics using the named statistics variables
that are shown below.

`ifspeed`::
  Current estimated bandwidth of the interface in bits per second.
  Stores 64-bit statistics.
`media`::
  Current media type in use by the device (string).
`intr`::
  Number of times that the interrupt handler was called, causing an
  interrupt (`long`).
`norcvbuf`::
  Number of times a valid incoming packet was known to have been
  discarded because no buffer could be allocated for receive (`long`).
`ierrors`::
  Total number of packets that were received but could not be processed
  due to errors (`long`).
`oerrors`::
  Total packets that were not successfully transmitted because of errors
  (`long`).
`missed`::
  Packets known to have been dropped by the hardware on receive
  (`long`).
`uflo`::
  Times FIFO underflowed on transmit (`long`).
`oflo`::
  Times receiver overflowed during receive (`long`).

The following
group of statistics applies to networks of type `DL++_++ETHER`. These
statistics are maintained by device-specific drivers of that type, as
shown previously.

`align++_++errors`::
  Packets that were received with framing errors, that is, the packets
  did not contain an integral number of octets (`long`).
`fcs++_++errors`::
  Packets received with CRC errors (`long`).
`duplex`::
  Current duplex mode of the interface (string).
`carrier++_++errors`::
  Number of times carrier was lost or never detected on a transmission
  attempt (`long`).
`collisions`::
  Ethernet collisions during transmit (`long`).
`ex++_++collisions`::
  Frames where excess collisions occurred on transmit, causing transmit
  failure (`long`).
`tx++_++late++_++collisions`::
  Number of times a transmit collision occurred late, that is, after 512
  bit times (`long`).
`defer++_++xmts`::
  Packets without collisions where first transmit attempt was delayed
  because the medium was busy (`long`).
`first++_++collisions`::
  Packets successfully transmitted with exactly one collision.
`multi++_++collisions`::
  Packets successfully transmitted with multiple collisions.
`sqe++_++errors`::
  Number of times that SQE test error was reported.
`macxmt++_++errors`::
  Packets encountering transmit MAC failures, except carrier and
  collision failures.
`macrcv++_++errors`::
  Packets received with MAC errors, except `align++_++errors`,
  `fcs++_++errors`, and `toolong++_++errors`.
`toolong++_++errors`::
  Packets received larger than the maximum allowed length.
`runt++_++errors`::
  Packets received smaller than the minimum allowed length (`long`).

The following group of statistics applies to networks of type
`DL++_++TPR`. These statistics are maintained by device-specific drivers
of that type, as shown above.

`line++_++errors`::
  Packets received with non-data bits or FCS errors.
`burst++_++errors`::
  Number of times an absence of transitions for five half-bit timers was
  detected.
`signal++_++losses`::
  Number of times loss of signal condition on the ring was detected.
`ace++_++errors`::
  Number of times that an AMP or SMP frame, in which A is equal to C is
  equal to 0, is followed by another SMP frame without an intervening
  AMP frame.
`internal++_++errors`::
  Number of times the station recognized an internal error.
`lost++_++frame++_++errors`::
  Number of times the TRR timer expired during transmit.
`frame++_++copied++_++errors`::
  Number of times a frame addressed to this station was received with
  the FS field ++`++A' bit set to `1`.
`token++_++errors`::
  Number of times the station acting as the active monitor recognized an
  error condition that needed a token transmitted.
`freq++_++errors`::
  Number of times the frequency of the incoming signal differed from the
  expected frequency.

The following group of statistics applies to networks of type
`DL++_++FDDI`. These statistics are maintained by device-specific
drivers of that type, as shown above.

`mac++_++errors`::
  Frames detected in error by this MAC that had not been detected in
  error by another MAC.
`mac++_++lost++_++errors`::
  Frames received with format errors such that the frame was stripped.
`mac++_++tokens`::
  Number of tokens that were received, that is, the total of
  non-restricted and restricted tokens.
`mac++_++tvx++_++expired`::
  Number of times that TVX has expired.
`mac++_++late`::
  Number of TRT expirations since either this MAC was reset or a token
  was received.
`mac++_++ring++_++ops`::
  Number of times the ring has entered the “Ring Operational” state from
  the “Ring Not Operational” state.

[[declarations-and-data-structures]]
[[declarations-and-data-structures-1]]
=== Declarations and Data Structures

This section describes the `gld++_++mac++_++info(9S)`
and `gld++_++stats` structures.

[[gldmacinfo-structure]]
==== `gld++_++mac++_++info` Structure

GLD data structures

gld++_++mac++_++info

gld++_++mac++_++info

The GLD MAC information (`gld++_++mac++_++info`) structure is the main
data interface that links the device-specific driver with GLD. This
structure contains data required by GLD and a pointer to an optional
additional driver-specific information structure.

Allocate the `gld++_++mac++_++info` structure using
`gld++_++mac++_++alloc`. Deallocate the structure using
`gld++_++mac++_++free`. Drivers must not make any assumptions about the
length of this structure, which might vary in different releases of the
illumos, GLD, or both. Structure members private to GLD, not documented
here, should neither be set nor be read by the device-specific driver.

The `gld++_++mac++_++info(9S)` structure contains the following fields.

[source,c]
----
caddr_t              gldm_private;              /* Driver private data */
int                  (*gldm_reset)();           /* Reset device */
int                  (*gldm_start)();           /* Start device */
int                  (*gldm_stop)();            /* Stop device */
int                  (*gldm_set_mac_addr)();    /* Set device phys addr */
int                  (*gldm_set_multicast)();   /* Set/delete multicast addr */
int                  (*gldm_set_promiscuous)(); /* Set/reset promiscuous mode */
int                  (*gldm_send)();            /* Transmit routine */
uint_t               (*gldm_intr)();            /* Interrupt handler */
int                  (*gldm_get_stats)();       /* Get device statistics */
int                  (*gldm_ioctl)();           /* Driver-specific ioctls */
char                 *gldm_ident;               /* Driver identity string */
uint32_t             gldm_type;                 /* Device type */
uint32_t             gldm_minpkt;               /* Minimum packet size */
                                                /* accepted by driver */
uint32_t             gldm_maxpkt;               /* Maximum packet size */
                                                /* accepted by driver */
uint32_t             gldm_addrlen;              /* Physical address length */
int32_t              gldm_saplen;               /* SAP length for DL_INFO_ACK */
unsigned char        *gldm_broadcast_addr;      /* Physical broadcast addr */
unsigned char        *gldm_vendor_addr;         /* Factory MAC address */
t_uscalar_t          gldm_ppa;                  /* Physical Point of */
                                                /* Attachment (PPA) number */
dev_info_t           *gldm_devinfo;             /* Pointer to device's */
                                                /* dev_info node */
ddi_iblock_cookie_t  gldm_cookie;               /* Device's interrupt */
                                                /* block cookie */
----

The `gldm++_++private` structure member is visible to the device driver.
`gldm++_++private` is also private to the device-specific driver.
`gldm++_++private` is not used or modified by GLD. Conventionally,
`gldm++_++private` is used as a pointer to private data, pointing to a
per-instance data structure that is both defined and allocated by the
driver.

The following group of structure members must be set by
the driver before calling `gld++_++register`, and should not thereafter
be modified by the driver. Because `gld++_++register` might use or cache
the values of structure members, changes made by the driver after
calling `gld++_++register` might cause unpredictable results. For more
information on these structures, see the `gld(9E)` man page.

`gldm++_++reset`::
  Pointer to driver entry point.
`gldm++_++start`::
  Pointer to driver entry point.
`gldm++_++stop`::
  Pointer to driver entry point.
`gldm++_++set++_++mac++_++addr`::
  Pointer to driver entry point.
`gldm++_++set++_++multicast`::
  Pointer to driver entry point.
`gldm++_++set++_++promiscuous`::
  Pointer to driver entry point.
`gldm++_++send`::
  Pointer to driver entry point.
`gldm++_++intr`::
  Pointer to driver entry point.
`gldm++_++get++_++stats`::
  Pointer to driver entry point.
`gldm++_++ioctl`::
  Pointer to driver entry point. This pointer is allowed to be null.
`gldm++_++ident`::
  Pointer to a string that contains a short description of the device.
  This pointer is used to identify the device in system messages.
`gldm++_++type`::
  Type of device the driver handles. GLD currently supports the
  following values:
  +
  * `DL++_++ETHER` (ISO 8802-3 (IEEE 802.3) and Ethernet Bus)
  * `DL++_++TPR` (IEEE 802.5 Token Passing Ring)
  * `DL++_++FDDI` (ISO 9314-2 Fibre Distributed Data Interface)
  +
  This structure member must be correctly set for GLD to function
  properly.
`gldm++_++minpkt`::
  Minimum ++<++Service++>++ ++<++Data++>++ ++<++Unit++>++ size: the
  minimum packet size, not including the MAC header, that the device can
  transmit. This size is allowed to be zero if the device-specific
  driver handles any required padding.
`gldm++_++maxpkt`::
  Maximum ++<++Service++>++ ++<++Data++>++ ++<++Unit++>++ size: the
  maximum size of packet, not including the MAC header, that can be
  transmitted by the device. For Ethernet, this number is 1500.
`gldm++_++addrlen`::
  The length in bytes of physical addresses handled by the device. For
  Ethernet, Token Ring, and FDDI, the value of this structure member
  should be 6.
`gldm++_++saplen`::
  The length in bytes of the SAP address used by the driver. For
  GLD-based drivers, the length should always be set to `-2`. A length
  of `-2` indicates that 2-byte SAP values are supported and that the
  SAP appears ++<++after++>++ the physical address in a DLSAP address.
  See Appendix A.2, “Message DL++_++INFO++_++ACK,” in the DLPI
  specification for more details.
`gldm++_++broadcast++_++addr`::
  Pointer to an array of bytes of length `gldm++_++addrlen` containing
  the broadcast address to be used for transmit. The driver must provide
  space to hold the broadcast address, fill the space with the
  appropriate value, and set `gldm++_++broadcast++_++addr` to point to
  the address. For Ethernet, Token Ring, and FDDI, the broadcast address
  is normally `0xFF-FF-FF-FF-FF-FF`.
`gldm++_++vendor++_++addr`::
  Pointer to an array of bytes of length `gldm++_++addrlen` that
  contains the vendor-provided network physical address of the device.
  The driver must provide space to hold the address, fill the space with
  information from the device, and set `gldm++_++vendor++_++addr` to
  point to the address.
`gldm++_++ppa`::
  PPA number for this instance of the device. The PPA
  number should always be set to the instance number that is returned
  from `ddi++_++get++_++instance(9F)`.
`gldm++_++devinfo`::
  Pointer to the `dev++_++info` node for this device.
`gldm++_++cookie`::
  Interrupt block cookie returned by one of the following routines:
  +
  * `ddi++_++get++_++iblock++_++cookie(9F)`
  * `ddi++_++add++_++intr(9F)`
  * `ddi++_++get++_++soft++_++iblock++_++cookie(9F)`
  * `ddi++_++add++_++softintr(9F)`
  +
  This cookie must correspond to the device's receive-interrupt, from
  which `gld++_++recv` is called.

[[gld_stats-structure]]
==== `gld++_++stats` Structure

GLD data structures

gld++_++stats

After calling `gldm++_++get++_++stats`, a GLD-based driver uses the
(`gld++_++stats`) structure to communicate statistics and state
information to GLD. See the `gld(9E)` and `gld(4D)` man pages. The
members of this structure, having been filled in by the GLD-based
driver, are used when GLD reports the statistics. In the tables below,
the name of the statistics variable reported by GLD is noted in the
comments. See the `gld(4D)` man page for a more detailed description of
the meaning of each statistic.

Drivers must not make any assumptions about the length of this
structure. The structure length might vary in different releases of the
illumos, GLD, or both. Structure members private to GLD, which are not
documented here, should not be set or be read by the device-specific
driver.

The following structure members are defined for all media types:

[source,c]
----
uint64_t    glds_speed;                   /* ifspeed */
uint32_t    glds_media;                   /* media */
uint32_t    glds_intr;                    /* intr */
uint32_t    glds_norcvbuf;                /* norcvbuf */
uint32_t    glds_errrcv;                  /* ierrors */
uint32_t    glds_errxmt;                  /* oerrors */
uint32_t    glds_missed;                  /* missed */
uint32_t    glds_underflow;               /* uflo */
uint32_t    glds_overflow;                /* oflo */
----

The following structure members are defined for media type
`DL++_++ETHER`:

[source,c]
----
uint32_t    glds_frame;                   /* align_errors */
uint32_t    glds_crc;                     /* fcs_errors */
uint32_t    glds_duplex;                  /* duplex */
uint32_t    glds_nocarrier;               /* carrier_errors */
uint32_t    glds_collisions;              /* collisions */
uint32_t    glds_excoll;                  /* ex_collisions */
uint32_t    glds_xmtlatecoll;             /* tx_late_collisions */
uint32_t    glds_defer;                   /* defer_xmts */
uint32_t    glds_dot3_first_coll;         /* first_collisions */
uint32_t    glds_dot3_multi_coll;         /* multi_collisions */
uint32_t    glds_dot3_sqe_error;          /* sqe_errors */
uint32_t    glds_dot3_mac_xmt_error;      /* macxmt_errors */
uint32_t    glds_dot3_mac_rcv_error;      /* macrcv_errors */
uint32_t    glds_dot3_frame_too_long;     /* toolong_errors */
uint32_t    glds_short;                   /* runt_errors */
----

The following structure members are defined for media type `DL++_++TPR`:

[source,c]
----
uint32_t    glds_dot5_line_error          /* line_errors */
uint32_t    glds_dot5_burst_error         /* burst_errors */
uint32_t    glds_dot5_signal_loss         /* signal_losses */
uint32_t    glds_dot5_ace_error           /* ace_errors */
uint32_t    glds_dot5_internal_error      /* internal_errors */
uint32_t    glds_dot5_lost_frame_error    /* lost_frame_errors */
uint32_t    glds_dot5_frame_copied_error  /* frame_copied_errors */
uint32_t    glds_dot5_token_error         /* token_errors */
uint32_t    glds_dot5_freq_error          /* freq_errors */
----

The following structure members are defined for media type
`DL++_++FDDI`:

[source,c]
----
uint32_t    glds_fddi_mac_error;          /* mac_errors */
uint32_t    glds_fddi_mac_lost;           /* mac_lost_errors */
uint32_t    glds_fddi_mac_token;          /* mac_tokens */
uint32_t    glds_fddi_mac_tvx_expired;    /* mac_tvx_expired */
uint32_t    glds_fddi_mac_late;           /* mac_late */
uint32_t    glds_fddi_mac_ring_op;        /* mac_ring_ops */
----

Most of the above statistics variables are counters that denote the
number of times that the particular event was observed. The following
statistics do not represent the number of times:

`glds++_++speed`::
  Estimate of the interface's current bandwidth in bits per second. This
  object should contain the nominal bandwidth for those interfaces that
  do not vary in bandwidth or where an accurate estimate cannot be made.
`glds++_++media`::
  Type of media (wiring) or connector used by the hardware. The
  following media names are supported:
  +
  * `GLDM++_++AUI`
  * `GLDM++_++BNC`
  * `GLDM++_++TP`
  * `GLDM++_++10BT`
  * `GLDM++_++100BT`
  * `GLDM++_++100BTX`
  * `GLDM++_++100BT4`
  * `GLDM++_++RING4`
  * `GLDM++_++RING16`
  * `GLDM++_++FIBER`
  * `GLDM++_++PHYMII`
  * `GLDM++_++UNKNOWN`
`glds++_++duplex`::
  Current duplex state of the interface. Supported values are
  `GLD++_++DUPLEX++_++HALF` and `GLD++_++DUPLEX++_++FULL`.
  `GLD++_++DUPLEX++_++UNKNOWN` is also allowed.

[[gld-arguments]]
=== GLD Arguments

The following arguments are used by the GLD routines.

++<++macinfo++>++::
  Pointer to a `gld++_++mac++_++info(9S)` structure.
++<++macaddr++>++::
  Pointer to the beginning of a character array that contains a valid
  MAC address. The array is of the length specified by the driver in the
  `gldm++_++addrlen` element of the `gld++_++mac++_++info(9S)`
  structure.
++<++multicastaddr++>++::
  Pointer to the beginning of a character array that contains a
  multicast, group, or functional address. The array is of the length
  specified by the driver in the `gldm++_++addrlen` element of the
  `gld++_++mac++_++info(9S)` structure.
++<++multiflag++>++::
  Flag indicating whether to enable or disable reception of the
  multicast address. This argument is specified as
  `GLD++_++MULTI++_++ENABLE` or `GLD++_++MULTI++_++DISABLE`.
++<++promiscflag++>++::
  Flag indicating what type
  of promiscuous mode, if any, is to be enabled. This argument is
  specified as `GLD++_++MAC++_++PROMISC++_++PHYS`,
  `GLD++_++MAC++_++PROMISC++_++MULTI`, or
  `GLD++_++MAC++_++PROMISC++_++NONE`.
++<++mp++>++::
  `gld++_++ioctl` uses ++<++mp++>++ as a pointer to a STREAMS message
  block containing the `ioctl` to be executed. `gldm++_++send` uses
  ++<++mp++>++ as a pointer to a STREAMS message block containing the
  packet to be transmitted. `gld++_++recv` uses ++<++mp++>++ as a
  pointer to a message block containing a received packet.
++<++stats++>++::
  Pointer to a `gld++_++stats(9S)` structure to be filled in with the
  current values of statistics counters.
++<++q++>++::
  Pointer to the `queue(9S)` structure to be used in the reply to the
  `ioctl`.
++<++dip++>++::
  Pointer to the device's `dev++_++info` structure.
++<++name++>++::
  Device interface name.

[[gld-entry-points]]
=== GLD Entry Points

for network drivers

Entry points must be implemented by a device-specific network driver
that has been designed to interface with GLD.

The `gld++_++mac++_++info(9S)` structure is the main structure for
communication between the device-specific driver and the GLD module. See
the `gld(4D)` man page. Some elements in that structure are function
pointers to the entry points that are described here. The
device-specific driver must, in its `attach(9E)` routine, initialize
these function pointers before calling `gld++_++register`.

[[gldm_reset-entry-point]]
==== `gldm++_++reset` Entry Point

[source,c]
----
int prefix_reset(gld_mac_info_t *macinfo);
----

`gldm++_++reset` resets the hardware to its initial state.

[[gldm_start-entry-point]]
==== `gldm++_++start` Entry Point

[source,c]
----
int prefix_start(gld_mac_info_t *macinfo);
----

`gldm++_++start` enables the device to generate
interrupts. `gldm++_++start` also prepares the driver to call
`gld++_++recv` to deliver received data packets to GLD.

[[gldm_stop-entry-point]]
==== `gldm++_++stop` Entry Point

GLD entry points

gldm++_++stop

[source,c]
----
int prefix_stop(gld_mac_info_t *macinfo);
----

`gldm++_++stop` disables the device from generating any interrupts and
stops the driver from calling `gld++_++recv` for delivering data packets
to GLD. GLD depends on the `gldm++_++stop` routine to ensure that the
device will no longer interrupt. `gldm++_++stop` must do so without
fail. This function should always return `GLD++_++SUCCESS`.

[[gldmsetmac_addr-entry-point]]
==== `gldm++_++set++_++mac++_++addr` Entry Point

GLD entry points

gldm++_++set++_++mac++_++addr

[source,c]
----
int prefix_set_mac_addr(gld_mac_info_t *macinfo, unsigned char *macaddr);
----

`gldm++_++set++_++mac++_++addr` sets the physical address
that the hardware is to use for receiving data. This function enables
the device to be programmed through the passed MAC address
++<++macaddr++>++. If sufficient resources are currently not available
to carry out the request, `gldm++_++set++_++mac++_++add` should return
GLD++_++NORESOURCES. If the requested function is not supported,
`gldm++_++set++_++mac++_++add` should return GLD++_++NOTSUPPORTED.

[[gldmsetmulticast-entry-point]]
==== `gldm++_++set++_++multicast` Entry Point

GLD entry points

gldm++_++set++_++multicast

[source,c]
----
int prefix_set_multicast(gld_mac_info_t *macinfo, 
     unsigned char *multicastaddr, int multiflag);
----

`gldm++_++set++_++multicast` enables and
disables device-level reception of specific multicast addresses. If the
third argument ++<++multiflag++>++ is set to `GLD++_++MULTI++_++ENABLE`,
then `gldm++_++set++_++multicast` sets the interface to receive packets
with the multicast address. `gldm++_++set++_++multicast` uses the
multicast address that is pointed to by the second argument. If
++<++multiflag++>++ is set to `GLD++_++MULTI++_++DISABLE`, the driver is
allowed to disable reception of the specified multicast address.

This function is called whenever GLD wants to enable or disable
reception of a multicast, group, or functional address. GLD makes no
assumptions about how the device does multicast support and calls this
function to enable or disable a specific multicast address. Some devices
might use a hash algorithm and a bitmask to enable collections of
multicast addresses. This procedure is allowed, and GLD filters out any
superfluous packets. If disabling an address could result in disabling
more than one address at the device level, the device driver should keep
any necessary information. This approach avoids disabling an address
that GLD has enabled but not disabled.

`gldm++_++set++_++multicast` is not called to enable a particular
multicast address that is already enabled. Similarly,
`gldm++_++set++_++multicast` is not called to disable an address that is
not currently enabled. GLD keeps track of multiple requests for the same
multicast address. GLD only calls the driver's entry point when the
first request to enable, or the last request to disable, a particular
multicast address is made. If sufficient resources are currently not
available to carry out the request, the function should return
`GLD++_++NORESOURCES`. The function should return GLD++_++NOTSUPPORTED
if the requested function is not supported.

[[gldmsetpromiscuous-entry-point]]
==== `gldm++_++set++_++promiscuous` Entry Point

GLD entry points

gldm++_++set++_++promiscuous

[source,c]
----
int prefix_set_promiscuous(gld_mac_info_t *macinfo, int promiscflag);
----

`gldm++_++set++_++promiscuous` enables and disables promiscuous mode.
This function is called whenever GLD wants to enable or disable the
reception of all packets on the medium. The function can also be limited
to multicast packets on the medium. If the second argument
++<++promiscflag++>++ is set to the value of
`GLD++_++MAC++_++PROMISC++_++PHYS`, then the function enables
physical-level promiscuous mode. Physical-level promiscuous mode causes
the reception of all packets on the medium. If ++<++promiscflag++>++ is
set to `GLD++_++MAC++_++PROMISC++_++MULTI`, then reception of all
multicast packets are enabled. If ++<++promiscflag++>++ is set to
`GLD++_++MAC++_++PROMISC++_++NONE`, then promiscuous mode is disabled.

In promiscuous multicast mode, drivers for devices without
multicast-only promiscuous mode must set the device to physical
promiscuous mode. This approach ensures that all multicast packets are
received. In this case, the routine should return `GLD++_++SUCCESS`. The
GLD software filters out any superfluous packets. If sufficient
resources are currently not available to carry out the request, the
function should return `GLD++_++NORESOURCES`.
`gld++_++set++_++promiscuous` should return `GLD++_++NOTSUPPORTED` if
the requested function is not supported.

For forward compatibility, `gldm++_++set++_++promiscuous` routines
should treat any unrecognized values for ++<++promiscflag++>++ as though
these values were `GLD++_++MAC++_++PROMISC++_++PHYS`.

[[gldm_send-entry-point]]
==== `gldm++_++send` Entry Point

GLD entry points

gldm++_++send

[source,c]
----
int prefix_send(gld_mac_info_t *macinfo, mblk_t *mp);
----

`gldm++_++send` queues a packet to the device for transmission. This
routine is passed a STREAMS message containing the packet to be sent.
The message might include multiple message blocks. The `send` routine
must traverse all the message blocks in the message to access the entire
packet to be sent. The driver should be prepared to handle and skip over
any zero-length message continuation blocks in the chain. The driver
should also check that the packet does not exceed the maximum allowable
packet size. The driver must pad the packet, if necessary, to the
minimum allowable packet size. If the send routine successfully
transmits or queues the packet, `GLD++_++SUCCESS` should be returned.

The send routine should return `GLD++_++NORESOURCES` if the packet for
transmission cannot be immediately accepted. In this case, GLD retries
later. If `gldm++_++send` ever returns `GLD++_++NORESOURCES`, the driver
must call `gld++_++sched` at a later time when resources have become
available. This call to `gld++_++sched` informs GLD to retry packets
that the driver previously failed to queue for transmission. (If the
driver's `gldm++_++stop` routine is called, the driver is absolved from
this obligation until the driver returns `GLD++_++NORESOURCES` from the
`gldm++_++send` routine. However, extra calls to `gld++_++sched` do not
cause incorrect operation.)

If the driver's send routine returns `GLD++_++SUCCESS`,
then the driver is responsible for freeing the message when the message
is no longer needed. If the hardware uses DMA to read the data directly,
the driver must not free the message until the hardware has completely
read the data. In this case, the driver can free the message in the
interrupt routine. Alternatively, the driver can reclaim the buffer at
the start of a future send operation. If the send routine returns
anything other than `GLD++_++SUCCESS`, then the driver must not free the
message. Return `GLD++_++NOLINK` if `gldm++_++send` is called when there
is no physical connection to the network or link partner.

[[gldm_intr-entry-point]]
==== `gldm++_++intr` Entry Point

GLD entry points

gldm++_++intr

[source,c]
----
int prefix_intr(gld_mac_info_t *macinfo);
----

`gldm++_++intr` is called when the device might have interrupted.
Because interrupts can be shared with other devices, the driver must
check the device status to determine whether that device actually caused
the interrupt. If the device that the driver controls did not cause the
interrupt, then this routine must return `DDI++_++INTR++_++UNCLAIMED`.
Otherwise, the driver must service the interrupt and return
`DDI++_++INTR++_++CLAIMED`. If the interrupt was caused by successful
receipt of a packet, this routine should put the received packet into a
STREAMS message of type `M++_++DATA` and pass that message to
`gld++_++recv`.

`gld++_++recv` passes the inbound packet upstream to the appropriate
next layer of the network protocol stack. The routine must correctly set
the `b++_++rptr` and `b++_++wptr` members of the STREAMS message before
calling `gld++_++recv`.

The driver should avoid holding mutex or other locks during the call to
`gld++_++recv`. In particular, locks that could be taken by a transmit
thread must not be held during a call to `gld++_++recv`. In some cases,
the interrupt thread that calls `gld++_++recv` sends an outgoing packet,
which results in a call to the driver's `gldm++_++send` routine. If
`gldm++_++send` tries to acquire a mutex that is held by `gldm++_++intr`
when `gld++_++recv` is called, a panic occurs due to recursive mutex
entry. If other driver entry points attempt to acquire a mutex that the
driver holds across a call to `gld++_++recv`, deadlock can result.

The interrupt code should increment statistics counters for any errors.
Errors include the failure to allocate a buffer that is needed for the
received data and any hardware-specific errors, such as CRC errors or
framing errors.

[[gldmgetstats-entry-point]]
==== `gldm++_++get++_++stats` Entry Point

GLD entry points

gldm++_++get++_++stats

[source,c]
----
int prefix_get_stats(gld_mac_info_t *macinfo, struct gld_stats *stats);
----

`gldm++_++get++_++stats` gathers statistics from the hardware, driver
private counters, or both, and updates the `gld++_++stats(9S)` structure
pointed to by ++<++stats++>++. This routine is called by GLD for
statistics requests. GLD uses the `gldm++_++get++_++stats` mechanism to
acquire device-dependent statistics from the driver before GLD composes
the reply to the statistics request. See the `gld++_++stats(9S)`,
`gld(4D)`, and `qreply(9F)` man pages for more information about defined
statistics counters.

[[gldm_ioctl-entry-point]]
==== `gldm++_++ioctl` Entry Point

GLD entry points

gldm++_++ioctl

[source,c]
----
int prefix_ioctl(gld_mac_info_t *macinfo, queue_t *q, mblk_t *mp);
----

`gldm++_++ioctl` implements any device-specific `ioctl` commands. This
element is allowed to be null if the driver does not implement any
`ioctl` functions. The driver is responsible for converting the message
block into an `ioctl` reply message and calling the `qreply(9F)`
function before returning `GLD++_++SUCCESS`. This function should always
return `GLD++_++SUCCESS`. The driver should report any errors as needed
in a message to be passed to `qreply(9F)`. If the `gldm++_++ioctl`
element is specified as `NULL`, GLD returns a message of type
`M++_++IOCNAK` with an error of EINVAL.

[[gld-return-values]]
==== GLD Return Values

Some entry point functions in GLD can return the following values,
subject to the restrictions above:

`GLD++_++BADARG`::
  If the function detected an unsuitable argument, for
  example, a bad multicast address, a bad MAC address, or a bad packet
`GLD++_++FAILURE`::
  On hardware failure
`GLD++_++SUCCESS`::
  On success

[[gld-service-routines]]
=== GLD Service Routines

This section provides the syntax and description for the GLD service
routines.

[[gldmacalloc-function]]
==== `gld++_++mac++_++alloc` Function

GLD service routines

gld++_++mac++_++alloc

gld++_++mac++_++alloc

[source,c]
----
gld_mac_info_t *gld_mac_alloc(dev_info_t *dip);
----

`gld++_++mac++_++alloc` allocates a new `gld++_++mac++_++info(9S)`
structure and returns a pointer to the structure. Some of the
GLD-private elements of the structure might be initialized before
`gld++_++mac++_++alloc` returns. All other elements are initialized to
zero. The device driver must initialize some structure members, as
described in the `gld++_++mac++_++info(9S)` man page, before passing the
pointer to the `gld++_++mac++_++info` structure to `gld++_++register`.

[[gldmacfree-function]]
==== `gld++_++mac++_++free` Function

GLD service routines

gld++_++mac++_++free

gld++_++mac++_++free

[source,c]
----
void gld_mac_free(gld_mac_info_t *macinfo);
----

`gld++_++mac++_++free` frees a `gld++_++mac++_++info(9S)` structure
previously allocated by `gld++_++mac++_++alloc`.

[[gld_register-function]]
==== `gld++_++register` Function

GLD service routines

gld++_++register

gld++_++register

[source,c]
----
int gld_register(dev_info_t *dip, char *name, gld_mac_info_t *macinfo);
----

`gld++_++register` is called from the device driver's `attach(9E)`
routine. `gld++_++register` links the GLD-based device driver with the
GLD framework. Before calling `gld++_++register`, the device driver's
`attach(9E)` routine uses `gld++_++mac++_++alloc` to allocate a
`gld++_++mac++_++info(9S)` structure, and then initializes several
structure elements. See `gld++_++mac++_++info(9S)` for more information.
A successful call to `gld++_++register` performs the following actions:

* Links the device-specific driver with the GLD system
* Sets the device-specific driver's private data pointer, using
`ddi++_++set++_++driver++_++private(9F)` to point to the `macinfo`
structure
* Creates the minor device node
* Returns `DDI++_++SUCCESS`

The device interface name passed to `gld++_++register` must exactly
match the name of the driver module as that name exists in the file
system.

The driver's `attach(9E)` routine should return `DDI++_++SUCCESS` if
`gld++_++register` succeeds. If `gld++_++register` does not return
`DDI++_++SUCCESS`, the `attach(9E)` routine should deallocate any
allocated resources before calling `gld++_++register`, and then return
`DDI++_++FAILURE`.

[[gld_unregister-function]]
==== `gld++_++unregister` Function

GLD service routines

gld++_++unregister

gld++_++unregister

[source,c]
----
int gld_unregister(gld_mac_info_t *macinfo);
----

`gld++_++unregister` is called by the device driver's `detach(9E)`
function, and if successful, performs the following tasks:

* Ensures that the device's interrupts are stopped, calling the driver's
`gldm++_++stop` routine if necessary
* Removes the minor device node
* Unlinks the device-specific driver from the GLD system
* Returns `DDI++_++SUCCESS`

If `gld++_++unregister` returns `DDI++_++SUCCESS`, the `detach(9E)`
routine should deallocate any data structures allocated in the
`attach(9E)` routine, using `gld++_++mac++_++free` to deallocate the
`macinfo` structure, and return `DDI++_++SUCCESS`. If
`gld++_++unregister` does not return `DDI++_++SUCCESS`, the driver's
`detach(9E)` routine must leave the device operational and return
`DDI++_++FAILURE`.

[[gld_recv-function]]
==== `gld++_++recv` Function

GLD service routines

gld++_++recv

gld++_++recv

[source,c]
----
void gld_recv(gld_mac_info_t *macinfo, mblk_t *mp);
----

`gld++_++recv` is called by the driver's interrupt handler to pass a
received packet upstream. The driver must construct and pass a STREAMS
`M++_++DATA` message containing the raw packet. `gld++_++recv`
determines which STREAMS queues should receive a copy of the packet,
duplicating the packet if necessary. `gld++_++recv` then formats a
`DL++_++UNITDATA++_++IND` message, if required, and passes the data up
all appropriate streams.

The driver should avoid holding mutex or other locks during the call to
`gld++_++recv`. In particular, locks that could be taken by a transmit
thread must not be held during a call to `gld++_++recv`. The interrupt
thread that calls `gld++_++recv` in some cases carries out processing
that includes sending an outgoing packet. Transmission of the packet
results in a call to the driver's `gldm++_++send` routine. If
`gldm++_++send` tries to acquire a mutex that is held by `gldm++_++intr`
when `gld++_++recv` is called, a panic occurs due to a recursive mutex
entry. If other driver entry points attempt to acquire a mutex that the
driver holds across a call to `gld++_++recv`, deadlock can result.

[[gld_sched-function]]
==== `gld++_++sched` Function

GLD service routines

gld++_++sched

gld++_++sched

[source,c]
----
void gld_sched(gld_mac_info_t *macinfo);
----

`gld++_++sched` is called by the device driver to
reschedule stalled outbound packets. Whenever the driver's
`gldm++_++send` routine returns `GLD++_++NORESOURCES`, the driver must
call `gld++_++sched` to inform the GLD framework to retry previously
unsendable packets. `gld++_++sched` should be called as soon as possible
after resources become available so that GLD resumes passing outbound
packets to the driver's `gldm++_++send` routine. (If the driver's
`gldm++_++stop` routine is called, the driver need not retry until
`GLD++_++NORESOURCES` is returned from `gldm++_++send`. However, extra
calls to `gld++_++sched` do not cause incorrect operation.)

[[gld_intr-function]]
==== `gld++_++intr` Function

GLD service routines

gld++_++intr

gld++_++intr

interrupt handling

gld++_++intr

....
uint_t gld_intr(caddr_t);
....

`gld++_++intr` is GLD's main interrupt handler. Normally,
`gld++_++intr` is specified as the interrupt routine in the device
driver's call to `ddi++_++add++_++intr(9F)`. The argument to the
interrupt handler is specified as ++<++int++_++handler++_++arg++>++ in
the call to `ddi++_++add++_++intr(9F)`. This argument must be a pointer
to the `gld++_++mac++_++info(9S)` structure. `gld++_++intr`, when
appropriate, calls the device driver's `gldm++_++intr` function, passing
that pointer to the `gld++_++mac++_++info(9S)` structure. However, to
use a high-level interrupt, the driver must provide its own high-level
interrupt handler and trigger a soft interrupt from within the handler.
In this case, `gld++_++intr` would normally be specified as the soft
interrupt handler in the call to `ddi++_++add++_++softintr`.
`gld++_++intr` returns a value that is appropriate for an interrupt
handler.

[[usb-drivers]]
=== USB Drivers

device drivers

USB driver

USBA (illumos USB Architecture)

USBA 2.0 framework

This chapter describes how to write a client USB device driver using the
USBA 2.0 framework for the illumos environment. This chapter discusses
the following topics:

* link:#usb-in-the-illumos-environment[USB in the illumos Environment]
* link:#binding-client-drivers[Binding Client Drivers]
* link:#basic-device-access[Basic Device Access]
* link:#device-communication[Device Communication]
* link:#device-state-management[Device State Management]
* link:#utility-functions[Utility Functions]
* link:#sample-usb-device-driver[Sample USB Device Driver]

[[usb-in-the-illumos-environment]]
=== USB in the illumos Environment

The illumos USB architecture includes the USBA 2.0 framework and USB
client drivers.

[[usba-20-framework]]
==== USBA 2.0 Framework

USB 2.0 specification

The USBA 2.0 framework is a service layer that presents an abstract view
of USB devices to USBA-compliant client drivers. The framework enables
USBA-compliant client drivers to manage their USB devices. The USBA 2.0
framework supports the USB 2.0 specification except for high speed
isochronous pipes. For information on the USB 2.0 specification, see
http://www.usb.org/.

The USBA 2.0 framework is platform-independent. The illumos USB
architecture is shown in the following figure. The USBA 2.0 framework is
the USBA layer in the figure. This layer interfaces through a
hardware-independent host controller driver interface to
hardware-specific host controller drivers. The host controller drivers
access the USB physical devices through the host controllers they
manage.

.illumos USB Architecture
[#euxbt]
image::figures/usb-arch.png[Diagram shows the flow of control from client and hub drivers, through the USB Architecture Interfaces, to the
controllers and devices.]

[[usb-client-drivers]]
==== USB Client Drivers

USB drivers

nexus driver

hub driver

The USBA 2.0 framework is not a device driver itself. This chapter
describes the client drivers shown in link:#euxbt[illumos USB
Architecture] and link:#euxbg[Driver and Controller Interfaces]. The
client drivers interact with various kinds of USB devices such as mass
storage devices, printers, and human interface devices. The hub driver
is a client driver that is also a nexus driver. The hub driver
enumerates devices on its ports and creates `devinfo` nodes for those
devices and then attaches the client drivers. This chapter does not
describe how to write a hub driver.

USB drivers have the same structure as any other illumos driver. USB
drivers can be block drivers, character drivers, or STREAMS drivers. USB
drivers follow the calling conventions and use the data structures and
routines described in the illumos section 9 man pages. See `Intro(9E)`,
`Intro(9F)`, and `Intro(9S)`.

The difference
between USB drivers and other illumos drivers is that USB drivers call
USBA 2.0 framework functions to access the device instead of directly
accessing the device. The USBA 2.0 framework supplements the standard
illumos DDI routines. See the following figure.

.Driver and Controller Interfaces
[#euxbg]
image::figures/usb-drv-ctrl-int.png[Diagram shows DDI and USBAI functions, different versions of the USBA framework, and different types of host
controllers.]

link:#euxbg[Driver and Controller Interfaces] shows interfaces in more
detail than link:#euxbt[illumos USB Architecture] does.
link:#euxbg[Driver and Controller Interfaces] shows that the USBA is a
kernel subsystem into which a client driver can call, just as a client
driver can call DDI functions.

Not all systems have all of the host controller interfaces shown in
link:#euxbg[Driver and Controller Interfaces]. OHCI (Open Host
Controller Interface) hardware is most prevalent on SPARC systems and
third-party USB PCI cards. UHCI (Universal Host Controller Interface)
hardware is most prevalent on x86 systems. However, both OHCI and UHCI
hardware can be used on any system. When EHCI (Enhanced Host Controller
Interface) hardware is present, the EHCI hardware is on the same card
and shares the same ports with either OHCI or UHCI.

The host controllers, host controller drivers, and HCDI make up a
transport layer that is commanded by the USBA. You cannot directly call
into the OHCI, EHCI, or UHCI. You call into them indirectly through the
platform-independent USBA interface.

[[binding-client-drivers]]
=== Binding Client Drivers

This section discusses binding a driver to a device. It discusses
compatible device names for devices with single interfaces and devices
with multiple interfaces.

[[how-usb-devices-appear-to-the-system]]
==== How USB Devices Appear to the System

USB device

current configuration

USB device

multiple configurations

USB device

USB device

alternate settings

USB device

alternate settings

USB drivers

USB devices

A USB device can support multiple configurations. Only one configuration
is active at any given time. The active configuration is called the
_current configuration_.

A configuration can have more than one _interface_, possibly with
intervening interface-associations that group two or more interfaces for
a function. All interfaces of a configuration are active simultaneously.
Different interfaces might be operated by different device drivers.

An interface can represent itself to the host system in different ways
by using _alternate settings_. Only one alternate setting is active for
any given interface.

Each alternate setting provides device access through _endpoints_. Each
endpoint has a specific purpose. The host system communicates with the
device by establishing a communication channel to an endpoint. This
communication channel is called a _pipe_.

[[usb-devices-and-the-illumos-device-tree]]
==== USB Devices and the illumos Device Tree

single device node

device node

If a USB device has one configuration, one interface, and device class
zero, the device is represented as a single _device node_. If a USB
device has multiple interfaces, the device is represented as a
hierarchical device structure. In a hierarchical device structure, the
device node for each interface is a child of the top-level device node.
An example of a device with multiple interfaces is an audio device that
presents simultaneously to the host computer both an audio control
interface and an audio streaming interface. The audio control interface
and the audio streaming interface each could be controlled by its own
driver.

[[compatible-device-names]]
==== Compatible Device Names

device information

compatible device names

USB device

compatible device names

device drivers

binding to device node

device information

binding a driver to a USB device

binding a driver to a USB device

displaying device names

The illumos software builds an ordered list of compatible device names
for USB binding based on identification information kept within each
device. This information includes device class, subclass, vendor ID,
product ID, revision, and protocol. See http://www.usb.org/ for a list
of USB classes and subclasses.

This name hierarchy enables binding to a general driver if a more
device-specific driver is not available. An example of a general driver
is a class-specific driver. Device names that begin with `usbif`
designate single interface devices. See
link:#usb-fig-27[example++_++title] for examples. The USBA 2.0 framework
defines all compatible names for a device. Use the `prtconf` command to
display these device names, as shown in link:#ewatq[example++_++title].

The following example shows an example of compatible device names for a
USB mouse device. This mouse device represents a combined node entirely
operated by a single driver. The USBA 2.0 framework gives this device
node the names shown in the example, in the order shown.

[[usb-fig-27]]
USB Mouse Compatible Device Names

....
1. 'usb430,100.102'      Vendor 430, product 100, revision 102
2. 'usb430,100'      Vendor 430, product 100
3. 'usbif430,class3.1.2' Vendor 430, class 3, subclass 1, protocol 2
4. 'usbif430,class3.1'   Vendor 430, class 3, subclass 1
5. 'usbif430,class3'     Vendor 430, class 3
6. 'usbif,class3.1.2'    Class 3, subclass 1, protocol 2
7. 'usbif,class3.1'      Class 3, subclass 1
8. 'usbif,class3'    Class 3
....

Note that the names in the above example progress from
the most specific to the most general. Entry 1 binds only to a
particular revision of a specific product from a particular vendor.
Entries 3, 4, and 5 are for class 3 devices manufactured by vendor 430.
Entries 6, 7, and 8 are for class 3 devices from any vendor. The binding
process looks for a match on the name from the top name down. To bind,
drivers must be added to the system with an alias that matches one of
these names. To get a list of compatible device names to which to bind
when you add your driver, check the `compatible` property of the device
in the output from the `prtconf` `vp` command.

The following example shows compatible property lists for a keyboard and
a mouse. Use the `prtconf` `D` command to display the bound driver.

[[ewatq]]
Compatible Device Names Shown by the Print Configuration Command

....
# prtconf -vD | grep compatible
            compatible: 'usb430,5.200' + 'usb430,5' + 'usbif430,class3.1.1'
+ 'usbif430,class3.1' + 'usbif430,class3' + 'usbif,class3.1.1' +
'usbif,class3.1' + 'usbif,class3'
            compatible: 'usb2222,2071.200' + 'usb2222,2071' +
'usbif2222,class3.1.2' + 'usbif2222,class3.1' + 'usbif2222,class3' +
'usbif,class3.1.2' + 'usbif,class3.1' + 'usbif,class3'
....

Use the most specific name you can to more accurately
identify a driver for a device or group of devices. To bind drivers
written for a specific revision of a specific product, use the most
specific name match possible. For example, if you have a USB mouse
driver written by vendor 430 for revision 102 of their product 100, use
the following command to add that driver to the system:

....
add_drv -n -i '"usb430,100.102"' specific_mouse_driver
....

To add a driver written for any USB mouse (class 3, subclass 1, protocol
2) from vendor 430, use the following command:

....
add_drv -n -i '"usbif430,class3.1.2"' more_generic_mouse_driver
....

If you install both of these drivers and then connect a compatible
device, the system binds the correct driver to the connected device. For
example, if you install both of these drivers and then connect a vendor
430, model 100, revision 102 device, this device is bound to
`specific++_++mouse++_++driver`. If you connect a vendor 430, model 98
device, this device is bound to `more++_++generic++_++mouse++_++driver`.
If you connect a mouse from another vendor, this device also is bound to
`more++_++generic++_++mouse++_++driver`. If multiple drivers are
available for a specific device, the driver binding framework selects
the driver with the first matching compatible name in the compatible
names list.

[[devices-with-multiple-interfaces]]
==== Devices With Multiple Interfaces

USB device

_Composite devices_ are devices that support multiple interfaces.
Composite devices have a list of compatible names for each interface.
This compatible names list ensures that the best available driver is
bound to the interface. The most general multiple interface entry is
`usb,device`.

For a USB audio composite device, the compatible names are as follows:

....
1. 'usb471,101.100'     Vendor 471, product 101, revision 100
2. 'usb471,101'         Vendor 471, product 101
3. 'usb,device'         Generic USB device
....

The name `usb,device` is a
compatible name that represents any whole USB device. The
`usb++_++mid(4D)` driver (USB multiple-interface driver) binds to the
`usb,device` device node if no other driver has claimed the whole
device. The `usb++_++mid` driver creates a child device node for each
interface of the physical device. The `usb++_++mid` driver also
generates a set of compatible names for each interface. Each of these
generated compatible names begins with `usbif`. The system then uses
these generated compatible names to find the best driver for each
interface. In this way, different interfaces of one physical device can
be bound to different drivers.

For example, the `usb++_++mid` driver binds to a multiple-interface
audio device through the `usb,device` node name of that audio device.
The `usb++_++mid` driver then creates interface-specific device nodes.
Each of these interface-specific device nodes has its own compatible
name list. For an audio control interface node, the compatible name list
might look like the list shown in the following example.

[[ekyic]]
USB Audio Compatible Device Names

....
1. 'usbif471,101.100.config1.0' Vend 471, prod 101, rev 100, cnfg 1, iface 0
2. 'usbif471,101.config1.0'     Vend 471, product 101, config 1, interface 0
3. 'usbif471,class1.1.0'    Vend 471, class 1, subclass 1, protocol 0
4. 'usbif471,class1.1'      Vend 471, class 1, subclass 1
5. 'usbif471,class1'        Vend 471, class 1
6. 'usbif,class1.1.0'       Class 1, subclass 1, protocol 0
7. 'usbif,class1.1'         Class 1, subclass 1
8. 'usbif,class1'           Class 1
....

Use the following command to bind a vendor-specific, device-specific
client driver named `vendor++_++model++_++audio++_++usb` to the
vendor-specific, device-specific configuration 1, interface 0 interface
compatible name shown in link:#ekyic[example++_++title].

....
add_drv -n -i '"usbif471,101.config1.0"' vendor_model_audio_usb
....

Use the following command to bind a class driver named
`audio++_++class++_++usb++_++if++_++driver` to the more general class 1,
subclass 1 interface compatible name shown in
link:#ekyic[example++_++title]:

....
add_drv -n -i '"usbif,class1.1"' audio_class_usb_if_driver
....

   Use the `prtconf` `D`
command to show a list of devices and their drivers. In the following
example, the `prtconf` `D` command shows that the `usb++_++mid` driver
manages the `audio` device. The `usb++_++mid` driver is splitting the
`audio` device into interfaces. Each interface is indented under the
`audio` device name. For each interface shown in the indented list, the
`prtconf` `D` command shows which driver manages the interface.

....
audio, instance #0 (driver name: usb_mid)
    sound-control, instance #2 (driver name: usb_ac)
    sound, instance #2 (driver name: usb_as)
    input, instance #8 (driver name: hid)
....

[[devices-with-interface-association-descriptors]]
==== Devices With Interface-Association Descriptors

device drivers

usb++_++mid

USB multi-interface driver

USB drivers

usb++_++mid

USB multi-interface driver

usb++_++mid

USB multi-interface driver

device drivers

interface association nodes

interface association nodes

device drivers

usb++_++ia

USB interface association driver

USB drivers

usb++_++ia

USB interface association driver

usb++_++ia

USB interface association driver

If the device includes an interface-association descriptor, the device
tree can be parsed at the following three levels:

* The `usb++_++mid(4D)` USB multi-interface driver binds to device level
nodes of a composite device if no vendor or class-specific driver is
available.
* A client driver is bound to the interface association nodes.
* The `usb++_++ia(4D)` USB interface association driver is bound by
default if no client driver is found. Then client drivers can be bound
to the interface level of this interface association.

The `usb++_++mid` driver creates an `ia` (interface association) node
for each `ia`. The compatible names of `ia` nodes generally begin with
`usbia`. The name `usb,ia` is a compatible name that represents any `ia`
as the tail of the compatible names. The `usb++_++ia` driver is bound to
an `ia` node if no other driver has claimed this `ia`. The `usb++_++ia`
driver creates a child node for each interface. An interface node as the
child node of an `ia` node has the same properties with an interface
node as the child of a device node.

[[usb-51]]
USB Video Interface Association Compatible Names

....
1. 'usbia46d,8c9.5.config1.0' vend 46d, prod 8c9, rev 5, cnfg 1, first_if_in_ia 0
2. 'usbia46d,8c9.config1.0'   vend 46d, prod 8c9, cnfg 1, first_if_in_ia 0
3. 'usbia46d,classe.3.0'      vend 46d, class e, subclass 3, protocol 0
4. 'usbia46d,classe.3'        vend 46d, class e, subclass 3
5. 'usbia46d,classe'          vend 46d, class e
6. 'usbia,classe.3.0'         class e, subclass 3, protocol 0
7. 'usbia,classe.3'           class e, subclass 3
8. 'usbia,classe'             class e
9. 'usb,ia'                   by default
....

Use the following command to bind a vendor-specific, device-specific
client driver named `vendor++_++model++_++video++_++usb` to the
vendor-specific, device-specific configuration 1,
first++_++if++_++in++_++ia 0 compatible name shown in
link:#usb-51[example++_++title]:

....
add_drv -n -i '"usbia46d,8c9.config1.0"' vendor_model_video_usb
....

Use the following command to bind a class driver named
`video++_++class++_++usb++_++ia++_++driver` to the more general class e
compatible names shown in link:#usb-51[example++_++title]:

....
add_drv -n -i '"usbia,classee"' video_class_usb_ia_driver
....

In the following example, the `prtconf` `D` command shows a device tree
of a webcam with `ia` of `video` and `audio`. The `usb++_++mid` driver
manages the device and creates two `ia` respectively for video and
audio. A video driver `usbvc` is bound to the video `ia`, and audio
drivers are bound to the interface of the audio `ia`.

....
miscellaneous, instance #28 (driver name: usb_mid)
    video, instance #24 (driver name: usbvc)
    audio, instance #30 (driver name: usb_ia)
        sound-control, instance #38 (driver name: usb_ac)
        sound, instance #47 (driver name: usb_as)
....

[[checking-device-driver-bindings]]
==== Checking Device Driver Bindings

device drivers

/etc/driver++_++aliases

add++_++drv

update++_++drv

The file `/etc/driver++_++aliases` contains entries for the bindings
that already exist on a system. Each line of the
`/etc/driver++_++aliases` file shows a driver name, followed by a space,
followed by a device name. Use this file to check existing device driver
bindings.

[NOTE]

Do not edit the `/etc/driver++_++aliases` file manually. Use the
`add++_++drv(8)` command to establish a binding. Use the
`update++_++drv(8)` command to change a binding.
===

[[basic-device-access]]
=== Basic Device Access

This section describes how to access a USB device and how to register a
client driver. This section also discusses the descriptor tree.

[[before-the-client-driver-is-attached]]
==== Before the Client Driver Is Attached

USB drivers

default control

use before

The following events take place before the client driver is attached:

[arabic]
. The PROM (OBP/BIOS) and USBA framework gain access to the device
before any client driver is attached.
. The hub driver probes devices on each of its hub's ports for identity
and configuration.
. The default control pipe to each device is opened, and each device is
probed for its device descriptor.
. Compatible names properties are constructed for each device, using the
device and interface descriptors.

The compatible names properties define different parts of the device
that can be individually bound to client drivers. Client drivers can
bind either to the entire device or to just one interface. See
link:#binding-client-drivers[Binding Client Drivers].

[[the-descriptor-tree]]
==== The Descriptor Tree

descriptor tree

USB drivers

descriptor tree

USB device

configuration descriptors

USB functions

usb++_++get++_++dev++_++data

USB functions

usb++_++parse++_++data

Parsing descriptors involves aligning structure members at natural
boundaries and converting the structure members to the endianness of the
host CPU. Parsed standard USB configuration descriptors, interface
descriptors, and endpoint descriptors are available to the client driver
in the form of a hierarchical tree for each configuration. Any raw
class-specific or vendor-specific descriptor information also is
available to the client driver in the same hierarchical tree.

Call the `usb++_++get++_++dev++_++data(9F)` function to retrieve the
hierarchical descriptor tree. The “SEE ALSO” section of the
`usb++_++get++_++dev++_++data(9F)` man page lists the man pages for each
standard USB descriptor. Use the `usb++_++parse++_++data(9F)` function
to parse raw descriptor information.

A descriptor tree for a device with two configurations might look like
the tree shown in the following figure.

.A Hierarchical USB Descriptor Tree
[#euxbn]
image::figures/usb-descr-tree.png[Diagram shows a tree of pairs of descriptors for each interface of a device with two configurations.]

The `dev++_++cfg` array shown in the above figure contains nodes that
correspond to configurations. Each node contains the following
information:

* A parsed configuration descriptor
* A pointer to an array of descriptors that correspond to the interfaces
of that configuration
* A pointer to an array of class-specific or vendor-specific raw data,
if any exists

The node that represents the second interface of the second indexed
configuration is at `dev++_++cfg++[++1++]++.cfg++_++if++[++1++]++` in
the diagram. That node contains an array of nodes that represent the
alternate settings for that interface. The hierarchy of USB descriptors
propagates through the tree. ASCII strings from string descriptor data
are attached where the USB specification says these strings exist.

The array of configurations is non-sparse and is indexed by the
configuration index. The first valid configuration (configuration 1) is
`dev++_++cfg++[++0++]++`. Interfaces and alternate settings have indices
that align with their numbers. Endpoints of each alternate setting are
indexed consecutively. The first endpoint of each alternate setting is
at index 0.

This numbering scheme makes the tree easy to traverse. For example, the
raw descriptor data of endpoint index 0, alternate 0, interface 1,
configuration index 1 is at the node defined by the following path:

....
dev_cfg[1].cfg_if[1].if_alt[0].altif_ep[0].ep_descr
....

An alternative to using the descriptor tree directly is
using the `usb++_++lookup++_++ep++_++data(9F)` function. The
`usb++_++lookup++_++ep++_++data(9F)` function takes as arguments the
interface, alternate, which endpoint, endpoint type, and direction. You
can use the `usb++_++lookup++_++ep++_++data(9F)` function to traverse
the descriptor tree to get a particular endpoint. See the
`usb++_++get++_++dev++_++data(9F)` man page for more information.

[[registering-drivers-to-gain-device-access]]
==== Registering Drivers to Gain Device Access

USB drivers

USB functions

usb++_++client++_++attach

USB functions

usb++_++get++_++dev++_++data

Two of the first calls into the USBA 2.0 framework by a client driver
are calls to the `usb++_++client++_++attach(9F)` function and the
`usb++_++get++_++dev++_++data(9F)` function. These two calls come from
the client driver's `attach(9E)` entry point. You must call the
`usb++_++client++_++attach(9F)` function before you call the
`usb++_++get++_++dev++_++data(9F)` function.

The `usb++_++client++_++attach(9F)` function registers a
client driver with the USBA 2.0 framework. The
`usb++_++client++_++attach(9F)` function enforces versioning. All client
driver source files must start with the following lines:

[source,c]
----
#define USBDRV_MAJOR_VER        2
#define USBDRV_MINOR_VER        minor-version
#include <sys/usb/usba.h>
----

The value of ++<++minor-version++>++ must be less than or equal to
`USBA++_++MINOR++_++VER`. The symbol `USBA++_++MINOR++_++VER` is defined
in the `++<++sys/usb/usbai.h++>++` header file. The
`++<++sys/usb/usbai.h++>++` header file is included by the
`++<++sys/usb/usba.h++>++` header file.

`USBDRV++_++VERSION` is a macro that generates the version number from
`USBDRV++_++MAJOR++_++VERSION` and `USBDRV++_++MINOR++_++VERSION`. The
second argument to `usb++_++client++_++attach` must be
`USBDRV++_++VERSION`. The `usb++_++client++_++attach` function fails if
the second argument is not `USBDRV++_++VERSION` or if
`USBDRV++_++VERSION` reflects an invalid version. This restriction
ensures programming interface compatibility.

`usb++_++get++_++dev++_++data` function returns information that is
required for proper USB device management. For example, the
`usb++_++get++_++dev++_++data` function returns the following
information:

* The default control pipe
* The ++<++iblock++_++cookie++>++ to use in mutex initializations (see
`mutex++_++init(9F)`)
* The parsed device descriptor
* ID strings
* The tree hierarchy as described in link:#the-descriptor-tree[The Descriptor Tree]

The call to the `usb++_++get++_++dev++_++data` function is mandatory.
Calling `usb++_++get++_++dev++_++data` is the only way to retrieve the
default control pipe and retrieve the ++<++iblock++_++cookie++>++
required for mutex initialization.

calling `usb++_++get++_++dev++_++data`, the client driver's `attach(9E)`
routine typically copies the desired descriptors and data from the
descriptor tree to the driver's soft state. Endpoint descriptors copied
to the soft state are used later to open pipes to those endpoints. The
`attach(9E)` routine usually calls `usb++_++free++_++descr++_++tree(9F)`
to free the descriptor tree after copying descriptors. Alternatively,
you might choose to keep the descriptor tree and not copy the
descriptors.

Specify one of the following three parse levels to the
`usb++_++get++_++dev++_++data(9F)` function to request the breadth of
the descriptor tree you want returned. You need greater tree breadth if
your driver needs to bind to more of the device.

* `USB++_++PARSE++_++LVL++_++IF`. If your client driver binds to a
specific interface, the driver needs the descriptors for only that
interface. Specify `USB++_++PARSE++_++LVL++_++IF` for the parse level in
the `usb++_++get++_++dev++_++data` call to retrieve only those
descriptors.
* `USB++_++PARSE++_++LVL++_++CFG`. If your client driver binds to the
whole device, specify `USB++_++PARSE++_++LVL++_++CFG` to retrieve all
descriptors of the current configuration.
*  `USB++_++PARSE++_++LVL++_++ALL`. Specify
`USB++_++PARSE++_++LVL++_++ALL` to retrieve all descriptors of all
configurations. For example, you need this greatest tree breadth to use
`usb++_++print++_++descr++_++tree(9F)` to print a descriptor dump of all
configurations of a device.

  The client driver's `detach(9E)` routine
must call the `usb++_++free++_++dev++_++data(9F)` function to release
all resources allocated by the `usb++_++get++_++dev++_++data` function.
The `usb++_++free++_++dev++_++data` function accepts handles where the
descriptor tree has already been freed with the
`usb++_++free++_++descr++_++tree` function. The client driver's `detach`
routine also must call the `usb++_++client++_++detach(9F)` function to
release all resources allocated by the `usb++_++client++_++attach(9F)`
function.

[[device-communication]]
=== Device Communication

USB device communication

USB drivers

USB devices operate by passing requests through communication channels
called _pipes_. Pipes must be open before you can submit requests. Pipes
also can be flushed, queried, and closed. This section discusses pipes,
data transfers and callbacks, and data requests.

[[usb-endpoints]]
==== USB Endpoints

USB device

USB device

USB device

USB device

The four kinds of pipes that communicate with the four kinds of USB
endpoints are:

* *Control*. Control pipes are used primarily to send commands and
retrieve status. Control pipes are intended for non-periodic,
host-initiated request and response communication of small-sized
structured data. Control pipes are bidirectional. The default pipe is a
control pipe. See link:#the-default-pipe[The Default Pipe].
* *Bulk*. Bulk pipes are used primarily for data transfer. Bulk pipes
offer reliable transportation of large amounts of data. Bulk pipes do
not necessarily deliver the data in a timely manner. Bulk pipes are
unidirectional.
* *Interrupt*. Interrupt pipes offer timely, reliable communication of
small amounts of unstructured data. Periodic polling often is started on
interrupt-IN pipes. Interrupt-IN pipes return data to the host when the
data becomes present on the device. Some devices have interrupt-OUT
pipes. Interrupt-OUT pipes transfer data to the device with the same
timely, reliable “interrupt pipe” characteristics of interrupt-IN pipes.
Interrupt pipes are unidirectional.
* *Isochronous*. Isochronous pipes offer a channel for transferring
constant-rate, time-relevant data, such as for audio devices. Data is
not retried on error. Isochronous pipes are unidirectional.

See Chapter 5 of the USB 2.0 specification or see link:#requests[Requests]
for more information on the transfer types that correspond to these
endpoints.

[[the-default-pipe]]
==== The Default Pipe

USB device

USB functions

usb++_++get++_++dev++_++data

USB drivers

default control

default control

Each USB device has a special control endpoint called the _default_
endpoint. Its communication channel is called the default pipe. Most, if
not all, device setup is done through this pipe. Many USB devices have
this pipe as their only control pipe.

The `usb++_++get++_++dev++_++data(9F)` function provides the default
control pipe to the client driver. This pipe is pre-opened to
accommodate any special setup needed before opening other pipes. This
default control pipe is special in the following ways:

* This pipe is shared. Drivers that are operating other interfaces of
the same device use the same default control pipe. The USBA 2.0
framework arbitrates this pipe among the different drivers.
* This pipe cannot be opened, closed, or reset by the client driver.
This restriction exists because the pipe is shared.
* The pipe is autocleared on an exception.

Other pipes, including other control pipes, must be opened explicitly
and are exclusive-open only.

[[pipe-states]]
==== Pipe States

Pipes are in one of the following states:

* `USB++_++PIPE++_++STATE++_++IDLE`
** All control and bulk pipes, interrupt-OUT pipes, and isochronous-OUT
pipes: No request is in progress.
** Interrupt-IN and isochronous-IN pipes: No polling is in progress.
* `USB++_++PIPE++_++STATE++_++ACTIVE`
** All control and bulk pipes, interrupt-OUT pipes, and isochronous-OUT
pipes: The pipe is transferring data or an I/O request is active.
** Interrupt-IN and isochronous-IN pipes: Polling is active.
*  `USB++_++PIPE++_++STATE++_++ERROR`. An error occurred.
If this pipe is not the default pipe and if autoclearing is not enabled,
then the client driver must call the `usb++_++pipe++_++reset(9F)`
function.
* `USB++_++PIPE++_++STATE++_++CLOSING`. The pipe is being closed.
* `USB++_++PIPE++_++STATE++_++CLOSED`. The pipe is closed.

Call the `usb++_++pipe++_++get++_++state(9F)` function to
retrieve the state of a pipe.

[[opening-pipes]]
==== Opening Pipes

USB drivers

USB functions

usb++_++lookup++_++ep++_++data

USB functions

usb++_++pipe++_++open

To open a pipe, pass to the `usb++_++pipe++_++open(9F)` function the
endpoint descriptor that corresponds to the pipe you want to open. Use
the `usb++_++get++_++dev++_++data(9F)` and
`usb++_++lookup++_++ep++_++data(9F)` functions to retrieve the endpoint
descriptor from the descriptor tree. The `usb++_++pipe++_++open(9F)`
function returns a handle to the pipe.

You must specify a pipe policy when you open a pipe. The pipe policy
contains an estimate of the number of concurrent asynchronous operations
that require separate threads that will be needed for this pipe. An
estimate of the number of threads is the number of parallel operations
that could occur during a callback. The value of this estimate must be
at least 2. See the `usb++_++pipe++_++open(9F)` man page for more
information on pipe policy.

[[closing-pipes]]
==== Closing Pipes

USB drivers

USB functions

usb++_++pipe++_++close

The driver must use the `usb++_++pipe++_++close(9F)` function to close
pipes other than the default pipe. The `usb++_++pipe++_++close(9F)`
function enables all remaining requests in the pipe to complete. The
function then allows one second for all callbacks of those requests to
complete.

[[data-transfer]]
==== Data Transfer

USB functions

usb++_++pipe++_++bulk++_++xfer

USB functions

usb++_++pipe++_++ctrl++_++xfer

USB functions

usb++_++pipe++_++intr++_++xfer

USB functions

usb++_++pipe++_++isoc++_++xfer

For all pipe types, the programming model is as follows:

[arabic]
. Allocate a request.
. Submit the request using one of the pipe transfer functions. See the
`usb++_++pipe++_++bulk++_++xfer(9F)`,
`usb++_++pipe++_++ctrl++_++xfer(9F)`,
`usb++_++pipe++_++intr++_++xfer(9F)`, and
`usb++_++pipe++_++isoc++_++xfer(9F)` man pages.
. Wait for completion notification.
. Free the request.

See link:#requests[Requests] for more information on requests. The
following sections describe the features of different request types.

[[synchronous-and-asynchronous-transfers-and-callbacks]]
===== Synchronous and Asynchronous Transfers and Callbacks

synchronous data transfers

asynchronous data transfers

Transfers are either synchronous or asynchronous. Synchronous transfers
block until they complete. Asynchronous transfers callback into the
client driver when they complete. Most transfer functions called with
the `USB++_++FLAGS++_++SLEEP` flag set in the ++<++flags++>++ argument
are synchronous.

Continuous transfers such as polling and isochronous transfers cannot be
synchronous. Calls to transfer functions for continuous transfers made
with the `USB++_++FLAGS++_++SLEEP` flag set block only to wait for
resources before the transfer begins.

Synchronous transfers are the most simple transfers to set up because
synchronous transfers do not require any callback functions. Synchronous
transfer functions return a transfer start status, even though
synchronous transfer functions block until the transfer is completed.
Upon completion, you can find additional information about the transfer
status in the completion reason field and callback flags field of the
request. Completion reasons and callback flags fields are discussed
below.

If the `USB++_++FLAGS++_++SLEEP` flag is not specified in the
++<++flags++>++ argument, that transfer operation is asynchronous. The
exception to this rule are isochronous transfers. Asynchronous transfer
operations set up and start the transfer, and then return before the
transfer is complete. Asynchronous transfer operations return a transfer
start status. The client driver receives transfer completion status
through callback handlers.

Callback handlers are functions that are called when
asynchronous transfers complete. Do not set up an asynchronous transfer
without callbacks. The two types of callback handlers are normal
completion handlers and exception handlers. You can specify one handler
to be called in both of these cases.

* *Normal completion*. A normal completion callback handler is called to
notify of a normally completed transfer.
* *Exception*. An exception callback handler is called to notify of an
abnormally completed transfer and to process its errors.

completion handlers and exception handlers receive the transfer's
request as an argument. Exception handlers use the completion reason and
callback status in the request to find out what happened. The completion
reason (`usb++_++cr++_++t`) indicates how the original transaction
completed. For example, a completion reason of `USB++_++CR++_++TIMEOUT`
indicates that the transfer timed out. As another example, if a USB
device is removed while in use, client drivers might receive
`USB++_++CR++_++DEV++_++NOT++_++RESP` as the completion reason on their
outstanding requests. The callback status (`usb++_++cb++_++flags++_++t`)
indicates what the USBA framework did to remedy the situation. For
example, a callback status of `USB++_++CB++_++STALL++_++CLEARED`
indicates that the USBA framework cleared a functional stall condition.
See the `usb++_++completion++_++reason(9S)` man page for more
information on completion reasons. See the
`usb++_++callback++_++flags(9S)` man page for more information on
callback status flags.

The context of the callback and the policy of the pipe
on which the requests are run limit what you can do in the callback.

* *Callback context*. Most callbacks execute in kernel context and
usually can block. Some callbacks execute in interrupt context and
cannot block. The `USB++_++CB++_++INTR++_++CONTEXT` flag is set in the
callback flags to denote interrupt context. See the
`usb++_++callback++_++flags(9S)` man page for more information on
callback context and details on blocking.
* *Pipe policy*. The pipe policy's hint on concurrent
asynchronous operations limits the number of operations that can be run
in parallel, including those executed from a callback handler. Blocking
on a synchronous operation counts as one operation. See the
`usb++_++pipe++_++open(9F)` man page for more information on pipe
policy.

[[requests]]
===== Requests

USB drivers

data transfer requests

This section discusses request structures and allocating and
deallocating different types of requests.

[[usb-25]]
====== Request Allocation and Deallocation

Requests are implemented as initialized request structures. Each
different endpoint type takes a different type of request. Each type of
request has a different request structure type. The following table
shows the structure type for each type of request. This table also lists
the functions to use to allocate and free each type of structure.

.Request Initialization
[width="100%",cols="16%,26%,30%,28%",options="header",]
|===
|Pipe or Endpoint Type |Request Structure |Request Structure Allocation
Function |Request Structure Free Function
|Control |`usb++_++ctrl++_++req++_++t` (see the
`usb++_++ctrl++_++request(9S)` man page)
|`usb++_++alloc++_++ctrl++_++req(9F)`
|`usb++_++free++_++ctrl++_++req(9F)`

|Bulk |`usb++_++bulk++_++req++_++t` (see the
`usb++_++bulk++_++request(9S)` man page)
|`usb++_++alloc++_++bulk++_++req(9F)`
|`usb++_++free++_++bulk++_++req(9F)`

|Interrupt |`usb++_++intr++_++req++_++t` (see the
`usb++_++intr++_++request(9S)` man page)
|`usb++_++alloc++_++intr++_++req(9F)`
|`usb++_++free++_++intr++_++req(9F)`

|Isochronous |`usb++_++isoc++_++req++_++t` (see the
`usb++_++isoc++_++request(9S)` man page)
|`usb++_++alloc++_++isoc++_++req(9F)`
|`usb++_++free++_++isoc++_++req(9F)`
|===

The following table lists the transfer functions that you can use for
each type of request.

.Request Transfer Setup
[width="100%",cols="26%,74%",options="header",]
|===
|Pipe or Endpoint Type |Transfer Functions
|Control |`usb++_++pipe++_++ctrl++_++xfer(9F)`,
`usb++_++pipe++_++ctrl++_++xfer++_++wait(9F)`

|Bulk |`usb++_++pipe++_++bulk++_++xfer(9F)`

|Interrupt |`usb++_++pipe++_++intr++_++xfer(9F)`,
`usb++_++pipe++_++stop++_++intr++_++polling(9F)`

|Isochronous |`usb++_++pipe++_++isoc++_++xfer(9F)`,
`usb++_++pipe++_++stop++_++isoc++_++polling(9F)`
|===

Use the following procedure to allocate and deallocate a request:

[arabic]
. Use the appropriate allocation function to allocate a request
structure for the type of request you need. The man pages for the
request structure allocation functions are listed in
link:#usb-tbl-33[Request Initialization].
. Initialize any fields you need in the structure. See
link:#usb-26[Request Features and Fields] or the appropriate request
structure man page for more information. The man pages for the request
structures are listed in link:#usb-tbl-33[Request Initialization].
. When the data transfer is complete, use the appropriate free function
to free the request structure. The man pages for the request structure
free functions are listed in link:#usb-tbl-33[Request Initialization].

[[usb-26]]
====== Request Features and Fields

USB drivers

message blocks

Data for all requests is passed in message blocks so that the data is
handled uniformly whether the driver is a STREAMS, character, or block
driver. The message block type, `mblk++_++t`, is described in the
`mblk(9S)` man page. The DDI offers several routines for manipulating
message blocks. Examples include `allocb(9F)` and `freemsg(9F)`. To
learn about other routines for manipulating message blocks, see the “SEE
ALSO” sections of the `allocb(9F)` and `freemsg(9F)` man pages. Also see
the STREAMS Programming Guide.

The following request fields are included in all transfer types. In each
field name, the possible values for ++<++xxxx++>++ are: ++<++ctrl++>++,
++<++bulk++>++, ++<++intr++>++, or ++<++isoc++>++.

++<++xxxx++_++client++_++private++>++::
  This field value is a pointer that is intended for internal data to be
  passed around the client driver along with the request. This pointer
  is not used to transfer data to the device.
++<++xxxx++_++attributes++>++::
  This field value is a set of transfer attributes.
  While this field is common to all request structures, the
  initialization of this field is somewhat different for each transfer
  type. See the appropriate request structure man page for more
  information. These man pages are listed in link:#usb-tbl-33[Request
  Initialization]. See also the `usb++_++request++_++attributes(9S)` man
  page.
++<++xxxx++_++cb++>++::
  This field value is a callback function for normal transfer
  completion. This function is called when an asynchronous transfer
  completes without error.
++<++xxxx++_++exc++_++cb++>++::
  This field value is a callback function for error handling. This
  function is called only when asynchronous transfers complete with
  errors.
++<++xxxx++_++completion++_++reason++>++::
  This field holds the completion status
  of the transfer itself. If an error occurred, this field shows what
  went wrong. See the `usb++_++completion++_++reason(9S)` man page for
  more information. This field is updated by the USBA 2.0 framework.
++<++xxxx++_++cb++_++flags++>++::
  This field lists the recovery actions
  that were taken by the USBA 2.0 framework before calling the callback
  handler. The `USB++_++CB++_++INTR++_++CONTEXT` flag indicates whether
  a callback is running in interrupt context. See the
  `usb++_++callback++_++flags(9S)` man page for more information. This
  field is updated by the USBA 2.0 framework.

The following sections describe the request fields that are different
for the four different transfer types. These sections describe how to
initialize these structure fields. These sections also describe the
restrictions on various combinations of attributes and parameters.

[[eqxri]]
====== Control Requests

USB drivers

control data transfer requests

USB drivers

synchronous control requests

USB functions

usb++_++pipe++_++ctrl++_++xfer++_++wait

USB structures

usb++_++ctrl++_++request

Use control requests to initiate message transfers down a control pipe.
You can set up transfers manually, as described below. You can also set
up and send synchronous transfers using the
`usb++_++pipe++_++ctrl++_++xfer++_++wait(9F)` wrapper function.

The client driver must initialize the ++<++ctrl++_++bmRequestType++>++,
++<++ctrl++_++bRequest++>++, ++<++ctrl++_++wValue++>++,
++<++ctrl++_++wIndex++>++, and ++<++ctrl++_++wLength++>++ fields as
described in the USB 2.0 specification.

The ++<++ctrl++_++data++>++ field of the request must be initialized to
point to a data buffer. The `usb++_++alloc++_++ctrl++_++req(9F)`
function initializes this field when you pass a positive value as the
buffer ++<++len++>++. The buffer must, of course, be initialized for any
outbound transfers. In all cases, the client driver must free the
request when the transfer is complete.

Multiple control requests can be queued. Queued requests can be a
combination of synchronous and asynchronous requests.

The ++<++ctrl++_++timeout++>++ field defines the maximum wait time for
the request to be processed, excluding wait time on the queue. This
field applies to both synchronous and asynchronous requests. The
++<++ctrl++_++timeout++>++ field is specified in seconds.

The ++<++ctrl++_++exc++_++cb++>++ field accepts the address of a
function to call if an exception occurs. The arguments of this exception
handler are specified in the `usb++_++ctrl++_++request(9S)` man page.
The second argument of the exception handler is the
`usb++_++ctrl++_++req++_++t` structure. Passing the request structure as
an argument allows the exception handler to check the
++<++ctrl++_++completion++_++reason++>++ and
++<++ctrl++_++cb++_++flags++>++ fields of the request to determine the
best recovery action.

The `USB++_++ATTRS++_++ONE++_++XFER` and `USB++_++ATTRS++_++ISOC++_*++`
flags are invalid attributes for all control requests. The
`USB++_++ATTRS++_++SHORT++_++XFER++_++OK` flag is valid only for
host-bound requests.

[[eqxrp]]
====== Bulk Requests

USB drivers

bulk data transfer requests

USB structures

usb++_++bulk++_++request

USB functions

usb++_++pipe++_++get++_++max++_++bulk++_++transfer++_++ size

bulk requests

Use bulk requests to send data that is not time-critical. Bulk requests
can take several USB frames to complete, depending on overall bus load.

All requests must receive an initialized message block. See the
`mblk(9S)` man page for a description of the `mblk++_++t` message block
type. This message block either supplies the data or stores the data,
depending on the transfer direction. Refer to the
`usb++_++bulk++_++request(9S)` man page for more details.

The `USB++_++ATTRS++_++ONE++_++XFER` and `USB++_++ATTRS++_++ISOC++_*++`
flags are invalid attributes for all bulk requests. The
`USB++_++ATTRS++_++SHORT++_++XFER++_++OK` flag is valid only for
host-bound requests.

The `usb++_++pipe++_++get++_++max++_++bulk++_++transfer++_++size(9F)`
function specifies the maximum number of bytes per request. The value
retrieved can be the maximum value used in the client driver's
`minphys(9F)` routine.

Multiple bulk requests can be queued.

[[eqxrk]]
====== Interrupt Requests

USB drivers

interrupt data transfer requests

USB functions

usb++_++pipe++_++intr++_++xfer

USB structures

usb++_++alloc++_++intr++_++request

USB functions

usb++_++pipe++_++stop++_++intr++_++polling

Interrupt requests typically are for periodic inbound data. Interrupt
requests periodically poll the device for data. However, the USBA 2.0
framework supports one-time inbound interrupt data requests, as well as
outbound interrupt data requests. All interrupt requests can take
advantage of the USB interrupt transfer features of timeliness and
retry.

The `USB++_++ATTRS++_++ISOC++_*++` flags are invalid attributes for all
interrupt requests. The `USB++_++ATTRS++_++SHORT++_++XFER++_++OK` and
`USB++_++ATTRS++_++ONE++_++XFER` flags are valid only for host-bound
requests.

Only one-time polls can be done as synchronous interrupt transfers.
Specifying the `USB++_++ATTRS++_++ONE++_++XFER` attribute in the request
results in a one-time poll.

Periodic polling is started as an asynchronous interrupt transfer. An
original interrupt request is passed to
`usb++_++pipe++_++intr++_++xfer(9F)`. When polling finds new data to
return, a new `usb++_++intr++_++req++_++t` structure is cloned from the
original and is populated with an initialized data block. When
allocating the request, specify zero for the ++<++len++>++ argument to
the `usb++_++alloc++_++intr++_++req(9F)` function. The ++<++len++>++
argument is zero because the USBA 2.0 framework allocates and fills in a
new request with each callback. After you allocate the request
structure, fill in the ++<++intr++_++len++>++ field to specify the
number of bytes you want the framework to allocate with each poll. Data
beyond ++<++intr++_++len++>++ bytes is not returned.

The client driver must free each request it receives. If the message
block is sent upstream, decouple the message block from the request
before you send the message block upstream. To decouple the message
block from the request, set the data pointer of the request to `NULL`.
Setting the data pointer of the request to `NULL` prevents the message
block from being freed when the request is deallocated.

Call the `usb++_++pipe++_++stop++_++intr++_++polling(9F)` function to
cancel periodic polling. When polling is stopped or the pipe is closed,
the original request structure is returned through an exception
callback. This returned request structure has its completion reason set
to `USB++_++CR++_++STOPPED++_++POLLING`.

Do not start polling while polling is already in progress. Do not start
polling while a call to `usb++_++pipe++_++stop++_++intr++_++polling(9F)`
is in progress.

[[eqxrl]]
====== Isochronous Requests

USB drivers

isochronous data transfer requests

Isochronous requests are for streaming, constant-rate, time-relevant
data. Retries are not made on errors. Isochronous requests have the
following request-specific fields:

++<++isoc++_++frame++_++no++>++::
  Specify this field when the overall transfer must
  start from a specific frame number. The value of this field must be
  greater than the current frame number. Use
  `usb++_++get++_++current++_++frame++_++number(9F)` to find the current
  frame number. Note that the current frame number is a moving target.
  For low-speed and full-speed buses, the current frame is new each
  millisecond. For high-speed buses, the current frame is new each 0.125
  millisecond. Set the `USB++_++ATTR++_++ISOC++_++START++_++FRAME`
  attribute so that the ++<++isoc++_++frame++_++no++>++ field is
  recognized.
  +
  To ignore this frame number field and start as soon as possible, set
  the `USB++_++ATTR++_++ISOC++_++XFER++_++ASAP` flag.
++<++isoc++_++pkts++_++count++>++::
  This field is the number of packets in the request.
  This value is bounded by the value returned by the
  `usb++_++get++_++max++_++pkts++_++per++_++isoc++_++request(9F)`
  function and by the size of the ++<++isoc++_++pkt++_++descr++>++ array
  (see below). The number of bytes transferable with this request is
  equal to the product of this ++<++isoc++_++pkts++_++count++>++ value
  and the ++<++wMaxPacketSize++>++ value of the endpoint.
++<++isoc++_++pkts++_++length++>++::
  This field is the sum of the lengths of all packets of the request.
  This value is set by the initiator. This value should be set to zero
  so that the sum of ++<++isoc++_++pkts++_++length++>++ in the
  ++<++isoc++_++pkt++_++descr++>++ list will be used automatically and
  no check will be applied to this element.
++<++isoc++_++error++_++count++>++::
  This field is the number of packets that completed with errors. This
  value is set by the USBA 2.0 framework.
++<++isoc++_++pkt++_++descr++>++::
  This field points to an array of packet descriptors
  that define how much data to transfer per packet. For an outgoing
  request, this value defines a private queue of sub-requests to
  process. For an incoming request, this value describes how the data
  arrived in pieces. The client driver allocates these descriptors for
  outgoing requests. The framework allocates and initializes these
  descriptors for incoming requests. Descriptors in this array contain
  framework-initialized fields that hold the number of bytes actually
  transferred and the status of the transfer. See the
  `usb++_++isoc++_++request(9S)` man page for more details.

All requests must receive an initialized message block.
This message block either supplies the data or stores the data. See the
`mblk(9S)` man page for a description of the `mblk++_++t` message block
type.

The `USB++_++ATTR++_++ONE++_++XFER` flag is an illegal attribute because
the system decides how to vary the amounts of data through available
packets. The `USB++_++ATTR++_++SHORT++_++XFER++_++OK` flag is valid only
on host-bound data.

The `usb++_++pipe++_++isoc++_++xfer(9F)` function makes
all isochronous transfers asynchronous, regardless of whether the
`USB++_++FLAGS++_++SLEEP` flag is set. All isochronous input requests
start polling.

Call the `usb++_++pipe++_++stop++_++isoc++_++polling(9F)` function to
cancel periodic polling. When polling is stopped or the pipe is closed,
the original request structure is returned through an exception
callback. This returned request structure has its completion reason set
to `USB++_++CR++_++STOPPED++_++POLLING`.

Polling continues until one of the following events occurs:

* A `usb++_++pipe++_++stop++_++isoc++_++polling(9F)` call is received.
* A device disconnect is reported through an exception callback.
* A `usb++_++pipe++_++close(9F)` call is received.

[[flushing-pipes]]
==== Flushing Pipes

USB drivers

USB functions

usb++_++pipe++_++reset

USB functions

usb++_++pipe++_++get++_++state

USB functions

usb++_++pipe++_++drain++_++reqs

You might need to clean up a pipe after errors, or you might want to
wait for a pipe to clear. Use one of the following methods to flush or
clear pipes:

* The `usb++_++pipe++_++reset(9F)` function resets the pipe and flushes
all of its requests. Do this for pipes that are in an error state if
autoclearing is not enabled on those pipes. Use
`usb++_++pipe++_++get++_++state(9F)` to determine the state of a pipe.
* The `usb++_++pipe++_++drain++_++reqs(9F)` function blocks waiting for
all pending requests to complete before continuing. This function can
wait indefinitely, or it can time-out after a specified period of time.
The `usb++_++pipe++_++drain++_++reqs(9F)` function neither closes nor
flushes the pipe.

[[device-state-management]]
=== Device State Management

USB device

Managing a USB device includes accounting for hotplugging, system power
management (checkpoint and resume), and device power management. All
client drivers should implement the basic state machine shown in the
following figure. For more information, see
`/usr/include/sys/usb/usbai.h`.

.USB Device State Machine
[#euxbq]
image::figures/usb-hotplug-state.png[Diagram shows what state the device goes to after each of seven different events.]

This state machine and its four states can be augmented with
driver-specific states. Device states `0x80` to `0xff` can be defined
and used only by client drivers.

[[hotplugging-usb-devices]]
==== Hotplugging USB Devices

USB device

USB device

USB devices support hotplugging. A USB device can be inserted or removed
at any time. The client driver must handle removal and reinsertion of an
open device. Use hotplug callbacks to handle open devices. Insertion and
removal of closed devices is handled by the `attach(9E)` and
`detach(9E)` entry points.

[[hotplug-callbacks]]
===== Hotplug Callbacks

USB device

The USBA 2.0
framework supports the following event notifications:

* The client driver receives a callback when the device is hot removed.
* The client driver receives a callback when the device is returned
after hot removal. This event callback can occur when the user returns
the device to its original port if the driver instance of the device is
not offlined. If the driver instance is held open, then the driver
instance cannot be offlined.

Client drivers must call
`usb++_++register++_++hotplug++_++cbs(9F)` in their `attach(9E)` routine
to register for event callbacks. Drivers must call
`usb++_++unregister++_++hotplug++_++cbs(9F)` in their `detach(9E)`
routine before dismantling.

[[hot-insertion]]
===== Hot Insertion

USB device

device drivers

USB hub driver

USB drivers

USB hub driver

USB hub driver

The sequence of events for hot insertion of a USB device is as follows:

[arabic]
. The hub driver, `hubd(4D)`, waits for a port connect status change.
. The `hubd` driver detects a port connect.
. The `hubd` driver enumerates the device, creates child device nodes,
and attaches client drivers. Refer to link:#binding-client-drivers[Binding Client
Drivers] for compatible names definitions.
. The client driver manages the device. The driver is in the `ONLINE`
state.

[[hot-removal]]
===== Hot Removal

USB device

device drivers

usb++_++mid

USB multi-interface driver

USB drivers

usb++_++mid

USB multi-interface driver

usb++_++mid

USB multi-interface driver

device drivers

hot removal

hot removal

The sequence of events for hot removal of a USB device is as follows:

[arabic]
. The hub driver, `hubd(4D)`, waits for a port connect status change.
. The `hubd` driver detects a port disconnect.
. The `hubd` driver sends a disconnect event to the child client driver.
If the child client driver is the `hubd` driver or the `usb++_++mid(4D)`
multi-interface driver, then the child client driver propagates the
event to its children.
. The client driver receives the disconnect event notification in kernel
thread context. Kernel thread context enables the driver's disconnect
handler to block.
. The client driver moves to the `DISCONNECTED` state. Outstanding I/O
transfers fail with the completion reason of `device not responding`.
All new I/O transfers and attempts to open the device node also fail.
The client driver is not required to close pipes. The driver is required
to save the device and driver context that needs to be restored if the
device is reconnected.
. The `hubd` driver attempts to offline the OS device node and its
children in bottom-up order.

The following events take place if the device node is not open when the
`hubd` driver attempts to offline the device node:

[arabic]
. The client driver's `detach(9E)` entry point is called.
. The device node is destroyed.
. The port becomes available for a new device.
. The hotplug sequence of events starts over. The `hubd` driver waits
for a port connect status change.

The following events take place if the device node is open when the
`hubd` driver attempts to offline the device node:

[arabic]
. The `hubd` driver puts the offline request in the periodic offline
retry queue.
. The port remains unavailable for a new device.

If the device node was open when the `hubd` driver attempted to offline
the device node and the user later closes the device node, the `hubd`
driver periodic offlining of that device node succeeds and the following
events take place:

[arabic]
. The client driver's `detach(9E)` entry point is called.
. The device node is destroyed.
. The port becomes available for a new device.
. The hotplug sequence of events starts over. The `hubd` driver waits
for a port connect status change.

If the user closes all applications that use the device, the port
becomes available again. If the application does not terminate or does
not close the device, the port remains unavailable.

[[hot-reinsertion]]
===== Hot Reinsertion

USB device

device drivers

configuration descriptor clouds

configuration descriptor clouds

The following events take place if a previously-removed device is
reinserted into the same port while the device node of the device is
still open:

[arabic]
. The hub driver, `hubd(4D)`, detects a port connect.
. The `hubd` driver restores the bus address and the device
configuration.
. The `hubd` driver cancels the offline retry request.
. The `hubd` driver sends a connect event to the client driver.
. The client driver receives the connect event.
. The client driver determines whether the new device is the same as the
device that was previously connected. The client driver makes this
determination first by comparing device descriptors. The client driver
might also compare serial numbers and configuration descriptor clouds.

The following events might take place if the client driver determines
that the current device is not the same as the device that was
previously connected:

[arabic]
. The client driver might issue a warning message to the console.
. The user might remove the device again. If the user removes the device
again, the hot remove sequence of events starts over. The `hubd` driver
detects a port disconnect. If the user does not remove the device again,
the following events take place:
[arabic]
.. The client driver remains in the `DISCONNECTED` state, failing all
requests and opens.
.. The port remains unavailable. The user must close and disconnect the
device to free the port.
.. The hotplug sequence of events starts over when the port is freed.
The `hubd` driver waits for a port connect status change.

The following events might take place if the client driver determines
that the current device is the same as the device that was previously
connected:

[arabic]
. The client driver might restore its state and continue normal
operation. This policy is up to the client driver. Audio speakers are a
good example where the client driver should continue.
. If it is safe to continue using the reconnected device, the hotplug
sequence of events starts over. The `hubd` driver waits for a port
connect status change. The device is in service once again.

[[power-management]]
[[power-management-1]]
==== Power Management

USB device

power management

power management

USB devices

This section discusses device power management and system power
management.

Device power management manages individual USB devices depending on
their I/O activity or idleness.

System power management uses checkpoint and resume to checkpoint the
state of the system into a file and shut down the system completely.
(Checkpoint is sometimes called “system suspend.”) The system is resumed
to its pre-suspend state when the system is powered up again.

[[device-power-management]]
[[device-power-management-1]]
===== Device Power Management

USB device

power management

device power management

USB devices

USB functions

usb++_++create++_++pm++_++components

device power management

usb++_++create++_++pm++_++components

device power management

device power management

pm++_++busy++_++component

device power management

pm++_++idle++_++component

device power management

pm++_++raise++_++power

pm++_++busy++_++component

pm++_++idle++_++component

pm++_++raise++_++power

The following summary lists what your driver needs to do to power manage
a USB device. A more detailed description of power management follows
this summary.

[arabic]
. Create power management components during `attach(9E)`. See the
`usb++_++create++_++pm++_++components(9F)` man page.
. Implement the `power(9E)` entry point.
. Call `pm++_++busy++_++component(9F)` and `pm++_++raise++_++power(9F)`
before accessing the device.
. Call `pm++_++idle++_++component(9F)` when finished accessing the
device.

The USBA 2.0 framework supports four power levels as specified by the
USB interface power management specification. See
`/usr/include/sys/usb/usbai.h` for information on mapping USB power
levels to operating system power levels.

The `hubd` driver suspends the port when the device goes to the
`USB++_++DEV++_++OS++_++PWR++_++OFF` state. The `hubd` driver resumes
the port when the device goes to the `USB++_++DEV++_++OS++_++PWR++_++1`
state and above. Note that port suspend is different from system
suspend. In port suspend, only the USB port is shut off. System suspend
is defined in link:#system-power-management[System Power Management].

The client driver might choose to enable
remote wakeup on the device. See the
`usb++_++handle++_++remote++_++wakeup(9F)` man page. When the `hubd`
driver sees a remote wakeup on a port, the `hubd` driver completes the
wakeup operation and calls `pm++_++raise++_++power(9F)` to notify the
child.

The following figure shows the relationship between the different pieces
of power management.

.USB Power Management
[#euxbo]
image::figures/usb-pwr-mgmt.png[Diagram shows when to employ two different power management schemes.]

The driver can implement one of the two power management schemes
described at the bottom of link:#euxbo[USB Power Management]. The
passive scheme is simpler than the active scheme because the passive
scheme does not do power management during device transfers.

[[ewavf]]
====== Active Power Management

USB device

power management

section describes the functions you need to use to implement the active
power management scheme.

Do the following work in the `attach(9E)` entry point for your driver:

[arabic]
. Call `usb++_++create++_++pm++_++components(9F)`.
. Optionally call `usb++_++handle++_++remote++_++wakeup(9F)` with
`USB++_++REMOTE++_++WAKEUP++_++ENABLE` as the second argument to enable
a remote wakeup on the device.
. Call `pm++_++busy++_++component(9F)`.
. Call `pm++_++raise++_++power(9F)` to take power to the
`USB++_++DEV++_++OS++_++FULL++_++PWR` level.
. Communicate with the device to initialize the device.
. Call `pm++_++idle++_++component(9F)`.

Do the following work in the `detach(9E)` entry point for your driver:

[arabic]
. Call `pm++_++busy++_++component(9F)`.
. Call `pm++_++raise++_++power(9F)` to take power to the
`USB++_++DEV++_++OS++_++FULL++_++PWR` level.
. If you called the `usb++_++handle++_++remote++_++wakeup(9F)` function
in your `attach(9E)` entry point, call
`usb++_++handle++_++remote++_++wakeup(9F)` here with
`USB++_++REMOTE++_++WAKEUP++_++DISABLE` as the second argument.
. Communicate with the device to cleanly shut down the device.
. Call `pm++_++lower++_++power(9F)` to take power to the
`USB++_++DEV++_++OS++_++PWR++_++OFF` level.
+
This is the only time a client driver calls
`pm++_++lower++_++power(9F)`.
. Call `pm++_++idle++_++component(9F)`.

When a driver thread wants to start I/O to the device, that thread does
the following tasks:

[arabic]
. Call `pm++_++busy++_++component(9F)`.
. Call `pm++_++raise++_++power(9F)` to take power to the
`USB++_++DEV++_++OS++_++FULL++_++PWR` level.
. Begin the I/O transfer.

The driver calls `pm++_++idle++_++component(9F)` when the driver
receives notice that an I/O transfer has completed.

In the `power(9E)` entry
point for your driver, check whether the power level to which you are
transitioning is valid. You might also need to account for different
threads calling into `power(9E)` at the same time.

The `power(9E)` routine might be called to take the device to the
`USB++_++DEV++_++OS++_++PWR++_++OFF` state if the device has been idle
for some time or the system is shutting down. This state corresponds to
the `PWRED++_++DWN` state shown in link:#euxbq[USB Device State
Machine]. If the device is going to the
`USB++_++DEV++_++OS++_++PWR++_++OFF` state, do the following work in
your `power(9E)` routine:

[arabic]
. Put all open pipes into the idle state. For example, stop polling on
the interrupt pipe.
. Save any device or driver context that needs to be saved.
+
The port to which the device is connected is suspended after the call to
`power(9E)` completes.

The `power(9E)` routine might be called to power on the device when
either a device-initiated remote wakeup or a system-initiated wakeup is
received. Wakeup notices occur after the device has been powered down
due to extended idle time or system suspend. If the device is going to
the `USB++_++DEV++_++OS++_++PWR++_++1` state or above, do the following
work in your `power(9E)` routine:

[arabic]
. Restore any needed device and driver context.
. Restart activity on the pipe that is appropriate to the specified
power level. For example, start polling on the interrupt pipe.

If the port to which the device is connected was previously suspended,
that port is resumed before `power(9E)` is called.

[[ewavb]]
====== Passive Power Management

USB device

power management

The passive power management scheme is simpler than the active power
management scheme described above. In this passive scheme, no power
management is done during transfers. To implement this passive scheme,
call `pm++_++busy++_++component(9F)` and `pm++_++raise++_++power(9F)`
when you open the device. Then call `pm++_++idle++_++component(9F)` when
you close the device.

[[system-power-management]]
[[system-power-management-1]]
===== System Power Management

USB device

power management

system power management

USB devices

CPR (CheckPoint and Resume)

system power management

system power management

system power management

system power management

System power management consists of turning off the entire system after
saving its state, and restoring the state after the system is turned
back on. This process is called _CPR_ (checkpoint and resume). USB
client drivers operate the same way that other client drivers operate
with respect to CPR. To suspend a device, the driver's `detach(9E)`
entry point is called with a ++<++cmd++>++ argument of
`DDI++_++SUSPEND`. To resume a device, the driver's `attach(9E)` entry
point is called with a ++<++cmd++>++ argument of `DDI++_++RESUME`. When
you handle the `DDI++_++SUSPEND` command in your `detach(9E)` routine,
clean up device state and clean up driver state as much as necessary for
a clean resume later. (Note that this corresponds to the `SUSPENDED`
state in link:#euxbq[USB Device State Machine].) When you handle the
`DDI++_++RESUME` command in your `attach(9E)` routine, always take the
device to full power to put the system in sync with the device.

For USB devices, suspend and resume are handled similarly to a hotplug
disconnect and reconnect (see link:#hotplugging-usb-devices[Hotplugging USB Devices]). An
important difference between CPR and hotplugging is that with CPR the
driver can fail the checkpoint process if the device is not in a state
from which it can be suspended. For example, the device cannot be
suspended if the device has an error recovery in progress. The device
also cannot be suspended if the device is busy and cannot be stopped
safely.

[[serialization]]
==== Serialization

In general, a driver should not call USBA functions while the driver is
holding a mutex. Therefore, race conditions in a client driver can be
difficult to prevent.

Do not allow normal operational code to run simultaneously with the
processing of asynchronous events such as a disconnect or CPR. These
types of asynchronous events normally clean up and dismantle pipes and
could disrupt the normal operational code.

One way to manage race conditions and protect normal operational code is
to write a serialization facility that can acquire and release an
exclusive-access synchronization object. You can write the serialization
facility in such a way that the synchronization object is safe to hold
through calls to USBA functions. The `usbskel` sample driver
demonstrates this technique. See link:#sample-usb-device-driver[Sample USB Device Driver]
for information on the `usbskel` driver.

[[utility-functions]]
=== Utility Functions

This section describes several functions that are of general use.

[[device-configuration-facilities]]
==== Device Configuration Facilities

This section describes functions related to device configuration.

[[getting-interface-numbers]]
===== Getting Interface Numbers

device drivers

usb++_++mid

USB multi-interface driver

USB drivers

usb++_++mid

USB multi-interface driver

usb++_++mid

USB multi-interface driver

interface number

USB device

interface number

USB functions

usb++_++get++_++if++_++number

If you are using a multiple-interface device where the `usb++_++mid(4D)`
driver is making only one of its interfaces available to the calling
driver, you might need to know the number of the interface to which the
calling driver is bound. Use the `usb++_++get++_++if++_++number(9F)`
function to do any of the following tasks:

* Return the number of the interface to which the calling driver is
bound. The `usb++_++get++_++if++_++number(9F)` function returns an
interface number greater than zero in this case.
* Discover that the calling driver manages an entire multi-interface
device. The driver is bound at the device level so that `usb++_++mid`
has not split it. The `usb++_++get++_++if++_++number(9F)` function
returns `USB++_++DEVICE++_++NODE` in this case.
* Discover that the calling driver manages an entire device by managing
the only interface that device offers in its current configuration. The
`usb++_++get++_++if++_++number(9F)` function returns
`USB++_++COMBINED++_++NODE` in this case.

[[managing-entire-devices]]
===== Managing Entire Devices

USB functions

usb++_++owns++_++device

If a driver manages an entire composite
device, that driver can bind to the entire device by using a compatible
name that contains vendor ID, product ID, and revision ID. A driver that
is bound to an entire composite device must manage all the interfaces of
that device as a nexus driver would. In general, you should not bind
your driver to an entire composite device. Instead, you should use the
generic multiple-interface driver `usb++_++mid(4D)`.

Use the `usb++_++owns++_++device(9F)` function to determine whether a
driver owns an entire device. The device might be a composite device.
The `usb++_++owns++_++device(9F)` function returns `TRUE` if the driver
owns the entire device.

[[multiple-configuration-devices]]
===== Multiple-Configuration Devices

USB drivers

set configuration

USB functions

usb++_++get++_++cfg

USB functions

cfgadm++_++usb

cfgadm++_++usb

USB functions

usb++_++set++_++cfg

USB devices make only a single configuration available to the host at
any particular time. Most devices support only a single configuration.
However, a few USB devices support multiple configurations.

Any device that has multiple
configurations is placed into the first configuration for which a driver
is available. When seeking a match, device configurations are considered
in numeric order. If no matching driver is found, the device is set to
the first configuration. In this case, the `usb++_++mid` driver takes
over the device and splits the device into interface nodes. Use the
`usb++_++get++_++cfg(9F)` function to return the current configuration
of a device.

You can use either of the following two methods to request a different
configuration. Using either of these two methods to modify the device
configuration ensures that the USBA module remains in sync with the
device.

* Use the `cfgadm++_++usb(8)` command.
* Call the `usb++_++set++_++cfg(9F)` function from the driver.
+
Because changing device configuration affects an entire device, the
client driver must meet all of the following criteria to call the
`usb++_++set++_++cfg(9F)` function successfully:
** The client driver must own the entire device.
** The device must have no child nodes, because other drivers could
drive the device through them.
** All pipes except the default pipe must be closed.
** The device must have multiple configurations.

[CAUTION]

Do not change the device configuration by doing a
`SET++_++CONFIGURATION` USB request manually. Using a
`SET++_++CONFIGURATION` request to change the configuration is not
supported.
===

[[modifying-or-getting-the-alternate-setting]]
===== Modifying or Getting the Alternate Setting

USB drivers

set alternate

USB functions

usb++_++set++_++alt++_++if

USB functions

usb++_++get++_++alt++_++if

alternate setting

A client driver can call the `usb++_++set++_++alt++_++if(9F)` function
to change the selected alternate setting of the currently selected
interface. Be sure to close all pipes that were opened explicitly. When
switching alternate settings, the `usb++_++set++_++alt++_++if(9F)`
function verifies that only the default pipe is open. Be sure the device
is settled before you call `usb++_++set++_++alt++_++if(9F)`.

Changing the alternate setting can affect which endpoints and which
class-specific and vendor-specific descriptors are available to the
driver. See link:#the-descriptor-tree[The Descriptor Tree] for more information about
endpoints and descriptors.

Call the `usb++_++get++_++alt++_++if(9F)` function to retrieve the
number of the current alternate setting.

[NOTE]

When you request a new alternate setting, a new configuration, or a new
interface, all pipes except the default pipe to the device must be
closed. This is because changing an alternate setting, a configuration,
or an interface changes the mode of operation of the device. Also,
changing an alternate setting, a configuration, or an interface changes
the device's presentation to the system.
===

[[other-utility-functions]]
==== Other Utility Functions

This section describes other functions that are useful in USB device
drivers.

[[retrieving-a-string-descriptor]]
===== Retrieving a String Descriptor

USB functions

usb++_++get++_++string++_++descr

Call the `usb++_++get++_++string++_++descr(9F)` function to retrieve a
string descriptor given its index. Some configuration, interface, or
device descriptors have string IDs associated with them. Such
descriptors contain string index fields with nonzero values. Pass a
string index field value to the `usb++_++get++_++string++_++descr(9F)`
to retrieve the corresponding string.

[[pipe-private-data-facility]]
===== Pipe Private Data Facility

USB functions

usb++_++pipe++_++get++_++private

USB functions

usb++_++pipe++_++set++_++private

Each pipe has one pointer of space set aside for the client driver's
private use. Use the `usb++_++pipe++_++set++_++private(9F)` function to
install a value. Use the `usb++_++pipe++_++get++_++private(9F)` function
to retrieve the value. This facility is useful in callbacks, when pipes
might need to bring their own client-defined state to the callback for
specific processing.

[[clearing-a-usb-condition]]
===== Clearing a USB Condition

USB functions

usb++_++clr++_++feature

Use the `usb++_++clr++_++feature(9F)` function to do the following
tasks:

* Issue a USB `CLEAR++_++FEATURE` request to clear a halt condition on
an endpoint.
* Clear a remote wakeup condition on a device.
* Clear a device-specific condition at a device, interface, or endpoint
level.

[[getting-device-interface-or-endpoint-status]]
===== Getting Device, Interface, or Endpoint Status

USB functions

usb++_++get++_++status

Use the `usb++_++get++_++status(9F)` function to issue a USB
`GET++_++STATUS` request to retrieve the status of a device, interface,
or endpoint.

* *Device status*. Self-powered and remote-wakeup-enabled.
* *Interface status*. Returns zero, per USB 2.0 specification.
* *Endpoint status*. Endpoint halted. This status indicates a functional
stall. A halt must be cleared before the device can operate again.
+
A protocol stall indicates that an unsupported control pipe request has
been made. A protocol stall is cleared automatically at the beginning of
the next control transfer.

[[getting-the-bus-address-of-a-device]]
===== Getting the Bus Address of a Device

USB functions

usb++_++get++_++addr

Use the `usb++_++get++_++addr(9F)` function to get the USB bus address
of a device for debugging purposes. This address maps to a particular
USB port.

[[sample-usb-device-driver]]
=== Sample USB Device Driver

This section describes a template USB device driver that uses the
USBA 2.0 framework for the illumos environment. This driver demonstrates
many of the features discussed in this chapter. This template or
skeleton driver is named `usbskel`.

The `usbskel` driver is a template that you can use to start your own
USB device driver. The `usbskel` driver demonstrates the following
features:

* Reading the raw configuration data of a device. Every USB device needs
to be able to report device raw configuration data.
* Managing pipes. The `usbskel` driver opens an interrupt pipe to show
how to manage pipes.
* Polling. Comments in the `usbskel` driver discuss how to do polling.
* USB version management and registration.
* USB logging.
* Accommodations for USB hotplugging.
* Accommodations for illumos suspend and resume.
* Accommodations for power management.
* USB serialization.
* Use of USB callbacks.

This `usbskel` driver is available on Sun's web site at
http://www.sun.com/bigadmin/software/usbskel/.

For source for additional USB drivers, see the illumos web site. Go to
http://src.illumos.org/.

== Building a Device Driver

The third part of this book provides advice on building device drivers
for the illumos Operating illumos:

* link:#compiling-loading-packaging-and-testing-drivers[Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers] provides information on compiling, linking, and
installing a driver.
* link:#debugging-testing-and-tuning-device-drivers[Debugging&#44; Testing&#44; and Tuning Device Drivers]
describes techniques for debugging, testing, and tuning drivers.
* link:#recommended-coding-practices[Recommended Coding Practices] describes the
recommended coding practices for writing drivers.

[[compiling-loading-packaging-and-testing-drivers]]
=== Compiling, Loading, Packaging, and Testing Drivers

This chapter describes the procedure for driver development, including
code layout, compilation, packaging, and testing.

* link:#driver-code-layout[Driver Code Layout]
* link:#preparing-for-driver-installation[Preparing for Driver Installation]
* link:#installing-updating-and-removing-drivers[Installing&#44; Updating&#44; and Removing
Drivers]
* link:#loading-and-unloading-drivers[Loading and Unloading Drivers]
* link:#driver-packaging[Driver Packaging]
* link:#criteria-for-testing-drivers[Criteria for Testing Drivers]

[[driver-development-summary]]
=== Driver Development Summary

This chapter and the following two chapters,
link:#debugging-testing-and-tuning-device-drivers[Debugging&#44; Testing&#44; and Tuning Device Drivers]
and link:#recommended-coding-practices[Recommended Coding Practices], provide
detailed information on developing a device driver.

[arabic]
. Write, compile, and link the new code.
+
See link:#driver-code-layout[Driver Code Layout] for the conventions on naming
files. Use a C compiler to compile the driver. Link the driver using
`ld(1)`. See link:#compiling-and-linking-the-driver[Compiling and Linking the Driver] and
link:#module-dependencies[Module Dependencies].
. Create the necessary hardware configuration files.
+
Create a hardware configuration file unique to the device called
_xx_`.conf` where _xx_ is the prefix for the device. This file is used
to update the `driver.conf(5)` file. See link:#writing-a-hardware-configuration-file[Writing a
Hardware Configuration File]. For a pseudo device driver, create a
`pseudo(5)` file.
. Copy the driver to the appropriate module directory.
+
See link:#copying-the-driver-to-a-module-directory[Copying the Driver to a Module Directory].
. Install the device driver using `add++_++drv(8)`.
+
Installing the driver with `add++_++drv` is usually done as part of a
postinstall script. See link:#installing-drivers-with-add_drv[Installing Drivers with ]. Use
the `update++_++drv(8)` command to make any changes to the driver. See
link:#updating-driver-information[Updating Driver Information].
. Load the driver.
+
The driver can be loaded automatically by accessing the device. See
link:#loading-and-unloading-drivers[Loading and Unloading Drivers] and
link:#package-postinstall[Package Postinstall]. Drivers can also be loaded by
using the `modload(8)` command. The `modload` command does not call any
routines in the module and therefore is useful for testing. See
link:#loading-and-unloading-test-modules[Loading and Unloading Test Modules].
. Test the driver.
+
Drivers should be rigorously tested in the following areas:
* link:#configuration-testing[Configuration Testing]
* link:#functionality-testing[Functionality Testing]
* link:#error-handling[Error Handling]
* link:#testing-loading-and-unloading[Testing Loading and Unloading]
* link:#stress-performance-and-interoperability-testing[Stress&#44; Performance&#44; and Interoperability
Testing]
* link:#ddidki-compliance-testing[DDI/DKI Compliance Testing]
* link:#installation-and-packaging-testing[Installation and Packaging Testing]
+
For additional driver-specific testing, see link:#testing-specific-types-of-drivers[Testing
Specific Types of Drivers].
. Remove the driver if necessary.
+
Use the `rem++_++drv(8)` command to remove a device driver. See
link:#removing-the-driver[Removing the Driver] and link:#package-preremove[Package
Preremove].

[[driver-code-layout]]
=== Driver Code Layout

* Header files (`.h` files)
* Source files (`.c` files)
* Optional configuration file (`driver.conf` file)

[[header-files]]
==== Header Files

* Data structures specific to the device, such as a structure
representing the device registers
* Data structures defined by the driver for maintaining state
information
* Defined constants, such as those representing the bits of the device
registers
* Macros, such as those defining the static mapping between the minor
device number and the instance number

Some of the header file definitions, such as the state structure, might
be needed only by the device driver. This information should go in
_private_ header files that are only included by the device driver
itself.

Any information that an application might require, such as the I/O
control commands, should be in _public_ header files. These files are
included by the driver and by any applications that need information
about the device.

While there is no standard for naming private and public files, one
convention is to name the private header file `xximpl.h` and the public
header file `xxio.h`.

[[source-files]]
==== Source Files

* Contains the data declarations and the code for the entry points of
the driver
* Contains the `#include` statements that are needed by the driver
* Declares `extern` references
* Declares local data
* Sets up the `cb++_++ops` and `dev++_++ops` structures
* Declares and initializes the module configuration section, that is,
the `modlinkage(9S)` and `modldrv(9S)` structures
* Makes any other necessary declarations
* Defines the driver entry points

[[configuration-files]]
==== Configuration Files

In general, the configuration file for a
driver defines all of the properties that the driver needs. Entries in
the driver configuration file specify possible device instances that the
driver can probe for existence. Driver global properties can be set in
the driver's configuration file. See the `driver.conf(5)` man page for
more information.

Driver configuration files are required for devices that are not
self-identifying.

Driver configuration files are optional for self-identifying devices
(SID). For self-identifying devices, the configuration file can be used
to add properties into SID nodes.

* Drivers that use the SBus peripheral bus generally get property
information from the SBus card. In cases where additional properties are
needed, the driver configuration file can contain properties that are
defined by `sbus(5)`.
* The properties of a PCI bus can generally be derived from the PCI
configuration space. In cases where private driver properties are
needed, the driver configuration file can contain properties that are
defined by `pci(5)`.
* Drivers on the ISA bus can use additional properties that are defined
by `isa(5)`.

[[preparing-for-driver-installation]]
=== Preparing for Driver Installation

[arabic]
. Compile the driver.
. Create a configuration file if necessary.
. Identify the driver module to the system through either of the
following alternatives:
* Match the driver's name to the name of the device node.
* Use either `add++_++drv(8)` or `update++_++drv(8)` to inform the
system of the module names.

The system maintains a one-to-one association between the name of the
driver module and the name of the `dev++_++info` node. For example,
consider a `dev++_++info` node for a device that is named `mydevice`.
The device `mydevice` is handled by a driver module that is also named
`mydevice`. The `mydevice` module resides in a subdirectory that is
called `drv`, which is in the module path. The module is in
`drv/mydevice` if you are using a 32-bit kernel. The module is in
`drv/sparcv9/mydevice` if you are using a 64-bit SPARC kernel. The
module is in `drv/amd64/mydevice` if you are using a 64-bit x86 kernel.

* Only alphanumeric characters (a-z, A-Z, 0-9), plus the underbar
('++_++'), are allowed.
* Neither the first nor the last character of the name can be a digit.
* The name cannot exceed 16 characters in length. Names in the range of
3-8 characters in length are preferable.

If the driver must manage `dev++_++info` nodes with different names, the
`add++_++drv(8)` utility can create aliases. The `-i` flag specifies the
names of other `dev++_++info` nodes that the driver handles. The
`update++_++drv` command can also modify aliases for an installed device
driver.

[[compiling-and-linking-the-driver]]
==== Compiling and Linking the Driver

compiling drivers

linking drivers

loading drivers

device drivers

compiling drivers

device drivers

linking drivers

device drivers

loading drivers

Sun Studio

You need to compile each driver source file and link the resulting
object files into a driver module. illumos is compatible with both the
Sun Studio C compiler and the GNU C compiler from the Free Software
Foundation, Inc. The examples in this section use the Sun Studio C
compiler unless otherwise noted. For information on the Sun Studio C
compiler, see the Sun Studio 12: C User’s Guide and the
http://developers.sun.com/sunstudio/documentation/[Sun Studio
Documentation] on the Sun Developer Network web site. For more
information on compile and link options, see the Sun Studio Man Pages.
The GNU C compiler is supplied in the `/usr/sfw` directory. For
information on the GNU C compiler, see http://gcc.gnu.org/ or check the
man pages in `/usr/sfw/man`.

The example below shows a driver that is called ++<++xx++>++ with two C
source files. A driver module that is called ++<++xx++>++ is generated.
The driver that is created in this example is for a 32-bit kernel. You
must use `ld` `r` even if your driver has only one object module.

....
% cc -D_KERNEL -c xx1.c
% cc -D_KERNEL -c xx2.c
% ld -r -o xx xx1.o xx2.o
....

The `++_++KERNEL` symbol
must be defined to indicate that this code defines a kernel module. No
other symbols should be defined, except for driver private symbols. The
`DEBUG` symbol can be defined to enable any calls to `ASSERT(9F)`.

If you are compiling for a 64-bit SPARC architecture using Sun Studio 9,
Sun Studio 10, or Sun Studio 11, use the `xarch=v9` option:

....
% cc -D_KERNEL -xarch=v9 -c xx.c
....

If you are compiling for a 64-bit SPARC architecture using Sun Studio
12, use the `m64` option:

....
% cc -D_KERNEL -m64 -c xx.c
....

If you are compiling for a 64-bit x86 architecture using Sun Studio 10
or Sun Studio 11, use both the `xarch=amd64` option and the
`xmodel=kernel` option:

....
% cc -D_KERNEL -xarch=amd64 -xmodel=kernel -c xx.c
....

If you are compiling for a 64-bit x86 architecture using Sun Studio 12,
use the `m64` option, the `xarch=sse2a` option, and the `xmodel=kernel`
option:

....
% cc -D_KERNEL -m64 -xarch=sse2a -xmodel=kernel -c xx.c
....

[NOTE]

Sun Studio 9 does not support 64-bit x86 architectures. Use Sun Studio
10, Sun Studio 11, or Sun Studio 12 to compile and debug drivers for
64-bit x86 architectures.
===

After the driver is stable, you might want to add optimization flags to
build a production quality driver. See the `cc`(1) man page in Sun
Studio Man Pages for specific information on optimizations in the Sun
Studio C compiler.

Global variables should be treated as `volatile` in device drivers. The
`volatile` tag is discussed in greater detail in
link:#declaring-a-variable-volatile[Declaring a Variable Volatile]. Use of the flag
depends on the platform. See the man pages.

[[module-dependencies]]
==== Module Dependencies

If the driver module depends on symbols exported by another kernel
module, the dependency can be specified by the `dy` and `N` options of
the loader, `ld(1)`. If the driver depends on a symbol exported by
`misc/mySymbol`, the example below should be used to create the driver
binary.

....
% ld -dy -r -o xx xx1.o xx2.o -N misc/mySymbol
....

[[writing-a-hardware-configuration-file]]
==== Writing a Hardware Configuration File

If a device
is non-self-identifying, the kernel might require a hardware
configuration file for that device. If the driver is called
++<++xx++>++, the hardware configuration file for the driver should be
called ++<++xx++>++`.conf`.

On the x86 platform, device information is now supplied by the booting
system. Hardware configuration files should no longer be needed, even
for non-self-identifying devices.

See the `driver.conf(5)`, `pseudo(5)`, `sbus(5)`,
`scsi++_++free++_++consistent++_++buf(9F)`, and `update++_++drv(8)` man
pages for more information on hardware configuration files.

Arbitrary properties can be defined in hardware configuration files.
Entries in the configuration file are in the form
++<++property++>++=++<++value++>++, where ++<++property++>++ is the
property name and ++<++value++>++ is its initial value. The
configuration file approach enables devices to be configured by changing
the property values.

[[installing-updating-and-removing-drivers]]
=== Installing, Updating, and Removing Drivers

Before a driver can be used, the system must be informed that the driver
exists. The `add++_++drv(8)` utility must be used to correctly install
the device driver. After a driver is installed, that driver can be
loaded and unloaded from memory without using the `add++_++drv` command.

[[copying-the-driver-to-a-module-directory]]
==== Copying the Driver to a Module Directory

loading modules

module directory

module directory

* The platform that the driver runs on
* The architecture for which the driver is compiled
* Whether the path is needed at boot time

Device drivers reside in the following locations:

`/platform/++`++uname -i++`++``/kernel/drv`::
  Contains 32-bit drivers that run only on a specific platform.
`/platform/++`++uname -i++`++``/kernel/drv/sparcv9`::
  Contains 64-bit drivers that run only on a specific SPARC-based
  platform.
`/platform/++`++uname -i++`++``/kernel/drv/amd64`::
  Contains 64-bit drivers that run only on a specific x86-based
  platform.
`/platform/++`++uname -m++`++``/kernel/drv`::
  Contains 32-bit drivers that run only on a specific family of
  platforms.
`/platform/++`++uname -m++`++``/kernel/drv/sparcv9`::
  Contains 64-bit drivers that run only on a specific family of
  SPARC-based platforms.
`/platform/++`++uname -m++`++``/kernel/drv/amd64`::
  Contains 64-bit drivers that run only on a specific family of
  x86-based platforms.
`/usr/kernel/drv`::
  Contains 32-bit drivers that are independent of platforms.
`/usr/kernel/drv/sparcv9`::
  Contains 64-bit drivers on SPARC-based systems that are independent of
  platforms.
`/usr/kernel/drv/amd64`::
  Contains 64-bit drivers on x86-based systems that are independent of
  platforms.

To install a 32-bit driver, the driver and its configuration file must
be copied to a `drv` directory in the module path. For example, to copy
a driver to `/usr/kernel/drv`, type:

....
$ su
# cp xx /usr/kernel/drv
# cp xx.conf /usr/kernel/drv
....

To install a SPARC driver, copy the driver to a `drv/sparcv9` directory
in the module path. Copy the driver configuration file to the `drv`
directory in the module path. For example, to copy a driver to
`/usr/kernel/drv`, you would type:

....
$ su
# cp xx /usr/kernel/drv/sparcv9
# cp xx.conf /usr/kernel/drv
....

To install a 64-bit x86 driver, copy the driver to a `drv/amd64`
directory in the module path. Copy the driver configuration file to the
`drv` directory in the module path. For example, to copy a driver to
`/usr/kernel/drv`, you would type:

....
$ su
# cp xx /usr/kernel/drv/amd64
# cp xx.conf /usr/kernel/drv
....

[NOTE]

All driver configuration files (`.conf`
files) must go in the `drv` directory in the module path. The `.conf`
files cannot go into any subdirectory of the `drv` directory.
===

[[installing-drivers-with-add_drv]]
==== Installing Drivers with `add++_++drv`

loading drivers

add++_++drv

add++_++drv

Use the `add++_++drv(8)` command to install the driver in the system. If
the driver installs successfully, `add++_++drv` runs `devfsadm(8)` to
create the logical names in the `/dev` directory.

....
# add_drv xx
....

In this case, the device identifies itself as ++<++xx++>++. The device
special files have default ownership and permissions (`0600` `root`
`sys`). The `add++_++drv` command also allows additional names for the
device (aliases) to be specified. See the `add++_++drv`(1M) man page for
information on adding aliases and setting file permissions explicitly.

[NOTE]

Do not use the `add++_++drv` command to install a STREAMS module. See
the STREAMS Programming Guide for details.
===

If the driver creates minor nodes that do not
represent terminal devices such as disks, tapes, or ports, you can
modify `/etc/devlink.tab` to cause `devfsadm` to create logical device
names in `/dev`. Alternatively, logical names can be created by a
program that is run at driver installation time.

[[updating-driver-information]]
==== Updating Driver Information

device drivers

modifying information with

update++_++drv

update++_++drv

device drivers

modifying permissions

device drivers

minor device node

modifying permissions of

Use the `update++_++drv(8)` command to notify the system of any changes
to an installed device driver. By default, the system re-reads the
driver configuration file and reloads the driver binary module.

[[removing-the-driver]]
==== Removing the Driver

To remove a driver from the system, use the `rem++_++drv(8)` command,
and then delete the driver module and configuration file from the module
path. A driver cannot be used again until that driver is reinstalled
with `add++_++drv(8)`. The removal of a SCSI HBA driver requires a
reboot to take effect.

[[loading-and-unloading-drivers]]
=== Loading and Unloading Drivers

Opening a special file (accessing the device) that is associated with a
device driver causes that driver to be loaded. You can use the
`modload(8)` command to load the driver into memory, but `modload` does
not call any routines in the module. The preferred method is to open the
device.

Normally, the system automatically unloads device drivers when the
device is no longer in use. During development, you might want to use
`modunload(8)` to unload the driver explicitly. In order for `modunload`
to be successful, the device driver must be inactive. No outstanding
references to the device should exist, such as through `open(2)` or
`mmap(2)`.

The `modunload` command takes a
runtime-dependent `module++_++id` as an argument. To find the
`module++_++id`, use `grep` to search the output of `modinfo(8)` for the
driver name in question. Check in the first column.

....
# modunload -i module-id
....

To unload all currently unloadable modules, specify module ID zero:

....
# modunload -i 0
....

In addition to being inactive, the driver must have working `detach(9E)`
and `++_++fini(9E)` routines for `modunload(8)` to succeed.

[[driver-packaging]]
=== Driver Packaging

The normal delivery vehicle for software
is to create a package that contains all of the software components. A
package provides a controlled mechanism for installation and removal of
all the components of a software product. In addition to the files for
using the product, the package includes control files for installing and
uninstalling the application. The postinstall and preremove installation
scripts are two such control files.

[[package-postinstall]]
==== Package Postinstall

After a package with a driver binary is installed onto a system, the
`add++_++drv(8)` command must be run. The `add++_++drv` command
completes the installation of the driver. Typically, `add++_++drv` is
run in a postinstall script, as in the following example.

....
#!/bin/sh
#
#       @(#)postinstall 1.1

PATH="/usr/bin:/usr/sbin:${PATH}"
export PATH

#
# Driver info
#
DRV=<driver-name>
DRVALIAS="<company-name>,<driver-name>"
DRVPERM='* 0666 root sys'

ADD_DRV=/usr/sbin/add_drv

#
# Select the correct add_drv options to execute.
# add_drv touches /reconfigure to cause the
# next boot to be a reconfigure boot.
#
if [ "${BASEDIR}" = "/" ]; then
    #
    # On a running system, modify the
    # system files and attach the driver
    #
    ADD_DRV_FLAGS=""
    #
    # On a client, modify the system files
    # relative to BASEDIR
    #
    ADD_DRV_FLAGS="-b ${BASEDIR}"
 
#
# Make sure add_drv has not been previously executed
# before attempting to add the driver.
#
grep "^${DRV} " $BASEDIR/etc/name_to_major > /dev/null 2>&1
if [ $? -ne 0 ]; then
    ${ADD_DRV} ${ADD_DRV_FLAGS} -m "${DRVPERM}" -i "${DRVALIAS}" ${DRV}
    if [ $? -ne 0 ]; then
        echo "postinstall: add_drv $DRV failed\n" >&2
        exit 1
exit 0
....

[[package-preremove]]
==== Package Preremove

When removing a package that includes a driver, the `rem++_++drv(8)`
command must be run prior to removing the driver binary and other
components. The following example demonstrates a preremove script that
uses the `rem++_++drv` command for driver removal.

....
#!/bin/sh
#
#       @(#)preremove  1.1
 
PATH="/usr/bin:/usr/sbin:${PATH}"
export PATH
 
#
# Driver info
#
DRV=<driver-name>
REM_DRV=/usr/sbin/rem_drv
 
#
# Select the correct rem_drv options to execute.
# rem_drv touches /reconfigure to cause the
# next boot to be a reconfigure boot.
#
if [ "${BASEDIR}" = "/" ]; then
    #
    # On a running system, modify the
    # system files and remove the driver
    #
    REM_DRV_FLAGS=""
    #
    # On a client, modify the system files
    # relative to BASEDIR
    #
    REM_DRV_FLAGS="-b ${BASEDIR}"
 
${REM_DRV} ${REM_DRV_FLAGS} ${DRV}
 
exit 0
....

[[criteria-for-testing-drivers]]
=== Criteria for Testing Drivers

Once a device driver is functional, that
driver should be thoroughly tested prior to distribution. Besides
testing the features in traditional UNIX device drivers, illumos drivers
require testing power management features, such as dynamic loading and
unloading of drivers.

[[configuration-testing]]
==== Configuration Testing

A driver's ability to handle multiple device configurations is an
important part of the test process. Once the driver is working on a
simple, or default, configuration, additional configurations should be
tested. Depending on the device, configuration testing can be
accomplished by changing jumpers or DIP switches. If the number of
possible configurations is small, all configurations should be tried. If
the number is large, various classes of possible configurations should
be defined, and a sampling of configurations from each class should be
tested. Defining these classes depends on the potential interactions
among the different configuration parameters. These interactions are a
function of the type of the device and the way in which the driver was
written.

For each device configuration, the basic functions must be tested, which
include loading, opening, reading, writing, closing, and unloading the
driver. Any function that depends upon the configuration deserves
special attention. For example, changing the base memory address of
device registers is not likely to affect the behavior of most driver
functions. If a driver works well with one address, that driver is
likely to work as well with a different address. On the other hand, a
special I/O control call might have different effects depending on the
particular device configuration.

Loading the driver with varying configurations ensures that the
`probe(9E)` and `attach(9E)` entry points can find the device at
different addresses. For basic functional testing, using regular UNIX
commands such as `cat(1)` or `dd(8)` is usually sufficient for character
devices. Mounting or booting might be required for block devices.

[[functionality-testing]]
==== Functionality Testing

After a driver has been completely tested for
configuration, all of the driver's functionality should be thoroughly
tested. These tests require exercising the operation of all of the
driver's entry points.

Many drivers require custom applications to test functionality. However,
basic drivers for devices such as disks, tapes, or asynchronous boards
can be tested using standard system utilities. All entry points should
be tested in this process, including `devmap(9E)`, `chpoll(9E)`, and
`ioctl(9E)`, if applicable. The `ioctl` tests might be quite different
for each driver. For nonstandard devices, a custom testing application
is generally required.

[[error-handling]]
[[error-handling-1]]
==== Error Handling

A driver might perform correctly in an
ideal environment but fail in cases of errors, such as erroneous
operations or bad data. Therefore, an important part of driver testing
is the testing of the driver's error handling.

All possible error conditions of a driver should be exercised, including
error conditions for actual hardware malfunctions. Some hardware error
conditions might be difficult to induce, but an effort should be made to
force or to simulate such errors if possible. All of these conditions
could be encountered in the field. Cables should be removed or be
loosened, boards should be removed, and erroneous user application code
should be written to test those error paths. See also
link:#hardening-illumos-drivers[Hardening illumos Drivers].

[CAUTION]

Be sure to take proper electrical precautions when testing.
===

[[testing-loading-and-unloading]]
==== Testing Loading and Unloading

Because a driver that does not load or unload can force unscheduled
downtime, loading and unloading must be thoroughly tested.

A script like the following example should suffice:

....
#!/bin/sh
cd <location_of_driver>
while [ 1 ]
    modunload -i 'modinfo | grep " <driver_name> " | cut -cl-3' &
    modload <driver_name> &
....

[[stress-performance-and-interoperability-testing]]
==== Stress, Performance, and Interoperability Testing

To help ensure that a driver performs well, that driver should be
subjected to vigorous stress testing. For example, running single
threads through a driver does not test locking logic or conditional
variables that have to wait. Device operations should be performed by
multiple processes at once to cause several threads to execute the same
code simultaneously.

Techniques for performing simultaneous tests depend upon the driver.
Some drivers require special testing applications, while starting
several UNIX commands in the background is suitable for others.
Appropriate testing depends upon where the particular driver uses locks
and condition variables. Testing a driver on a multiprocessor machine is
more likely to expose problems than testing on a single-processor
machine.

Interoperability between drivers must also be tested, particularly
because different devices can share interrupt levels. If possible,
configure another device at the same interrupt level as the one being
tested. A stress test can determine whether the driver correctly claims
its own interrupts and operates according to expectations. Stress tests
should be run on both devices at once. Even if the devices do not share
an interrupt level, this test can still be valuable. For example,
consider a case in which serial communication devices experience errors
when a network driver is tested. The same problem might be causing the
rest of the system to encounter interrupt latency problems as well.

Driver performance under these stress tests should be measured using
UNIX performance-measuring tools. This type of testing can be as simple
as using the `time(1)` command along with commands to be used in the
stress tests.

[[ddidki-compliance-testing]]
==== DDI/DKI Compliance Testing

To ensure compatibility with later
releases and reliable support for the current release, every driver
should be DDI/DKI compliant. Check that only kernel routines in
https://illumos.org/man/9f[manual pages section 9F: DDI and DKI Kernel
Functions] and https://illumos.org/man/9e/[manual pages section 9E: DDI
and DKI Driver Entry Points] and data structures in
https://illumos.org/man/9s[manual pages section 9S: DDI and DKI
Properties and Data Structures] are used.

[[installation-and-packaging-testing]]
==== Installation and Packaging Testing

Drivers are delivered to customers in _packages_. A
package can be added or be removed from the system using a standard
mechanism (see the Application Packaging Developer’s Guide).

The ability of a user to add or remove the package from a system should
be tested. In testing, the package should be both installed and removed
from every type of media to be used for the release. This testing should
include several system configurations. Packages must not make
unwarranted assumptions about the directory environment of the target
system. Certain valid assumptions, however, can be made about where
standard kernel files are kept. Also test adding and removing of
packages on newly installed machines that have not been modified for a
development environment. A common packaging error is for a package to
rely on a tool or file that is used in development only. For example, no
tools from the Source Compatibility package, `SUNWscpu`, should be used
in driver installation programs.

The driver installation must be tested on a minimal illumos system
without any optional packages.

[[testing-specific-types-of-drivers]]
==== Testing Specific Types of Drivers

This section provides some suggestions about how to test
certain types of standard devices.

[[tape-drivers]]
===== Tape Drivers

tape drivers

Tape drivers should be tested by performing several archive and restore
operations. The `cpio(1)` and `tar(1)` commands can be used for this
purpose. Use the `dd(8)` command to write an entire disk partition to
tape. Next, read back the data, and write the data to another partition
of the same size. Then compare the two copies. The `mt(1)` command can
exercise most of the I/O controls that are specific to tape drivers. See
the `mtio(4I)` man page. Try to use all the options. These three
techniques can test the error-handling capabilities of tape drivers:

* Remove the tape and try various operations
* Write-protect the tape and try a write
* Turn off power in the middle of different operations

Tape drivers typically implement exclusive-access `open(9E)` calls.
These `open` calls can be tested by opening a device and then having a
second process try to open the same device.

[[disk-drivers]]
===== Disk Drivers

Disk drivers should be tested in both the
raw and block device modes. For block device tests, create a new file
system on the device. Then try to mount the new file system. Then try to
perform multiple file operations.

[NOTE]

The file system uses a page cache, so reading the same file over and
over again does not really exercise the driver. The page cache can be
forced to retrieve data from the device by memory-mapping the file with
`mmap(2)`. Then use `msync(3C)` to invalidate the in-memory copies.
===

Copy another (unmounted) partition of the same size to the raw device.
Then use a command such as `fsck(8)` to verify the correctness of the
copy. The new partition can also be mounted and then later compared to
the old partition on a file-by-file basis.

[[asynchronous-communication-drivers]]
===== Asynchronous Communication Drivers

Asynchronous drivers can be tested at the
basic level by setting up a `login` line to the serial ports. A good
test is to see whether a user can log in on this line. To sufficiently
test an asynchronous driver, however, all the I/O control functions must
be tested, with many interrupts at high speed. A test involving a
loopback serial cable and high data transfer rates can help determine
the reliability of the driver. You can run `uucp(1C)` over the line to
provide some exercise. However, because `uucp` performs its own error
handling, verify that the driver is not reporting excessive numbers of
errors to the `uucp` process.

These types of devices are usually STREAMS-based. See the STREAMS
Programming Guide for more information.

[[network-drivers]]
===== Network Drivers

Network drivers can be tested using
standard network utilities. The `ftp(1)` and `rcp(1)` commands are
useful because the files can be compared on each end of the network. The
driver should be tested under heavy network loading, so that various
commands can be run by multiple processes.

* Traffic to the test machine is heavy.
* Traffic among all machines on the network is heavy.

Network cables should be unplugged while the tests are executing to
ensure that the driver recovers gracefully from the resulting error
conditions. Another important test is for the driver to receive multiple
packets in rapid succession, that is, _back-to-back_ packets. In this
case, a relatively fast host on a lightly loaded network should send
multiple packets in quick succession to the test machine. Verify that
the receiving driver does not drop the second and subsequent packets.

These types of devices are usually STREAMS-based. See the STREAMS
Programming Guide for more information.

[[debugging-testing-and-tuning-device-drivers]]
=== Debugging, Testing, and Tuning Device Drivers

device drivers

This chapter presents an overview of the various tools that are provided
to assist with testing, debugging, and tuning device drivers. This
chapter provides information on the following subjects:

* link:#testing-drivers[Testing Drivers] – Testing a driver can potentially
impair a system's ability to function. Use of both serial connections
and alternate kernels helps facilitate recovery from crashes.
* link:#debugging-tools[Debugging Tools] – Integral debugging facilities enable
you to exercise and observe driver features conveniently without having
to run a separate debugger.
* link:#tuning-drivers[Tuning Drivers] – illumos provides facilities for
measuring the performance of device drivers. Writing kernel statistics
structures for your device exports continuous statistics as the device
is running. If an area for performance improvement is determined, then
the DTrace dynamic instrumentation tool can help determine any problems
more precisely.

[[testing-drivers]]
=== Testing Drivers

testing device drivers

device drivers

testing device drivers

To avoid data loss and other problems, you should take special care when
testing a new device driver. This section discusses various testing
strategies. For example, setting up a separate system that you control
through a serial connection is the safest way to test a new driver. You
can load test modules with various kernel variable settings to test
performance under different kernel conditions. Should your system crash,
you should be prepared to restore backup data, analyze any crash dumps,
and rebuild the device directory.

[[enable-the-deadman-feature-to-avoid-a-hard-hang]]
==== Enable the Deadman Feature to Avoid a Hard Hang

If your system is in a hard
hang, then you cannot break into the debugger. If you enable the deadman
feature, the system panics instead of hanging indefinitely. You can then
use the `kmdb(1)` kernel debugger to analyze your problem.

The deadman feature checks every second whether the system clock is
updating. If the system clock is not updating, then you are in an
indefinite hang. If the system clock has not been updated for 50
seconds, the deadman feature induces a panic and puts you in the
debugger.

[arabic]
. Make sure you are capturing crash images with `dumpadm(8)`.
. Set the `snooping` variable in the `/etc/system` file. See the
`system(5)` man page for information on the `/etc/system` file.
+
....
set snooping=1
....
. Reboot the system so that the `/etc/system` file is read again and the
`snooping` setting takes effect.

Note that any zones on your system inherit the deadman setting as well.

If your system hangs while the deadman feature is enabled, you should
see output similar to the following example on your console:

....
panic[cpu1]/thread=30018dd6cc0: deadman: timed out after 9 seconds of
clock inactivity

panic: entering debugger (continue to save dump)
....

Inside the debugger, use the `::cpuinfo` command to investigate why the
clock interrupt was not able to fire and advance the system time.

[[testing-with-a-serial-connection]]
==== Testing With a Serial Connection

Using a serial
connection is a good way to test drivers. Use the `tip(1)` command to
make a serial connection between a host system and a test system. With
this approach, the _tip window_ on the host console is used as the
console of the test machine. See the `tip(1)` man page for additional
information.

* Interactions with the test system and kernel debuggers can be
monitored. For example, the window can keep a log of the session for use
if the driver crashes the test system.
* The test machine can be accessed remotely by logging into a _tip host_
machine and using `tip(1)` to connect to the test machine.

[NOTE]

Although using a tip connection and a second machine are not required to
debug an illumos device driver, this technique is still recommended.
===

. Connect the host system to the test machine using serial port A on
both machines.
+
This connection must be made with a null modem cable.
. On the host system, make sure there is an entry in `/etc/remote` for
the connection. See the `remote(5)` man page for details.
+
The terminal entry must match the serial port that is used. illumos
comes with the correct entry for serial port B, but a terminal entry
must be added for serial port A:
+
....
debug:\
        :dv=/dev/term/a:br#9600:el=^C^S^Q^U^D:ie=%$:oe=^D:
....
+
[NOTE]

The baud rate must be set to 9600.
===
. In a shell window on the host, run `tip(1)` and specify the name of
the entry:
+
....
% tip debug
....
+
The shell window is now a tip window with a connection to the console of
the test machine.
+
[CAUTION]

Do not use `STOP-A` for SPARC machines or `F1-A` for x86 architecture
machines on the host machine to stop the test machine. This action
actually stops the host machine. To send a break to the test machine,
type `~#` in the tip window. Commands such as `~#` are recognized only
if these characters on first on the line. If the command has no effect,
press either the Return key or Control-U.
===

[[setting-up-a-target-system-on-the-sparc-platform]]
===== Setting Up a Target System on the SPARC Platform

setting up a SPARC test system

A quick way to set up the test machine on the SPARC platform is to
unplug the keyboard before turning on the machine. The machine then
automatically uses serial port A as the console.

Another way to set up the test machine is to use boot PROM commands to
make serial port A the console. On the test machine, at the boot PROM
`ok` prompt, direct console I/O to the serial line. To make the test
machine always come up with serial port A as the console, set the
environment variables: `input-device` and `output-device`.

[[faaxq]]
Setting `input-device` and `output-device` With Boot PROM Commands

....
ok setenv input-device ttya
ok setenv output-device ttya
....

The `eeprom` command can also be used to make serial port A the console.
As superuser, execute the following commands to make the `input-device`
and `output-device` parameters point to serial port A. The following
example demonstrates the `eeprom` command.

[[faasj]]
Setting `input-device` and `output-device` With the `eeprom` Command

....
# eeprom input-device=ttya
# eeprom output-device=ttya
....

The `eeprom` commands cause the console to be redirected to serial port
A at each subsequent system boot.

[[setting-up-a-target-system-on-the-x86-platform]]
===== Setting Up a Target System on the x86 Platform

setting up an x86 test system

On x86 platforms, use the `eeprom` command to make serial port A the
console. This procedure is the same as the SPARC platform procedure. See
link:#setting-up-a-target-system-on-the-sparc-platform[Setting Up a Target System on the SPARC Platform]. The
`eeprom` command causes the console to switch to serial port A (COM1)
during reboot.

[NOTE]

x86 machines do not transfer console control to the `tip` connection
until an early stage in the boot process unless the BIOS supports
console redirection to a serial port. In SPARC machines, the `tip`
connection maintains console control throughout the boot process.
===

[[setting-up-test-modules]]
==== Setting Up Test Modules

`system(5)` file in the `/etc` directory enables you to set the value of
kernel variables at boot time. With kernel variables, you can toggle
different behaviors in a driver and take advantage of debugging features
that are provided by the kernel. The kernel variables `moddebug` and
`kmem++_++flags`, which can be very useful in debugging, are discussed
later in this section. See also link:#enable-the-deadman-feature-to-avoid-a-hard-hang[Enable the Deadman Feature
to Avoid a Hard Hang].

Changes to kernel variables after boot are unreliable, because
`/etc/system` is read only once when the kernel boots. After this file
is modified, the system must be rebooted for the changes to take effect.
If a change in the file causes the system not to work, boot with the ask
(`-a`) option. Then specify `/dev/null` as the system file.

[NOTE]

Kernel variables cannot be relied on to be present in subsequent
releases.
===

[[setting-kernel-variables]]
===== Setting Kernel Variables

kernel variables

The `set` command changes the value of module or kernel variables. To
set module variables, specify the module name and the variable:

....
set module_name:variable=value
....

For example, to set the variable `test++_++debug` in a driver that is
named `myTest`, use `set` as follows:

....
% set myTest:test_debug=1
....

To set a variable that is exported by the kernel itself, omit the module
name.

You can also use a bitwise OR operation to set a value, for example:

....
% set moddebug | 0x80000000
....

[[loading-and-unloading-test-modules]]
===== Loading and Unloading Test Modules

loading test modules

unloading test modules

The commands `modload(8)`, `modunload(8)`, and `modinfo(8)` can be used
to add test modules, which is a useful technique for debugging and
stress-testing drivers. These commands are generally not needed in
normal operation, because the kernel automatically loads needed modules
and unloads unused modules. The `moddebug` kernel variable works with
these commands to provide information and set controls.

[[faato]]
====== Using the `modload` Function

Use `modload(8)` to force a module into memory. The `modload` command
verifies that the driver has no unresolved references when that driver
is loaded. Loading a driver does _not_ necessarily mean that the driver
can attach. When a driver loads successfully, the driver's
`++_++info(9E)` entry point is called. The `attach` entry point is not
necessarily called.

[[faasm]]
====== Using the `modinfo` Function

Use `modinfo(8)` to confirm that the driver is loaded.

[[faatr]]
Using `modinfo` to Confirm a Loaded Driver

....
$ modinfo
Id Loadaddr   Size Info Rev Module Name
  6 101b6000    732   -   1  obpsym (OBP symbol callbacks)
  7 101b65bd  1acd0 226   1  rpcmod (RPC syscall)
  7 101b65bd  1acd0 226   1  rpcmod (32-bit RPC syscall)
  7 101b65bd  1acd0   1   1  rpcmod (rpc interface str mod)
  8 101ce8dd  74600   0   1  ip (IP STREAMS module)
  8 101ce8dd  74600   3   1  ip (IP STREAMS device)
...
$ modinfo | grep mydriver
169 781a8d78   13fb   0   1  mydriver (Test Driver 1.5)
....

The number in the `info` field is the major number that has been chosen
for the driver. The `modunload(8)` command can be used to unload a
module if the module ID is provided. The module ID is found in the left
column of `modinfo` output.

Sometimes a driver does not unload as expected after a `modunload` is
issued, because the driver is determined to be busy. This situation
occurs when the driver fails `detach(9E)`, either because the driver
really is busy, or because the `detach` entry point is implemented
incorrectly.

[[faaur]]
====== Using `modunload`

To remove all of the currently unused modules from memory, run
`modunload(8)` with a module ID of 0:

....
# modunload -i 0
....

[[faawr]]
====== Setting the `moddebug` Kernel Variable

The `moddebug` kernel variable controls the module
loading process. The possible values of `moddebug` are:

`0x80000000`::
  Prints messages to the console when loading or unloading modules.
`0x40000000`::
  Gives more detailed error messages.
`0x20000000`::
  Prints more detail when loading or unloading, such as including the
  address and size.
`0x00001000`::
  No auto-unloading drivers. The system does not attempt to unload the
  device driver when the system resources become low.
`0x00000080`::
  No auto-unloading streams. The system does not attempt to unload the
  STREAMS module when the system resources become low.
`0x00000010`::
  No auto-unloading of kernel modules of any type.
`0x00000001`::
  If running with `kmdb`, `moddebug` causes a breakpoint to be executed
  and a return to `kmdb` immediately before each module's `++_++init`
  routine is called. This setting also generates additional debug
  messages when the module's `++_++info` and `++_++fini` routines are
  executed.

[[setting-kmem_flags-debugging-flags]]
===== Setting `kmem++_++flags` Debugging Flags

kmem++_++flags

kmem++_++flags

kernel variable

The `kmem++_++flags` kernel variable enables debugging features in the
kernel's memory allocator. Set `kmem++_++flags` to `0xf` to enable the
allocator's debugging features. These features include runtime checks to
find the following code conditions:

* Writing to a buffer after the buffer is freed
* Using memory before the memory is initialized
* Writing past the end of a buffer

The Modular Debugger Guide describes how to use the kernel memory
allocator to analyze such problems.

[NOTE]

Testing and developing with `kmem++_++flags` set to `0xf` can help
detect latent memory corruption bugs. Because setting `kmem++_++flags`
to `0xf` changes the internal behavior of the kernel memory allocator,
you should thoroughly test without `kmem++_++flags` as well.
===

[[avoiding-data-loss-on-a-test-system]]
==== Avoiding Data Loss on a Test System

avoiding data loss while testing

testing debuggers

avoiding data loss

A driver bug can sometimes render a system incapable of
booting. By taking precautions, you can avoid system reinstallation in
this event, as described in this section.

[[back-up-critical-system-files]]
===== Back Up Critical System Files

A number of driver-related system files are difficult, if not
impossible, to reconstruct. Files such as `/etc/name++_++to++_++major`,
`/etc/driver++_++aliases`, `/etc/driver++_++classes`, and
`/etc/minor++_++perm` can be corrupted if the driver crashes the system
during installation. See the `add++_++drv(8)` man page.

To be safe, make a backup copy of the root file system after the test
machine is in the proper configuration. If you plan to modify the
`/etc/system` file, make a backup copy of the file before making
modifications.

booting an alternate kernel

booting an alternate kernel

To avoid rendering a system inoperable, you should boot from a copy of
the kernel and associated binaries rather than from the default kernel.

. Make a copy of the drivers in `/platform/++*++`.
+
....
# cp -r /platform/`uname -i`/kernel /platform/`uname -i`/kernel.test
....
. Place the driver module in
`/platform/++`++uname -i++`++/kernel.test/drv`.
. Boot the alternate kernel instead of the default kernel.
+
After you have created and stored the alternate kernel, you can boot
this kernel in a number of ways.
* You can boot the alternate kernel by rebooting:
+
....
# reboot -- kernel.test/unix
....
* On a SPARC-based system, you can also boot from the PROM:
+
....
ok boot kernel.test/sparcv9/unix
....
+
[NOTE]

To boot with the `kmdb` debugger, use the `k` option as described in
link:#getting-started-with-the-modular-debugger[Getting Started With the Modular Debugger].
===
* On an x86-based system, when the `Select (b)oot or (i)nterpreter:`
message is displayed in the boot process, type the following:
+
....
boot kernel.test/unix
....

[[faavq]]
Booting an Alternate Kernel

The following example demonstrates booting with an alternate kernel.

....
ok boot kernel.test/sparcv9/unix
Rebooting with command: boot kernel.test/sparcv9/unix
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a File and \
    args:
kernel.test/sparcv9/unix
....

[[faayx]]
Booting an Alternate Kernel With the `a` Option

Alternatively, the module path can be changed by booting with the ask
(`-a`) option. This option results in a series of prompts for
configuring the boot method.

....
ok boot -a
Rebooting with command: boot -a
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a File and \
args: -a
Enter filename [kernel/sparcv9/unix]: kernel.test/sparcv9/unix
Enter default directory for modules
[/platform/sun4u/kernel.test /kernel /usr/kernel]: <CR>
Name of system file [etc/system]: <CR>
SunOS Release 5.10 Version Generic 64-bit
Copyright 1983-2002 Sun Microsystems, Inc. All rights reserved.
root filesystem type [ufs]: <CR>
Enter physical name of root device
[/sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a]: <CR>
....

[[consider-alternative-back-up-plans]]
===== Consider Alternative Back-Up Plans

If the system is attached to a network, the test machine can be added as
a client of a server. If a problem occurs, the system can be booted from
the network. The local disks can then be mounted, and any fixes can be
made. Alternatively, the system can be booted directly from the illumos
system CD-ROM.

Another way to recover from disaster is to have another bootable root
file system. Use `format(8)` to make a partition that is the exact size
of the original. Then use `dd(8)` to copy the bootable root file system.
After making a copy, run `fsck(8)` on the new file system to ensure its
integrity.

Subsequently, if the system cannot boot from the original root
partition, boot the backup partition. Use `dd(8)` to copy the backup
partition onto the original partition. You might have a situation where
the system cannot boot even though the root file system is undamaged.
For example, the damage might be limited to the boot block or the boot
program. In such a case, you can boot from the backup partition with the
ask (`a`) option. You can then specify the original file system as the
root file system.

[[capture-system-crash-dumps]]
===== Capture System Crash Dumps

When a system panics, the system writes an
image of kernel memory to the dump device. The dump device is by default
the most suitable swap device. The dump is a system crash dump, similar
to core dumps generated by applications. On rebooting after a panic,
`savecore(8)` checks the dump device for a crash dump. If a dump is
found, `savecore` makes a copy of the kernel's symbol table, which is
called `unix.n`. The `savecore` utility then dumps a core file that is
called `vmcore.n` in the core image directory. By default, the core
image directory is `/var/crash/machine++_++name`. If `/var/crash` has
insufficient space for a core dump, the system displays the needed space
but does not actually save the dump. The `mdb(1)` debugger can then be
used on the core dump and the saved kernel.

In most illumos distributions, crash dump is enabled by default. The
`dumpadm(8)` command is used to configure system crash dumps. Use the
`dumpadm` command to verify that crash dumps are enabled and to
determine the location of core files that have been saved.

[NOTE]

You can prevent the `savecore` utility from filling the file system. Add
a file that is named `minfree` to the directory in which the dumps are
to be saved. In this file, specify the number of kilobytes to remain
free after `savecore` has run. If insufficient space is available, the
core file is not saved.
===

[[recovering-the-device-directory]]
==== Recovering the Device Directory

disaster recovery

recovering the device directory

device directory

Damage to the `/devices` and `/dev` directories can occur if the driver
crashes during `attach(9E)`. If either directory is damaged, you can
rebuild the directory by booting the system and running `fsck(8)` to
repair the damaged root file system. The root file system can then be
mounted. Recreate the `/devices` and `/dev` directories by running
`devfsadm(8)` and specifying the `/devices` directory on the mounted
disk.

The following example shows how to repair a damaged root file system on
a SPARC system. In this example, the damaged disk is
`/dev/dsk/c0t3d0s0`, and an alternate boot disk is `/dev/dsk/c0t1d0s0`.

[[faauw]]
Recovering a Damaged Device Directory

....
ok boot disk1
...
Rebooting with command: boot kernel.test/sparcv9/unix
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@31,0:a File and \
    args:
kernel.test/sparcv9/unix
...
# fsck /dev/dsk/c0t3d0s0** /dev/dsk/c0t3d0s0
** Last Mounted on /
** Phase 1 - Check Blocks and Sizes
** Phase 2 - Check Pathnames
** Phase 3 - Check Connectivity
** Phase 4 - Check Reference Counts
** Phase 5 - Check Cyl groups
1478 files, 9922 used, 29261 free
     (141 frags, 3640 blocks, 0.4% fragmentation)
# mount /dev/dsk/c0t3d0s0 /mnt
# devfsadm -r /mnt
....

[NOTE]

A fix to the `/devices` and `/dev` directories can allow the system to
boot while other parts of the system are still corrupted. Such repairs
are only a temporary fix to save information, such as system crash
dumps, before reinstalling the system.
===

[[debugging-tools]]
=== Debugging Tools

device drivers

* The `kmdb(1)` *kernel debugger* provides typical runtime debugger
facilities, such as breakpoints, watch points, and single-stepping. The
`kmdb` debugger supersedes `kadb`, which was available in previous
releases. The commands that were previously available from `kadb` are
used in `kmdb`, in addition to new functionality. Where `kadb` could
only be loaded at boot time, `kmdb` can be loaded at any time. The
`kmdb` debugger is preferred for live, interactive debugging due to its
execution controls.
* The `mdb(1)` *modular debugger* is more limited than `kmdb` as a
real-time debugger, but `mdb` has rich facilities for postmortem
debugging.

The `kmdb` and `mdb` debuggers mostly share the same user interface.
Many debugging techniques therefore can be applied with the same
commands in both tools. Both debuggers support macros, dcmds, and dmods.
A _dcmd_ (pronounced dee-command) is a routine in the debugger that can
access any of the properties of the current target program. A dcmd can
be dynamically loaded at runtime. A _dmod_, which is short for debugger
module, is a package of dcmds that can be loaded to provide non-standard
behavior.

Both `mdb` and `kmdb` are backward-compatible with legacy debuggers such
as `adb` and `kadb`. The `mdb` debugger can execute all of the macros
that are available to `kmdb` as well as any legacy user-defined macros
for `adb`. See the Modular Debugger Guide for information about where to
find standard macro sets.

[[postmortem-debugging]]
==== Postmortem Debugging

postmortem debugging

Postmortem analysis offers numerous advantages to driver developers.
More than one developer can examine a problem in parallel. Multiple
instances of the debugger can be used simultaneously on a single crash
dump. The analysis can be performed offline so that the crashed system
can be returned to service, if possible. Postmortem analysis enables the
use of user-developed debugger functionality in the form of dmods. Dmods
can bundle functionality that would be too memory-intensive for
real-time debuggers, such as `kmdb`.

When a system panics while `kmdb` is loaded, control is passed to the
debugger for immediate investigation. If `kmdb` does not seem
appropriate for analyzing the current problem, a good strategy is to use
`:c` to continue execution and save the crash dump. When the system
reboots, you can perform postmortem analysis with `mdb` on the saved
crash dump. This process is analogous to debugging an application crash
from a process core file.

[NOTE]

In earlier versions of the Solaris operating system,
`adb(1)` was the recommended tool for postmortem analysis. In the
current illumos releases, `mdb(1)` is the recommended tool for
postmortem analysis. The `mdb` feature set surpasses the set of commands
from the legacy `crash(8)` utility. The `crash` utility is no longer
available in illumos.
===

[[using-the-kmdb-kernel-debugger]]
==== Using the `kmdb` Kernel Debugger

* Control of kernel execution
* Inspection of the kernel state
* Live modifications to the code

This section assumes that you are already familiar with the `kmdb`
debugger. The focus in this section is on `kmdb` capabilities that are
useful in device driver design. To learn how to use `kmdb` in detail,
refer to the `kmdb(1)` man page and to the Modular Debugger Guide. If
you are familiar with `kadb`, refer to the `kadb(8)` man page for the
major differences between `kadb` and `kmdb`.

The `kmdb` debugger can be loaded and unloaded at will. Instructions for
loading and unloading `kmdb` are in the Modular Debugger Guide. For
safety and convenience, booting with an alternate kernel is highly
encouraged. The boot process is slightly different between the SPARC
platform and the x86 platform, as described in this section.

[NOTE]

By default, `kmdb` uses the CPU ID as the prompt when `kmdb` is running.
In the examples in this chapter `++[++0++]++` is used as the prompt
unless otherwise noted.
===

[[booting-kmdb-with-an-alternate-kernel-on-the-sparc-platform]]
===== Booting `kmdb` With an Alternate Kernel on the SPARC Platform

booting the

on SPARC systems

booting on SPARC systems

Use either of the following commands to boot a SPARC system with both
`kmdb` and an alternate kernel:

....
boot kmdb -D kernel.test/sparcv9/unix 
boot kernel.test/sparcv9/unix -k
....

[[booting-kmdb-with-an-alternate-kernel-on-the-x86-platform]]
===== Booting `kmdb` With an Alternate Kernel on the x86 Platform

booting the

on x86 systems

booting on x86 systems

Use either of the following commands to boot an x86 system with both
`kmdb` and an alternate kernel:

....
b kmdb -D kernel.test/unix 
b kernel.test/unix -k
....

[[setting-breakpoints-in-kmdb]]
===== Setting Breakpoints in `kmdb`

setting breakpoints

Use the `bp` command to set a breakpoint, as shown in the following
example.

[[ezsuo]]
Setting Standard Breakpoints in `kmdb`

....
[0]> myModule`myBreakpointLocation::bp
....

If the target module has not been loaded, then an error message that
indicates this condition is displayed, and the breakpoint is not
created. In this case you can use a _deferred breakpoint_. A deferred
breakpoint activates automatically when the specified module is loaded.
Set a deferred breakpoint by specifying the target location after the
`bp` command. The following example demonstrates a deferred breakpoint.

[[ezsup]]
Setting Deferred Breakpoints in `kmdb`

....
[0]>::bp myModule`myBreakpointLocation
....

For more information on using breakpoints, see the Modular Debugger
Guide. You can also get help by typing either of the following two
lines:

....
> ::help bp
> ::bp dcmd
....

[[kmdb-macros-for-driver-developers]]
===== `kmdb` Macros for Driver Developers

The `kmdb`(1M) debugger supports macros that can be used to display
kernel data structures. Use `$M` to display `kmdb` macros. Macros are
used in the form:

....
[ address ] $<macroname
....

[NOTE]

Neither the information displayed by these macros nor the format in
which the information is displayed, constitutes an interface. Therefore,
the information and format can change at any time.
===

The `kmdb` macros in the following table are particularly useful to
developers of device drivers. For convenience, legacy macro names are
shown where applicable.

.`kmdb` Macros
[width="100%",cols="34%,33%,33%",options="header",]
|===
|Dcmd |Legacy Macro |Description
|`::devinfo` a|
`devinfo`

`devinfo++_++brief`

`devinfo.prop`

|Print a summary of a device node

|`::walk devinfo++_++parents` |`devinfo.parent` |Walk the ancestors of a
device node

|`::walk devinfo++_++sibling` |`devinfo.sibling` |Walk the siblings of a
device node

|`::minornodes` |`devinfo.minor` |Print the minor nodes that correspond
to the given device node

|`::major2name` | |Print the name of a device that is bound to a given
device node.

|`::devbindings` | |Print the device nodes that are bound to a given
device node or major number.
|===

The `::devinfo` dcmd displays a node state that can have one of the
following values:

`DS++_++ATTACHED`::
  The driver's `attach(9E)` routine returned successfully.
`DS++_++BOUND`::
  The node is bound to a driver, but the driver's `probe(9E)` routine
  has not yet been called.
`DS++_++INITIALIZED`::
  The parent nexus has assigned a bus address for the driver. The
  implementation-specific initializations have been completed. The
  driver's `probe(9E)` routine has not yet been called at this point.
`DS++_++LINKED`::
  The device node has been linked into the kernel's device tree, but the
  system has not yet found a driver for this node.
`DS++_++PROBED`::
  The driver's `probe(9E)` routine returned successfully.
`DS++_++READY`::
  The device is fully configured.

[[using-the-mdb-modular-debugger]]
==== Using the `mdb` Modular Debugger

modular debugger

* Live operating system components
* Operating system crash dumps
* User processes
* User process core dumps
* Object files

The `mdb` debugger provides sophisticated debugging support for
analyzing kernel problems. This section provides an overview of `mdb`
features. For a complete discussion of `mdb`, refer to the Modular
Debugger Guide.

Although `mdb` can be used to alter live kernel state, `mdb` lacks the
kernel execution control that is provided by `kmdb`. As a result `kmdb`
is preferred for runtime debugging. The `mdb` debugger is used more for
static situations.

[NOTE]

The prompt for `mdb` is `++>++`.
===

[[getting-started-with-the-modular-debugger]]
===== Getting Started With the Modular Debugger

The `mdb` debugger provides an extensive programming API for
implementing debugger modules so that driver developers can implement
custom debugging support. The `mdb` debugger also provides many
usability features, such as command-line editing, command history, an
output pager, and online help.

[NOTE]

The `adb` macros should no longer be used. That functionality has
largely been superseded by the dcmds in `mdb`.
===

The `mdb` debugger provides a rich set of modules and dcmds. With these
tools, you can debug the illumos kernel, any associated modules, and
device drivers. These facilities enable you to perform tasks such as:

* Formulate complex debugging queries
* Locate all the memory allocated by a particular thread
* Print a visual picture of a kernel STREAM
* Determine what type of structure a particular address refers to
* Locate leaked memory blocks in the kernel
* Analyze memory to locate stack traces
* Assemble dcmds into modules called _dmods_ for creating customized

To get started, switch to the crash directory and type `mdb`, specifying
a system crash dump, as illustrated in the following example.

[[fahpd]]
Invoking `mdb` on a Crash Dump

....
% cd /var/crash/testsystem
% ls
bounds     unix.0    vmcore.0
% mdb unix.0 vmcore.0
Loading modules: [ unix krtld genunix ufs_log ip usba s1394 cpc nfs ]
> ::status
debugging crash dump vmcore.0 (64-bit) from testsystem
operating system: 5.10 Generic (sun4u)
panic message: zero
dump content: kernel pages only
....

When `mdb` responds with the `++>++` prompt, you can run commands.

To examine the running kernel on a live system, run `mdb` from the
system prompt as follows.

[[fahpg]]
Invoking `mdb` on a Running Kernel

....
# mdb -k
Loading modules: [ unix krtld genunix ufs_log ip usba s1394 ptm cpc ipc nfs ]
> ::status
debugging live kernel (64-bit) on testsystem
operating system: 5.10 Generic (sun4u)
....

[[useful-debugging-tasks-with-kmdb-and-mdb]]
==== Useful Debugging Tasks With `kmdb` and `mdb`

common tasks

This section provides examples of useful debugging tasks. The tasks in
this section can be performed with either `mdb` or `kmdb` unless
specifically noted. This section assumes a basic knowledge of the use of
`kmdb` and `mdb`. Note that the information presented here is dependent
on the type of system used. A Sun Blade 100 workstation running the
64-bit kernel was used to produce these examples.

[CAUTION]

Because irreversible destruction of data can result from modifying data
in kernel structures, you should exercise extreme caution. Do not modify
or rely on data in structures that are not part of the illumos DDI. See
the `Intro(9S)` man page for information on structures that are part of
the illumos DDI.
===

[[exploring-system-registers-with-kmdb]]
===== Exploring System Registers With `kmdb`

system registers

system registers

reading and writing

The `kmdb` debugger can display machine registers as a group or
individually. To display all registers as a group, use `$r` as shown in
the following example.

[[ezsuj]]
Reading All Registers on a SPARC Processor With `kmdb`

....
[0]: $r

g0    0                                 l0      0
g1    100130a4      debug_enter         l1      edd00028
g2    10411c00      tsbmiss_area+0xe00  l2      10449c90
g3    10442000      ti_statetbl+0x1ba   l3      1b
g4    3000061a004                       l4      10474400     ecc_syndrome_tab+0x80
g5    0                                 l5      3b9aca00
g6    0                                 l6      0
g7    2a10001fd40                       l7      0
o0    0                                 i0      0
o1    c                                 i1      10449e50
o2    20                                i2      0
o3    300006b2d08                       i3      10
o4    0                                 i4      0
o5    0                                 i5      b0
sp    2a10001b451                       fp      2a10001b521
o7    1001311c      debug_enter+0x78    i7      1034bb24     zsa_xsint+0x2c4
y     0
tstate: 1604  (ccr=0x0, asi=0x0, pstate=0x16, cwp=0x4)
pstate: ag:0 ie:1 priv:1 am:0 pef:1 mm:0 tle:0 cle:0 mg:0 ig:0
winreg: cur:4 other:0 clean:7 cansave:1 canrest:5 wstate:14
tba   0x10000000
pc    edd000d8 edd000d8:        ta      %icc,%g0 + 125
npc   edd000dc edd000dc:        nop
....

The debugger exports each register value to a variable with the same
name as the register. If you read the variable, the current value of the
register is returned. If you write to the variable, the value of the
associated machine register is changed. The following example changes
the value of the `%o0` register from 0 to 1 on an x86 machine.

[[ezsul]]
Reading and Writing Registers on an x86 Machine With `kmdb`

....
[0]> &lt;eax=K
[0]> 0>eax
[0]> &lt;eax=K
[0]>  c1e6e0f0>eax
....

If you need to inspect the registers of a different processor, you can
use the `::cpuregs` dcmd. The ID of the processor to be examined can be
supplied as either the address to the dcmd or as the value of the `c`
option, as shown in the following example.

[[fapkf]]
Inspecting the Registers of a Different Processor

....
[0]> 0::cpuregs
   %cs = 0x0158            %eax = 0xc1e6e0f0 kmdbmod`kaif_dvec
   %ds = 0x0160            %ebx = 0x00000000
....

The following example switches from processor `0` to processor `3` on a
SPARC machine. The `%g3` register is inspected and then cleared. To
confirm the new value, `%g3` is read again.

[[ezsuq]]
Retrieving the Value of an Individual Register From a Specified

....
[0]> 3::switch
[3]> <g3=K
[3]> 0>g3
[3]> <g3
....

[[detecting-kernel-memory-leaks]]
===== Detecting Kernel Memory Leaks

detecting kernel memory leaks

memory leaks, detecting with

detecting kernel memory leaks with

detecting leaks with

detecting kernel memory leaks

The `::findleaks` dcmd provides powerful, efficient detection of memory
leaks in kernel crash dumps. The full set of kernel-memory debugging
features must be enabled for `::findleaks` to be effective. For more
information, see link:#setting-kmem_flags-debugging-flags[Setting Debugging Flags]. Run `::findleaks`
during driver development and testing to detect code that leaks memory,
thus wasting kernel resources. See Modular Debugger Guide for a complete
discussion of `::findleaks`.

[NOTE]

Code that leaks kernel memory can render the system vulnerable to
denial-of-service attacks.
===

[[writing-debugger-commands-with-mdb]]
===== Writing Debugger Commands With `mdb`

writing commands

The `mdb` debugger provides a powerful API for implementing debugger
facilities that you customize to debug your driver. The Modular Debugger
Guide explains the programming API in detail.

The `SUNWmdbdm` package installs sample `mdb` source code in the
directory `/usr/demo/mdb`. You can use `mdb` to automate lengthy
debugging chores or help to validate that your driver is behaving
properly. You can also package your `mdb` debugging modules with your
driver product. With packaging, these facilities are available to
service personnel at a customer site.

[[obtaining-kernel-data-structure-information]]
===== Obtaining Kernel Data Structure Information

kernel data structures

displaying kernel data structures

The illumos kernel provides data type information in structures that can
be inspected with either `kmdb` or `mdb`.

[NOTE]

The `kmdb` and `mdb` dcmds can be used only with objects that contain
compressed symbolic debugging information that has been designed for use
with `mdb`. This information is currently available only for certain
illumos kernel modules. The `SUNWzlib` package must be installed to
process the symbolic debugging information.
===

The following example demonstrates how to display the data in the
`scsi++_++pkt` structure.

[[fahqd]]
Displaying Kernel Data Structures With a Debugger

[source,c]
----
> 7079ceb0::print -t 'struct scsi_pkt'
{
    opaque_t pkt_ha_private = 0x7079ce20
    struct scsi_address pkt_address = {
        struct scsi_hba_tran *a_hba_tran = 0x70175e68
        ushort_t a_target = 0x6
        uchar_t a_lun = 0
        uchar_t a_sublun = 0
    }
    opaque_t pkt_private = 0x708db4d0
    int (*)() *pkt_comp = sd_intr
    uint_t pkt_flags = 0
    int pkt_time = 0x78
    uchar_t *pkt_scbp = 0x7079ce74
    uchar_t *pkt_cdbp = 0x7079ce64
    ssize_t pkt_resid = 0
    uint_t pkt_state = 0x37
    uint_t pkt_statistics = 0
    uchar_t pkt_reason = 0
}
----

The size of a data structure can be useful in debugging. Use the
`::sizeof` dcmd to obtain the size of a structure, as shown in the
following example.

[[fahpl]]
Displaying the Size of a Kernel Data Structure

....
> ::sizeof struct scsi_pkt
sizeof (struct scsi_pkt) = 0x58
....

The address of a specific member within a structure is also useful in
debugging. Several methods are available for determining a member's
address.

Use the `::offsetof` dcmd to obtain the offset for a given member of a
structure, as in the following example.

[[fahpt]]
Displaying the Offset to a Kernel Data Structure

....
> ::offsetof struct scsi_pkt pkt_state
offsetof (struct pkt_state) = 0x48
....

Use the `::print` dcmd with the `a` option to display the addresses of
all members of a structure, as in the following example.

[[fahph]]
Displaying the Relative Addresses of a Kernel Data Structure

[source,c]
----
> ::print -a struct scsi_pkt
{
    0 pkt_ha_private
    8 pkt_address {
    ...
    }
    18 pkt_private
    ...
}
----

If an address is specified with `::print` in conjunction with the `a`
option, the absolute address for each member is displayed.

[[fahqj]]
Displaying the Absolute Addresses of a Kernel Data Structure

[source,c]
----
> 10000000::print -a struct scsi_pkt
{
    10000000 pkt_ha_private
    10000008 pkt_address {
    ...
    }
    10000018 pkt_private
    ...
}
----

The `::print`, `::sizeof` and `::offsetof` dcmds enable you to debug
problems when your driver interacts with the illumos kernel.

[CAUTION]

This facility provides access to _raw_ kernel data structures. You can
examine any structure whether or not that structure appears as part of
the DDI. Therefore, you should refrain from relying on any data
structure that is not explicitly part of the DDI.
===

[NOTE]

These dcmds should be used only with objects that contain compressed
symbolic debugging information that has been designed for use with
`mdb`. Symbolic debugging information is currently available for certain
illumos kernel modules only. The `SUNWzlib` (32-bit) or `SUNWzlibx`
(64-bit) decompression software must be installed to process the
symbolic debugging information. The `kmdb` debugger can process symbolic
type data with or without the `SUNWzlib` or `SUNWzlibx` packages.
===

[[obtaining-device-tree-information]]
===== Obtaining Device Tree Information

device tree

navigating, in debugger

navigating device tree with

The `mdb` debugger provides the `::prtconf` dcmd for displaying the
kernel device tree. The output of the `::prtconf` dcmd is similar to the
output of the `prtconf(8)` command.

[[fahqi]]
Using the `::prtconf` Dcmd

....
> ::prtconf
300015d3e08      SUNW,Sun-Blade-100
    300015d3c28      packages (driver not attached)
        300015d3868      SUNW,builtin-drivers (driver not attached)
        300015d3688      deblocker (driver not attached)
        300015d34a8      disk-label (driver not attached)
        300015d32c8      terminal-emulator (driver not attached)
        300015d30e8      obp-tftp (driver not attached)
        300015d2f08      dropins (driver not attached)
        300015d2d28      kbd-translator (driver not attached)
        300015d2b48      ufs-file-system (driver not attached)
    300015d3a48      chosen (driver not attached)
    300015d2968      openprom (driver not attached)
....

You can display the node by using a macro, such as the `::devinfo` dcmd,
as shown in the following example.

[[fahpi]]
Displaying Device Information for an Individual Node

....
> 300015d3e08::devinfo
300015d3e08      SUNW,Sun-Blade-100
        System properties at 0x300015abdc0:
            name='relative-addressing' type=int items=1
                value=00000001
            name='MMU_PAGEOFFSET' type=int items=1
                value=00001fff
            name='MMU_PAGESIZE' type=int items=1
                value=00002000
            name='PAGESIZE' type=int items=1
                value=00002000
        Driver properties at 0x300015abe00:
            name='pm-hardware-state' type=string items=1
                value='no-suspend-resume'
....

Use `::prtconf` to see where your driver has attached in the device
tree, and to display device properties. You can also specify the verbose
(`v`) flag to `::prtconf` to display the properties for each device
node, as follows.

[[fahpu]]
Using the `::prtconf` Dcmd in Verbose Mode

....
> ::prtconf -v
DEVINFO          NAME
300015d3e08      SUNW,Sun-Blade-100
        System properties at 0x300015abdc0:
            name='relative-addressing' type=int items=1
                value=00000001
            name='MMU_PAGEOFFSET' type=int items=1
                value=00001fff
            name='MMU_PAGESIZE' type=int items=1
                value=00002000
            name='PAGESIZE' type=int items=1
                value=00002000
        Driver properties at 0x300015abe00:
            name='pm-hardware-state' type=string items=1
                value='no-suspend-resume'
        ...
        300015ce798      pci10b9,5229, instance #0
                Driver properties at 0x300015ab980:
                    name='target2-dcd-options' type=any items=4
                        value=00.00.00.a4
                    name='target1-dcd-options' type=any items=4
                        value=00.00.00.a2
                    name='target0-dcd-options' type=any items=4
                        value=00.00.00.a4
....

Another way to locate instances of your driver is the `::devbindings`
dcmd. Given a driver name, the command displays a list of all instances
of the named driver as demonstrated in the following example.

[[fahpr]]
Using the `::devbindings` Dcmd to Locate Driver Instances

....
> ::devbindings dad
300015ce3d8      ide-disk (driver not attached)
300015c9a60      dad, instance #0
        System properties at 0x300015ab400:
            name='lun' type=int items=1
                value=00000000
            name='target' type=int items=1
                value=00000000
            name='class_prop' type=string items=1
                value='ata'
            name='type' type=string items=1
                value='ata'
            name='class' type=string items=1
                value='dada'
...
300015c9880      dad, instance #1
        System properties at 0x300015ab080:
            name='lun' type=int items=1
                value=00000000
            name='target' type=int items=1
                value=00000002
            name='class_prop' type=string items=1
                value='ata'
            name='type' type=string items=1
                value='ata'
            name='class' type=string items=1
                value='dada'
....

[[retrieving-driver-soft-state-information]]
===== Retrieving Driver Soft State Information

retrieving soft state information

soft state information

retrieving in

A common problem when debugging a driver is retrieving the _soft state_
for a particular driver instance. The soft state is allocated with the
`ddi++_++soft++_++state++_++zalloc(9F)` routine. The driver can obtain
the soft state through `ddi++_++get++_++soft++_++state(9F)`. The name of
the _soft state pointer_ is the first argument to
`ddi++_++soft++_++state++_++init(9F)`). With the name, you can use `mdb`
to retrieve the soft state for a particular driver instance through the
`::softstate` dcmd:

....
> *bst_state::softstate 0x3
....

In this case, `::softstate` is used to fetch the soft state for instance
3 of the `bst` sample driver. This pointer references a `bst++_++soft`
structure that is used by the driver to track state for this instance.

[[modifying-kernel-variables]]
===== Modifying Kernel Variables

using kernel variables

kernel variables

use with debuggers

You can use both `kmdb` and `mdb` to modify kernel variables or other
kernel state. Kernel state modification with `mdb` should be done with
care, because `mdb` does not stop the kernel before making
modifications. Groups of modifications can be made atomically by using
`kmdb`, because `kmdb` stops the kernel before allowing access by the
user. The `mdb` debugger is capable of making single atomic
modifications only.

* `w` – Writes the lowest two bytes of the value of each expression to
the target beginning at the location specified by dot
* `W` – Writes the lowest 4 bytes of the value of each expression to the
target beginning at the location specified by dot
* `Z` – Write the complete 8 bytes of the value of each expression to
the target beginning at the location specified by dot

Use the `::sizeof` dcmd to determine the size of the variable to be
modified.

The following example overwrites the value of `moddebug` with the value
0x80000000.

[[fahpy]]
Modifying a Kernel Variable With a Debugger

....
> moddebug/W 0x80000000
    moddebug:       0 = 0x80000000
....

[[tuning-drivers]]
=== Tuning Drivers

device drivers

tuning device drivers

illumos provides kernel statistics structures so that you can implement
counters for your driver. The DTrace facility enables you to analyze
performance in real time. This section presents the following topics on
device performance:

* link:#kernel-statistics[Kernel Statistics] – illumos provides a set of data
structures and functions for capturing performance statistics in the
kernel. Kernel statistics (called _kstats_) enable your driver to export
continuous statistics while the system is running. The kstat data is
handled programmatically by using the kstat functions.
* link:#dtrace-for-dynamic-instrumentation[DTrace for Dynamic Instrumentation] – DTrace enables you
to add instrumentation to your driver dynamically so that you can
perform tasks like analyzing the system and measuring performance.
DTrace takes advantage of predefined kstat structures.

[[kernel-statistics]]
==== Kernel Statistics

device drivers

using kstats

tuning device drivers

kernel statistics

To assist in performance tuning, the illumos kernel provides the
`kstat(3KSTAT)` facility. The kstat facility provides a set of functions
and data structures for device drivers and other kernel modules to
export module-specific kernel statistics.

A kstat is a data structure for recording quantifiable aspects of a
device's usage. A kstat is stored as a null-terminated linked list. Each
kstat has a common header section and a type-specific data section. The
header section is defined by the `kstat++_++t` structure.

The article “Using kstat From Within a Program in the Solaris OS” on the
Sun Developer Network at
http://developers.sun.com/solaris/articles/kstat_api.html provides two
practical examples on how to use the `kstat(3KSTAT)` and
`libkstat(3LIB)` APIs to extract metrics from illumos. The examples
include “Walking Through All the kstat” and “Getting NIC kstat Output
Using the Java Platform.”

[[kernel-statistics-structure-members]]
===== Kernel Statistics Structure Members

The members of a kstat structure are:

`ks++_++class++[++KSTAT++_++STRLEN++]++`::
  Categorizes the kstat type as `bus`, `controller`, `device++_++error`,
  `disk`, `hat`, `kmem++_++cache`, `kstat`, `misc`, `net`, `nfs`,
  `pages`, `partition`, `rps`, `ufs`, `vm`, or `vmem`.
`ks++_++crtime`::
  Time at which the kstat was created. `ks++_++crtime` is commonly used
  in calculating rates of various counters.
`ks++_++data`::
  Points to the data section for the kstat.
`ks++_++data++_++size`::
  Total size of the data section in bytes.
`ks++_++instance`::
  The instance of the kernel module that created this kstat.
  `ks++_++instance` is combined with `ks++_++module` and `ks++_++name`
  to give the kstat a unique, meaningful name.
`ks++_++kid`::
  Unique ID for the kstat.
`ks++_++module++[++KSTAT++_++STRLEN++]++`::
  Identifies the kernel module that created this kstat. `ks++_++module`
  is combined with `ks++_++instance` and `ks++_++name` to give the kstat
  a unique, meaningful name. `KSTAT++_++STRLEN` sets the maximum length
  of `ks++_++module`.
`ks++_++name++[++KSTAT++_++STRLEN++]++`::
  A name assigned to the kstat in combination with `ks++_++module` and
  `ks++_++instance`. `KSTAT++_++STRLEN` sets the maximum length of
  `ks++_++module`.
`ks++_++ndata`::
  Indicates the number of data records for those kstat types that
  support multiple records: `KSTAT++_++TYPE++_++RAW`,
  `KSTAT++_++TYPE++_++NAMED`, and `KSTAT++_++TYPE++_++TIMER`
`ks++_++next`::
  Points to next kstat in the chain.
`ks++_++resv`::
  A reserved field.
`ks++_++snaptime`::
  The timestamp for the last data snapshot, useful in calculating rates.
`ks++_++type`::
  The data type, which can be `KSTAT++_++TYPE++_++RAW` for binary data,
  `KSTAT++_++TYPE++_++NAMED` for name/value pairs,
  `KSTAT++_++TYPE++_++INTR` for interrupt statistics,
  `KSTAT++_++TYPE++_++IO` for I/O statistics, and
  `KSTAT++_++TYPE++_++TIMER` for event timers.

[[kernel-statistics-structures]]
===== Kernel Statistics Structures

The structures for the different kinds of kstats are:

`kstat(9S)`::
  Each kernel statistic (kstat) that is exported by device drivers
  consists of a header section and a data section. The `kstat(9S)`
  structure is the header portion of the statistic.
`kstat++_++intr(9S)`::
  Structure for interrupt kstats. The types of interrupts are:
  +
  * Hard interrupt – Sourced from the hardware device itself
  * Soft interrupt – Induced by the system through the use of some
  system interrupt source
  * Watchdog interrupt – Induced by a periodic timer call
  * Spurious interrupt – An interrupt entry point was entered but there
  was no interrupt to service
  * Multiple service – An interrupt was detected and serviced just prior
  to returning from any of the other types
  +
  Drivers generally report only claimed hard interrupts and soft
  interrupts from their handlers, but measurement of the spurious class
  of interrupts is useful for auto-vectored devices to locate any
  interrupt latency problems in a particular system configuration.
  Devices that have more than one interrupt of the same type should use
  multiple structures.
`kstat++_++io(9S)`::
  Structure for I/O kstats.
`kstat++_++named(9S)`::
  Structure for named kstats. A named kstat is an array of name-value
  pairs. These pairs are kept in the `kstat++_++named` structure.

[[kernel-statistics-functions]]
===== Kernel Statistics Functions

The functions for using kstats are:

`kstat++_++create(9F)`::
  Allocate and initialize a `kstat(9S)` structure.
`kstat++_++delete(9F)`::
  Remove a kstat from the system.
`kstat++_++install(9F)`::
  Add a fully initialized kstat to the system.
`kstat++_++named++_++init(9F)`, `kstat++_++named++_++setstr(9F)`::
  Initialize a named kstat. `kstat++_++named++_++setstr` associates
  `str`, a string, with the named kstat pointer.
`kstat++_++queue(9F)`::
  A large number of I/O subsystems have at least two basic queues of
  transactions to be managed. One queue is for transactions that have
  been accepted for processing but for which processing has yet to
  begin. The other queue is for transactions that are actively being
  processed but not yet done. For this reason, two cumulative time
  statistics are kept:_wait time_ and _run time_. Wait time is prior to
  service. Run time is during the service. The `kstat++_++queue` family
  of functions manages these times based on the transitions between the
  driver wait queue and run queue:
  +
  * `kstat++_++runq++_++back++_++to++_++waitq(9F)`
  * `kstat++_++runq++_++enter(9F)`
  * `kstat++_++runq++_++exit(9F)`
  * `kstat++_++waitq++_++enter(9F)`
  * `kstat++_++waitq++_++exit(9F)`
  * `kstat++_++waitq++_++to++_++runq(9F)`

[[kernel-statistics-for-illumos-ethernet-drivers]]
===== Kernel Statistics for illumos Ethernet Drivers

Ethernet drivers

The kstat interface described in the following table is an effective way
to obtain Ethernet physical layer statistics from the driver. Ethernet
drivers should export these statistics to guide users in better
diagnosis and repair of Ethernet physical layer problems. With exception
of `link++_++up`, all statistics have a default value of 0 when not
present. The value of the `link++_++up` statistic should be assumed to
be 1.

The following example gives all the shared link setup. In this case
`mii` is used to filter statistics.

....
kstat ce:0:mii:link_*
....

.Ethernet MII/GMII Physical Layer Interface Kernel Statistics
[width="100%",cols="21%,26%,53%",options="header",]
|===
|Kstat Variable |Type |Description
|`xcvr++_++addr` |`KSTAT++_++DATA++_++UINT32` a|
Provides the MII address of the transceiver that is currently in use.

* {empty}(0) - (31) are for the MII address of the physical layer device
in use for a given Ethernet device.
* (-1) is used where there is no externally accessible MII interface,
and therefore the MII address is undefined or irrelevant.

|`xcvr++_++id` |`KSTAT++_++DATA++_++UINT32` |Provides the specific
vendor ID or device ID of the transceiver that is currently in use.

|`xcvr++_++inuse` |`KSTAT++_++DATA++_++UINT32` a|
Indicates the type of transceiver that is currently in use. The IEEE
`aPhytType` enumerates the following set:

* {empty}(0) other undefined
* {empty}(1) no MII interface is present, but no transceiver is
connected
* {empty}(2) 10 Mbits/s Clause 7 10 Mbits/s Manchester
* {empty}(3) 100BASE-T4 Clause 23 100 Mbits/s 8B/6T
* {empty}(4) 100BASE-X Clause 24 100 Mbits/s 4B/5B
* {empty}(5) 100BASE-T2 Clause 32 100 Mbits/s PAM5X5
* {empty}(6) 1000BASE-X Clause 36 1000 Mbits/s 8B/10B
* {empty}(7) 1000BASE-T Clause 40 1000 Mbits/s 4D-PAM5

This set is smaller than the set specified by `ifMauType`, which is
defined to include all of the above plus their half duplex/full duplex
options. Since this information can be provided by the `cap++_++`++*++
statistics, the missing definitions can be derived from the combination
of `xcvr++_++inuse` and `cap++_++`++*++ to provide all the combinations
of `ifMayType`.

|`cap++_++1000fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is 1
Gbits/s full duplex capable.

|`cap++_++1000hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is 1
Gbits/s half duplex capable.

|`cap++_++100fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is
100 Mbits/s full duplex capable.

|`cap++_++100hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is
100 Mbits/s half duplex capable.

|`cap++_++10fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is 10
Mbits/s full duplex capable.

|`cap++_++10hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is 10
Mbits/s half duplex capable.

|`cap++_++asmpause` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is
capable of asymmetric pause Ethernet flow control.

|`cap++_++pause` |`KSTAT++_++DATA++_++CHAR` a|
Indicates the device is capable of symmetric pause Ethernet flow control
when `cap++_++pause` is set to 1 and `cap++_++asmpause` is set to 0.
When `cap++_++asmpause` is set to 1, `cap++_++pause` has the following
meaning:

* `cap++_++pause` = 0 Transmit pauses based on receive congestion.
* `cap++_++pause` = 1 Receive pauses and slow down transmit to avoid
congestion.

|`cap++_++rem++_++fault` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is capable of remote fault indication.

|`cap++_++autoneg` |`KSTAT++_++DATA++_++CHAR` |Indicates the device is
capable of auto-negotiation.

|`adv++_++cap++_++1000fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 1 Gbits/s full duplex capability.

|`adv++_++cap++_++1000hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 1 Gbits/s half duplex capability.

|`adv++_++cap++_++100fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 100 Mbits/s full duplex capability.

|`adv++_++cap++_++100hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 100 Mbits/s half duplex capability.

|`adv++_++cap++_++10fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 10 Mbits/s full duplex capability.

|`adv++_++cap++_++10hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising 10 Mbits/s half duplex capability.

|`adv++_++cap++_++asmpause` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising the capability of asymmetric pause Ethernet flow
control.

|`adv++_++cap++_++pause` |`KSTAT++_++DATA++_++CHAR` a|
Indicates the device is advertising the capability of symmetric pause
Ethernet flow control when `adv++_++cap++_++pause` is set to 1 and
`adv++_++cap++_++asmpause` is set to 0. When `adv++_++cap++_++asmpause`
is set to 1, `adv++_++cap++_++pause` has the following meaning:

* `adv++_++cap++_++pause` = 0 Transmit pauses based on receive
congestion.
* `adv++_++cap++_++pause` = 1 Receive pauses and slow down transmit to
avoid congestion.

|`adv++_++rem++_++fault` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is experiencing a fault that it is going to forward to the link
partner.

|`adv++_++cap++_++autoneg` |`KSTAT++_++DATA++_++CHAR` |Indicates the
device is advertising the capability of auto-negotiation.

|`lp++_++cap++_++1000fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 1 Gbits/s full duplex capable.

|`lp++_++cap++_++1000hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 1 Gbits/s half duplex capable.

|`lp++_++cap++_++100fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 100 Mbits/s full duplex capable.

|`lp++_++cap++_++100hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 100 Mbits/s half duplex capable.

|`lp++_++cap++_++10fdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 10 Mbits/s full duplex capable.

|`lp++_++cap++_++10hdx` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is 10 Mbits/s half duplex capable.

|`lp++_++cap++_++asmpause` |`KSTAT++_++DATA++_++CHAR` |Indicates the
link partner device is capable of asymmetric pause Ethernet flow
control.

|`lp++_++cap++_++pause` |`KSTAT++_++DATA++_++CHAR` a|
Indicates the link partner device is capable of symmetric pause Ethernet
flow control when `lp++_++cap++_++pause` is set to 1 and
`lp++_++cap++_++asmpause` is set to 0. When `lp++_++cap++_++asmpause` is
set to 1, `lp++_++cap++_++pause` has the following meaning:

* `lp++_++cap++_++pause` = 0 Link partner will transmit pauses based on
receive congestion.
* `lp++_++cap++_++pause` = 1 Link partner will receive pauses and slow
down transmit to avoid congestion.

|`lp++_++rem++_++fault` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner is experiencing a fault with the link.

|`lp++_++cap++_++autoneg` |`KSTAT++_++DATA++_++CHAR` |Indicates the link
partner device is capable of auto-negotiation.

|`link++_++asmpause` |`KSTAT++_++DATA++_++CHAR` |Indicates the link is
operating with asymmetric pause Ethernet flow control.

|`link++_++pause` |`KSTAT++_++DATA++_++CHAR` a|
Indicates the resolution of the pause capability. Indicates the link is
operating with symmetric pause Ethernet flow control when
`link++_++pause` is set to 1 and `link++_++asmpause` is set to 0. When
`link++_++asmpause` is set to 1 and is relative to a local view of the
link, `link++_++pause` has the following meaning:

* `link++_++pause` = 0 This station will transmit pauses based on
receive congestion.
* `link++_++pause` = 1 This station will receive pauses and slow down
transmit to avoid congestion.

|`link++_++duplex` |`KSTAT++_++DATA++_++CHAR` a|
Indicates the link duplex.

* `link++_++duplex` = 0 Link is down and duplex is unknown.
* `link++_++duplex` = 1 Link is up and in half duplex mode.
* `link++_++duplex` = 2 Link is up and in full duplex mode.

|`link++_++up` |`KSTAT++_++DATA++_++CHAR` a|
Indicates whether the link is up or down.

* `link++_++up` = 0 Link is down.
* `link++_++up` = 1 Link is up.

|===

[[dtrace-for-dynamic-instrumentation]]
==== DTrace for Dynamic Instrumentation

tuning device drivers

DTrace is a comprehensive dynamic tracing facility for examining the
behavior of both user programs and the operating system itself. With
DTrace, you can collect data at strategic locations in your environment,
referred to as _probes_. DTrace enables you to record such data as stack
traces, timestamps, the arguments to a function, or simply counts of how
often the probe fires. Because DTrace enables you to insert probes
dynamically, you do not need to recompile your code. For more
information on DTrace, see the Dynamic Tracing Guide and the
http://www.dtrace.org/guide[DTrace User Guide].

[[recommended-coding-practices]]
=== Recommended Coding Practices

This chapter describes how to write drivers that are robust. Drivers
that are written in accordance with the guidelines that are discussed in
this chapter are easier to debug. The recommended practices also protect
the system from hardware and software faults.

This chapter provides information on the following subjects:

* link:#debugging-preparation-techniques[Debugging Preparation Techniques]
* link:#declaring-a-variable-volatile[Declaring a Variable Volatile]
* link:#serviceability[Serviceability]

[[debugging-preparation-techniques]]
=== Debugging Preparation Techniques

Driver code is more difficult to debug than user programs because:

* The driver interacts directly with the hardware
* The driver operates without the protection of the operating system
that is available to user processes

Be sure to build debugging support into
your driver. This support facilitates both maintenance work and future
development.

[[use-a-unique-prefix-to-avoid-kernel-symbol-collisions]]
==== Use a Unique Prefix to Avoid Kernel Symbol Collisions

unique prefix for driver symbols

unique prefix for driver symbols

The name of each function, data element, and driver preprocessor
definition must be unique for each driver.

A driver module is linked into the kernel. The name of each symbol
unique to a particular driver must not collide with other kernel
symbols. To avoid such collisions, each function and data element for a
particular driver must be named with a prefix common to that driver. The
prefix must be sufficient to uniquely name each driver symbol.
Typically, this prefix is the name of the driver or an abbreviation for
the name of the driver. For example, `xx++_++open` would be the name of
the `open(9E)` routine of driver `xx`.

When building a driver, a driver must necessarily include a number of
system header files. The globally-visible names within these header
files cannot be predicted. To avoid collisions with these names, each
driver preprocessor definition must be given a unique name by using an
identifying prefix.

A distinguishing driver symbol prefix also is an aid to deciphering
system logs and panics when troubleshooting. Instead of seeing an error
related to an ambiguous `attach` function, you see an error message
about `xx++_++attach`.

[[use-cmn_err-to-log-driver-activity]]
==== Use `cmn++_++err` to Log Driver Activity

Use the `cmn++_++err(9F)` function to print messages to
a system log from within the device driver. The `cmn++_++err(9F)`
function for kernel modules is similar to the `printf(3C)` function for
applications. The `cmn++_++err(9F)` function provides additional format
characters, such as the `%b` format to print device register bits. The
`cmn++_++err(9F)` function writes messages to a system log. Use the
`tail(1)` command to monitor these messages on `/var/adm/messages`.

....
% tail -f /var/adm/messages
....

[[use-assert-to-catch-invalid-assumptions]]
==== Use `ASSERT` to Catch Invalid Assumptions

Assertions are an extremely valuable form of active documentation. The
syntax for `ASSERT(9F)` is as follows:

....
void ASSERT(EXPRESSION)
....

The `ASSERT` macro halts the execution of the kernel if a condition that
is expected to be true is actually false. `ASSERT` provides a way for
the programmer to validate the assumptions made by a piece of code.

The `ASSERT` macro is defined only when the `DEBUG` compilation symbol
is defined. When `DEBUG` is not defined, the `ASSERT` macro has no
effect.

The following example assertion tests the assumption that a particular
pointer value is not `NULL`:

....
ASSERT(ptr != NULL);
....

If the driver has been compiled with `DEBUG`, and if the value of `ptr`
is `NULL` at this point in execution, then the following panic message
is printed to the console:

....
panic: assertion failed: ptr != NULL, file: driver.c, line: 56
....

[NOTE]

Because `ASSERT(9F)` uses the `DEBUG` compilation symbol, any
conditional debugging code should also use `DEBUG`.
===

[[use-mutex_owned-to-validate-and-document-locking-requirements]]
==== Use `mutex++_++owned` to Validate and Document Locking Requirements

The syntax for `mutex++_++owned(9F)` is as follows:

[source,c]
----
int mutex_owned(kmutex_t *mp);
----

A significant portion of driver development involves
properly handling multiple threads. Comments should always be used when
a mutex is acquired. Comments can be even more useful when an apparently
necessary mutex is _not_ acquired. To determine whether a mutex is held
by a thread, use `mutex++_++owned` within `ASSERT(9F)`:

[source,c]
----
void helper(void)
{
    /* this routine should always be called with xsp's mutex held */
    ASSERT(mutex_owned(&xsp->mu));
    /* ... */
}
----

[NOTE]

`mutex++_++owned` is only valid within `ASSERT` macros. You should use
`mutex++_++owned` to control the behavior of a driver.
===

[[use-conditional-compilation-to-toggle-costly-debugging-features]]
==== Use Conditional Compilation to Toggle Costly Debugging Features

You can insert code for debugging into a driver through
conditional compiles by using a preprocessor symbol such as `DEBUG` or
by using a global variable. With conditional compilation, unnecessary
code can be removed in the production driver. Use a variable to set the
amount of debugging output at runtime. The output can be specified by
setting a debugging level at runtime with an `ioctl` or through a
debugger. Commonly, these two methods are combined.

The following example relies on the compiler to remove unreachable code,
in this case, the code following the always-false test of zero. The
example also provides a local variable that can be set in `/etc/system`
or patched by a debugger.

[source,c]
----
#ifdef DEBUG
/* comments on values of xxdebug and what they do */
static int xxdebug;
#define dcmn_err if (xxdebug) cmn_err
#else
#define dcmn_err if (0) cmn_err
#endif
/* ... */
    dcmn_err(CE_NOTE, "Error!\n");
----

This method handles the fact that `cmn++_++err(9F)` has a variable
number of arguments. Another method relies on the fact that the macro
has one argument, a parenthesized argument list for `cmn++_++err(9F)`.
The macro removes this argument. This macro also removes the reliance on
the optimizer by expanding the macro to nothing if `DEBUG` is not
defined.

[source,c]
----
#ifdef DEBUG
/* comments on values of xxdebug and what they do */
static int xxdebug;
#define dcmn_err(X) if (xxdebug) cmn_err X
#else
#define dcmn_err(X) /* nothing */
#endif
/* ... */
/* Note:double parentheses are required when using dcmn_err. */
    dcmn_err((CE_NOTE, "Error!"));
----

You can extend this technique in many ways. One way is to specify
different messages from `cmn++_++err(9F)`, depending on the value of
`xxdebug`. However, in such a case, you must be careful not to obscure
the code with too much debugging information.

Another common scheme is to write an `xxlog` function, which uses
`vsprintf(9F)` or `vcmn++_++err(9F)` to handle variable argument lists.

[[declaring-a-variable-volatile]]
=== Declaring a Variable Volatile

`volatile` is a keyword that must be applied when declaring any variable
that will reference a device register. Without the use of `volatile`,
the compile-time optimizer can inadvertently delete important accesses.
Neglecting to use `volatile` might result in bugs that are difficult to
track down.

The correct use of `volatile` is necessary to prevent
elusive bugs. The `volatile` keyword instructs the compiler to use exact
semantics for the declared objects, in particular, not to remove or
reorder accesses to the object. Two instances where device drivers must
use the `volatile` qualifier are:

* When data refers to an external hardware device register, that is,
memory that has side effects other than just storage. Note, however,
that if the DDI data access functions are used to access device
registers, you do not have to use `volatile`.
* When data refers to global memory that is accessible by more than one
thread, that is not protected by locks, and that relies on the
sequencing of memory accesses. Using `volatile`consumes fewer resources
than using lock.

The following example uses `volatile`. A busy flag is used to prevent a
thread from continuing while the device is busy and the flag is not
protected by a lock:

[source,c]
----
while (busy) {
    /* do something else */
}
----

The testing thread will continue when another thread turns off the
`busy` flag:

....
busy = 0;
....

Because `busy` is accessed frequently in the testing thread, the
compiler can potentially optimize the test by placing the value of
`busy` in a register and test the contents of the register without
reading the value of `busy` in memory before every test. The testing
thread would never see `busy` change and the other thread would only
change the value of `busy` in memory, resulting in deadlock. Declaring
the `busy` flag as `volatile` forces its value to be read before each
test.

[NOTE]

An alternative to the `busy` flag is to use a condition variable. See
link:#condition-variables-in-thread-synchronization[Condition Variables in Thread Synchronization].
===

When using the `volatile` qualifier, avoid the risk of accidental
omission. For example, the following code

[source,c]
----
struct device_reg {
    volatile uint8_t csr;
    volatile uint8_t data;
};
struct device_reg *regp;
----

is preferable to the next example:

[source,c]
----
struct device_reg {
    uint8_t csr;
    uint8_t data;
};
volatile struct device_reg *regp;
----

Although the two examples are functionally equivalent, the second one
requires the writer to ensure that `volatile` is used in every
declaration of type `struct` `device++_++reg`. The first example results
in the data being treated as volatile in all declarations and is
therefore preferred. As mentioned above, using the DDI data access
functions to access device registers makes qualifying variables as
`volatile` unnecessary.

=== Serviceability

To ensure serviceability, the driver must be enabled to take the
following actions:

* Detect faulty devices and report the
fault
* Remove a device as supported by the illumos hot-plug
model
* Add a new device as supported by the illumos hot-plug
model
* Perform periodic health checks to enable the detection
of latent faults

==== Periodic Health Checks

A latent fault is one that does not show
itself until some other action occurs. For example, a hardware failure
occurring in a device that is a cold standby could remain undetected
until a fault occurs on the master device. At this point, the system now
contains two defective devices and might be unable to continue
operation.

Latent faults that remain undetected typically cause system failure
eventually. Without latent fault checking, the overall availability of a
redundant system is jeopardized. To avoid this situation, a device
driver must detect latent faults and report them in the same way as
other faults.

You should provide the driver with a mechanism for making periodic
health checks on the device. In a fault-tolerant situation where the
device can be the secondary or failover device, early detection of a
failed secondary device is essential to ensure that the secondary device
can be repaired or replaced before any failure in the primary device
occurs.

Periodic health checks can be used to perform the following activities:

* Check any register or memory location on the device whose value might
have been altered since the last poll.
+
Features of a device that typically exhibit deterministic behavior
include heartbeat semaphores, device timers (for example, local `lbolt`
used by download), and event counters. Reading an updated predictable
value from the device gives a degree of confidence that things are
proceeding satisfactorily.
* Timestamp outgoing requests such as transmit blocks or commands that
are issued by the driver.
+
The periodic health check can look for any suspect requests that have
not completed.
* Initiate an action on the device that should be completed before the
next scheduled check.
+
If this action is an interrupt, this check is an ideal way to ensure
that the device's circuitry can deliver an interrupt.

== Appendixes

The appendixes provide the following background material:

* link:#hardware-overview[appendix++_++title] discusses multiplatform hardware
issues for device drivers.
* link:#summary-of-illumos-ddidki-services[appendix++_++title] provides tables of kernel
functions for device drivers. Deprecated functions are indicated as
well.
* link:#making-a-device-driver-64-bit-ready[appendix++_++title] provides guidelines for updating
a device driver to run in a 64-bit environment.
* link:#console-frame-buffer-drivers[appendix++_++title] describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.

[[hardware-overview]]
=== Hardware Overview

This appendix discusses general issues about hardware that is capable of
supporting illumos. The discussion includes the processor, bus
architectures, and memory models that are supported by illumos. Various
device issues and the PROM used in Sun platforms are also covered.

[NOTE]

The material in this appendix is for informational purposes only. This
information might be of use during driver debugging. However, many of
these implementation details are hidden from device drivers by the
illumos DDI/DKI interfaces.
===

This appendix provides information on the following subjects:

* link:#sparc-processor-issues[SPARC Processor Issues]
* link:#x86-processor-issues[x86 Processor Issues]
* link:#endianness[Endianness]
* link:#store-buffers[Store Buffers]
* link:#system-memory-model[System Memory Model]
* link:#bus-architectures[Bus Architectures]
* link:#bus-specifics[Bus Specifics]
* link:#device-issues[Device Issues]
* link:#prom-on-sparc-machines[PROM on SPARC Machines]

[[sparc-processor-issues]]
=== SPARC Processor Issues

  This section describes a
number of SPARC processor-specific topics such as data alignment, byte
ordering, register windows, and availability of floating-point
instructions. For information on x86 processor-specific topics, see
link:#x86-processor-issues[x86 Processor Issues].

[NOTE]

Drivers should never perform floating-point operations, because these
operations are not supported in the kernel.
===

[[sparc-data-alignment]]
==== SPARC Data Alignment

SPARC processor

data alignment

data alignment for SPARC

All quantities must be aligned on their natural boundaries, using
standard C data types:

* `short` integers are aligned on 16-bit boundaries.
* `int` integers are aligned on 32-bit boundaries.
* `long` integers are aligned on 64-bit boundaries for SPARC systems.
For information on data models, see
link:#making-a-device-driver-64-bit-ready[appendix++_++title].
* `long long` integers are aligned on 64-bit boundaries.

Usually, the compiler handles any alignment issues. However, driver
writers are more likely to be concerned about alignment because the
proper data types must be used to access the devices. Because device
registers are commonly accessed through a pointer reference, drivers
must ensure that pointers are properly aligned when accessing the
device.

[[member-alignment-in-sparc-structures]]
==== Member Alignment in SPARC Structures

SPARC processor

structure member alignment

Because of the data alignment restrictions imposed by the SPARC
processor, C structures also have alignment requirements. Structure
alignment requirements are imposed by the most strictly aligned
structure component. For example, a structure containing only characters
has no alignment restrictions, while a structure containing a `long`
`long` member must be constructed to guarantee that this member falls on
a 64-bit boundary.

[[sparc-byte-ordering]]
==== SPARC Byte Ordering

SPARC processor

byte ordering

The SPARC processor uses _big-endian_ byte ordering. The most
significant byte (MSB) of an integer is stored at the lowest address of
the integer. The least significant byte is stored at the highest address
for words in this processor. For example, byte 63 is the least
significant byte for 64-bit processors.

image:figures/hwovr-sparcbyteorder[Diagram shows how bytes are ordered
in big-endian architectures, that is, byte 0 is the most significant
byte.]

[[sparc-register-windows]]
==== SPARC Register Windows

SPARC processor

register windows

SPARC processors use register windows. Each register window consists of
eight _in_ registers, eight _local_ registers, eight _out_ registers,
and eight _global_ registers. Out registers are the in registers for the
next window. The number of register windows ranges from 2 to 32,
depending on the processor implementation.

Because drivers are normally written in C, the compiler
usually hides the fact that register windows are used. However, you
might have to use register windows when debugging the driver.

[[sparc-multiply-and-divide-instructions]]
==== SPARC Multiply and Divide Instructions

SPARC processor

multiply and divide instructions

The Version 7 SPARC processors do not have multiply or
divide instructions. The multiply and divide instructions are emulated
in software. Because a driver might run on a Version 7, Version 8, or
Version 9 processor, avoid intensive integer multiplication and
division. Instead, use bitwise left and right shifts to multiply and
divide by powers of two.

The SPARC Architecture Manual, Version 9, contains more specific
information on the SPARC CPU. The SPARC Compliance Definition, Version
2.4, contains details of the application binary interface (ABI) for
SPARC V9. The manual describes the 32-bit SPARC V8 ABI and the 64-bit
SPARC V9 ABI. You can obtain this document from SPARC International at
http://www.sparc.com.

[[x86-processor-issues]]
=== x86 Processor Issues

Data types have
no alignment restrictions. However, extra memory cycles might be
required for the x86 processor to properly handle misaligned data
transfers.

[NOTE]

Drivers should not perform floating-point operations, as these
operations are not supported in the kernel.
===

[[x86-byte-ordering]]
==== x86 Byte Ordering

x86 processor

byte ordering

The x86 processors use _little-endian_ byte ordering. The least
significant byte (LSB) of an integer is stored at the lowest address of
the integer. The most significant byte is stored at the highest address
for data items in this processor. For example, byte 7 is the most
significant byte for 64-bit processors.

image:figures/hwovr-iabyteorder[Diagram shows how bytes are ordered in
little-endian architectures, that is, byte 0 is the least significant
byte.]

[[x86-architecture-manuals]]
==== x86 Architecture Manuals

Both Intel Corporation and AMD publish a number of books on the x86
family of processors. See http://www.intel.com and http://www.amd.com/.

[[endianness]]
=== Endianness

To achieve the goal of multiple-platform,
multiple-instruction-set architecture portability, host bus dependencies
were removed from the drivers. The first dependency issue to be
addressed was the endianness, that is, byte ordering, of the processor.
For example, the x86 processor family is little-endian while the SPARC
architecture is big-endian.

Bus architectures display the same endianness types as processors. The
PCI local bus, for example, is little-endian, the SBus is big-endian,
the ISA bus is little-endian, and so on.

To maintain portability between processors and buses,
DDI-compliant drivers must be endian neutral. Although drivers can
manage their endianness by runtime checks or by preprocessor directives
like `#ifdef ++_++LITTLE++_++ENDIAN` in the source code, long-term
maintenance can be troublesome. In some cases, the DDI framework
performs the byte swapping using a software approach. In other cases,
byte swapping can be done by hardware page-level swapping as in memory
management unit (MMU) or by special machine instructions. The DDI
framework can take advantage of the hardware features to improve
performance.

.Byte Ordering Required for Host Bus Dependency
[#hwovr-fig-67]
image::figures/hwovr-byteorderbusdepend.png[Diagram shows byte swapping to reverse endianness.]

Along with being endian-neutral, portable drivers must also be
independent from data ordering of the processor. Under most
circumstances, data must be transferred in the sequence instructed by
the driver. However, sometimes data can be merged, batched, or reordered
to streamline the data transfer, as illustrated in the following figure.
For example, data merging can be applied to accelerate graphics display
on frame buffers. Drivers have the option to advise the DDI framework to
use other optimal data transfer mechanisms during the transfer.

.Data Ordering Host Bus Dependency
[#hwovr-fig-69]
image::figures/hwovr-dataorderbusdepend.png[Diagram shows reordering of bytes by CPU.]

[[store-buffers]]
=== Store Buffers

memory model

store buffers

store buffers

To improve performance, the CPU uses internal store buffers to
temporarily store data. Using internal buffers can affect the
synchronization of device I/O operations. Therefore, the driver needs to
take explicit steps to make sure that writes to registers are completed
at the proper time.

For example, consider the case where access to device space, such as
registers or a frame buffer, is synchronized by a lock. The driver needs
to check that the store to the device space has actually completed
before releasing the lock. The release of the lock does not guarantee
the flushing of I/O buffers.

To give another example, when acknowledging an interrupt, the driver
usually sets or clears a bit in a device control register. The driver
must ensure that the write to the control register has reached the
device before the interrupt handler returns. Similarly, a device might
require a delay, that is, driver busy-waits, after writing a command to
the control register. In such a case, the driver must ensure that the
write has reached the device before delaying.

Where device registers can be read without undesirable side effects,
verification of a write can simply consist of reading the register
immediately after the write. If that particular register cannot be read
without undesirable side effects, another device register in the same
register set can be used.

[[system-memory-model]]
=== System Memory Model

The system memory model defines the
semantics of memory operations such as _load_ and _store_ and specifies
how the order in which these operations are issued by a processor is
related to the order in which they reach memory. The memory model
applies to both uniprocessors and shared-memory multiprocessors. Two
memory models are supported: total store ordering (TSO) and partial
store ordering (PSO).

[[total-store-ordering-tso]]
==== Total Store Ordering (TSO)

TSO guarantees that the sequence in which store, FLUSH, and atomic
load-store instructions appear in memory for a given processor is
identical to the sequence in which they were issued by the processor.

Both x86 and SPARC processors support TSO.

[[partial-store-ordering-pso]]
==== Partial Store Ordering (PSO)

PSO does not guarantee that the sequence in which store,
FLUSH, and atomic load-store instructions appear in memory for a given
processor is identical to the sequence in which they were issued by the
processor. The processor can reorder the stores so that the sequence of
stores to memory is not the same as the sequence of stores issued by the
CPU.

SPARC processors support PSO; x86 processors do not.

For SPARC processors, conformance between _issuing_ order and _memory_
order is provided by the system framework using the STBAR instruction.
If two of the above instructions are separated by an STBAR instruction
in the issuing order of a processor, or if the instructions reference
the same location, the memory order of the two instructions is the same
as the issuing order. Enforcement of strong data-ordering in
DDI-compliant drivers is provided by the
`ddi++_++regs++_++map++_++setup(9F)` interface. Compliant drivers cannot
use the STBAR instruction directly.

See the SPARC Architecture Manual, Version 9, for more details on the
SPARC memory model.

[[bus-architectures]]
=== Bus Architectures

This section describes device
identification, device addressing, and interrupts.

[[device-identification]]
==== Device Identification

identification is the process of determining which devices are present
in the system. Some devices are self-identifying meaning that the device
itself provides information to the system so that the system can
identify the device driver that needs to be used. SBus and PCI local bus
devices are examples of self-identifying devices. On SBus, the
information is usually derived from a small Forth program stored in the
FCode PROM on the device. Most PCI devices provide a configuration space
containing device configuration information. See the `sbus(5)` and
`pci(5)` man pages for more information.

All modern bus architectures require devices to be self-identifying.

[[supported-interrupt-types]]
==== Supported Interrupt Types

The illumos platform supports both polling and vectored interrupts. The
illumos DDI/DKI interrupt model is the same for both types of
interrupts. See link:#interrupt-handlers[Interrupt Handlers] for more
information about interrupt handling.

[[bus-specifics]]
=== Bus Specifics

This section covers addressing and device configuration issues specific
to the buses that the illumos platform supports.

[[pci-local-bus]]
==== PCI Local Bus

  The PCI local bus
is a high-performance bus designed for high-speed data transfer. The PCI
bus resides on the system board. This bus is normally used as an
interconnect mechanism between highly integrated peripheral components,
peripheral add-on boards, and host processor or memory systems. The host
processor, main memory, and the PCI bus itself are connected through a
PCI host bridge, as shown in link:#hwovr-fig-23[Machine Block Diagram].

A tree structure of interconnected I/O buses is supported through a
series of PCI bus bridges. Subordinate PCI bus bridges can be extended
underneath the PCI host bridge to enable a single bus system to be
expanded into a complex system with multiple secondary buses. PCI
devices can be connected to one or more of these secondary buses. In
addition, other bus bridges, such as SCSI or USB, can be connected.

Every PCI device has a unique vendor ID and
device ID. Multiple devices of the same kind are further identified by
their unique device numbers on the bus where they reside.

.Machine Block Diagram
[#hwovr-fig-23]
image::figures/hwovr-machinediagram.png[Diagram shows how a PCI host bridge connects the CPU and main memory to a PCI bus.]

The PCI host bridge provides an interconnect between the processor and
peripheral components. Through the PCI host bridge, the processor can
directly access main memory independent of other PCI bus masters. For
example, while the CPU is fetching data from the cache controller in the
host bridge, other PCI devices can also access the system memory through
the host bridge. The advantage of this architecture is that this
architecture separates the I/O bus from the processor's host bus.

The PCI host bridge also provides data access mappings between the CPU
and peripheral I/O devices. The bridge maps every peripheral device to
the host address domain so that the processor can access the device
through programmed I/O. On the local bus side, the PCI host bridge maps
the system memory to the PCI address domain so that the PCI device can
access the host memory as a bus master. link:#hwovr-fig-23[Machine Block
Diagram] shows the two address domains.

[[pci-address-domain]]
==== PCI Address Domain

The PCI address domain consists of three distinct address spaces:
configuration, memory, and I/O space.

[[pci-configuration-address-space]]
===== PCI Configuration Address Space

Configuration space is defined
geographically. The location of a peripheral device is determined by its
physical location within an interconnected tree of PCI bus bridges. A
device is located by its _bus number_ and _device_ (_slot_) _number_.
Each peripheral device contains a set of well-defined configuration
registers in its PCI configuration space. The registers are used not
only to identify devices but also to supply device configuration
information to the configuration framework. For example, base address
registers in the device configuration space must be mapped before a
device can respond to data access.

The method for generating configuration cycles is host dependent. In x86
machines, special I/O ports are used. On other platforms, the PCI
configuration space can be memory-mapped to certain address locations
corresponding to the PCI host bridge in the host address domain. When a
device configuration register is accessed by the processor, the request
is routed to the PCI host bridge. The bridge then translates the access
into proper configuration cycles on the bus.

[[pci-configuration-base-address-registers]]
===== PCI Configuration Base Address Registers

The PCI configuration space consists of up
to six 32-bit base address registers for each device. These registers
provide both size and data type information. System firmware assigns
base addresses in the PCI address domain to these registers.

Each addressable region can be either memory or I/O space. The value
contained in bit 0 of the base address register identifies the type. A
value of 0 in bit 0 indicates a memory space and a value of 1 indicates
an I/O space. The following figure shows two base address registers: one
for memory and the other for I/O types.

.Base Address Registers for Memory and I/O
[#hwovr-fig-29]
image::figures/hwovr-memiobaseaddr.png[Diagram shows how bit 0 in a base address indicates a memory or I/O space.]

[[pci-memory-address-space]]
===== PCI Memory Address Space

PCI supports both 32-bit and 64-bit addresses
for memory space. System firmware assigns regions of memory space in the
PCI address domain to PCI peripherals. The base address of a region is
stored in the base address register of the device's PCI configuration
space. The size of each region must be a power of two, and the assigned
base address must be aligned on a boundary equal to the size of the
region. Device addresses in memory space are _memory-mapped_ into the
host address domain so that data access to any device can be performed
by the processor's native load or store instructions.

[[pci-io-address-space]]
===== PCI I/O Address Space

PCI supports 32-bit I/O space. I/O space can
be accessed differently on different platforms. Processors with special
I/O instructions, like the Intel processor family, access the I/O space
with `in` and `out` instructions. Machines without special I/O
instructions will map to the address locations corresponding to the PCI
host bridge in the host address domain. When the processor accesses the
memory-mapped addresses, an I/O request will be sent to the PCI host
bridge, which then translates the addresses into I/O cycles and puts
them on the PCI bus. Memory-mapped I/O is performed by the native
load/store instructions of the processor.

[[pci-hardware-configuration-files]]
===== PCI Hardware Configuration Files

configuration files should be unnecessary for PCI local bus devices.
However, on some occasions drivers for PCI devices need to use hardware
configuration files to augment the driver private information. See the
`driver.conf(5)` and `pci(5)` man pages for further details.

[[pci-express]]
==== PCI Express

The standard PCI bus has evolved into PCI Express. PCI Express is the
next generation high performance I/O bus for connecting peripheral
devices in such applications as desktop, mobile, workstation, server,
embedded computing and communication platforms.

PCI Express improves bus performance, reduces overall system cost and
takes advantage of new developments in computer design. PCI Express uses
a serial, point-to-point type interconnect for communication between two
devices. Using switches enables users to connect a large number of
devices together in a system. Serial interconnect implies fewer pins per
device package, which reduces cost and makes the performance highly
scalable.

The PCI Express bus has built-in features to accommodate the following
technologies:

* QoS (Quality of Service)
* Hotplugging and hot swap
* Advanced power management
* RAS (Reliability, Available, Serviceable)
* Improved error handling
* MSI interrupts

A PCI Express interconnect that connects two devices together is called
a _link_. A link can either be x1, x2, x4, x8, x12, x16 or x32
bidirectional signal pairs. These signals are called _lanes_. The
bandwidth (x1) of each lane is 500 MB/sec in duplex mode. Although PCI-X
and PCI Express have different hardware connections, the two buses are
identical from a driver writer's point of view. PCI-X is a shared bus.
For example, all the devices on the bus share a single set of data lines
and signal lines. PCI-Express is a switched bus, which enables more
efficient use of the bandwidth between the devices and the system bus.

For more information on PCI Express, please refer to the following web
site: http://www.pcisig.com/

[[sbus]]
==== SBus

Typical SBus systems consist of a
motherboard (containing the CPU and SBus interface logic), a number of
SBus devices on the motherboard itself, and a number of SBus expansion
slots. An SBus can also be connected to other types of buses through an
appropriate bus bridge.

The SBus is geographically addressed. Each
SBus slot exists at a fixed physical address in the system. An SBus card
has a different address, depending on which slot it is plugged into.
Moving an SBus device to a new slot causes the system to treat this
device as a new device.

The SBus uses polling interrupts. When an SBus device interrupts, the
system only knows which of several devices might have issued the
interrupt. The system interrupt handler must ask the driver for each
device whether that device is responsible for the interrupt.

[[sbus-physical-address-space]]
===== SBus Physical Address Space

The following table shows the physical
address space layout of the Sun UltraSPARC 2 computer. A physical
address on the UltraSPARC 2 model consists of 41 bits. The 41-bit
physical address space is further broken down into multiple 33-bit
address spaces identified by `PA(40:33)`.

.Device Physical Space in the Ultra 2
[width="100%",cols="23%,44%,33%",options="header",]
|===
|PA(40:33) |33-bit Space |Usage
|0x0 |`0x000000000 - 0x07FFFFFFF` |2 Gbytes main memory
|0x80 – 0xDF |`Reserved on Ultra 2` |Reserved on Ultra 2
|0xE0 |`Processor 0` |Processor 0
|0xE1 |`Processor 1` |Processor 1
|0xE2 – 0xFD |`Reserved on Ultra 2` |Reserved on Ultra 2
|0xFE |`0x000000000 - 0x1FFFFFFFF` |UPA Slave (FFB)
|0xFF |`0x000000000 - 0x0FFFFFFFF` |System I/O space
| |`0x100000000 - 0x10FFFFFFF` |SBus Slot 0
| |`0x110000000 - 0x11FFFFFFF` |SBus Slot 1
| |`0x120000000 - 0x12FFFFFFF` |SBus Slot 2
| |`0x130000000 - 0x13FFFFFFF` |SBus Slot 3
| |`0x1D0000000 - 0x1DFFFFFFF` |SBus Slot D
| |`0x1E0000000 - 0x1EFFFFFFF` |SBus Slot E
| |`0x1F0000000 - 0x1FFFFFFFF` |SBus Slot F
|===

[[physical-sbus-addresses]]
===== Physical SBus Addresses

The SBus has 32 address bits, as described
in the SBus Specification. The following table describes how the Ultra 2
uses the address bits.

.Ultra 2 SBus Address Bits
[width="100%",cols="23%,77%",options="header",]
|===
|Bits |Description
|0 - 27 |These bits are the SBus address lines used by an SBus card to
address the contents of the card.

|28 - 31 |Used by the CPU to select one of the SBus slots. These bits
generate the SlaveSelect lines.
|===

This addressing scheme yields the Ultra 2 addresses shown in
link:#hwovr-tbl-34[Device Physical Space in the Ultra 2]. Other
implementations might use a different number of address bits.

The Ultra 2 has seven SBus slots, four of which are physical. Slots 0
through 3 are available for SBus cards. Slots 4-12 are reserved. The
slots are used as follows:

* Slots 0-3 are
physical slots that have DMA-master capability.
* Slots D, E, and F are not actual physical slots, but refer to the
onboard direct memory access (DMA), SCSI, Ethernet, and audio
controllers. For convenience, these classes of devices are viewed as
being plugged into slots D, E, and F.
+
[NOTE]

Some SBus slots are slave-only slots. Drivers that require DMA
capability should use `ddi++_++slaveonly(9F)` to determine whether their
device is in a DMA-capable slot. For an example of this function, see
link:#attach-entry-point[ Entry Point].
===

[[sbus-hardware-configuration-files]]
===== SBus Hardware Configuration Files

configuration files are normally unnecessary for SBus devices. However,
on some occasions, drivers for SBus devices need to use hardware
configuration files to augment the information provided by the SBus
card. See the `driver.conf(5)` and `sbus(5)` man page for further
details.

[[device-issues]]
=== Device Issues

This section describes issues with special devices.

[[timing-critical-sections]]
==== Timing-Critical Sections

While most driver operations can be performed without
mechanisms for synchronization and protection beyond those provided by
the locking primitives, some devices require that a sequence of events
occur in order without interruption. In conjunction with the locking
primitives, the function `ddi++_++enter++_++critical(9F)` asks the
system to guarantee, to the best of its ability, that the current thread
will neither be preempted nor interrupted. This guarantee stays in
effect until a closing call to `ddi++_++exit++_++critical(9F)` is made.
See the `ddi++_++enter++_++critical(9F)` man page for details.

[[delays]]
==== Delays

Many chips specify that they can be accessed only at
specified intervals. For example, the Zilog Z8530 SCC has a “write
recovery time” of 1.6 microseconds. This specification means that a
delay must be enforced with `drv++_++usecwait(9F)` when writing
characters with an 8530. In some instances, the specifications do not
make explicit what delays are needed, so the delays must be determined
empirically.

Be careful not to compound delays for parts of devices that might exist
in large numbers, for example, thousands of SCSI disk drives.

[[internal-sequencing-logic]]
==== Internal Sequencing Logic

Devices with internal sequencing logic map multiple
internal registers to the same external address. The various kinds of
internal sequencing logic include the following types:

* The Intel 8251A and the Signetics 2651
alternate the same external register between _two_ internal mode
registers. Writing to the first internal register is accomplished by
writing to the external register. This write, however, has the side
effect of setting up the sequencing logic in the chip so that the next
read/write operation refers to the second internal register.
* The NEC PD7201 PCC has multiple internal data registers. To write a
byte into a particular register, two steps must be performed. The first
step is to write into register zero the number of the register into
which the following byte of data will go. The data is then written to
the specified data register. The sequencing logic automatically sets up
the chip so that the next byte sent will go into data register zero.
* The AMD 9513 timer has a data pointer register that points at the data
register into which a data byte will go. When sending a byte to the data
register, the pointer is incremented. The current value of the pointer
register _cannot_ be read.

[[interrupt-issues]]
==== Interrupt Issues

Note the following common interrupt-related issues:

* A controller interrupt does _not_ necessarily indicate that _both_ the
controller _and_ one of its slave devices are ready. For some
controllers, an interrupt can indicate that either the controller is
ready or one of its devices is ready but not both.
* Not all devices power up with interrupts disabled and can begin
interrupting at any time.
* Some devices do not provide a way to determine that the board has
generated an interrupt.
* Not all interrupting boards shut off interrupts when told to do so or
after a bus reset.

[[prom-on-sparc-machines]]
=== PROM on SPARC Machines

Some platforms have a PROM monitor that
provides support for debugging a device without an operating system.
This section describes how to use the PROM on SPARC machines to map
device registers so that they can be accessed. Usually, the device can
be exercised enough with PROM commands to determine whether the device
is working correctly.

See the `boot(8)` man page for a description of the x86 boot subsystem.

The PROM has several purposes, including:

* Bringing the machine up from power on, or from a hard reset PROM
`reset` command
* Providing an interactive tool for examining and setting memory, device
registers, and memory mappings
* Booting the illumos system.
+
Simply powering up the computer and attempting to use its PROM to
examine device registers can fail. While the device might be correctly
installed, those mappings are specific to illumos and do not become
active until the illumos kernel is booted. Upon power up, the PROM maps
only essential system devices, such as the keyboard.
* Taking a system crash dump using the `sync` command

[[open-boot-prom-3]]
==== Open Boot PROM 3

For complete documentation on the Open Boot PROM, see the
Open Boot PROM Toolkit User's Guide and the `monitor(8)` man page. The
examples in this section refer to a Sun4U architecture. Other
architectures might require different commands to perform actions.

[NOTE]

The Open Boot PROM is currently used on Sun machines with an SBus or
UPA/PCI. The Open Boot PROM uses an “`ok`” prompt. On older machines,
you might have to type ++`++`n`' to get the “`ok`” prompt.
===

If the PROM is in _secure mode_ (the `security-mode` parameter is not
set to _none_), the PROM password might be required (set in the
`security-password` parameter).

The `printenv` command displays all parameters and their values.

Help is available with the `help` command.

EMACS-style command-line history is available. Use Control-N (next) and
Control-P (previous) to traverse the history list.

[[forth-commands]]
===== Forth Commands

The Open Boot PROM uses the Forth programming language. Forth is a
stack-based language. Arguments must be pushed on the stack before
running the correct command (called a _word_), and the result is left on
the stack.

To place a number on the stack, type its value.

....
ok 57
ok 68
....

To add the two top values on the stack, use the `{plus}` operator.

....
ok +
....

The result remains on the stack. The stack is shown with the `.s`
_word_.

....
ok .s
....

The default base is hexadecimal. The `hex` and `decimal` _words_ can be
used to switch bases.

....
ok decimal
ok .s
....

See the Forth User's Guide for more information.

[[walking-the-proms-device-tree]]
===== Walking the PROMs Device Tree

The commands `pwd`, `cd`, and `ls` walk the PROM device tree to get to
the device. The `cd` command must be used to establish a position in the
tree before `pwd` will work. This example is from an Ultra 1 workstation
with a `cgsix` frame buffer on an SBus.

....
ok cd /
....

To see the devices attached to the current node in the tree, use `ls`.

....
ok ls
f006a064 SUNW,UltraSPARC@0,0
f00598b0 sbus@1f,0
f00592dc counter-timer@1f,3c00
f004eec8 virtual-memory
f004e8e8 memory@0,0
f002ca28 aliases
f002c9b8 options
f002c880 openprom
f002c814 chosen
f002c7a4 packages
....

The full node name can be used:

....
ok cd sbus@1f,0
ok ls
f006a4e4 cgsix@2,0
f0068194 SUNW,bpp@e,c800000
f0065370 ledma@e,8400010
f006120c espdma@e,8400000
f005a448 SUNW,pll@f,1304000
f005a394 sc@f,1300000
f005a24c zs@f,1000000
f005a174 zs@f,1100000
f005a0c0 eeprom@f,1200000
f0059f8c SUNW,fdtwo@f,1400000
f0059ec4 flashprom@f,0
f0059e34 auxio@f,1900000
f0059d28 SUNW,CS4231@d,c000000
....

Rather than using the full node name in the previous example, you could
also use an abbreviation. The abbreviated command-line entry looks like
the following example:

....
ok cd sbus
....

The name is actually `device@slot,offset` (for SBus devices). The
`cgsix` device is in slot 2 and starts at offset 0. If an SBus device is
displayed in this tree, the device has been recognized by the PROM.

The `.properties` command displays the PROM properties of a device.
These properties can be examined to determine which properties the
device exports. This information is useful later to ensure that the
driver is looking for the correct hardware properties. These properties
are the same properties that can be retrieved with
`ddi++_++getprop(9F)`.

....
ok cd cgsix
ok .properties
character-set            ISO8859-1
intr                     00000005 00000000
interrupts               00000005
reg                      00000002 00000000 01000000
dblbuf                   00 00 00 00
vmsize                   00 00 00 01
...
....

The reg property defines an array of register description structures
containing the following fields:

[source,c]
----
uint_t        bustype;       /* cookie for related bus type*/
uint_t        addr;          /* address of reg relative to bus */
uint_t        size;          /* size of this register set */
----

For the `cgsix` example, the address is 0.

[[mapping-the-device]]
===== Mapping the Device

A device must be mapped into memory to be tested. The PROM can then be
used to verify proper operation of the device by using data-transfer
commands to transfer bytes, words, and long words. If the device can be
operated from the PROM, even in a limited way, the driver should also be
able to operate the device.

To set up the device for initial testing, perform the following steps:

[arabic]
. Determine the SBus slot number the device is in.
+
In this example, the `cgsix` device is located in slot 2.
. Determine the offset within the physical address space used by the
device.
+
The offset used is specific to the device. In the `cgsix` example, the
video memory happens to start at an offset of 0x800000.
. Use the `select-dev` _word_ to select the Sbus device and the `map-in`
_word_ to map the device in.
+
The `select-dev` _word_ takes a string of the device path as its
argument. The `map-in` _word_ takes an _offset_, a _slot number_, and a
_size_ as arguments to map. Like the offset, the size of the byte
transfer is specific to the device. In the `cgsix` example, the size is
set to 0x100000 bytes.
+
In the following code example, the Sbus path is displayed as an argument
to the `select-dev` word, and the offset, slot number, and size values
for the frame buffer are displayed as arguments to the `map-in` word.
Notice the space between the opening quote and / in the `select-dev`
argument. The virtual address to use remains on top of the stack. The
stack is shown using the `.s` word. The stack can be assigned a name
with the `constant` operation.
+
....
ok " sbus@1f,0" select-dev
ok 800000 2 100000 map-in
ok .s
ok constant fb
....

[[reading-and-writing]]
==== Reading and Writing

The PROM provides a variety of 8-bit, 16-bit, and 32-bit operations. In
general, a `c` (character) prefix indicates an 8-bit (one-byte)
operation; a `w` (word) prefix indicates a 16-bit (two-byte) operation;
and an `L` (longword) prefix indicates a 32-bit (four-byte) operation.

A suffix of `!` indicates a write operation. The write operation takes
the first two items off the stack. The first item is the address, and
the second item is the value.

....
ok 55 ffe98000 c!
....

A suffix of `@` indicates a read operation. The read operation takes the
address off the stack.

....
ok ffe98000 c@
ok .s
....

A suffix of `?` is used to display the value without affecting the
stack.

....
ok ffe98000 c?
....

Be careful when trying to query the device. If the mappings are not set
up correctly, trying to read or write could cause errors. Special words
are provided to handle these cases. `cprobe`, `wprobe`, and `lprobe`,
for example, read from the given address but return zero if the location
does not respond, or nonzero if it does.

....
ok fffa4000 c@
Data Access Error

ok fffa4000 cprobe
ok .s0

ok ffe98000 cprobe
ok .s
0 ffffffffffffffff
....

A region of memory can be shown with the `dump` word. This takes an
++<++address++>++ and a ++<++length++>++, and displays the contents of
the memory region in bytes.

In the following example, the `fill` word is used to fill video memory
with a pattern. `fill` takes the address, the number of bytes to fill,
and the byte to use. Use `wfill` and an `Lfill` for words and longwords.
This fill example causes the `cgsix` to display simple patterns based on
the byte passed.

....
ok " /sbus" select-dev
ok 800000 2 100000 map-in
ok constant fb
ok fb 10000 ff fill
ok fb 20000 0 fill
ok fb 18000 55 fill
ok fb 15000 3 fill
ok fb 10000 5 fillok fb 5000 f9 fill
....

[[summary-of-illumos-ddidki-services]]
=== Summary of illumos DDI/DKI Services

DDI function tables

This appendix discusses the interfaces provided by the illumos DDI/DKI.
These descriptions should not be considered complete or definitive, nor
do they provide a thorough guide to usage. The descriptions are intended
to describe what the functions do in general terms. See `physio(9F)` for
more detailed information. The categories are:

* link:#module-functions[Module Functions]
* link:#device-information-tree-node-devinfot-functions[Device Information Tree Node () Functions]
* link:#device-dev_t-functions[Device () Functions]
* link:#property-functions[Property Functions]
* link:#device-software-state-functions[Device Software State Functions]
* link:#memory-allocation-and-deallocation-functions[Memory Allocation and Deallocation Functions]
* link:#kernel-thread-control-and-synchronization-functions[Kernel Thread Control and Synchronization
Functions]
* link:#task-queue-management-functions[Task Queue Management Functions]
* link:#interrupt-functions[Interrupt Functions]
* link:#programmed-io-functions[Programmed I/O Functions]
* link:#direct-memory-access-dma-functions[Direct Memory Access (DMA) Functions]
* link:#user-space-access-functions[User Space Access Functions]
* link:#user-process-event-functions[User Process Event Functions]
* link:#user-process-information-functions[User Process Information Functions]
* link:#user-application-kernel-and-device-access-functions[User Application Kernel and Device Access
Functions]
* link:#time-related-functions[Time-Related Functions]
* link:#power-management-functions[Power Management Functions]
* link:#fault-management-functions[Fault Management Functions]
* link:#kernel-statistics-functions[Kernel Statistics Functions]
* link:#kernel-logging-and-printing-functions[Kernel Logging and Printing Functions]
* link:#buffered-io-functions[Buffered I/O Functions]
* link:#virtual-memory-functions[Virtual Memory Functions]
* link:#device-id-functions[Device ID Functions]
* link:#scsi-functions[SCSI Functions]
* link:#resource-map-management-functions[Resource Map Management Functions]
* link:#system-global-state[System Global State]
* link:#utility-functions[Utility Functions]

This appendix does not discuss STREAMS interfaces; to learn more about
network drivers, see the STREAMS Programming Guide.

[[module-functions]]
=== Module Functions

module functions

loadable module functions

individual functions

The module functions are:

`mod++_++info`::
  Query a loadable module
`mod++_++install`::
  Add a loadable module
`mod++_++remove`::
  Remove a loadable module

[[device-information-tree-node-devinfot-functions]]
=== Device Information Tree Node (`dev++_++info++_++t`) Functions

dev++_++info++_++t

The device information tree node functions are:

`ddi++_++binding++_++name`::
  Return driver binding name
`ddi++_++dev++_++is++_++sid`::
  Tell whether a device is self-identifying
`ddi++_++driver++_++major`::
  Return driver major device number
`ddi++_++driver++_++name`::
  Return normalized driver name
`ddi++_++node++_++name`::
  Return the `devinfo` node name
`ddi++_++get++_++devstate`::
  Check device state
`ddi++_++get++_++instance`::
  Get device instance number
`ddi++_++get++_++name`::
  Return driver binding name
`ddi++_++get++_++parent`::
  Find the parent of a device information structure
`ddi++_++root++_++node`::
  Get the root of the `dev++_++info` tree

[[device-dev_t-functions]]
=== Device (`dev++_++t`) Functions

dev++_++t

The device functions are:

`ddi++_++create++_++minor++_++node`::
  Create a minor node for a device
`ddi++_++getiminor`::
  Get kernel internal minor number from an external `dev++_++t`
`ddi++_++remove++_++minor++_++node`::
  Remove a minor mode for a device
`getmajor`::
  Get major device number
`getminor`::
  Get minor device number
`makedevice`::
  Make device number from major and minor numbers

[[property-functions]]
=== Property Functions

property functions

The property functions are:

`ddi++_++prop++_++exists`::
  Check for the existence of a property
`ddi++_++prop++_++free`::
  Free resources consumed by property lookup
`ddi++_++prop++_++get++_++int`::
  Look up integer property
`ddi++_++prop++_++get++_++int64`::
  Look up 64-bit integer property
`ddi++_++prop++_++lookup++_++byte++_++array`::
  Look up byte array property
`ddi++_++prop++_++lookup++_++int++_++array`::
  Look up integer array property
`ddi++_++prop++_++lookup++_++int64++_++array`::
  Look up 64-bit integer array property
`ddi++_++prop++_++lookup++_++string`::
  Look up string property
`ddi++_++prop++_++lookup++_++string++_++array`::
  Look up string array property
`ddi++_++prop++_++remove`::
  Remove a property of a device
`ddi++_++prop++_++remove++_++all`::
  Remove all properties of a device
`ddi++_++prop++_++undefine`::
  Hide a property of a device
`ddi++_++prop++_++update++_++byte++_++array`::
  Create or update byte array property
`ddi++_++prop++_++update++_++int`::
  Create or update integer property
`ddi++_++prop++_++update++_++int64`::
  Create or update 64-bit integer property
`ddi++_++prop++_++update++_++int++_++array`::
  Create or update integer array property
`ddi++_++prop++_++update++_++int64++_++array`::
  Create or update 64-bit integer array property
`ddi++_++prop++_++update++_++string`::
  Create or update string property
`ddi++_++prop++_++update++_++string++_++array`::
  Create or update string array property

.Deprecated Property Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Functions |Replacements
|`ddi++_++getlongprop` |see `ddi++_++prop++_++lookup`
|`ddi++_++getlongprop++_++buf` |`ddi++_++prop++_++lookup`
|`ddi++_++getprop` |`ddi++_++prop++_++get++_++int`
|`ddi++_++getproplen` |`ddi++_++prop++_++lookup`
|`ddi++_++prop++_++create` |`ddi++_++prop++_++lookup`
|`ddi++_++prop++_++modify` |`ddi++_++prop++_++lookup`
|`ddi++_++prop++_++op` |`ddi++_++prop++_++lookup`
|===

[[device-software-state-functions]]
=== Device Software State Functions

software state functions

The device software state functions are:

`ddi++_++get++_++driver++_++private`::
  Get the address of the device's private data area
`ddi++_++get++_++soft++_++state`::
  Get pointer to instance soft-state structure
`ddi++_++set++_++driver++_++private`::
  Set the address of the device's private data area
`ddi++_++soft++_++state++_++fini`::
  Destroy driver soft-state structure
`ddi++_++soft++_++state++_++free`::
  Free instance soft-state structure
`ddi++_++soft++_++state++_++init`::
  Initialize driver soft-state structure
`ddi++_++soft++_++state++_++zalloc`::
  Allocate instance soft-state structure

[[memory-allocation-and-deallocation-functions]]
=== Memory Allocation and Deallocation Functions

memory allocation functions

The memory allocation and deallocation functions are:

`kmem++_++alloc`::
  Allocate kernel memory
`kmem++_++free`::
  Free kernel memory
`kmem++_++zalloc`::
  Allocate zero-filled kernel memory

The following functions allocate and free memory intended
to be used for DMA. See link:#direct-memory-access-dma-functions[Direct Memory Access (DMA)
Functions].

`ddi++_++dma++_++mem++_++alloc`::
  Allocate memory for DMA transfer
`ddi++_++dma++_++mem++_++free`::
  Free previously allocated DMA memory

The following functions allocate and free memory intended to be exported
to user space. See link:#user-space-access-functions[User Space Access Functions].

`ddi++_++umem++_++alloc`::
  Allocate page-aligned kernel memory
`ddi++_++umem++_++free`::
  Free page-aligned kernel memory

.Deprecated Memory Allocation and Deallocation Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`ddi++_++iopb++_++alloc` |`ddi++_++dma++_++mem++_++alloc`
|`ddi++_++iopb++_++free` |`ddi++_++dma++_++mem++_++free`
|`ddi++_++mem++_++alloc` |`ddi++_++dma++_++mem++_++alloc`
|`ddi++_++mem++_++free` |`ddi++_++dma++_++mem++_++free`
|===

[[kernel-thread-control-and-synchronization-functions]]
=== Kernel Thread Control and Synchronization Functions

condition variable functions

kernel thread functions

The kernel thread control and synchronization functions are:

`cv++_++broadcast`::
  Wake up all waiting threads
`cv++_++destroy`::
  Free an allocated condition variable
`cv++_++init`::
  Allocate a condition variable
`cv++_++signal`::
  Wake up one waiting thread
`cv++_++timedwait`::
  Await an event with timeout
`cv++_++timedwait++_++sig`::
  Await an event or signal with timeout
`cv++_++wait`::
  Await an event
`cv++_++wait++_++sig`::
  Await an event or signal
`ddi++_++can++_++receive++_++sig`::
  Determine whether the current thread can receive a signal
`ddi++_++enter++_++critical`::
  Enter a critical region of control
`ddi++_++exit++_++critical`::
  Exit a critical region of control
`mutex++_++destroy`::
  Destroy mutual exclusion lock
`mutex++_++enter`::
  Acquire mutual exclusion lock
`mutex++_++exit`::
  Release mutual exclusion lock
`mutex++_++init`::
  Initialize mutual exclusion lock
`mutex++_++owned`::
  Determine whether current thread is holding mutual exclusion lock
`mutex++_++tryenter`::
  Attempt to acquire mutual exclusion lock without waiting
`rw++_++destroy`::
  Destroy a readers/writer lock
`rw++_++downgrade`::
  Downgrade a readers/writer lock holding from writer to reader
`rw++_++enter`::
  Acquire a readers/writer lock
`rw++_++exit`::
  Release a readers/writer lock
`rw++_++init`::
  Initialize a readers/writer lock
`rw++_++read++_++locked`::
  Determine whether readers/writer lock is held for read or write
`rw++_++tryenter`::
  Attempt to acquire a readers/writer lock without waiting
`rw++_++tryupgrade`::
  Attempt to upgrade readers/writer lock holding from reader to writer
`sema++_++destroy`::
  Destroy a semaphore
`sema++_++init`::
  Initialize a semaphore
`sema++_++p`::
  Decrement semaphore and possibly block
`sema++_++p++_++sig`::
  Decrement semaphore but do not block if signal is pending
`sema++_++tryp`::
  Attempt to decrement semaphore but do not block
`sema++_++v`::
  Increment semaphore and possibly unblock waiter

[[task-queue-management-functions]]
=== Task Queue Management Functions

task queues

The task queue management functions are listed below. See the
`taskq(9F)` man page for more information about these interfaces.

`ddi++_++taskq++_++create`::
  Create a task queue
`ddi++_++taskq++_++destroy`::
  Destroy a task queue
`ddi++_++taskq++_++dispatch`::
  Add a task to a task queue
`ddi++_++taskq++_++wait`::
  Wait for pending tasks to complete
`ddi++_++taskq++_++suspend`::
  Suspend a task queue
`ddi++_++taskq++_++suspended`::
  Check whether a task queue is suspended
`ddi++_++taskq++_++resume`::
  Resume a suspended task queue

[[interrupt-functions]]
=== Interrupt Functions

interrupt functions

The interrupt functions are:

`ddi++_++intr++_++add++_++handler(9F)`::
  Adds an interrupt handler.
`ddi++_++intr++_++add++_++softint(9F)`::
  Adds a soft interrupt handler.
`ddi++_++intr++_++alloc(9F)`::
  Allocates system resources and interrupt vectors for the specified
  type of interrupt.
`ddi++_++intr++_++block++_++disable(9F)`::
  Disables the specified range of interrupts. For MSI only.
`ddi++_++intr++_++block++_++enable(9F)`::
  Enables the specified range of interrupts. For MSI only.
`ddi++_++intr++_++clr++_++mask(9F)`::
  Clears an interrupt mask if the specified interrupt is enabled.
`ddi++_++intr++_++disable(9F)`::
  Disables the specified interrupt.
`ddi++_++intr++_++dup++_++handler(9F)`::
  Use with MSI-X only. Copies an address and data pair for an allocated
  interrupt vector to an unused interrupt vector on the same device.
`ddi++_++intr++_++enable(9F)`::
  Enables the specified interrupt.
`ddi++_++intr++_++free(9F)`::
  Releases the system resources and interrupt vectors for a specified
  interrupt handle.
`ddi++_++intr++_++get++_++cap(9F)`::
  Returns interrupt capability flags for the specified interrupt.
`ddi++_++intr++_++get++_++hilevel++_++pri(9F)`::
  Returns the minimum priority level for a high-level interrupt.
`ddi++_++intr++_++get++_++navail(9F)`::
  Returns the number of interrupts available for a particular hardware
  device and given interrupt type.
`ddi++_++intr++_++get++_++nintrs(9F)`::
  Get the number of interrupts that the device supports for the given
  interrupt type.
`ddi++_++intr++_++get++_++pending(9F)`::
  Read the interrupt pending bit if one is supported by either the host
  bridge or the device.
`ddi++_++intr++_++get++_++pri(9F)`::
  Returns the current software priority setting for the specified
  interrupt.
`ddi++_++intr++_++get++_++softint++_++pri(9F)`::
  Returns the soft interrupt priority for the specified interrupt.
`ddi++_++intr++_++get++_++supported++_++types(9F)`::
  Returns the hardware interrupt types that are supported by both the
  device and the host.
`ddi++_++intr++_++remove++_++handler(9F)`::
  Removes the specified interrupt handler.
`ddi++_++intr++_++remove++_++softint(9F)`::
  Remove the specified soft interrupt handler.
`ddi++_++intr++_++set++_++cap(9F)`::
  Sets the DDI++_++INTR++_++FLAG++_++LEVEL or
  DDI++_++INTR++_++FLAG++_++EDGE flag for the specified interrupt.
`ddi++_++intr++_++set++_++mask(9F)`::
  Sets an interrupt mask if the specified interrupt is enabled.
`ddi++_++intr++_++set++_++pri(9F)`::
  Sets the interrupt priority level for the specified interrupt.
`ddi++_++intr++_++set++_++softint++_++pri(9F)`::
  Changes the relative soft interrupt priority for the specified soft
  interrupt.
`ddi++_++intr++_++trigger++_++softint(9F)`::
  Trigger the specified soft interrupt.

To take advantage of the features of the new framework, use the above
interfaces. Do not use the deprecated interfaces that are listed in the
following table. These deprecated interfaces are retained for
compatibility purposes only.

.Deprecated Interrupt Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Interrupt Functions |Replacements
|`ddi++_++add++_++intr(9F)` a|
Three-step process:

[arabic]
. `ddi++_++intr++_++alloc(9F)`
. `ddi++_++intr++_++add++_++handler(9F)`
. `ddi++_++intr++_++enable(9F)`

|`ddi++_++add++_++softintr(9F)` |`ddi++_++intr++_++add++_++softint(9F)`

|`ddi++_++dev++_++nintrs(9F)` |`ddi++_++intr++_++get++_++nintrs(9F)`

|`ddi++_++get++_++iblock++_++cookie(9F)` a|
Three-step process:

[arabic]
. `ddi++_++intr++_++alloc(9F)`
. `ddi++_++intr++_++get++_++pri(9F)`
. `ddi++_++intr++_++free(9F)`

|`ddi++_++get++_++soft++_++iblock++_++cookie(9F)` a|
Three-step process:

[arabic]
. `ddi++_++intr++_++add++_++softint(9F)`
. `ddi++_++intr++_++get++_++softint++_++pri(9F)`
. `ddi++_++intr++_++remove++_++softint(9F)`

|`ddi++_++intr++_++hilevel(9F)` a|
Three-step process:

[arabic]
. `ddi++_++intr++_++alloc(9F)`
. `ddi++_++intr++_++get++_++hilevel++_++pri(9F)`
. `ddi++_++intr++_++free(9F)`

|`ddi++_++remove++_++intr(9F)` a|
Three-step process:

[arabic]
. `ddi++_++intr++_++disable(9F)`
. `ddi++_++intr++_++remove++_++handler(9F)`
. `ddi++_++intr++_++free(9F)`

|`ddi++_++remove++_++softintr(9F)`
|`ddi++_++intr++_++remove++_++softint(9F)`

|`ddi++_++trigger++_++softintr(9F)`
|`ddi++_++intr++_++trigger++_++softint(9F)`
|===

[[programmed-io-functions]]
=== Programmed I/O Functions

programmed I/O functions

The programmed I/O functions are:

`ddi++_++dev++_++nregs`::
  Return the number of register sets a device has
`ddi++_++dev++_++regsize`::
  Return the size of a device's register
`ddi++_++regs++_++map++_++setup`::
  Set up a mapping for a register address space
`ddi++_++regs++_++map++_++free`::
  Free a previously mapped register address space
`ddi++_++device++_++copy`::
  Copy data from one device register to another device register
`ddi++_++device++_++zero`::
  Zero fill the device
`ddi++_++check++_++acc++_++handle`::
  Check data access handle
`ddi++_++get8`::
  Read 8-bit data from mapped memory, device register, or DMA memory
`ddi++_++get16`::
  Read 16-bit data from mapped memory, device register, or DMA memory
`ddi++_++get32`::
  Read 32-bit data from mapped memory, device register, or DMA memory
`ddi++_++get64`::
  Read 64-bit data from mapped memory, device register, or DMA memory
`ddi++_++put8`::
  Write 8-bit data to mapped memory, device register, or DMA memory
`ddi++_++put16`::
  Write 16-bit data to mapped memory, device register, or DMA memory
`ddi++_++put32`::
  Write 32-bit data to mapped memory, device register, or DMA memory
`ddi++_++put64`::
  Write 64-bit data to mapped memory, device register, or DMA memory
`ddi++_++rep++_++get8`::
  Read multiple 8-bit data from mapped memory, device register, or DMA
`ddi++_++rep++_++get16`::
  Read multiple 16-bit data from mapped memory, device register, or DMA
`ddi++_++rep++_++get32`::
  Read multiple 32-bit data from mapped memory, device register, or DMA
`ddi++_++rep++_++get64`::
  Read multiple 64-bit data from mapped memory, device register, or DMA
`ddi++_++rep++_++put8`::
  Write multiple 8-bit data to mapped memory, device register, or DMA
`ddi++_++rep++_++put16`::
  Write multiple 16-bit data to mapped memory, device register, or DMA
`ddi++_++rep++_++put32`::
  Write multiple 32-bit data to mapped memory, device register, or DMA
`ddi++_++rep++_++put64`::
  Write multiple 64-bit data to mapped memory, device register, or DMA
`ddi++_++peek8`::
  Cautiously read an 8-bit value from a location
`ddi++_++peek16`::
  Cautiously read a 16-bit value from a location
`ddi++_++peek32`::
  Cautiously read a 32-bit value from a location
`ddi++_++peek64`::
  Cautiously read a 64-bit value from a location
`ddi++_++poke8`::
  Cautiously write an 8-bit value to a location
`ddi++_++poke16`::
  Cautiously write a 16-bit value to a location
`ddi++_++poke32`::
  Cautiously write a 32-bit value to a location
`ddi++_++poke64`::
  Cautiously write a 64-bit value to a location

The general programmed I/O functions
listed above can always be used rather than the `mem`, `io`, and
`pci++_++config` functions that follow. However, the following functions
can be used as alternatives in cases where the type of access is known
at compile time.

`ddi++_++io++_++get8`::
  Read 8-bit data from a mapped device register in I/O space
`ddi++_++io++_++get16`::
  Read 16-bit data from a mapped device register in I/O space
`ddi++_++io++_++get32`::
  Read 32-bit data from a mapped device register in I/O space
`ddi++_++io++_++put8`::
  Write 8-bit data to a mapped device register in I/O space
`ddi++_++io++_++put16`::
  Write 16-bit data to a mapped device register in I/O space
`ddi++_++io++_++put32`::
  Write 32-bit data to a mapped device register in I/O space
`ddi++_++io++_++rep++_++get8`::
  Read multiple 8-bit data from a mapped device register in I/O space
`ddi++_++io++_++rep++_++get16`::
  Read multiple 16-bit data from a mapped device register in I/O space
`ddi++_++io++_++rep++_++get32`::
  Read multiple 32-bit data from a mapped device register in I/O space
`ddi++_++io++_++rep++_++put8`::
  Write multiple 8-bit data to a mapped device register in I/O space
`ddi++_++io++_++rep++_++put16`::
  Write multiple 16-bit data to a mapped device register in I/O space
`ddi++_++io++_++rep++_++put32`::
  Write multiple 32-bit data to a mapped device register in I/O space
`ddi++_++mem++_++get8`::
  Read 8-bit data from a mapped device in memory space or DMA memory
`ddi++_++mem++_++get16`::
  Read 16-bit data from a mapped device in memory space or DMA memory
`ddi++_++mem++_++get32`::
  Read 32-bit data from a mapped device in memory space or DMA memory
`ddi++_++mem++_++get64`::
  Read 64-bit data from a mapped device in memory space or DMA memory
`ddi++_++mem++_++put8`::
  Write 8-bit data to a mapped device in memory space or DMA memory
`ddi++_++mem++_++put16`::
  Write 16-bit data to a mapped device in memory space or DMA memory
`ddi++_++mem++_++put32`::
  Write 32-bit data to a mapped device in memory space or DMA memory
`ddi++_++mem++_++put64`::
  Write 64-bit data to a mapped device in memory space or DMA memory
`ddi++_++mem++_++rep++_++get8`::
  Read multiple 8-bit data from a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++get16`::
  Read multiple 16-bit data from a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++get32`::
  Read multiple 32-bit data from a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++get64`::
  Read multiple 64-bit data from a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++put8`::
  Write multiple 8-bit data to a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++put16`::
  Write multiple 16-bit data to a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++put32`::
  Write multiple 32-bit data to a mapped device in memory space or DMA
  memory
`ddi++_++mem++_++rep++_++put64`::
  Write multiple 64-bit data to a mapped device in memory space or DMA
`pci++_++config++_++setup`::
  Set up access to PCI Local Bus Configuration space
`pci++_++config++_++teardown`::
  Tear down access to PCI Local Bus Configuration space
`pci++_++config++_++get8`::
  Read 8-bit data from the PCI Local Bus Configuration space
`pci++_++config++_++get16`::
  Read 16-bit data from the PCI Local Bus Configuration space
`pci++_++config++_++get32`::
  Read 32-bit data from the PCI Local Bus Configuration space
`pci++_++config++_++get64`::
  Read 64-bit data from the PCI Local Bus Configuration space
`pci++_++config++_++put8`::
  Write 8-bit data to the PCI Local Bus Configuration space
`pci++_++config++_++put16`::
  Write 16-bit data to the PCI Local Bus Configuration space
`pci++_++config++_++put32`::
  Write 32-bit data to the PCI Local Bus Configuration space
`pci++_++config++_++put64`::
  Write 64-bit data to the PCI Local Bus Configuration space

.Deprecated Programmed I/O Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`ddi++_++getb` |`ddi++_++get8`
|`ddi++_++getl` |`ddi++_++get32`
|`ddi++_++getll` |`ddi++_++get64`
|`ddi++_++getw` |`ddi++_++get16`
|`ddi++_++io++_++getb` |`ddi++_++io++_++get8`
|`ddi++_++io++_++getl` |`ddi++_++io++_++get32`
|`ddi++_++io++_++getw` |`ddi++_++io++_++get16`
|`ddi++_++io++_++putb` |`ddi++_++io++_++put8`
|`ddi++_++io++_++putl` |`ddi++_++io++_++put32`
|`ddi++_++io++_++putw` |`ddi++_++io++_++put16`
|`ddi++_++io++_++rep++_++getb` |`ddi++_++io++_++rep++_++get8`
|`ddi++_++io++_++rep++_++getl` |`ddi++_++io++_++rep++_++get32`
|`ddi++_++io++_++rep++_++getw` |`ddi++_++io++_++rep++_++get16`
|`ddi++_++io++_++rep++_++putb` |`ddi++_++io++_++rep++_++put8`
|`ddi++_++io++_++rep++_++putl` |`ddi++_++io++_++rep++_++put32`
|`ddi++_++io++_++rep++_++putw` |`ddi++_++io++_++rep++_++put16`
|`ddi++_++map++_++regs` |`ddi++_++regs++_++map++_++setup`
|`ddi++_++mem++_++getb` |`ddi++_++mem++_++get8`
|`ddi++_++mem++_++getl` |`ddi++_++mem++_++get32`
|`ddi++_++mem++_++getll` |`ddi++_++mem++_++get64`
|`ddi++_++mem++_++getw` |`ddi++_++mem++_++get16`
|`ddi++_++mem++_++putb` |`ddi++_++mem++_++put8`
|`ddi++_++mem++_++putl` |`ddi++_++mem++_++put32`
|`ddi++_++mem++_++putll` |`ddi++_++mem++_++put64`
|`ddi++_++mem++_++putw` |`ddi++_++mem++_++put16`
|`ddi++_++mem++_++rep++_++getb` |`ddi++_++mem++_++rep++_++get8`
|`ddi++_++mem++_++rep++_++getl` |`ddi++_++mem++_++rep++_++get32`
|`ddi++_++mem++_++rep++_++getll` |`ddi++_++mem++_++rep++_++get64`
|`ddi++_++mem++_++rep++_++getw` |`ddi++_++mem++_++rep++_++get16`
|`ddi++_++mem++_++rep++_++putb` |`ddi++_++mem++_++rep++_++put8`
|`ddi++_++mem++_++rep++_++putl` |`ddi++_++mem++_++rep++_++put32`
|`ddi++_++mem++_++rep++_++putll` |`ddi++_++mem++_++rep++_++put64`
|`ddi++_++mem++_++rep++_++putw` |`ddi++_++mem++_++rep++_++put16`
|`ddi++_++peekc` |`ddi++_++peek8`
|`ddi++_++peekd` |`ddi++_++peek64`
|`ddi++_++peekl` |`ddi++_++peek32`
|`ddi++_++peeks` |`ddi++_++peek16`
|`ddi++_++pokec` |`ddi++_++poke8`
|`ddi++_++poked` |`ddi++_++poke64`
|`ddi++_++pokel` |`ddi++_++poke32`
|`ddi++_++pokes` |`ddi++_++poke16`
|`ddi++_++putb` |`ddi++_++put8`
|`ddi++_++putl` |`ddi++_++put32`
|`ddi++_++putll` |`ddi++_++put64`
|`ddi++_++putw` |`ddi++_++put16`
|`ddi++_++rep++_++getb` |`ddi++_++rep++_++get8`
|`ddi++_++rep++_++getl` |`ddi++_++rep++_++get32`
|`ddi++_++rep++_++getll` |`ddi++_++rep++_++get64`
|`ddi++_++rep++_++getw` |`ddi++_++rep++_++get16`
|`ddi++_++rep++_++putb` |`ddi++_++rep++_++put8`
|`ddi++_++rep++_++putl` |`ddi++_++rep++_++put32`
|`ddi++_++rep++_++putll` |`ddi++_++rep++_++put64`
|`ddi++_++rep++_++putw` |`ddi++_++rep++_++put16`
|`ddi++_++unmap++_++regs` |`ddi++_++regs++_++map++_++free`
|`inb` |`ddi++_++io++_++get8`
|`inl` |`ddi++_++io++_++get32`
|`inw` |`ddi++_++io++_++get16`
|`outb` |`ddi++_++io++_++put8`
|`outl` |`ddi++_++io++_++put32`
|`outw` |`ddi++_++io++_++put16`
|`pci++_++config++_++getb` |`pci++_++config++_++get8`
|`pci++_++config++_++getl` |`pci++_++config++_++get32`
|`pci++_++config++_++getll` |`pci++_++config++_++get64`
|`pci++_++config++_++getw` |`pci++_++config++_++get16`
|`pci++_++config++_++putb` |`pci++_++config++_++put8`
|`pci++_++config++_++putl` |`pci++_++config++_++put32`
|`pci++_++config++_++putll` |`pci++_++config++_++put64`
|`pci++_++config++_++putw` |`pci++_++config++_++put16`
|`repinsb` |`ddi++_++io++_++rep++_++get8`
|`repinsd` |`ddi++_++io++_++rep++_++get32`
|`repinsw` |`ddi++_++io++_++rep++_++get16`
|`repoutsb` |`ddi++_++io++_++rep++_++put8`
|`repoutsd` |`ddi++_++io++_++rep++_++put32`
|`repoutsw` |`ddi++_++io++_++rep++_++put16`
|===

[[direct-memory-access-dma-functions]]
=== Direct Memory Access (DMA) Functions

DMA functions

The DMA functions are:

`ddi++_++dma++_++alloc++_++handle`::
  Allocate a DMA handle
`ddi++_++dma++_++free++_++handle`::
  Free a DMA handle
`ddi++_++dma++_++mem++_++alloc`::
  Allocate memory for a DMA transfer
`ddi++_++dma++_++mem++_++free`::
  Free previously allocated DMA memory
`ddi++_++dma++_++addr++_++bind++_++handle`::
  Bind an address to a DMA handle
`ddi++_++dma++_++buf++_++bind++_++handle`::
  Bind a system buffer to a DMA handle
`ddi++_++dma++_++unbind++_++handle`::
  Unbind the address in a DMA handle
`ddi++_++dma++_++nextcookie`::
  Retrieve the subsequent DMA cookie
`ddi++_++dma++_++getwin`::
  Activate a new DMA window
`ddi++_++dma++_++numwin`::
  Retrieve number of DMA windows
`ddi++_++dma++_++sync`::
  Synchronize CPU and I/O views of memory
`ddi++_++check++_++dma++_++handle`::
  Check a DMA handle
`ddi++_++dma++_++set++_++sbus64`::
  Allow 64-bit transfers on SBus
`ddi++_++slaveonly`::
  Report whether a device is installed in a slave access-only location
`ddi++_++iomin`::
  Find the minimum alignment and transfer size for DMA
`ddi++_++dma++_++burstsizes`::
  Find out the allowed burst sizes for a DMA mapping
`ddi++_++dma++_++devalign`::
  Find DMA mapping alignment and minimum transfer size
`ddi++_++dmae++_++alloc`::
  Acquire a DMA channel
`ddi++_++dmae++_++release`::
  Release a DMA channel
`ddi++_++dmae++_++getattr`::
  Get the DMA engine attributes
`ddi++_++dmae++_++prog`::
  Program a DMA channel
`ddi++_++dmae++_++stop`::
  Terminate a DMA engine operation
`ddi++_++dmae++_++disable`::
  Disable a DMA channel
`ddi++_++dmae++_++enable`::
  Enable a DMA channel
`ddi++_++dmae++_++getcnt`::
  Get the remaining DMA engine count
`ddi++_++dmae++_++1stparty`::
  Configure the DMA channel cascade mode
`ddi++_++dma++_++coff`::
  Convert a DMA cookie to an offset within a DMA handle

.Deprecated Direct Memory Access (DMA) Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`ddi++_++dma++_++addr++_++setup` |`ddi++_++dma++_++alloc++_++handle`,
`ddi++_++dma++_++addr++_++bind++_++handle`

|`ddi++_++dma++_++buf++_++setup` |`ddi++_++dma++_++alloc++_++handle`,
`ddi++_++dma++_++buf++_++bind++_++handle`

|`ddi++_++dma++_++curwin` |`ddi++_++dma++_++getwin`

|`ddi++_++dma++_++free` |`ddi++_++dma++_++free++_++handle`

|`ddi++_++dma++_++htoc` |`ddi++_++dma++_++addr++_++bind++_++handle`,
`ddi++_++dma++_++buf++_++bind++_++handle`

|`ddi++_++dma++_++movwin` |`ddi++_++dma++_++getwin`

|`ddi++_++dma++_++nextseg` |`ddi++_++dma++_++nextcookie`

|`ddi++_++dma++_++segtocookie` |`ddi++_++dma++_++nextcookie`

|`ddi++_++dma++_++setup` |`ddi++_++dma++_++alloc++_++handle`,
`ddi++_++dma++_++addr++_++bind++_++handle`,
`ddi++_++dma++_++buf++_++bind++_++handle`

|`ddi++_++dmae++_++getlim` |`ddi++_++dmae++_++getattr`

|`ddi++_++iopb++_++alloc` |`ddi++_++dma++_++mem++_++alloc`

|`ddi++_++iopb++_++free` |`ddi++_++dma++_++mem++_++free`

|`ddi++_++mem++_++alloc` |`ddi++_++dma++_++mem++_++alloc`

|`ddi++_++mem++_++free` |`ddi++_++dma++_++mem++_++free`

|`hat++_++getkpfnum` |`ddi++_++dma++_++addr++_++bind++_++handle`,
`ddi++_++dma++_++buf++_++bind++_++handle`, `ddi++_++dma++_++nextcookie`
|===

[[user-space-access-functions]]
=== User Space Access Functions

user space access functions

The user space access functions are:

`ddi++_++copyin`::
  Copy data to a driver buffer
`ddi++_++copyout`::
  Copy data from a driver
`uiomove`::
  Copy kernel data using a `uio` structure
`ureadc`::
  Add character to a `uio` structure
`uwritec`::
  Remove a character from a `uio` structure
`getminor`::
  Get minor device number.
`ddi++_++model++_++convert++_++from`::
  Determine a data model type mismatch
`IOC++_++CONVERT++_++FROM`::
  Determine whether there is a need to translate M++_++IOCTL contents
`STRUCT++_++DECL`::
  Establish the handle to application data in a possibly differing data
`STRUCT++_++HANDLE`::
  Establish the handle to application data in a possibly differing data
`STRUCT++_++INIT`::
  Establish the handle to application data in a possibly differing data
`STRUCT++_++SET++_++HANDLE`::
  Establish the handle to application data in a possibly differing data
`SIZEOF++_++PTR`::
  Return the size of pointer in specified data model
`SIZEOF++_++STRUCT`::
  Return the size of a structure in the specified data model
`STRUCT++_++SIZE`::
  Return the size of a structure in the application data model
`STRUCT++_++BUF`::
  Return a pointer to the native mode instance of the structure
`STRUCT++_++FADDR`::
  Return a pointer to the specified field of a structure
`STRUCT++_++FGET`::
  Return the specified field of a structure in the application data
`STRUCT++_++FGETP`::
  Return the specified pointer field of a structure in the application
  data model
`STRUCT++_++FSET`::
  Set a specified field of a structure in the application data model
`STRUCT++_++FSETP`::
  Set a specified pointer field of a structure in the application data

.Deprecated User Space Access Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`copyin` |`ddi++_++copyin`
|`copyout` |`ddi++_++copyout`
|`ddi++_++getminor` |`getminor`
|===

[[user-process-event-functions]]
=== User Process Event Functions

user process event functions

The user process event functions are:

`pollwakeup`::
  Inform a process that an event has occurred
`proc++_++ref`::
  Get a handle on a process to signal
`proc++_++unref`::
  Release a handle on a process to signal
`proc++_++signal`::
  Send a signal to a process

[[user-process-information-functions]]
=== User Process Information Functions

user process information functions

The user process information functions are:

`ddi++_++get++_++cred`::
  Return a pointer to the credential structure of the caller
`drv++_++priv`::
  Determine process credentials privilege
`ddi++_++get++_++pid`::
  Return the process ID

.Deprecated User Process Information Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Functions |Replacement
|`drv++_++getparm` |`ddi++_++get++_++pid`, `ddi++_++get++_++cred`
|===

[[user-application-kernel-and-device-access-functions]]
=== User Application Kernel and Device Access Functions

user application kernel functions

device access functions

The user application kernel and device access functions are:

`ddi++_++dev++_++nregs`::
  Return the number of register sets a device has
`ddi++_++dev++_++regsize`::
  Return the size of a device's register
`ddi++_++devmap++_++segmap`, `devmap++_++setup`::
  Set up a user mapping to device memory using the `devmap` framework
`devmap++_++devmem++_++setup`::
  Export device memory to user space
`devmap++_++load`::
  Validate memory address translations
`devmap++_++unload`::
  Invalidate memory address translations
`devmap++_++do++_++ctxmgt`::
  Perform device context switching on a mapping
`devmap++_++set++_++ctx++_++timeout`::
  Set the timeout value for the context management callback
`devmap++_++default++_++access`::
  Default driver memory access function
`ddi++_++umem++_++alloc`::
  Allocate page-aligned kernel memory
`ddi++_++umem++_++free`::
  Free page-aligned kernel memory
`ddi++_++umem++_++lock`::
  Lock memory pages
`ddi++_++umem++_++unlock`::
  Unlock memory pages
`ddi++_++umem++_++iosetup`::
  Setup I/O requests to application memory
`devmap++_++umem++_++setup`::
  Export kernel memory to user space
`ddi++_++model++_++convert++_++from`::
  Determine data model type mismatch

.Deprecated User Application Kernel and Device Access Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`ddi++_++mapdev` |`devmap++_++setup`
|`ddi++_++mapdev++_++intercept` |`devmap++_++load`
|`ddi++_++mapdev++_++nointercept` |`devmap++_++unload`
|`ddi++_++mapdev++_++set++_++device++_++acc++_++attr` |`devmap`
|`ddi++_++segmap` |`devmap`
|`ddi++_++segmap++_++setup` |`devmap++_++setup`
|`hat++_++getkpfnum` |`devmap`
|`ddi++_++mmap++_++get++_++model` |`devmap`
|===

[[time-related-functions]]
=== Time-Related Functions

time-related functions

The time-related functions are:

`ddi++_++get++_++lbolt`::
  Return the number of clock ticks since reboot
`ddi++_++get++_++time`::
  Return the current time in seconds
`ddi++_++periodic++_++add`::
  Issue nanosecond periodic timeout requests
`ddi++_++periodic++_++delete`::
  Cancel nanosecond periodic timeout requests
`delay`::
  Delay execution for a specified number of clock ticks
`drv++_++hztousec`::
  Convert clock ticks to microseconds
`drv++_++usectohz`::
  Convert microseconds to clock ticks
`drv++_++usecwait`::
  Busy-wait for specified interval
`gethrtime`::
  Get high-resolution time
`gethrvtime`::
  Get high-resolution LWP virtual time
`timeout`::
  Execute a function after a specified length of time
`untimeout`::
  Cancel the previous time out function call
`drv++_++getparm`::
  `ddi++_++get++_++lbolt`, `ddi++_++get++_++time`

.Deprecated Time-Related Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`drv++_++getparm` |`ddi++_++get++_++lbolt`, `ddi++_++get++_++time`
|===

[[power-management-functions]]
=== Power Management Functions

power management functions

The power management functions are:

`ddi++_++removing++_++power`::
  Check if device loses power with DDI++_++SUSPEND
`pci++_++report++_++pmcap`::
  Report the power management capability of a PCI device
`pm++_++busy++_++component`::
  Mark a component as busy
`pm++_++idle++_++component`::
  Mark a component as idle
`pm++_++raise++_++power`::
  Raise the power level of a component
`pm++_++lower++_++power`::
  Lower the power level of a component
`pm++_++power++_++has++_++changed`::
  Notify the power management framework of an autonomous power level
`pm++_++trans++_++check`::
  Device power cycle advisory check

.Deprecated Power Management Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Function Name |Description
|`ddi++_++dev++_++is++_++needed` |Inform the system that a device's
component is required

|`pm++_++create++_++components` |Create power-manageable components

|`pm++_++destroy++_++components` |Destroy power-manageable components

|`pm++_++get++_++normal++_++power` |Get the normal power level of a
device component

|`pm++_++set++_++normal++_++power` |Set the normal power level of a
device component
|===

[[fault-management-functions]]
=== Fault Management Functions

fault management

The fault management functions are:

`ddi++_++fm++_++init`::
  Allocates and initializes resources based on declared fault management
`ddi++_++fm++_++fini`::
  Cleans up resources that were allocated for this device instance to
  support fault management capabilities declared to
  `ddi++_++fm++_++init`
`ddi++_++fm++_++capable`::
  Returns the capability bit mask currently set for this device instance
`ddi++_++fm++_++handler++_++register`::
  Registers an error handler callback routine with the IO Fault
  Management framework
`ddi++_++fm++_++handler++_++unregister`::
  Removes an error handler callback routine that was registered with
  `ddi++_++fm++_++handler++_++register`
`ddi++_++fm++_++acc++_++err++_++get`::
  Returns the error status for an access handle
`ddi++_++fm++_++dma++_++err++_++get`::
  Returns the error status for a DMA handle
`ddi++_++fm++_++acc++_++err++_++clear`::
  Clears the error status for an access handle
`ddi++_++fm++_++dma++_++err++_++clear`::
  Clears the error status for a DMA handle
`ddi++_++fm++_++ereport++_++post`::
  Queues an encoded fault management error report name-value pair list
  for delivery to the Fault Manager daemon, `fmd(8)`
`ddi++_++fm++_++service++_++impact`::
  Reports the impact of an error
`pci++_++ereport++_++setup`::
  Initializes support for error report generation and sets up the
  resources for subsequent accesses to PCI, PCI/X, or PCI Express
  configuration space
`pci++_++ereport++_++teardown`::
  Releases any resources allocated and setup by
  `pci++_++ereport++_++setup` for this device instance
`pci++_++ereport++_++post`::
  Scans for and posts any PCI, PCI/X, or PCI Express bus errors

[[kernel-statistics-functions]]
[[kernel-statistics-functions-1]]
=== Kernel Statistics Functions

kernel statistics functions

The kernel statistics (kstats) functions are:

`kstat++_++create`::
  Create and initialize a new kstat
`kstat++_++delete`::
  Remove a kstat from the system
`kstat++_++install`::
  Add a fully initialized kstat to the system
`kstat++_++named++_++init`::
  Initialize a named kstat
`kstat++_++runq++_++back++_++to++_++waitq`::
  Record a transaction migration from run queue to the wait queue
`kstat++_++runq++_++enter`::
  Record a transaction addition to the run queue
`kstat++_++runq++_++exit`::
  Record a transaction removal from the run queue
`kstat++_++waitq++_++enter`::
  Record a transaction addition to the wait queue
`kstat++_++waitq++_++exit`::
  Record a transaction removal from the wait queue
`kstat++_++waitq++_++to++_++runq`::
  Record a transaction migration from the wait queue to the run queue

[[kernel-logging-and-printing-functions]]
=== Kernel Logging and Printing Functions

kernel logging functions

printing functions

The kernel logging and printing functions are:

`cmn++_++err`, `vcmn++_++err`::
  Display an error message
`ddi++_++report++_++dev`::
  Announce a device
`strlog`::
  Submit messages to the log driver
`ddi++_++dev++_++report++_++fault`::
  Report a hardware failure
`scsi++_++errmsg`::
  Display a SCSI request sense message
`scsi++_++log`::
  Display a SCSI-device-related message
`scsi++_++vu++_++errmsg`::
  Display a SCSI request sense message

[[buffered-io-functions]]
=== Buffered I/O Functions

buffered I/O functions

The buffered I/O functions are:

`physio`::
  Perform physical I/O
`aphysio`::
  Perform asynchronous physical I/O
`anocancel`::
  Prevent cancellation of an asynchronous I/O request
`minphys`::
  Limit the `physio` buffer size
`biowait`::
  Suspend processes pending completion of block I/O
`biodone`::
  Release the buffer after buffer I/O transfer and notify blocked
`bioerror`::
  Indicate the error in a buffer header
`geterror`::
  Return an I/O error
`bp++_++mapin`::
  Allocate virtual address space
`bp++_++mapout`::
  Deallocate virtual address space
`disksort`::
  Use a single-direction elevator seek strategy to sort for buffers
`getrbuf`::
  Get a raw buffer header
`freerbuf`::
  Free a raw buffer header
`biosize`::
  Return the size of a buffer structure
`bioinit`::
  Initialize a buffer structure
`biofini`::
  Uninitialize a buffer structure
`bioreset`::
  Reuse a private buffer header after I/O is complete
`bioclone`::
  Clone another buffer
`biomodified`::
  Check whether a buffer is modified
`clrbuf`::
  Erase the contents of a buffer

[[virtual-memory-functions]]
=== Virtual Memory Functions

virtual memory functions

The virtual memory functions are:

`ddi++_++btop`::
  Convert device bytes to pages (round down)
`ddi++_++btopr`::
  Convert device bytes to pages (round up)
`ddi++_++ptob`::
  Convert device pages to bytes
`btop`::
  Convert size in bytes to size in pages (round down)
`btopr`::
  Convert size in bytes to size in pages (round up)
`ptob`::
  Convert size in pages to size in bytes

.Deprecated Virtual Memory Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Functions |Replacement
|`hat++_++getkpfnum` |`devmap`, `ddi++_++dma++_*_++bind++_++handle`,
`ddi++_++dma++_++nextcookie`
|===

[[device-id-functions]]
=== Device ID Functions

device ID functions

The device ID functions are:

`ddi++_++devid++_++init`::
  Allocate a device ID structure
`ddi++_++devid++_++free`::
  Free a device ID structure
`ddi++_++devid++_++register`::
  Register a device ID
`ddi++_++devid++_++unregister`::
  Unregister a device ID
`ddi++_++devid++_++compare`::
  Compare two device IDs
`ddi++_++devid++_++sizeof`::
  Return the size of a device ID
`ddi++_++devid++_++valid`::
  Validate a device ID
`ddi++_++devid++_++str++_++encode`::
  Encode a device ID and minor++_++name into a null-terminated ASCII
  string; return a pointer to that string
`ddi++_++devid++_++str++_++decode`::
  Decode the device ID and minor++_++name from a previously encoded
  string; allocate and return pointers to the extracted parts
`ddi++_++devid++_++str++_++free`::
  Free all strings returned by the `ddi++_++devid++_*++` functions

[[scsi-functions]]
=== SCSI Functions

SCSI functions

The SCSI functions are:

`scsi++_++probe`::
  Probe a SCSI device
`scsi++_++unprobe`::
  Free resources allocated during initial probing
`scsi++_++alloc++_++consistent++_++buf`::
  Allocate an I/O buffer for SCSI DMA
`scsi++_++free++_++consistent++_++buf`::
  Free a previously allocated SCSI DMA I/O buffer
`scsi++_++init++_++pkt`::
  Prepare a complete SCSI packet
`scsi++_++destroy++_++pkt`::
  Free an allocated SCSI packet and its DMA resource
`scsi++_++setup++_++cdb`::
  Set up SCSI command descriptor block (CDB)
`scsi++_++transport`::
  Start a SCSI command
`scsi++_++poll`::
  Run a polled SCSI command
`scsi++_++ifgetcap`::
  Get SCSI transport capability
`scsi++_++ifsetcap`::
  Set SCSI transport capability
`scsi++_++sync++_++pkt`::
  Synchronize CPU and I/O views of memory
`scsi++_++abort`::
  Abort a SCSI command
`scsi++_++reset`::
  Reset a SCSI bus or target
`scsi++_++reset++_++notify`::
  Notify the target driver of bus resets
`scsi++_++cname`::
  Decode a SCSI command
`scsi++_++dname`::
  Decode a SCSI peripheral device type
`scsi++_++mname`::
  Decode a SCSI message
`scsi++_++rname`::
  Decode a SCSI packet completion reason
`scsi++_++sname`::
  Decode a SCSI sense key
`scsi++_++errmsg`::
  Display a SCSI request sense message
`scsi++_++log`::
  Display a SCSI-device-related message
`scsi++_++vu++_++errmsg`::
  Display a SCSI request sense message
`scsi++_++hba++_++init`::
  SCSI HBA system initialization routine
`scsi++_++hba++_++fini`::
  SCSI HBA system completion routine
`scsi++_++hba++_++attach++_++setup`::
  SCSI HBA attach routine
`scsi++_++hba++_++detach`::
  SCSI HBA detach routine
`scsi++_++hba++_++probe`::
  Default SCSI HBA probe function
`scsi++_++hba++_++tran++_++alloc`::
  Allocate a transport structure
`scsi++_++hba++_++tran++_++free`::
  Free a transport structure
`scsi++_++hba++_++pkt++_++alloc`::
  Allocate a `scsi++_++pkt` structure
`scsi++_++hba++_++pkt++_++free`::
  Free a `scsi++_++pkt` structure
`scsi++_++hba++_++lookup++_++capstr`::
  Return an index matching capability string

.Deprecated SCSI Functions
[width="100%",cols="45%,55%",options="header",]
|===
|Deprecated Function |Replacement
|`free++_++pktiopb` |`scsi++_++free++_++consistent++_++buf`
|`get++_++pktiopb` |`scsi++_++alloc++_++consistent++_++buf`
|`makecom++_++g0` |`scsi++_++setup++_++cdb`
|`makecom++_++g0++_++s` |`scsi++_++setup++_++cdb`
|`makecom++_++g1` |`scsi++_++setup++_++cdb`
|`makecom++_++g5` |`scsi++_++setup++_++cdb`
|`scsi++_++dmafree` |`scsi++_++destroy++_++pkt`
|`scsi++_++dmaget` |`scsi++_++init++_++pkt`
|`scsi++_++hba++_++attach` |`scsi++_++hba++_++attach++_++setup`
|`scsi++_++pktalloc` |`scsi++_++init++_++pkt`
|`scsi++_++pktfree` |`scsi++_++destroy++_++pkt`
|`scsi++_++resalloc` |`scsi++_++init++_++pkt`
|`scsi++_++resfree` |`scsi++_++destroy++_++pkt`
|`scsi++_++slave` |`scsi++_++probe`
|`scsi++_++unslave` |`scsi++_++unprobe`
|===

[[resource-map-management-functions]]
=== Resource Map Management Functions

resource map functions

The resource map management functions are:

`rmallocmap`::
  Allocate a resource map
`rmallocmap++_++wait`::
  Allocate a resource map, wait if necessary
`rmfreemap`::
  Free a resource map
`rmalloc`::
  Allocate space from a resource map
`rmalloc++_++wait`::
  Allocate space from a resource map, wait if necessary
`rmfree`::
  Free space back into a resource map

[[system-global-state]]
=== System Global State

system global state functions

`ddi++_++in++_++panic`::
  Determine whether the system is in panic state

[[utility-functions]]
[[utility-functions-1]]
=== Utility Functions

utility functions

The utility functions are:

`nulldev`::
  Zero return function
`nodev`::
  Error return function
`nochpoll`::
  Error return function for non-pollable devices
`ASSERT`::
  Expression verification
`bcopy`::
  Copy data between address locations in the kernel
`bzero`::
  Clear memory for a given number of bytes
`bcmp`::
  Compare two byte arrays
`ddi++_++ffs`::
  Find the first bit set in a long integer
`ddi++_++fls`::
  Find the last bit set in a long integer
`swab`::
  Swap bytes in 16-bit halfwords
`strcmp`::
  Compare two null-terminated strings
`strncmp`::
  Compare two null-terminated strings, with length limit
`strlen`::
  Determine the number of non-null bytes in a string
`strnlen`::
  Determine the number of non-null bytes in a string, with length limit
`strcpy`::
  Copy a string from one location to another
`strncpy`::
  Copy a string from one location to another, with length limit
`strchr`::
  Find a character in a string
`sprintf`, `vsprintf`::
  Format characters in memory
`numtos`::
  Convert an integer to a decimal string
`stoi`::
  Convert a decimal string to an integer
`max`::
  Return the larger of two integers
`min`::
  Return the lesser of two integers
`va++_++arg`::
  Finds the next value in a variable argument list
`va++_++copy`::
  Copies the state of a variable argument list
`va++_++end`::
  Deletes pointer to a variable argument list
`va++_++start`::
  Finds the pointer to the start of a variable argument list

[[making-a-device-driver-64-bit-ready]]
=== Making a Device Driver 64-Bit Ready

This appendix provides information for device driver writers who are
converting their device drivers to support the 64-bit kernel. It
presents the differences between 32-bit and 64-bit device drivers and
describes the steps to convert 32-bit device drivers to 64-bit. This
information is specific to regular character and block device drivers
only.

This appendix provides information on the following subjects:

* link:#introduction-to-64-bit-driver-design[Introduction to 64-Bit Driver Design]
* link:#general-conversion-steps[General Conversion Steps]
* {empty}link:#well-known-ioctl-interfaces[Well
Known Interfaces]

[[introduction-to-64-bit-driver-design]]
=== Introduction to 64-Bit Driver Design

For drivers that only need support for the 32-bit kernel, existing
32-bit device drivers will continue to work without recompilation.
However, most device drivers require some changes to run correctly in
the 64-bit kernel, and all device drivers require recompilation to
create a 64-bit driver module. The information in this appendix will
help you to enable drivers for 32-bit and 64-bit environments to be
generated from common source code, thus increasing code portability and
reducing the maintenance effort.

Before starting to modify a device driver for the 64-bit environment,
you should understand how the 32-bit environment differs from the 64-bit
environment. In particular, you must be familiar with the C language
data type models ILP32 and LP64. See the following table.

.Comparison of ILP32 and LP64 Data Types
[width="100%",cols="34%,33%,33%",options="header",]
|===
|C Type |ILP32 |LP64
|`char` |8 |8
|`short` |16 |16
|`int` |32 |32
|`long` |32 |64
|`long long` |64 |64
|`float` |32 |32
|`double` |64 |64
|`long double` |96 |128
|`pointer` |32 |64
|===

The driver-specific issues due to the differences between ILP32 and LP64
are the subject of this appendix. More general topics are covered in the
Solaris 64-bit Developer’s Guide.

In addition to general code cleanup to support the data model changes
for LP64, driver writers have to provide support for both 32-bit and
64-bit applications.

The `ioctl(9E)`, `devmap(9E)`, and `mmap(9E)` entry points enable data
structures to be shared directly between applications and device
drivers. If those data structures change size between the 32-bit and
64-bit environments, then the entry points must be modified so that the
driver can determine whether the data model of the application is the
same as that of the kernel. When the data models differ, data structures
can be adjusted. See link:#io-control-support-for-64-bit-capable-device-drivers[I/O Control Support for
64-Bit Capable Device Drivers], link:#32-bit-and-64-bit-data-structure-macros[32-bit and 64-bit
Data Structure Macros], and link:#associating-kernel-memory-with-user-mappings[Associating Kernel Memory
With User Mappings].

In many drivers, only a few `ioctls` need this kind of handling. The
other `ioctls` should work without change as long as these `ioctls` pass
data structures that do not change in size.

[[general-conversion-steps]]
=== General Conversion Steps

The sections below provide information on converting drivers to run in a
64-bit environment. Driver writers might need to perform one or more of
the following tasks:

[arabic]
. Use fixed-width types for hardware registers.
. Use fixed-width common access functions.
. Check and extend use of derived types.
. Check changed fields within DDI data structures.
. Check changed arguments of DDI functions.
. Modify the driver entry points that handle user data, where needed.
. Check structures that use 64-bit long types on x86 platforms.

These steps are explained in detail below.

After each step is complete, fix all compiler warnings,
and use `lint` to look for other problems. The SC5.0 (or newer) version
of `lint` should be used with `Xarch=v9` and `errchk=longptr64`
specified to find 64-bit problems. See the notes on using and
interpreting the output of `lint` in the Solaris 64-bit Developer’s
Guide.

[NOTE]

Do not ignore compilation warnings during conversion for LP64. Warnings
that were safe to ignore previously in the ILP32 environment might now
indicate a more serious problem.
===

After all the steps are complete, compile and test the driver as both a
32-bit and 64-bit module.

[[use-fixed-width-types-for-hardware-registers]]
==== Use Fixed-Width Types for Hardware Registers

Many device drivers that manipulate hardware devices use C data
structures to describe the layout of the hardware. In the LP64 data
model, data structures that use `long` or unsigned long to define
hardware registers are almost certainly incorrect, because `long` is now
a 64-bit quantity. Start by including `++<++sys/inttypes.h++>++`, and
update this class of data structure to use `int32++_++t` or
`uint32++_++t` instead of `long` for 32-bit device data. This approach
preserves the binary layout of 32-bit data structures. For example,
change:

[source,c]
----
struct device_regs {
    ulong_t        addr;
    uint_t         count;
};      /* Only works for ILP32 compilation */
----

to:

[source,c]
----
struct device_regs {
    uint32_t        addr;
    uint32_t        count;
};      /* Works for any data model */
----

[[use-fixed-width-common-access-functions]]
==== Use Fixed-Width Common Access Functions

The illumos DDI allows device registers to be accessed by access
functions for portability to multiple platforms. Previously, the DDI
common access functions specified the size of data in terms of bytes,
words, and so on. For example, `ddi++_++getl(9F)` is used to access
32-bit quantities. This function is not available in the 64-bit DDI
environment, and has been replaced by versions of the function that
specify the number of bits to be acted on.

These routines were added to the 32-bit kernel in the Solaris 2.6
operating environment, to enable their early adoption by driver writers.
For example, to be portable to both 32-bit and 64-bit kernels, the
driver must use `ddi++_++get32(9F)` to access 32-bit data rather than
`ddi++_++getl(9F)`.

All common access routines are replaced by their fixed-width
equivalents. See the `ddi++_++get8(9F)`, `ddi++_++put8(9F)`,
`ddi++_++rep++_++get8(9F)`, and `ddi++_++rep++_++put8(9F)` man pages for
details.

[[check-and-extend-use-of-derived-types]]
==== Check and Extend Use of Derived Types

System-derived types, such as `size++_++t`, should be used where
possible so that the resulting variables make sense when passed between
functions. The new derived types `uintptr++_++t` or `intptr++_++t`
should be used as the integral type for pointers.

Fixed-width integer types are useful for representing explicit sizes of
binary data structures or hardware registers, while fundamental C
language data types, such as `int`, can still be used for loop counters
or file descriptors.

Some system-derived types represent 32-bit quantities on a 32-bit system
but represent 64-bit quantities on a 64-bit system. Derived types that
change size in this way include: `clock++_++t`, `daddr++_++t`,
`dev++_++t`, `ino++_++t`, `intptr++_++t`, `off++_++t`, `size++_++t`,
`ssize++_++t`, `time++_++t`, `uintptr++_++t`, and
`timeout++_++id++_++t`.

When designing drivers that use these derived types, pay particular
attention to the use of these types, particularly if the drivers are
assigning these values to variables of another derived type, such as a
fixed-width type.

[[check-changed-fields-in-ddi-data-structures]]
==== Check Changed Fields in DDI Data Structures

The data types of some of the fields within DDI data structures, such as
`buf(9S)`, have been changed. Drivers that use these data structures
should make sure that these fields are being used appropriately. The
data structures and the fields that were changed in a significant way
are listed below.

[[buf-structure-changes]]
===== `buf` Structure Changes

changes to

The fields listed below pertain to transfer size, which can now exceed
more than 4 Gbytes.

[source,c]
----
size_t        b_bcount;          /* was type unsigned int */
size_t        b_resid;           /* was type unsigned int */
size_t        b_bufsize;         /* was type long */
----

[[ddidmaattr]]
===== `ddi++_++dma++_++attr`

The `ddi++_++dma++_++attr(9S)` structure defines
attributes of the DMA engine and the device. Because these attributes
specify register sizes, fixed-width data types have been used instead of
fundamental types.

[[ddidmacookie-structure-changes]]
===== `ddi++_++dma++_++cookie` Structure Changes

[source,c]
----
uint32_t     dmac_address;    /* was type unsigned long */
size_t       dmac_size;       /* was type u_int */
----

The `ddi++_++dma++_++cookie(9S)` structure contains a
32-bit DMA address, so a fixed-width data type has been used to define
the address. The size has been redefined as `size++_++t`.

[[csiarqstatus-structure-changes]]
===== `csi++_++arq++_++status` Structure Changes

[source,c]
----
uint_t    sts_rqpkt_state;         /* was type u_long */
uint_t    sts_rqpkt_statistics;    /* was type u_long */
----

These fields in the structure do not need to grow and
have been redefined as 32-bit quantities.

[[scsi_pkt-structure-changes]]
===== `scsi++_++pkt` Structure Changes

[source,c]
----
uint_t      pkt_flags;           /* was type u_long */
int     pkt_time;        /* was type long */
ssize_t     pkt_resid;           /* was type long */
uint_t      pkt_state;           /* was type u_long */
uint_t      pkt_statistics;      /* was type u_long */
----

Because the `pkt++_++flags`, `pkt++_++state`, and
`pkt++_++statistics` fields in the `scsi++_++pkt(9S)` structure do not
need to grow, these fields have been redefined as 32-bit integers. The
data transfer size `pkt++_++resid` field _does_ grow and has been
redefined as `ssize++_++t`.

[[check-changed-arguments-of-ddi-functions]]
==== Check Changed Arguments of DDI Functions

This section describes the DDI function argument data types that have
been changed.

[[getrbuf-argument-changes]]
===== `getrbuf` Argument Changes

....
struct buf *getrbuf(int sleepflag);
....

In previous releases, `sleepflag` was defined as a type
`long`.

[[drv_getparm-argument-changes]]
===== `drv++_++getparm` Argument Changes

[source,c]
----
int drv_getparm(unsigned int parm, void *value_p);
----

In previous releases, `value++_++p` was defined as type
`unsigned long`. In the 64-bit kernel, `drv++_++getparm(9F)` can fetch
both 32-bit and 64-bit quantities. The interface does not define data
types of these quantities, and simple programming errors can occur.

The following new routines offer a safer alternative:

[source,c]
----
clock_t       ddi_get_lbolt(void);
time_t        ddi_get_time(void);
cred_t        *ddi_get_cred(void);
pid_t         ddi_get_pid(void);
----

Driver writers
are strongly urged to use these routines instead of
`drv++_++getparm(9F)`.

[[delay-and-timeout-argument-changes]]
===== `delay` and `timeout` Argument Changes

[source,c]
----
void delay(clock_t ticks);
timeout_id_t timeout(void (*func)(void *), void *arg, clock_t ticks);
----

++<++ticks++>++ argument to the `delay(9F)` and `timeout(9F)` routines
has been changed from `long` to `clock++_++t`.

[[rmallocmap-and-rmallocmap_wait-argument-changes]]
===== `rmallocmap` and `rmallocmap++_++wait` Argument Changes

[source,c]
----
struct map *rmallocmap(size_t mapsize);
struct map *rmallocmap_wait(size_t mapsize);
----

The `mapsize` argument to
the `rmallocmap(9F)` and `rmallocmap++_++wait(9F)` routines has been
changed from `ulong++_++t` to `size++_++t`.

[[scsiallocconsistent_buf-argument-changes]]
===== `scsi++_++alloc++_++consistent++_++buf` Argument Changes

[source,c]
----
struct buf *scsi_alloc_consistent_buf(struct scsi_address *ap,
    struct buf *bp, size_t datalen, uint_t bflags,
    int (*callback )(caddr_t), caddr_t arg);
----

In previous releases, `datalen` was defined as an `int`
and `bflags` was defined as a `ulong`.

[[uiomove-argument-changes]]
===== `uiomove` Argument Changes

[source,c]
----
int uiomove(caddr_t address, size_t nbytes,
    enum uio_rw rwflag, uio_t *uio_p);
----

The `nbytes` argument was defined as a
type `long`, but because `nbytes` represents a size in bytes,
`size++_++t` is more appropriate.

[[cvtimedwait-and-cvtimedwait_sig-argument-changes]]
===== `cv++_++timedwait` and `cv++_++timedwait++_++sig` Argument Changes

cv++_++timedwait

changes to

cv++_++timedwait++_++sig

changes to

argument,

cv++_++timedwait

changes to

[source,c]
----
int cv_timedwait(kcondvar_t *cvp, kmutex_t *mp, clock_t timeout);
int cv_timedwait_sig(kcondvar_t *cvp, kmutex_t *mp,    clock_t timeout);
----

In previous releases, the `timeout` argument to the
`cv++_++timedwait(9F)` and `cv++_++timedwait++_++sig(9F)` routines was
defined to be of type `long`. Because these routines represent time in
ticks, `clock++_++t` is more appropriate.

[[ddidevicecopy-argument-changes]]
===== `ddi++_++device++_++copy` Argument Changes

[source,c]
----
int ddi_device_copy(ddi_acc_handle_t src_handle,
    caddr_t src_addr, ssize_t src_advcnt,
    ddi_acc_handle_t dest_handle, caddr_t dest_addr,
    ssize_t dest_advcnt, size_t bytecount, uint_t dev_datasz);
----

`src++_++advcnt`, `dest++_++advcnt`, `dev++_++datasz` arguments have
changed type. These arguments were previously defined as `long`, `long`,
and `ulong++_++t` respectively.

[[ddidevicezero-argument-changes]]
===== `ddi++_++device++_++zero` Argument Changes

[source,c]
----
int ddi_device_zero(ddi_acc_handle_t handle,
    caddr_t dev_addr, size_t bytecount, ssize_t dev_advcnt,
    uint_t dev_datasz):
----

In previous releases,
`dev++_++advcnt` was defined as a type `long` and `dev++_++datasz` as a
`ulong++_++t`.

[[ddidmamem_alloc-argument-changes]]
===== `ddi++_++dma++_++mem++_++alloc` Argument Changes

[source,c]
----
int ddi_dma_mem_alloc(ddi_dma_handle_t handle,
    size_t length, ddi_device_acc_attr_t *accattrp,
    uint_t flags, int (*waitfp)(caddr_t), caddr_t arg,
    caddr_t *kaddrp, size_t *real_length,
    ddi_acc_handle_t *handlep);
----

In previous
releases, `length`, `flags`, and `real++_++length` were defined with
types `uint++_++t`, `ulong++_++t`, and `uint++_++t ++*++`.

[[modify-routines-that-handle-data-sharing]]
==== Modify Routines That Handle Data Sharing

If a device driver shares data structures that contain
`long`s or pointers with a 32-bit application using `ioctl(9E)`,
`devmap(9E)`, or `mmap(9E)`, and the driver is recompiled for a 64-bit
kernel, the binary layout of data structures will be incompatible. If a
field is currently defined in terms of type `long` and 64-bit data items
are not used, change the data structure to use data types that remain as
32-bit quantities (`int` and `unsigned` `int`). Otherwise, the driver
needs to be aware of the different structure shapes for ILP32 and LP64
and determine whether a model mismatch between the application and the
kernel has occurred.

To handle potential data model differences, the `ioctl`, `devmap`, and
`mmap` driver entry points, which interact directly with user
applications, need to be written to determine whether the argument came
from an application using the same data model as the kernel.

[[data-sharing-in-ioctl]]
===== Data Sharing in `ioctl`

To determine whether a model mismatch exists between the
application and the driver, the driver uses the `FMODELS` mask to
determine the model type from the `ioctl` `mode` argument. The following
values are OR-ed into mode to identify the application data model:

* `FLP64` – Application uses the LP64 data model
* `FILP32` – Application uses the ILP32 data model

The code examples in
link:#io-control-support-for-64-bit-capable-device-drivers[I/O Control Support for 64-Bit Capable Device
Drivers] show how this situation can be handled using
`ddi++_++model++_++convert++_++from(9F)`.

[[data-sharing-in-devmap]]
===== Data Sharing in `devmap`

To enable a 64-bit driver and a 32-bit application to
share memory, the binary layout generated by the 64-bit driver must be
the same as the layout consumed by the 32-bit application. The mapped
memory being exported to the application might need to contain
data-model-dependent data structures.

Few memory-mapped devices face this problem because the device registers
do not change size when the kernel data model changes. However, some
pseudo-devices that export mappings to the user address space might want
to export different data structures to ILP32 or LP64 applications. To
determine whether a data model mismatch has occurred, `devmap(9E)` uses
the `model` parameter to describe the data model expected by the
application. The `model` parameter is set to one of the following
values:

* `DDI++_++MODEL++_++ILP32` – The application uses the
ILP32 data model
* `DDI++_++MODEL++_++LP64` – The application uses the LP64
data model

The model parameter can be passed untranslated to the
`ddi++_++model++_++convert++_++from(9F)` routine or to
`STRUCT++_++INIT`. See link:#32-bit-and-64-bit-data-structure-macros[32-bit and 64-bit Data
Structure Macros].

[[data-sharing-in-mmap]]
===== Data Sharing in `mmap`

Because `mmap(9E)` does not have a parameter that can be
used to pass data model information, the driver's `mmap(9E)` entry point
can be written to use the new DDI function
`ddi++_++model++_++convert++_++from(9F)`. This function returns one of
the following values to indicate the application's data type model:

* `DDI++_++MODEL++_++ILP32` – Application expects the
ILP32 data model
* `DDI++_++MODEL++_++ILP64` – Application expects the LP64
data model
* `DDI++_++FAILURE` – Function was not called from `mmap(9E)`

As with `ioctl` and `devmap`, the model bits can be passed to
`ddi++_++model++_++convert++_++from(9F)` to determine whether data
conversion is necessary, or the model can be handed to
`STRUCT++_++INIT`.

Alternatively, migrate the device driver to support the `devmap(9E)`
entry point.

[[check-structures-with-64-bit-long-data-types-on-x86-based-platforms]]
==== Check Structures with 64-bit Long Data Types on x86-Based Platforms

You should carefully check structures that use 64-bit long types, such
as `uint64++_++t`, on the x86 platforms. The alignment and size can
differ between compilation in 32-bit mode versus a 64-bit mode. Consider
the following example.

[source,c]
----
#include &lt;studio>
#include &ltsys>

struct myTestStructure {
        uint32_t        my1stInteger;
        uint64_t        my2ndInteger;
};

{
        struct myTestStructure a;

        printf("sizeof myTestStructure is: %d\n", sizeof(a));
        printf("offset to my2ndInteger is: %d\n", (uintptr_t)&a.bar - (uintptr_t)&a);
}
----

On a 32-bit system, this example displays the following results:

....
sizeof myTestStructure is: 12
offset to my2ndInteger is: 4
....

Conversely, on a 64-bit system, this example displays the following
results:

....
sizeof myTestStructure is: 16
offset to my2ndInteger is: 8
....

Thus, the 32-bit application and the 64-bit application view the
structure differently. As a result, trying to make the same structure
work in both a 32-bit and 64-bit environment can cause problems. This
situation occurs often, particularly in situations where structures are
passed into and out of the kernel through `ioctl` calls.

[[well-known-ioctl-interfaces]]
=== Well Known `ioctl` Interfaces

Many `ioctl(9E)` operations are common to a class of
device drivers. For example, most disk drivers implement many of the
`dkio(4I)` family of `ioctls`. Many of these interfaces copy in or copy
out data structures from the kernel, and some of these data structures
have changed size in the LP64 data model. The following section lists
the `ioctls`that now require explicit conversion in 64-bit driver
`ioctl` routines for the `dkio`, `fdio(4I)`, `fbio(4I)`, `cdio(4I)`, and
`mtio(4I)` families of `ioctls`.

[width="100%",cols="30%,29%,41%",options="header",]
|===
|`ioctl` command |Affected data structure |Reference
a|
`DKIOCGAPART`

`DKIOCSAPART`

a|
`dk++_++map`

`dk++_++allmap`

|`dkio(4I)`
a|
`DKIOGVTOC`

`DKIOSVTOC`

a|
`partition`

`vtoc`

|`dkio(4I)`
a|
`FBIOPUTCMAP`

`FBIOGETCMAP`

|`fbcmap` |`fbio(4I)`
a|
`FBIOPUTCMAPI`

`FBIOGETCMAPI`

|`fbcmap++_++i` |`fbio(4I)`
a|
`FBIOGCURSOR`

`FBIOSCURSOR`

|`fbcursor` |`fbio(4I)`
a|
`CDROMREADMODE1`

`CDROMREADMODE2`

|`cdrom++_++read` |`cdio(4I)`
|`CDROMCDDA` |`cdrom++_++cdda` |`cdio(4I)`
|`CDROMCDXA` |`cdrom++_++cdxa` |`cdio(4I)`
|`CDROMSUBCODE` |`cdrom++_++subcode` |`cdio(4I)`
|`FDIOCMD` |`fd++_++cmd` |`fdio(4I)`
|`FDRAW` |`fd++_++raw` |`fdio(4I)`
|`MTIOCTOP` |`mtop` |`mtio(4I)`
|`MTIOCGET` |`mtget` |`mtio(4I)`
|`MTIOCGETDRIVETYPE` |`mtdrivetype++_++request` |`mtio(4I)`
|`USCSICMD` |`uscsi++_++cmd` |`scsi++_++free++_++consistent++_++buf(9F)`
|===

[[device-sizes]]
==== Device Sizes

nblocks property is exported by each slice of a block device driver.
This property contains the number of 512-byte blocks that each slice of
the device can support. The nblocks property is defined as a signed
32-bit quantity, which limits the maximum size of a slice to 1 Tbyte.

Disk devices that provide more than 1 Tbyte of storage per disk must
define the Nblocks property, which should still contain the number of
512 byte blocks that the device can support. However, Nblocks is a
signed 64-bit quantity, which removes any practical limit on disk space.

The nblocks property is now deprecated. All disk devices should provide
the Nblocks property.

[[console-frame-buffer-drivers]]
=== Console Frame Buffer Drivers

Drivers for frame buffers that are used for the system
console must provide interfaces to enable the system to display text on
the console. illumos provides enhanced visual I/O interfaces to enable
the kernel terminal emulator to display text directly on the console
frame buffer. This appendix describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.

[[illumos-consoles-and-the-kernel-terminal-emulator]]
=== illumos Consoles and the Kernel Terminal Emulator

role of the kernel terminal emulator is to render text onto the console
frame buffer in the proper position and representation determined by the
frame buffer's screen height, width, and pixel depth mode. The terminal
emulator also drives scrolling, controls a software cursor, and
interprets ANSI terminal escape sequences. The terminal emulator
accesses the console frame buffer in either VGA text mode or pixel mode,
depending upon the graphics card. To be used as an illumos console frame
buffer driver, your frame buffer driver must be compatible with the
illumos kernel terminal emulator. The target platform is the most
significant factor that determines whether you need to modify your frame
buffer driver to make your driver compatible with the illumos kernel
terminal emulator.

* x86 platforms – Console frame buffer drivers do not need to be
modified because x86 console frame buffer drivers already support the
console frame buffer interfaces.
* SPARC platforms – Console frame buffer drivers should use the
interfaces described in this appendix to enable the driver to interact
with the illumos kernel terminal emulator.

[[x86-platform-console-communication]]
==== x86 Platform Console Communication

tem (terminal emulator module)

VGA text mode

On x86 platforms, the illumos kernel terminal emulator module (`tem`)
uses VGA text mode exclusively to interact with the `vgatext` module.
The `vgatext` module uses industry standard VGA text mode to interact
with x86 compatible frame buffer devices. Because the `vgatext` module
already supports the console frame buffer interfaces, x86 frame buffer
drivers are compatible with the kernel `tem` module. You do not need to
add special interfaces to x86 frame buffer drivers.

The remainder of this appendix applies to SPARC platforms only.

[[sparc-platform-console-communication]]
==== SPARC Platform Console Communication

video mode

SPARC frame buffer drivers typically do not operate in VGA text mode.
SPARC frame buffer drivers typically are required to send pixel patterns
that depict the text and images displayed. The kernel `tem` requires
SPARC drivers to support specific interfaces to facilitate rendering
data to the screen, perform scrolling, and display a text cursor. How
the driver actually renders data sent from the `tem` onto the screen
depends on the device. The driver typically draws the data into video
memory according to the hardware and video mode.

illumos provides interfaces that enable the kernel terminal emulator to
drive compatible console frame buffers directly. The advantages of
converting a driver to be compatible with the kernel terminal emulator
are:

* Dramatically improved performance, particularly for scrolling
* Enhanced ANSI text color capabilities
* The ability to start a login session on the console frame buffer even
when the system console stream is directed out the serial port

SPARC console frame buffer drivers are not required to be compatible
with the kernel terminal emulator. If the console frame buffer driver is
not compatible with the kernel terminal emulator, the system uses the
FCode terminal emulator in the OpenBoot PROM.

The console frame buffer is identified
through the EEPROM `screen` environment variable. The system determines
whether the console frame buffer is compatible with the kernel terminal
emulator module by checking whether the frame buffer driver exports the
`tem-support` DDI property. If the `tem-support` property is exported,
then the system issues the `VIS++_++DEVINIT` I/O control (`ioctl`)
command to the frame buffer driver during system boot, while configuring
the console. If the `tem-support` DDI property is exported and the
`VIS++_++DEVINIT` `ioctl` command succeeds and returns a compatible
version number to the `tem`, the system configures the system console to
utilize that frame buffer driver through the kernel terminal emulator.
See the `ioctl(9E)` man page for information about the I/O control
driver entry point.

SPARC drivers that support the kernel terminal emulator should export
the `tem-support` DDI property. This property indicates that the driver
supports the kernel terminal emulator. If a frame buffer driver exports
the `tem-support` DDI property, then that driver will be handled early
in the boot process, while the console is being configured. If a frame
buffer driver does not export the `tem-support` property, then that
driver might not be handled early enough in the boot process.

`tem-support`::
  When set to 1, this DDI property indicates that this driver is
  compatible with the console kernel frame buffer interface.

The kernel terminal emulator module interacts with the console frame
buffer driver through two major interfaces:

* Through `ioctl` interfaces during normal system operation
* Through polled I/O interfaces during standalone mode

The following section provides detailed information.

[[console-visual-io-interfaces]]
=== Console Visual I/O Interfaces

kernel terminal emulator interacts with the console frame buffer driver
through two interfaces. During normal system activity (after a
successful boot of the system), communication between the kernel
terminal emulator and the console frame buffer driver is through `ioctl`
interfaces. During standalone mode (before system boot or during
debugging), communication between the kernel terminal emulator and the
console frame buffer driver is through polled I/O interfaces. All
activity between the kernel terminal emulator and the console frame
buffer driver is initiated by the kernel terminal emulator, with the
exception of a callback function used by the console frame buffer driver
to notify the kernel terminal emulator of changes in the video mode.

The console visual I/O interfaces are documented in detail in the
`visual++_++io(4I)` man page. For more information on the video mode
change callback function, see link:#video-mode-change-callback-interface[Video Mode Change Callback
Interface].

[[io-control-interfaces]]
==== I/O Control Interfaces

During normal system activity, the kernel terminal emulator communicates
with the console frame buffer driver through the `ioctl` interfaces
listed in the following table:

[width="100%",cols="34%,33%,33%",options="header",]
|===
|`ioctl` Name |Corresponding Data Structure |Description
|`VIS++_++DEVINIT` |`vis++_++devinit` |Initializes the session between
the terminal emulator module and the frame buffer. See link:#vis_devinit[].

|`VIS++_++DEVFINI` |Not Applicable |Terminates the session between the
terminal emulator module and the frame buffer. See link:#vis_defini[].

|`VIS++_++CONSDISPLAY` |`vis++_++consdisplay` |Displays pixels as a
rectangle. See link:#vis_consdisplay[].

|`VIS++_++CONSCOPY` |`vis++_++conscopy` |Copies a rectangle of pixels
(scroll). See link:#vis_conscopy[].

|`VIS++_++CONSCURSOR` |`vis++_++conscursor` |Displays or hides a text
cursor. See link:#vis_conscursor[].

|`VIS++_++PUTCMAP` |`vis++_++cmap` |Sends the terminal emulator module
color map to the frame buffer driver. See link:#vis_putcmap[].

|`VIS++_++GETCMAP` |`vis++_++cmap` |Reads the terminal emulator module
color map from the frame buffer. See link:#vis_getcmap[].
|===

[[polled-io-interfaces]]
==== Polled I/O Interfaces

The polled I/O
interfaces provide the same functionality as the `VIS++_++CONSDISPLAY`,
`VIS++_++CONSCOPY`, and `VIS++_++CONSCURSOR` `ioctl` interfaces. The
polled I/O interfaces are called only when the operating system is
quiesced and in _standalone_ mode. See link:#implementing-polled-io-in-console-frame-buffer-drivers[Implementing Polled
I/O in Console Frame Buffer Drivers] for more information.

While in standalone mode, the kernel terminal emulator communicates with
the console frame buffer driver through the polled I/O interfaces listed
in the following table:

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Polled I/O Function |Corresponding Data Structure |Description
|`(++*++display)` |`vis++_++consdisplay` |Displays pixels as a
rectangle.

|`(++*++copy)` |`vis++_++conscopy` |Copies a rectangle of pixels
(scroll).

|`(++*++cursor)` |`vis++_++conscursor` |Displays or hides a text cursor.
|===

[[video-mode-change-callback-interface]]
==== Video Mode Change Callback Interface

The console frame buffer driver and the
kernel terminal emulator must be in agreement about the video mode at
all times. _Video mode_ includes the console screen height, width, and
depth in pixels. Video mode also includes whether communication between
the kernel terminal emulator and the console frame buffer is in VGA text
mode or pixel mode.

In order for the console frame buffer driver to notify the kernel
terminal emulator of changes in the video mode, the console frame buffer
driver is initialized with the address of the `(++*++modechg++_++cb)`
kernel terminal emulator callback function described in the following
table:

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Callback Function |Corresponding Data Structures |Description
|`(++*++modechg++_++cb)` a|
`vis++_++modechg++_++arg`

`vis++_++devinit`

|Keep the terminal emulator module synchronized with the driver video
mode (screen height, width, and pixel depth).
|===

[[implementing-the-visual-io-interfaces-in-console-frame-buffer-drivers]]
=== Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers

Except for the video mode change callback, all activity between the
driver and the kernel terminal emulator is initiated by the `tem`
(terminal emulator module). This means that the `tem` issues all of the
`ioctl` commands described in this document. The following sections
provide implementation details for each `ioctl` command. For more
information, see the `visual++_++io(4I)` man page and the
`/usr/include/sys/visual++_++io.h` include file. See link:#video-mode-change-callback-interface[Video
Mode Change Callback Interface] for detailed information about the video
mode change callback function.

[NOTE]

Each `ioctl` command should determine whether the `FKIOCTL` is set in
the `ioctl` flag argument and return `EPERM` if that bit is not set.
===

[[vis_devinit]]
==== `VIS++_++DEVINIT`

The `VIS++_++DEVINIT` `ioctl` command initializes the frame buffer
driver as the system console device. This `ioctl` passes the address of
a `vis++_++devinit` structure.

The `tem` first loads the address of its video mode change callback
function into the `modechg++_++cb` field of the `vis++_++devinit`
structure and loads its soft state into the `modechg++_++arg` field. The
`tem` then issues the `VIS++_++DEVINIT` `ioctl` command. The frame
buffer driver then initializes itself and returns a summary of its
configuration back to the `tem` by setting the `version`, `width`,
`height`, `linebytes`, `depth`, `mode`, and `polledio` fields in the
`vis++_++devinit` structure. The `vis++_++devinit` structure is shown in
the following code.

[source,c]
----
struct vis_devinit {
      /*
       * This set of fields are used as parameters passed from the
       * layered frame buffer driver to the terminal emulator.
       */
      int             version;        /* Console IO interface rev */
      screen_size_t   width;          /* Width of the device */
      screen_size_t   height;         /* Height of the device */
      screen_size_t   linebytes;      /* Bytes per scan line */
      int             depth;          /* Device depth */
      short           mode;           /* Display mode Mode */
      struct vis_polledio *polledio;  /* Polled output routines */
      /*
       * The following fields are used as parameters passed from the
       * terminal emulator to the underlying frame buffer driver.
       */
      vis_modechg_cb_t modechg_cb;   /* Video mode change callback */
      struct vis_modechg_arg *modechg_arg;  /* Mode change cb arg */
};
----

To implement the `VIS++_++DEVINIT` `ioctl` command in the console frame
buffer driver, follow these general steps:

[arabic]
. Define a `struct` to contain the console-specific state. This
structure is private to the console frame buffer driver. This structure
is referred to as `consinfo` in this appendix. The `consinfo` structure
contains information such as:
* Current size of the blit buffer
* Pointer to the blit buffer
* Color map information
* Driver rendering mode information such as line pitch
* Background color
* Video memory address
* Terminal emulator callback address
. Allocate memory:
[arabic]
.. Allocate a blit buffer large enough to store a reasonable default
sized rectangle of pixels at the highest video depth. Additional memory
can be allocated if an incoming request exceeds the size of the buffer.
The frame buffer driver's largest font is 12×22. Assuming
`DEFAULT++_++HEIGHT` is 12, `DEFAULT++_++WIDTH` is 22, and the maximum
video depth is 32, the buffer size should be 8448 bytes
(`DEFAULT++_++HEIGHT` × `DEFAULT++_++WIDTH` × 32).
.. Allocate a `vis++_++polledio` structure.
.. Allocate a buffer to hold a cursor. This buffer should be the size of
the largest character. This buffer will not change size.
. Obtain the video change callback address and callback context of the
`tem` from `modechg++_++cb` and `modechg++_++ctx` and store this
information in the `consinfo` structure.
. Populate the `vis++_++polledio` structure with entry point addresses
for the polled display, copy, and cursor functions.
. Provide the appropriate information in the fields of the
`vis++_++devinit` structure that was passed to the driver by the `tem`:
[arabic]
.. Set the `version` field to `VIS++_++CONS++_++REV`, which is a
constant defined in the `/usr/include/sys/visual++_++io.h` header file.
.. Set the `mode` field to `VIS++_++PIXEL`.
.. Set the `polledio` field to the address of the `vis++_++polledio`
structure.
.. Set the `height` field to the video mode height in pixels.
.. Set the `width` field to the video mode width in pixels.
.. Set the `depth` field to the frame buffer pixel depth in bytes (for
example, a 32-bit pixel depth would be 4 bytes).
.. Set the `linebytes` field to the value of `height` × `width` ×
`depth`.
+
This information is sent from the driver to the `tem` by using the
`vis++_++devinit` structure. This information tells the terminal
emulator how to render information and pass it to the graphics driver.
+
Whenever the console frame buffer driver
changes its video mode (specifically `height`, `width`, or `depth`), the
driver _must_ call the video mode change callback function of the `tem`
to update the `vis++_++devinit` structure and to pass this structure
back to the terminal emulator. The terminal emulator passes its mode
change callback function address in the `modechg++_++cb` field of the
`vis++_++devinit` structure. The mode change callback function has the
following function signature:
+
....
typedef void (*vis_modechg_cb_t)
      (struct vis_modechg_arg *, struct vis_devinit *);
....
+
As shown in the preceding `typedef`, the mode change callback function
takes two arguments. The first argument is the `modechg++_++arg` and the
second argument is the `vis++_++devinit` structure. The
`modechg++_++arg` is sent from the `tem` to the driver during the
`VIS++_++DEVINIT` `ioctl` command initialization. The driver must send
the `modechg++_++arg` back to the `tem` with each video mode change
callback.
. Initialize the context of the kernel console. Specific requirements
vary depending upon the capability of the graphics device. This
initialization might include such steps as setting the draw engine
state, initializing the palette, or locating and mapping video memory or
the rendering engine so that data can be blitted onto the screen.
. Return the `vis++_++devinit` structure to the caller.

[[vis_defini]]
==== `VIS++_++DEFINI`

The `VIS++_++DEFINI` `ioctl` command releases the driver's console
resources and finishes the session.

To implement the `VIS++_++DEVFINI` `ioctl` command in the console frame
buffer driver, follow these general steps:

[arabic]
. Reset the console frame buffer driver state.
. Clear the polled I/O entry points and the kernel terminal emulator
video change function callback address.
. Release memory.

[[vis_consdisplay]]
==== `VIS++_++CONSDISPLAY`

The `VIS++_++CONSDISPLAY` `ioctl` command displays a rectangle of pixels
at a specified location. This display is also referred to as _blitting_
a rectangle. The `vis++_++consdisplay` structure contains the
information necessary to render a rectangle at the video depth that both
the driver and the `tem` are using. The `vis++_++consdisplay` structure
is shown in the following code.

[source,c]
----
struct vis_consdisplay {
      screen_pos_t    row;      /* Row (in pixels) to display data at */
      screen_pos_t    col;      /* Col (in pixels) to display data at */
      screen_size_t   width;    /* Width of data (in pixels) */
      screen_size_t   height;   /* Height of data (in pixels) */
      unsigned char   *data;    /* Address of pixels to display */
      unsigned char   fg_color; /* Foreground color */
      unsigned char   bg_color; /* Background color */
};
----

To implement the `VIS++_++CONSDISPLAY` `ioctl` command in the console
frame buffer driver, follow these general steps:

[arabic]
. Copy the `vis++_++consdisplay` structure.
. Validate the display parameters. Return an error if any of the display
parameters is out of range.
. Calculate the size of the rectangle to be blitted into video memory.
Validate this size against the size of the blit buffer created during
`VIS++_++DEVINIT`. Allocate additional memory for the blit buffer if
necessary.
. Retrieve the blit data. This data has been prepared by the kernel
terminal emulator at the agreed upon pixel depth. That depth is the same
pixel depth that was conveyed by the `tem` during `VIS++_++DEVINIT`. The
pixel depth is updated whenever the device driver changes video modes
through callback to the `tem`. Typical pixel depths are 8-bit color map
indexed, and 32-bit TrueColor.
. Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
`VIS++_++CONSDISPLAY` `ioctl` completes.
. Establish the driver-specific console rendering context.
. If the frame buffer is running in 8-bit color indexed mode, restore
the kernel console color map that the `tem` set up through a previous
`VIS++_++PUTCMAP` `ioctl`. A lazy color map loading scheme is
recommended to optimize performance. In a _lazy_ scheme, the console
frame buffer only restores colors it has actually used since the
`VIS++_++DEVINIT` `ioctl` was issued.
. Display the data passed from the `tem` at the pixel coordinates sent
by the `tem`. You might need to transform the RGB pixel data byte order.

[[vis_conscopy]]
==== `VIS++_++CONSCOPY`

The `VIS++_++CONSCOPY` `ioctl` command copies a rectangular region of
pixels from one location to another location. One use for this `ioctl`
is to scroll.

To implement the `VIS++_++CONSCOPY` `ioctl` command in the console frame
buffer driver, follow these general steps:

[arabic]
. Copy the `vis++_++conscopy` structure. The `vis++_++conscopy`
structure describes the source and target rectangle sizes and locations.
. Validate the display parameters. Return an error if any of the display
parameters is out of range.
. Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
`VIS++_++CONSDISPLAY` `ioctl` completes.
. Call the function to copy the rectangle.
+
[NOTE]

For optimal performance, use the rendering engine of the graphic device
to implement the copy function. You need to decide how to do the context
management within the driver to set up the rendering engine for best
performance.
===

[[vis_conscursor]]
==== `VIS++_++CONSCURSOR`

The `VIS++_++CONSCURSOR` `ioctl` command displays or hides a cursor. The
`vis++_++conscursor` structure is shown in the following code.

[source,c]
----
struct vis_conscursor {
      screen_pos_t    row;      /* Row to display cursor (in pixels) */
      screen_pos_t    col;      /* Col to display cursor (in pixels) */
      screen_size_t   width;    /* Width of cursor (in pixels) */
      screen_size_t   height;   /* Height of cursor (in pixels) */
      color_t         fg_color; /* Foreground color */
      color_t         bg_color; /* Background color */
      short           action;   /* Show or Hide cursor */
};
----

To implement the `VIS++_++CONSCOPY` `ioctl` command in the console frame
buffer driver, follow these general steps:

[arabic]
. Copy the `vis++_++conscursor` structure from the kernel terminal
emulator.
. Validate the display parameters. Return an error if any of the display
parameters are out of range.
. Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
`VIS++_++CONSDISPLAY` `ioctl` completes.
. The terminal emulator can call the `VIS++_++CONSCOPY` `ioctl` with one
of the following two actions: `SHOW++_++CURSOR` and `HIDE++_++CURSOR`.
The following steps describe how to implement this functionality by
reading and writing video memory. You might also be able to use the
rendering engine to do this work. Whether you can use the rendering
engine depends on the frame buffer hardware.
+
Take these steps to implement the `SHOW++_++CURSOR` functionality:
[arabic]
.. Save the pixels within the rectangle where the cursor will be drawn.
These saved pixels will be needed to hide the cursor.
.. Scan all the pixels on the screen bounded by the rectangle where the
cursor will be drawn. Within this rectangle, replace the pixels that
match the specified cursor foreground color (`fg++_++color`) with white
pixels. Replace the pixels that match the specified cursor background
color (`bg++_++color`) with black pixels. The visual effect is of a
black cursor over white text. This method works with any foreground and
background color of text. Attempting to invert colors based upon color
map position is not feasible. More sophisticated strategies, such as
attempting color inversion using HSB coloring (Hue, Saturation,
Brightness), are not necessary.
+
To implement the `HIDE++_++CURSOR` functionality, replace the pixels
beneath the cursor rectangle with the pixels saved from the previous
`SHOW++_++CURSOR` action.

[[vis_putcmap]]
==== `VIS++_++PUTCMAP`

The `VIS++_++PUTCMAP` `ioctl` command establishes the console color map.
The terminal emulator calls this function to set up the color map of the
kernel. The `vis++_++cmap` structure is shown in the following code.
This structure only applies to 8-bit color indexed mode.

[source,c]
----
struct vis_cmap {
      int             index;  /* Index into colormap to start updating */
      int             count;  /* Number of entries to update */
      unsigned char   *red;   /* List of red values */
      unsigned char   *green; /* List of green values */
      unsigned char   *blue;  /* List of blue values */
};
----

The `VIS++_++PUTCMAP` `ioctl` command is similar to the `FBIOPUTCMAP`
command. The `VIS++_++PUTCMAP` command is specific to the frame buffer
terminal-emulator compatible console code.

[[vis_getcmap]]
==== `VIS++_++GETCMAP`

The terminal emulator calls the `VIS++_++GETCMAP` `ioctl` command to
retrieve the console color map.

[[implementing-polled-io-in-console-frame-buffer-drivers]]
=== Implementing Polled I/O in Console Frame Buffer Drivers

console frame buffer drivers

polled I/O interfaces

I/O

polled I/O interfaces

polled I/O interfaces

console frame buffer drivers

standalone mode

The polled I/O interfaces are implemented as functions in the driver and
are called directly by the kernel terminal emulator. The driver passes
the address of its polled I/O entry points to the terminal emulator
during the execution of the `VIS++_++DEVINIT` `ioctl` command. The
`VIS++_++DEVINIT` command is initiated by the terminal emulator.

The `vis++_++polledio` structure is shown in the following code.

[source,c]
----
typedef void * vis_opaque_arg_t;

struct vis_polledio {
      struct vis_polledio_arg *arg;
      void    (*display)(vis_opaque_arg_t, struct vis_consdisplay *);
      void    (*copy)(vis_opaque_arg_t, struct vis_conscopy *);
      void    (*cursor)(vis_opaque_arg_t, struct vis_conscursor *);
};
----

The polled I/O interfaces provide the same functionality as the
`VIS++_++CONSDISPLAY`, `VIS++_++CONSCOPY`, and `VIS++_++CONSCURSOR`
`ioctl` interfaces. The polled I/O interfaces should follow the same
steps that are described above for the respective `ioctl` commands. The
polled I/O interfaces must very strictly adhere to the additional
restrictions that are described in the remainder of this section.

The polled I/O interfaces are called only when the
operating system is quiesced and in standalone mode. The system enters
_standalone_ mode whenever the user enters OpenBoot PROM or enters the
`kmdb` debugger, or when the system panics. Only one CPU and one thread
are active. All other CPUs and threads are stopped. Timesharing, DDI
interrupts, and system services are turned off.

Standalone mode severely restricts driver functionality but simplifies
driver synchronization requirements. For example, a user application
cannot access the console frame buffer driver by way of the driver's
memory mappings from within a polled I/O routine.

In standalone mode, the console frame buffer driver must _not_ perform
any of the following actions:

* Wait for interrupts
* Wait for mutexes
* Allocate memory
* Use DDI or LDI interfaces
* Use system services

These restrictions are not difficult to obey since the polled I/O
functions are relatively simple operations. For example, when working
with the rendering engine, the console frame buffer driver can poll a
bit in the device rather than wait for an interrupt. The driver can use
pre-allocated memory to render blit data. DDI or LDI interfaces should
not be needed.

[[frame-buffer-specific-configuration-module]]
=== Frame Buffer Specific Configuration Module

console frame buffer drivers

video mode change callback interface

video mode

When the driver-specific `fbconfig` module causes a change in resolution
or color depth, that `fbconfig` module must send an `ioctl` to the frame
buffer driver. This `ioctl` triggers the frame buffer driver to call the
terminal emulator's mode change callback function with the new screen
size and depth. The frame buffer driver and the terminal emulator must
agree about the video mode at all times. When the frame buffer driver
and the terminal emulator do not agree about the video mode, the
information on the screen is illegible and meaningless.

[[the-x-window-system-frame-buffer-specific-ddx-module]]
=== The X Window System Frame Buffer Specific DDX Module

DDX module

When the X Window System exits to the command line, the frame buffer's
DDX module must send an `ioctl` to the frame buffer driver. This `ioctl`
triggers the frame buffer driver to call the terminal emulator's mode
change callback function. This communication keeps the frame buffer
driver and the terminal emulator in agreement about the video mode if
the X Window System starts and then changes the video resolution before
exiting. The frame buffer driver and the terminal emulator must agree
about the video mode at all times. When the frame buffer driver and the
terminal emulator do not agree about the video mode, the information on
the screen is illegible and meaningless.

[[developing-testing-and-debugging-console-frame-buffer-drivers]]
=== Developing, Testing, and Debugging Console Frame Buffer Drivers

Debugging a console frame
buffer driver on an active system can be problematic.

* Errors that are encountered in the early stages of booting the system
do not generate a core dump.
* Error or informative messages might not be displayed correctly on the
screen.
* USB keyboard input might fail.

This section offers some suggestions to help you develop, test, and
debug console frame buffer drivers.

[[testing-the-io-control-interfaces]]
==== Testing the I/O Control Interfaces

To test the `ioctl` commands, create additional `ioctl` entry points
that are callable from a user application. Be sure to copy in the
arguments appropriately. Use the `ddi++_++copyin(9F)` and
`ddi++_++copyout(9F)` routines to transfer data to and from user address
space. Then write an application to validate rendering, scrolling, and
cursor behavior. This way, these `ioctl` commands do not affect your
console while you develop and test the commands.

To ensure that the `ioctl` commands are working correctly, boot the
system and log in. Check whether you get expected behavior when you
execute commands such as `prstat`(1M), `ls`(1), `vi`(1), and `man`(1).

Execute the following script to validate that ANSI color is working
correctly:

....
#!/bin/bash
printf "\n\n\n\e[37;40m             Color List       \e[m\n\n"
printf "\e[30m Color 30 black\e[m\n"
printf "\e[31m Color 31 red\e[m\n"
printf "\e[32m Color 32 green\e[m\n"
printf "\e[33m Color 33 yellow\e[m\n"
printf "\e[34m Color 34 blue\e[m\n"
printf "\e[35m Color 35 purple\e[m\n"
printf "\e[36m Color 36 cyan\e[m\n"
printf "\e[37m Color 37 white\e[m\n\n"
printf "\e[40m Backlight 40 black \e[m\n"
printf "\e[41m Backlight 41 red   \e[m\n"
printf "\e[34;42m Backlight 42 green \e[m\n"
printf "\e[43m Backlight 43 yellow\e[m\n"
printf "\e[37;44m Backlight 44 blue  \e[m\n"
printf "\e[45m Backlight 45 purple\e[m\n"
printf "\e[30;46m Backlight 46 cyan  \e[m\n"
printf "\e[30;47m Backlight 47 white \e[m\n\n"
....

[[testing-the-polled-io-interfaces]]
==== Testing the Polled I/O Interfaces

The polled I/O interfaces are only available under the following
circumstances:

* When you enter the OpenBoot PROM by using the L1{plus}A keystroke
sequence
* When you boot the system with a standalone debugger such as `kmdb(1)`
* When the system panics

The polled I/O interfaces only become available at a certain point in
the boot process. Polled I/O requests issued from the OpenBoot PROM
before the system is running are not rendered. Similarly, `kmdb` prompts
issued before the console is configured are not rendered.

To test the polled I/O interfaces, enter the OpenBoot PROM by using the
L1{plus}A keystroke sequence. To validate that the polled I/O interfaces
are being used, type the following command at the OpenBoot PROM `ok`
prompt:

....
ok 1b emit ." [32m This is a test" 1b emit ." [m"
....

The polled I/O interfaces are working properly if the following
statements are true:

* The result of the above command is that the phrase `This is a test` is
displayed in green.
* The OpenBoot PROM continues to function correctly.
* Scrolling performs as expected.
* The cursor displays correctly.
* The system can be reentered and continued repeatedly.

[[testing-the-video-mode-change-callback-function]]
==== Testing the Video Mode Change Callback Function

To determine whether the video mode change callback
function is working properly, log in to the system and use `fbconfig(8)`
to change the resolution and depth of the frame buffer several times. If
the console continues to display text properly, the video mode change
callback function is working correctly. The kernel terminal emulator
might adjust the font size to accommodate different screen sizes, but
that is not significant to the console frame buffer driver.

To determine whether the X Window System and the console frame buffer
driver interact correctly, switch between the X Window System and the
command line several times while modifying the X Window System's video
resolution and the command line resolution in different ways. If the X
Window System exits and the console characters are not displayed
correctly, either the X Window System did not notify the driver console
code that the video mode changed or the driver did not call the kernel
terminal emulator's video mode change callback function.

[[additional-suggestions-for-testing-console-frame-buffer-drivers]]
==== Additional Suggestions for Testing Console Frame Buffer Drivers

During boot, the system sends messages to
`/var/adm/messages` if the system fails to locate or successfully load a
kernel terminal emulator compatible frame buffer driver. To monitor
these messages, type the following command in a separate window:

....
% tail -f /var/adm/messages
....

To avoid problems with USB while debugging the driver,
change the EEPROM `input-device` NVRAM configuration parameter to use a
serial port instead of the keyboard. See the `eeprom(8)` man page for
more information about this parameter.

[[document-license]]
=== Document License

=== Public Documentation License (PDL), Version 1.01

[.first-word]#1.0  DEFINITIONS.#

--
1.1.  “Commercial Use” means distribution or otherwise making the
Documentation available to a third party.

1.2.  “Contributor” means a person or entity who creates or contributes
to the creation of Modifications.

1.3.  “Documentation” means the Original Documentation or Modifications
or the combination of the Original Documentation and Modifications, in
each case including portions thereof.

1.4.  “Editable Form” means the preferred form of Documentation for
making Modifications to such documentation. The Documentation can be in
an electronic, compressed or archival form, provided the appropriate
decompression or de-archiving software is widely available for no
charge.

1.5.  “Electronic Distribution Mechanism” means a mechanism generally
accepted for the electronic transfer of data.

1.6.  “Initial Writer” means the individual or entity identified as the
Initial Writer in the notice required by the Appendix.

1.7.  “Larger Work” means a work which combines Documentation or
portions thereof with documentation or other writings not governed by
the terms of this License.

1.8.  “License” means this document.

1.9.  “Modifications” means any addition to or deletion from the
substance or structure of either the Original Documentation or any
previous Modifications, such as a translation, abridgment, condensation,
or any other form in which the Original Documentation or previous
Modifications may be recast, transformed or adapted. A work consisting
of editorial revisions, annotations, elaborations, and other
modifications which, as a whole represent an original work of
authorship, is a Modification. For example, when Documentation is
released as a series of documents, a Modification is:

A.  Any addition to or deletion from the contents of the Original
Documentation or previous Modifications.

B.  Any new documentation that contains any part of the Original
Documentation or previous Modifications.

1.10.  “Original Documentation” means documentation described as
Original Documentation in the notice required by the Appendix, and
which, at the time of its release under this License is not already
Documentation governed by this License.

1.11.  “You” (or “Your”) means an individual or a legal entity
exercising rights under, and complying with all of the terms of, this
License or a future version of this License issued under Section 5.0
(“Versions of the License”). For legal entities, “You” includes any
entity which controls, is controlled by, or is under common control with
You. For purposes of this definition, “control” means (a) the power,
direct or indirect, to cause the direction or management of such entity,
whether by contract or otherwise, or (b) ownership of more than fifty
percent (50%) of the outstanding shares or beneficial ownership of such
entity.

--

[.first-word]#2.0  LICENSE GRANTS.#

[.first-word]#2.1  Initial Writer Grant.#

The Initial Writer hereby grants You a world-wide, royalty-free,
non-exclusive license to use, reproduce, prepare Modifications of,
compile, publicly perform, publicly display, demonstrate, market,
disclose and distribute the Documentation in any form, on any media or
via any Electronic Distribution Mechanism or other method now known or
later discovered, and to sublicense the foregoing rights to third
parties through multiple tiers of sublicensees in accordance with the
terms of this License.

The license rights granted in this Section 2.1 (“Initial Writer Grant”)
are effective on the date Initial Writer first distributes Original
Documentation under the terms of this License.

[.first-word]#2.2.  Contributor Grant.#

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license to use, reproduce, prepare Modifications of,
compile, publicly perform, publicly display, demonstrate, market,
disclose and distribute the Documentation in any form, on any media or
via any Electronic Distribution Mechanism or other method now known or
later discovered, and to sublicense the foregoing rights to third
parties through multiple tiers of sublicensees in accordance with the
terms of this License.

The license rights granted in this Section 2.2 (“Contributor Grant”) are
effective on the date Contributor first makes Commercial Use of the
Documentation.

[.first-word]#3.0  DISTRIBUTION OBLIGATIONS.#

[.first-word]#3.1.  Application of License.#

The Modifications which You create or to which You contribute are
governed by the terms of this License, including without limitation
Section 2.2 (“Contributor Grant”). The Documentation may be distributed
only under the terms of this License or a future version of this License
released in accordance with Section 5.0 (“Versions of the License”), and
You must include a copy of this License with every copy of the
Documentation You distribute. You may not offer or impose any terms that
alter or restrict the applicable version of this License or the
recipients' rights hereunder. However, You may include an additional
document offering the additional rights described in Section 3.5
(“Required Notices”).

[.first-word]#3.2.  Availability of Documentation.#

Any Modification which You create or to which You contribute must be
made available publicly in Editable Form under the terms of this License
via a fixed medium or an accepted Electronic Distribution Mechanism.

[.first-word]#3.3.  Description of Modifications.#

All Documentation to which You contribute must identify the changes You
made to create that Documentation and the date of any change. You must
include a prominent statement that the Modification is derived, directly
or indirectly, from Original Documentation provided by the Initial
Writer and include the name of the Initial Writer in the Documentation
or via an electronic link that describes the origin or ownership of the
Documentation. The foregoing change documentation may be created by
using an electronic program that automatically tracks changes to the
Documentation. You must make all such changes and required information
publicly available for at least five years following release of the
changed Documentation.

[.first-word]#3.4.  Intellectual Property Matters.#

Contributor represents that Contributor believes that Contributor's
Modifications are Contributor's original creation(s), Contributor has
sufficient rights to grant the rights conveyed by this License, or both
of these statements are true.

[.first-word]#3.5.  Required Notices.#

You must duplicate the notice in the Appendix in each file of the
Documentation. If it is not possible to put such notice in a particular
Documentation file due to its structure, then You must include such
notice in a location (such as a relevant directory) where a reader would
be likely to look for such a notice, for example, via a hyperlink in
each file of the Documentation that takes the reader to a page that
describes the origin and ownership of the Documentation. If You created
one or more Modification(s) You may add your name as a Contributor to
the notice described in the Appendix.

You must also duplicate this License in any Documentation file (or with
a hyperlink in each file of the Documentation) where You describe
recipients' rights or ownership rights.

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of
Documentation. However, You may do so only on Your own behalf, and not
on behalf of the Initial Writer or any Contributor. You must make it
absolutely clear than any such warranty, support, indemnity or liability
obligation is offered by You alone, and You hereby agree to indemnify
the Initial Writer and every Contributor for any liability incurred by
the Initial Writer or such Contributor as a result of warranty, support,
indemnity or liability terms You offer.

[.first-word]#3.6.  Larger Works.#

You may create a Larger Work by combining Documentation with other
documents not governed by the terms of this License and distribute the
Larger Work as a single product. In such a case, You must make sure the
requirements of this License are fulfilled for the Documentation.

[.first-word]#4.0  APPLICATION OF THIS LICENSE.#

This License applies to Documentation to which the Initial Writer has
attached this License and the notice in the Appendix.

[.first-word]#5.0  TRADEMARKS.#

This license does not grant permission to use the trade names,
trademarks, service marks, logos, or product names of the Initial Writer
or any Contributor, except as required for reasonable and customary use
in describing the Origin of the Documentation and reproducing the
content of any of the notices described in the Appendix.

[.first-word]#6.0  VERSIONS OF THE LICENSE.#

[.first-word]#6.1.  New Versions.#

Initial Writer may publish revised or new versions of the License from
time to time. Each version will be given a distinguishing version
number.

[.first-word]#6.2.  Effect of New Versions.#

Once Documentation has been published under a particular version of the
License, You may always continue to use it under the terms of that
version. You may also choose to use such Documentation under the terms
of any subsequent version of the License published by
++__________________[++Insert name of the foundation, company, Initial
Writer, or whoever may modify this License++]++. No one other than
++_________________++ ++[++Insert name of the foundation, company,
Initial Writer, or whoever may modify this License++]++ has the right to
modify the terms of this License. Filling in the name of the Initial
Writer, Original Documentation or Contributor in the notice described in
the Appendix shall not be deemed to be Modifications of this License.

[.first-word]#7.0  DISCLAIMER OF WARRANTY.#

DOCUMENTATION IS PROVIDED UNDER THIS LICENSE ON AN “AS IS” BASIS,
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENTATION IS FREE OF
DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING.
THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE
DOCUMENTATION IS WITH YOU. SHOULD ANY DOCUMENTATION PROVE DEFECTIVE IN
ANY RESPECT, YOU (NOT THE INITIAL WRITER OR ANY OTHER CONTRIBUTOR)
ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS
DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO
USE OF ANY DOCUMENTATION IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS
DISCLAIMER.

[.first-word]#8.0  TERMINATION.#

This License and the rights granted hereunder will terminate
automatically if You fail to comply with terms herein and fail to cure
such breach within 30 days of becoming aware of the breach. All
sublicenses to the Documentation which are properly granted shall
survive any termination of this License. Provisions which, by their
nature, must remain in effect beyond the termination of this License
shall survive.

[.first-word]#9.0  LIMITATION OF LIABILITY.#

UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT
(INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE INITIAL
WRITER, ANY OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF DOCUMENTATION, OR
ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY
CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL,
WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER
DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO THE USE OF THE
DOCUMENTATION, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE
POSSIBILITY OF SUCH DAMAGES.

[.first-word]#10.0  U.S. GOVERNMENT END USERS.#

If Documentation is being acquired by or on behalf of the U.S.
Government or by a U.S. Government prime contractor or subcontractor (at
any tier), then the Government's rights in Documentation will be only as
set forth in this Agreement; this is in accordance with 48 CFR 227.7201
through 227.7202-4 (for Department of Defense (DOD) acquisitions) and
with 48 CFR 2.101 and 12.212 (for non-DOD acquisitions).

[.first-word]#11.0  MISCELLANEOUS.#

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. This License shall be governed by
California law, excluding its conflict-of-law provisions. With respect
to disputes or any litigation relating to this License, the losing party
is responsible for costs, including without limitation, court costs and
reasonable attorneys' fees and expenses. The application of the United
Nations Convention on Contracts for the International Sale of Goods is
expressly excluded. Any law or regulation which provides that the
language of a contract shall be construed against the drafter shall not
apply to this License.

=== Public Documentation License Notice

The contents of this Documentation are subject to the Public
Documentation License Version 1.01 (the “License”); you may only use
this Documentation if you comply with the terms of this License. A copy
of the License is available at http://illumos.org/license/PDL

The Original Documentation is Writing Device Drivers. The Initial Writer
of the Original Documentation is Sun Microsystems Copyright (C)
2003-2009. All Rights Reserved. (Initial Writer contact(s):
http://sun.com).

Contributor(s): Joyent, Inc. Portions created by Joyent, Inc. are
Copyright (C) 2016. All Rights Reserved. (Contributor contact(s):
http://joyent.com).

This documentation was derived from the source at
https://github.com/rmustacc/illumos-docbooks[illumos docbooks]. For full
changes as required by the PDL, please see the above URL.

+++++
<script src="scroll-spy.js"></script>
+++++
