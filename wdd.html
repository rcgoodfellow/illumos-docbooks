<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Writing Device Drivers</title>
<style>
/*
 * Modern Light/Dark Mode Stylesheet for illumos Documentation
 * Pure CSS solution with automatic theme switching based on system preferences
 * Responsive design for all devices
 */

/* ==================== CSS CUSTOM PROPERTIES (VARIABLES) ==================== */

:root {
  /* Light mode colors (default) */
  --bg-color: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-tertiary: #e9ecef;
  --text-color: #212529;
  --text-secondary: #6c757d;
  --text-muted: #868e96;
  --border-color: #dee2e6;
  --border-secondary: #e9ecef;
  --link-color: #0d6efd;
  --link-hover: #0a58ca;
  --link-visited: #6f42c1;
  
  /* Code highlighting */
  --code-bg: #f8f9fa;
  --code-border: #e9ecef;
  --code-text: #0033b3;
  --code-block-bg: #fafbfc;
  --code-block-border: #d1d9e0;
  
  /* Admonition colors */
  --note-bg: #cff4fc;
  --note-border: #0dcaf0;
  --warning-bg: #fff3cd;
  --warning-border: #ffc107;
  --important-bg: #f8d7da;
  --important-border: #dc3545;
  --tip-bg: #d1e7dd;
  --tip-border: #198754;
  --caution-bg: #fff3cd;
  --caution-border: #fd7e14;
  
  /* Table colors */
  --table-bg: #ffffff;
  --table-stripe: #f8f9fa;
  --table-border: #dee2e6;
  --table-header-bg: #e9ecef;
  
  /* TOC colors */
  --toc-bg: #f8f9fa;
  --toc-border: #dee2e6;
  --toc-link: #495057;
  --toc-link-hover: #0d6efd;
  
  /* Shadow and focus */
  --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
  --shadow-lg: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  --focus-ring: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
  
  /* Typography */
  --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --font-family-mono: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --font-size-base: clamp(1rem, 0.9rem + 0.5vw, 1.125rem);
  --line-height-base: 1.6;
  
  /* Spacing */
  --content-max-width: 75rem;
  --toc-width: 16rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
}

/* Dark mode colors */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: #404040;
    --text-color: #e9ecef;
    --text-secondary: #adb5bd;
    --text-muted: #6c757d;
    --border-color: #495057;
    --border-secondary: #404040;
    --link-color: #6ea8fe;
    --link-hover: #9ec5fe;
    --link-visited: #b8a9ff;
    
    /* Code highlighting for dark mode */
    --code-bg: #2b2b2b;
    --code-border: #4a4a4a;
    --code-text: #569cd6;
    --code-block-bg: #1e1e1e;
    --code-block-border: #3e3e3e;
    
    /* Admonition colors for dark mode */
    --note-bg: #1f4a54;
    --note-border: #0dcaf0;
    --warning-bg: #4a3728;
    --warning-border: #ffc107;
    --important-bg: #4a2628;
    --important-border: #dc3545;
    --tip-bg: #1e3a28;
    --tip-border: #198754;
    --caution-bg: #4a3728;
    --caution-border: #fd7e14;
    
    /* Table colors for dark mode */
    --table-bg: #2d2d2d;
    --table-stripe: #404040;
    --table-border: #495057;
    --table-header-bg: #404040;
    
    /* TOC colors for dark mode */
    --toc-bg: #2d2d2d;
    --toc-border: #495057;
    --toc-link: #adb5bd;
    --toc-link-hover: #6ea8fe;
    
    /* Shadow for dark mode */
    --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.3);
    --shadow-lg: 0 0.5rem 1rem rgba(0, 0, 0, 0.4);
    --focus-ring: 0 0 0 0.25rem rgba(110, 168, 254, 0.25);
  }
}

/* ==================== BASE STYLES ==================== */

* {
  box-sizing: border-box;
}

html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--text-color);
  background-color: var(--bg-color);
  margin: 0;
  padding: 0;
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* ==================== LAYOUT ==================== */

.container {
  max-width: var(--content-max-width);
  margin: 0 auto;
  padding: var(--spacing-md);
}

/* Main content area */
#content {
  max-width: none;
  margin-right: var(--spacing-xl);
  padding-right: var(--spacing-lg);
}

/* Content when TOC is on left side */
body.toc2.toc-left #content {
  margin-right: var(--spacing-xl);
  padding-right: var(--spacing-xl);
}

/* ==================== TYPOGRAPHY ==================== */

h1, h2, h3, h4, h5, h6 {
  font-weight: 700;
  line-height: 1.2;
  margin-top: calc(var(--spacing-xl) * 1.5);
  margin-bottom: var(--spacing-lg);
  margin-right: var(--spacing-md);
  color: var(--text-color);
  letter-spacing: -0.02em;
  position: relative;
}

/* Make heading text clickable for easy linking */
h1[id]:hover, h2[id]:hover, h3[id]:hover, h4[id]:hover, h5[id]:hover, h6[id]:hover {
  cursor: pointer;
  text-decoration: underline;
  text-decoration-color: var(--link-color);
  text-decoration-thickness: 2px;
  text-underline-offset: 4px;
}

h1 {
  font-size: clamp(2rem, 2.2rem + 1vw, 2.8rem);
  font-weight: 800;
  border-bottom: 3px solid var(--border-color);
  padding-bottom: var(--spacing-md);
  margin-top: 0;
  margin-bottom: var(--spacing-xl);
}

h2 {
  font-size: clamp(1.6rem, 1.8rem + 0.5vw, 2.2rem);
  font-weight: 700;
  border-bottom: 2px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
  margin-top: calc(var(--spacing-xl) * 2);
}

h3 {
  font-size: clamp(1.4rem, 1.5rem + 0.3vw, 1.8rem);
  font-weight: 650;
  border-left: 4px solid var(--border-color);
  padding-left: var(--spacing-md);
  margin-top: calc(var(--spacing-xl) * 1.5);
}

h4 {
  font-size: clamp(1.2rem, 1.3rem + 0.2vw, 1.5rem);
  font-weight: 650;
  color: var(--text-color);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border-bottom: 1px dotted var(--border-color);
  padding-bottom: 0.25rem;
}

h5 {
  font-size: clamp(1.1rem, 1.15rem + 0.1vw, 1.3rem);
  font-weight: 600;
  font-style: italic;
}

h6 {
  font-size: clamp(1rem, 1.05rem + 0.1vw, 1.2rem);
  font-weight: 600;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

p {
  margin-bottom: var(--spacing-md);
  margin-right: var(--spacing-md);
}

/* ==================== LINKS ==================== */

a {
  color: var(--link-color);
  text-decoration: none;
  transition: color 0.2s ease;
}

a:hover {
  color: var(--link-hover);
  text-decoration: underline;
}

a:visited {
  color: var(--link-visited);
}

a:focus {
  outline: none;
  box-shadow: var(--focus-ring);
  border-radius: 0.25rem;
}

/* ==================== CODE BLOCKS ==================== */

code {
  font-family: var(--font-family-mono);
  font-size: 0.9em;
  color: var(--code-text);
  background-color: var(--code-bg);
  padding: 0.125rem 0.25rem;
  border-radius: 0.25rem;
  border: 1px solid var(--code-border);
}

pre {
  font-family: var(--font-family-mono);
  font-size: 0.875rem;
  line-height: 1.5;
  background-color: var(--code-block-bg);
  color: var(--text-color);
  border: 1px solid var(--code-block-border);
  border-radius: 0.5rem;
  padding: var(--spacing-md);
  margin: var(--spacing-md) var(--spacing-md) var(--spacing-md) 0;
  overflow-x: auto;
  box-shadow: var(--shadow);
}

pre code {
  background: none;
  border: none;
  padding: 0;
  color: inherit;
  font-size: inherit;
}

/* ==================== SYNTAX HIGHLIGHTING ==================== */

/* Base highlighting for light mode */
.hljs {
  background-color: var(--code-block-bg) !important;
  color: var(--text-color) !important;
}

/* Light mode syntax highlighting */
:root {
  --hl-keyword: #0033b3;          /* Keywords: blue */
  --hl-string: #067d17;           /* Strings: green */
  --hl-comment: #808080;          /* Comments: gray */
  --hl-number: #1750eb;           /* Numbers: blue */
  --hl-type: #800080;             /* Types: purple */
  --hl-function: #000080;         /* Functions: dark blue */
  --hl-variable: #660e7a;         /* Variables: dark purple */
  --hl-preprocessor: #808000;     /* Preprocessor: olive */
  --hl-operator: #000000;         /* Operators: black */
  --hl-literal: #0000ff;          /* Literals: blue */
}

/* Dark mode syntax highlighting */
@media (prefers-color-scheme: dark) {
  :root {
    --hl-keyword: #569cd6;        /* Keywords: light blue */
    --hl-string: #9cdcfe;         /* Strings: light cyan */
    --hl-comment: #6a9955;        /* Comments: green */
    --hl-number: #b5cea8;         /* Numbers: light green */
    --hl-type: #4ec9b0;           /* Types: teal */
    --hl-function: #dcdcaa;       /* Functions: yellow */
    --hl-variable: #9cdcfe;       /* Variables: light cyan */
    --hl-preprocessor: #c586c0;   /* Preprocessor: light purple */
    --hl-operator: #d4d4d4;       /* Operators: light gray */
    --hl-literal: #d69d85;        /* Literals: orange */
  }
}

/* Highlight.js C/C++ syntax highlighting */
.hljs-keyword,
.hljs-selector-tag,
.hljs-built_in {
  color: var(--hl-keyword) !important;
  font-weight: 600;
}

.hljs-string,
.hljs-attribute {
  color: var(--hl-string) !important;
}

.hljs-comment,
.hljs-quote {
  color: var(--hl-comment) !important;
  font-style: italic;
}

.hljs-number,
.hljs-literal {
  color: var(--hl-number) !important;
}

.hljs-type,
.hljs-class .hljs-title {
  color: var(--hl-type) !important;
  font-weight: 600;
}

.hljs-function .hljs-title,
.hljs-title.function_ {
  color: var(--hl-function) !important;
  font-weight: 600;
}

.hljs-variable,
.hljs-name {
  color: var(--hl-variable) !important;
}

.hljs-meta,
.hljs-preprocessor {
  color: var(--hl-preprocessor) !important;
  font-weight: 600;
}

.hljs-operator,
.hljs-punctuation {
  color: var(--hl-operator) !important;
}

/* DTrace-specific highlighting */
.hljs-dtrace-probe,
.hljs-dtrace-builtin {
  color: var(--hl-function) !important;
  font-weight: 600;
}

/* Additional C-specific tokens */
.hljs-params {
  color: var(--text-color) !important;
}

.hljs-title {
  color: var(--hl-function) !important;
  font-weight: 600;
}

/* Ensure good contrast for inline code */
code:not(.hljs) {
  color: var(--hl-keyword) !important;
  background-color: var(--code-bg) !important;
  font-weight: 500;
}

/* Fallback for code blocks without syntax highlighting */
pre:not(.hljs) {
  color: var(--text-color) !important;
  background-color: var(--code-block-bg) !important;
}

/* Improve readability for unstyled code blocks */
pre code:not(.hljs) {
  color: var(--text-color) !important;
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
}

/* ==================== TABLES ==================== */

table {
  width: calc(100% - 2 * var(--spacing-md));
  border-collapse: collapse;
  margin: var(--spacing-md) var(--spacing-md);
  background-color: var(--table-bg);
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: var(--shadow);
  border: 1px solid var(--table-border);
}

th, td {
  padding: calc(var(--spacing-sm) * 0.75) var(--spacing-sm);
  text-align: left;
  border-bottom: 1px solid var(--table-border);
  border-right: 1px solid var(--table-border);
}

th:last-child,
td:last-child {
  border-right: none;
}

th {
  background-color: var(--table-header-bg);
  font-weight: 600;
  color: var(--text-color);
  border-bottom: 2px solid var(--table-border);
}

tbody tr:nth-child(even) {
  background-color: var(--table-stripe);
}

tbody tr:hover {
  background-color: var(--bg-tertiary);
}

/* Lists inside table cells - reduce spacing */
td ul, td ol, th ul, th ol {
  margin: var(--spacing-sm) 0;
  padding-left: var(--spacing-lg);
}

td li, th li {
  margin: calc(var(--spacing-sm) * 0.25) 0;
}

/* Paragraphs in table cells - reduce spacing */
td p, th p {
  margin-bottom: calc(var(--spacing-sm) * 0.5);
  margin-right: 0;
}

/* ==================== TABLE OF CONTENTS ==================== */

#toc {
  background-color: var(--toc-bg);
  border: 1px solid var(--toc-border);
  border-radius: 0.5rem;
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-xl);
  box-shadow: var(--shadow);
  position: relative;
}

#toc .title {
  font-weight: 600;
  font-size: 0.95rem;
  margin-bottom: calc(var(--spacing-sm) * 0.5);
  color: var(--text-color);
}

#toc ul {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#toc ul ul {
  padding-left: calc(var(--spacing-md) * 0.75);
  margin-top: calc(var(--spacing-sm) * 0.25);
}

#toc li {
  margin: calc(var(--spacing-sm) * 0.25) 0;
}

#toc a {
  color: var(--toc-link);
  text-decoration: none;
  display: block;
  padding: 0.125rem 0.375rem;
  border-radius: 0.25rem;
  transition: all 0.2s ease;
  font-size: 0.9rem;
}

#toc a:hover {
  color: var(--toc-link-hover);
  background-color: var(--bg-tertiary);
  text-decoration: none;
}

/* Active/Current section highlighting */
#toc a.active {
  color: var(--link-color);
  background-color: var(--link-color);
  background-color: color-mix(in srgb, var(--link-color) 15%, transparent);
  font-weight: 600;
  border-left: 3px solid var(--link-color);
  padding-left: calc(0.375rem - 3px);
}

@media (prefers-color-scheme: dark) {
  #toc a.active {
    background-color: color-mix(in srgb, var(--link-color) 20%, transparent);
  }
}

/* Target section highlighting */
:target {
  scroll-margin-top: var(--spacing-xl);
  animation: highlight-target 2s ease-out;
}

@keyframes highlight-target {
  0% {
    background-color: color-mix(in srgb, var(--link-color) 20%, transparent);
  }
  100% {
    background-color: transparent;
  }
}

/* Smooth scrolling enhancement */
html {
  scroll-behavior: smooth;
  scroll-padding-top: var(--spacing-xl);
}

/* Progressive enhancement for scroll-spy */
body.js-enabled #toc a {
  transition: all 0.2s ease;
}

body.js-enabled #toc a.active {
  transform: translateX(2px);
}

/* Parent section highlighting for nested TOC */
#toc a.active-parent {
  color: var(--toc-link-hover);
  font-weight: 500;
  background-color: color-mix(in srgb, var(--link-color) 8%, transparent);
}

/* Fallback for browsers without color-mix support */
@supports not (background-color: color-mix(in srgb, blue 15%, transparent)) {
  #toc a.active {
    background-color: var(--link-hover);
    background-color: rgba(13, 110, 253, 0.15);
  }
  
  @media (prefers-color-scheme: dark) {
    #toc a.active {
      background-color: rgba(110, 168, 254, 0.2);
    }
  }
  
  #toc a.active-parent {
    background-color: rgba(13, 110, 253, 0.08);
  }
  
  @media (prefers-color-scheme: dark) {
    #toc a.active-parent {
      background-color: rgba(110, 168, 254, 0.1);
    }
  }
}

/* Left TOC layout for larger screens */
@media (min-width: 1200px) {
  body.toc2.toc-left {
    padding-left: calc(var(--toc-width) + var(--spacing-lg));
  }
  
  #toc.toc2 {
    position: fixed;
    left: 0;
    top: 0;
    width: var(--toc-width);
    height: 100vh;
    overflow-y: auto;
    margin: 0;
    border-radius: 0;
    border-left: none;
    border-top: none;
    border-bottom: none;
    z-index: 1000;
  }
}

/* ==================== ADMONITIONS ==================== */

.admonitionblock {
  margin: var(--spacing-lg) var(--spacing-md);
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: var(--shadow);
}

.admonitionblock table {
  margin: 0;
  box-shadow: none;
  width: 100%;
  border: none;
  border-radius: 0;
}

.admonitionblock td.icon {
  display: none;
}

.admonitionblock td.content {
  padding: var(--spacing-md);
  border: none;
  border-bottom: none;
  border-right: none;
}

/* Note */
.admonitionblock.note {
  background-color: var(--note-bg);
  border-left: 4px solid var(--note-border);
}

/* Warning */
.admonitionblock.warning {
  background-color: var(--warning-bg);
  border-left: 4px solid var(--warning-border);
}

/* Important */
.admonitionblock.important {
  background-color: var(--important-bg);
  border-left: 4px solid var(--important-border);
}

/* Tip */
.admonitionblock.tip {
  background-color: var(--tip-bg);
  border-left: 4px solid var(--tip-border);
}

/* Caution */
.admonitionblock.caution {
  background-color: var(--caution-bg);
  border-left: 4px solid var(--caution-border);
}

/* ==================== LISTS ==================== */

ul, ol {
  padding-left: var(--spacing-xl);
  margin: var(--spacing-md) var(--spacing-md) var(--spacing-md) 0;
}

li {
  margin: var(--spacing-sm) 0;
}

dt {
  font-weight: 600;
  margin-top: var(--spacing-md);
  color: var(--text-color);
}

dd {
  margin-left: var(--spacing-xl);
  margin-bottom: var(--spacing-md);
}

/* ==================== BLOCKQUOTES ==================== */

blockquote {
  border-left: 4px solid var(--border-color);
  margin: var(--spacing-lg) var(--spacing-md) var(--spacing-lg) 0;
  padding: var(--spacing-md) var(--spacing-lg);
  background-color: var(--bg-secondary);
  font-style: italic;
  border-radius: 0 0.5rem 0.5rem 0;
}

/* ==================== IMAGES AND FIGURES ==================== */

img {
  max-width: 80%;
  width: auto;
  height: auto;
  border-radius: 0.5rem;
  box-shadow: var(--shadow);
  margin: var(--spacing-md) auto;
  display: block;
}

.imageblock {
  text-align: center;
  margin: var(--spacing-lg) 0;
}

.imageblock .title {
  font-style: italic;
  color: var(--text-secondary);
  margin-top: var(--spacing-sm);
}

/* ==================== RESPONSIVE DESIGN ==================== */

/* Mobile adjustments */
@media (max-width: 768px) {
  .container {
    padding: var(--spacing-sm);
  }
  
  #content {
    margin-right: var(--spacing-md);
    padding-right: var(--spacing-sm);
  }
  
  body.toc2.toc-left #content {
    margin-right: var(--spacing-md);
    padding-right: var(--spacing-sm);
  }
  
  h1 {
    font-size: 1.8rem;
    margin-right: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
    padding-bottom: var(--spacing-sm);
  }
  
  h2 {
    font-size: 1.5rem;
    margin-right: var(--spacing-sm);
    margin-top: var(--spacing-xl);
    padding: var(--spacing-sm);
  }
  
  h3 {
    font-size: 1.3rem;
    margin-top: var(--spacing-lg);
    padding-left: var(--spacing-sm);
  }
  
  h4 {
    font-size: 1.1rem;
  }
  
  h1, h2, h3, h4, h5, h6 {
    margin-right: var(--spacing-sm);
  }
  
  p {
    margin-right: var(--spacing-sm);
  }
  
  pre {
    font-size: 0.8rem;
    padding: var(--spacing-sm);
    margin-right: var(--spacing-sm);
  }
  
  ul, ol {
    margin-right: var(--spacing-sm);
  }
  
  blockquote {
    margin-right: var(--spacing-sm);
  }
  
  table {
    font-size: 0.9rem;
    width: calc(100% - 2 * var(--spacing-sm));
    margin: var(--spacing-md) var(--spacing-sm);
  }
  
  th, td {
    padding: calc(var(--spacing-sm) * 0.5) calc(var(--spacing-sm) * 0.75);
  }
  
  #toc {
    margin-bottom: var(--spacing-md);
  }
  
  .admonitionblock {
    margin: var(--spacing-md) var(--spacing-sm);
  }
  
  .admonitionblock td.icon {
    display: none;
  }
  
  .admonitionblock td.content {
    padding: var(--spacing-sm);
    border: none;
  }
  
  .admonitionblock table {
    margin: 0;
    width: 100%;
  }
  
  /* Even more compact lists in table cells on mobile */
  td ul, td ol, th ul, th ol {
    margin: calc(var(--spacing-sm) * 0.5) 0;
    padding-left: var(--spacing-md);
  }
  
  td li, th li {
    margin: calc(var(--spacing-sm) * 0.125) 0;
  }
  
  td p, th p {
    margin-bottom: calc(var(--spacing-sm) * 0.25);
  }
}

/* Tablet adjustments */
@media (min-width: 769px) and (max-width: 1199px) {
  .container {
    padding: var(--spacing-md) var(--spacing-lg);
  }
}

/* ==================== PRINT STYLES ==================== */

@media print {
  :root {
    --bg-color: white;
    --text-color: black;
    --border-color: #ccc;
  }
  
  body {
    font-size: 12pt;
    line-height: 1.4;
  }
  
  #toc.toc2 {
    position: static;
    width: auto;
    height: auto;
    margin-bottom: var(--spacing-lg);
  }
  
  body.toc2.toc-left {
    padding-left: 0;
  }
  
  .admonitionblock {
    page-break-inside: avoid;
  }
  
  pre {
    page-break-inside: avoid;
  }
  
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
}

/* ==================== UTILITIES ==================== */

.text-center {
  text-align: center;
}

.text-right {
  text-align: right;
}

.mb-0 {
  margin-bottom: 0;
}

.mt-0 {
  margin-top: 0;
}

/* ==================== ACCESSIBILITY ==================== */

/* Focus indicators */
*:focus {
  outline: 2px solid var(--link-color);
  outline-offset: 2px;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  :root {
    --border-color: #000000;
    --border-secondary: #000000;
    --text-secondary: var(--text-color);
  }
}

/* ==================== CUSTOM ENHANCEMENTS ==================== */

/* Note: This CSS includes scroll-spy functionality that works with CSS alone
 * For enhanced scroll-spy with JavaScript, include scroll-spy.js:
 * <script src="scroll-spy.js"></script>
 */

/* Better selection colors */
::selection {
  background-color: var(--link-color);
  color: white;
}

/* Loading state */
body {
  opacity: 0;
  animation: fadeIn 0.3s ease-in-out forwards;
}

@keyframes fadeIn {
  to {
    opacity: 1;
  }
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Writing Device Drivers</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_preface">1. Preface</a>
<ul class="sectlevel2">
<li><a href="#whats-new">1.1. What&#8217;s New</a></li>
<li><a href="#who-should-use-this-book">1.2. Who Should Use This Book</a></li>
<li><a href="#how-this-book-is-organized">1.3. How This Book Is Organized</a></li>
<li><a href="#related-books-and-papers">1.4. Related Books and Papers</a></li>
<li><a href="#_typographic_conventions">1.5. Typographic Conventions</a></li>
<li><a href="#shell-prompts-in-command-examples">1.6. Shell Prompts in Command Examples</a></li>
</ul>
</li>
<li><a href="#_designing_device_drivers_for_the_illumos_platform">2. Designing Device Drivers for the illumos Platform</a>
<ul class="sectlevel2">
<li><a href="#overview-of-illumos-device-drivers">2.1. Overview of illumos Device Drivers</a></li>
<li><a href="#device-driver-basics">2.2. Device Driver Basics</a>
<ul class="sectlevel3">
<li><a href="#what-is-a-device-driver">2.2.1. What Is a Device Driver?</a></li>
<li><a href="#what-is-a-device-driver-entry-point">2.2.2. What Is a Device Driver Entry Point?</a></li>
</ul>
</li>
<li><a href="#device-driver-entry-points">2.3. Device Driver Entry Points</a>
<ul class="sectlevel3">
<li><a href="#entry-points-common-to-all-drivers">2.3.1. Entry Points Common to All Drivers</a></li>
<li><a href="#entry-points-for-block-device-drivers">2.3.2. Entry Points for Block Device Drivers</a></li>
<li><a href="#entry-points-for-character-device-drivers">2.3.3. Entry Points for Character Device Drivers</a></li>
<li><a href="#entry-points-for-streams-device-drivers">2.3.4. Entry Points for STREAMS Device Drivers</a></li>
<li><a href="#entry-points-for-memory-mapped-devices">2.3.5. Entry Points for Memory Mapped Devices</a></li>
<li><a href="#entry-points-for-the-generic-lan-device-gld-driver">2.3.6. Entry Points for the Generic LAN Device (GLD) Driver</a></li>
<li><a href="#entry-points-for-scsi-hba-drivers">2.3.7. Entry Points for SCSI HBA Drivers</a></li>
<li><a href="#entry-points-for-pc-card-drivers">2.3.8. Entry Points for PC Card Drivers</a></li>
</ul>
</li>
<li><a href="#considerations-in-device-driver-design">2.4. Considerations in Device Driver Design</a>
<ul class="sectlevel3">
<li><a href="#ddidki-facilities">2.4.1. DDI/DKI Facilities</a></li>
<li><a href="#driver-context">2.4.2. Driver Context</a></li>
<li><a href="#returning-errors">2.4.3. Returning Errors</a></li>
<li><a href="#dynamic-memory-allocation">2.4.4. Dynamic Memory Allocation</a></li>
<li><a href="#hotplugging">2.4.5. Hotplugging</a></li>
</ul>
</li>
<li><a href="#illumos-kernel-and-device-tree">2.5. illumos Kernel and Device Tree</a></li>
<li><a href="#what-is-the-kernel">2.6. What Is the Kernel?</a>
<ul class="sectlevel3">
<li><a href="#multithreaded-execution-environment">2.6.1. Multithreaded Execution Environment</a></li>
<li><a href="#virtual-memory">2.6.2. Virtual Memory</a></li>
<li><a href="#devices-as-special-files">2.6.3. Devices as Special Files</a></li>
<li><a href="#ddidki-interfaces">2.6.4. DDI/DKI Interfaces</a></li>
</ul>
</li>
<li><a href="#overview-of-the-device-tree">2.7. Overview of the Device Tree</a>
<ul class="sectlevel3">
<li><a href="#device-tree-components">2.7.1. Device Tree Components</a></li>
<li><a href="#displaying-the-device-tree">2.7.2. Displaying the Device Tree</a></li>
<li><a href="#binding-a-driver-to-a-device">2.7.3. Binding a Driver to a Device</a></li>
</ul>
</li>
<li><a href="#multithreading">2.8. Multithreading</a></li>
<li><a href="#locking-primitives">2.9. Locking Primitives</a>
<ul class="sectlevel3">
<li><a href="#storage-classes-of-driver-data">2.9.1. Storage Classes of Driver Data</a></li>
<li><a href="#mutual-exclusion-locks">2.9.2. Mutual-Exclusion Locks</a></li>
<li><a href="#readerswriter-locks">2.9.3. Readers/Writer Locks</a></li>
<li><a href="#semaphores">2.9.4. Semaphores</a></li>
</ul>
</li>
<li><a href="#thread-synchronization">2.10. Thread Synchronization</a>
<ul class="sectlevel3">
<li><a href="#condition-variables-in-thread-synchronization">2.10.1. Condition Variables in Thread Synchronization</a></li>
<li><a href="#cvwait-and-cvtimedwait-functions">2.10.2. <code>cv_wait</code> and <code>cv_timedwait</code> Functions</a></li>
<li><a href="#cvwaitsig-function">2.10.3. <code>cv_wait_sig</code> Function</a></li>
<li><a href="#cvtimedwaitsig-function">2.10.4. <code>cv_timedwait_sig</code> Function</a></li>
</ul>
</li>
<li><a href="#choosing-a-locking-scheme">2.11. Choosing a Locking Scheme</a>
<ul class="sectlevel3">
<li><a href="#potential-locking-pitfalls">2.11.1. Potential Locking Pitfalls</a></li>
<li><a href="#threads-unable-to-receive-signals">2.11.2. Threads Unable to Receive Signals</a></li>
</ul>
</li>
<li><a href="#properties">2.12. Properties</a></li>
<li><a href="#device-properties-1">2.13. Device Properties</a>
<ul class="sectlevel3">
<li><a href="#device-property-names">2.13.1. Device Property Names</a></li>
<li><a href="#creating-and-updating-properties">2.13.2. Creating and Updating Properties</a></li>
<li><a href="#looking-up-properties">2.13.3. Looking Up Properties</a></li>
<li><a href="#prop_op-entry-point">2.13.4. <code>prop_op</code> Entry Point</a></li>
</ul>
</li>
<li><a href="#managing-events-and-queueing-tasks">2.14. Managing Events and Queueing Tasks</a></li>
<li><a href="#managing-events">2.15. Managing Events</a>
<ul class="sectlevel3">
<li><a href="#introduction-to-events">2.15.1. Introduction to Events</a></li>
<li><a href="#using-ddilogsysevent-to-log-events">2.15.2. Using <code>ddi_log_sysevent</code> to Log Events</a></li>
<li><a href="#defining-event-attributes">2.15.3. Defining Event Attributes</a></li>
</ul>
</li>
<li><a href="#queueing-tasks">2.16. Queueing Tasks</a>
<ul class="sectlevel3">
<li><a href="#introduction-to-task-queues">2.16.1. Introduction to Task Queues</a></li>
<li><a href="#task-queue-interfaces">2.16.2. Task Queue Interfaces</a></li>
<li><a href="#using-task-queues">2.16.3. Using Task Queues</a></li>
<li><a href="#observing-task-queues">2.16.4. Observing Task Queues</a></li>
</ul>
</li>
<li><a href="#driver-autoconfiguration">2.17. Driver Autoconfiguration</a></li>
<li><a href="#driver-loading-and-unloading">2.18. Driver Loading and Unloading</a></li>
<li><a href="#data-structures-required-for-drivers">2.19. Data Structures Required for Drivers</a>
<ul class="sectlevel3">
<li><a href="#modlinkage-structure">2.19.1. <code>modlinkage</code> Structure</a></li>
<li><a href="#modldrv-structure">2.19.2. <code>modldrv</code> Structure</a></li>
<li><a href="#dev_ops-structure">2.19.3. <code>dev_ops</code> Structure</a></li>
<li><a href="#cb_ops-structure">2.19.4. <code>cb_ops</code> Structure</a></li>
</ul>
</li>
<li><a href="#loadable-driver-interfaces">2.20. Loadable Driver Interfaces</a>
<ul class="sectlevel3">
<li><a href="#_init-example">2.20.1. <code>_init</code> Example</a></li>
<li><a href="#_fini-example">2.20.2. <code>_fini</code> Example</a></li>
<li><a href="#_info-example">2.20.3. <code>_info</code> Example</a></li>
</ul>
</li>
<li><a href="#device-configuration-concepts">2.21. Device Configuration Concepts</a>
<ul class="sectlevel3">
<li><a href="#device-instances-and-instance-numbers">2.21.1. Device Instances and Instance Numbers</a></li>
<li><a href="#minor-nodes-and-minor-numbers">2.21.2. Minor Nodes and Minor Numbers</a></li>
<li><a href="#probe-entry-point">2.21.3. <code>probe</code> Entry Point</a></li>
<li><a href="#attach-entry-point">2.21.4. <code>attach</code> Entry Point</a></li>
<li><a href="#detach-entry-point">2.21.5. <code>detach</code> Entry Point</a></li>
<li><a href="#getinfo-entry-point">2.21.6. <code>getinfo</code> Entry Point</a></li>
</ul>
</li>
<li><a href="#using-device-ids">2.22. Using Device IDs</a>
<ul class="sectlevel3">
<li><a href="#registering-device-ids">2.22.1. Registering Device IDs</a></li>
<li><a href="#unregistering-device-ids">2.22.2. Unregistering Device IDs</a></li>
</ul>
</li>
<li><a href="#device-access-programmed-io">2.23. Device Access: Programmed I/O</a></li>
<li><a href="#device-memory">2.24. Device Memory</a>
<ul class="sectlevel3">
<li><a href="#managing-differences-in-device-and-host-endianness">2.24.1. Managing Differences in Device and Host Endianness</a></li>
<li><a href="#managing-data-ordering-requirements">2.24.2. Managing Data Ordering Requirements</a></li>
<li><a href="#ddideviceacc_attr-structure">2.24.3. <code>ddi_device_acc_attr</code> Structure</a></li>
<li><a href="#mapping-device-memory">2.24.4. Mapping Device Memory</a></li>
<li><a href="#mapping-setup-example">2.24.5. Mapping Setup Example</a></li>
</ul>
</li>
<li><a href="#device-access-functions">2.25. Device Access Functions</a>
<ul class="sectlevel3">
<li><a href="#alternate-device-access-interfaces">2.25.1. Alternate Device Access Interfaces</a></li>
</ul>
</li>
<li><a href="#interrupt-handlers">2.26. Interrupt Handlers</a></li>
<li><a href="#interrupt-handler-overview">2.27. Interrupt Handler Overview</a></li>
<li><a href="#device-interrupts">2.28. Device Interrupts</a>
<ul class="sectlevel3">
<li><a href="#high-level-interrupts">2.28.1. High-Level Interrupts</a></li>
<li><a href="#legacy-interrupts">2.28.2. Legacy Interrupts</a></li>
<li><a href="#standard-and-extended-message-signaled-interrupts">2.28.3. Standard and Extended Message-Signaled Interrupts</a></li>
<li><a href="#software-interrupts">2.28.4. Software Interrupts</a></li>
</ul>
</li>
<li><a href="#ddi-interrupt-functions">2.29. DDI Interrupt Functions</a>
<ul class="sectlevel3">
<li><a href="#interrupt-capability-functions">2.29.1. Interrupt Capability Functions</a></li>
<li><a href="#interrupt-initialization-and-destruction-functions">2.29.2. Interrupt Initialization and Destruction Functions</a></li>
<li><a href="#priority-management-functions">2.29.3. Priority Management Functions</a></li>
<li><a href="#soft-interrupt-functions">2.29.4. Soft Interrupt Functions</a></li>
<li><a href="#interrupt-function-examples">2.29.5. Interrupt Function Examples</a></li>
</ul>
</li>
<li><a href="#registering-interrupts">2.30. Registering Interrupts</a>
<ul class="sectlevel3">
<li><a href="#registering-legacy-interrupts">2.30.1. Registering Legacy Interrupts</a></li>
<li><a href="#registering-msi-interrupts">2.30.2. Registering MSI Interrupts</a></li>
</ul>
</li>
<li><a href="#interrupt-handler-functionality">2.31. Interrupt Handler Functionality</a></li>
<li><a href="#handling-high-level-interrupts">2.32. Handling High-Level Interrupts</a>
<ul class="sectlevel3">
<li><a href="#high-level-mutexes">2.32.1. High-Level Mutexes</a></li>
<li><a href="#high-level-interrupt-handling-example">2.32.2. High-Level Interrupt Handling Example</a></li>
</ul>
</li>
<li><a href="#direct-memory-access-dma-1">2.33. Direct Memory Access (DMA)</a></li>
<li><a href="#dma-model">2.34. DMA Model</a></li>
<li><a href="#types-of-device-dma">2.35. Types of Device DMA</a>
<ul class="sectlevel3">
<li><a href="#bus-master-dma">2.35.1. Bus-Master DMA</a></li>
<li><a href="#third-party-dma">2.35.2. Third-Party DMA</a></li>
<li><a href="#first-party-dma">2.35.3. First-Party DMA</a></li>
</ul>
</li>
<li><a href="#types-of-host-platform-dma">2.36. Types of Host Platform DMA</a></li>
<li><a href="#dma-software-components-handles-windows-and-cookies">2.37. DMA Software Components: Handles, Windows, and Cookies</a></li>
<li><a href="#dma-operations">2.38. DMA Operations</a>
<ul class="sectlevel3">
<li><a href="#performing-bus-master-dma-transfers">2.38.1. Performing Bus-Master DMA Transfers</a></li>
<li><a href="#performing-first-party-dma-transfers">2.38.2. Performing First-Party DMA Transfers</a></li>
<li><a href="#performing-third-party-dma-transfers">2.38.3. Performing Third-Party DMA Transfers</a></li>
<li><a href="#dma-attributes">2.38.4. DMA Attributes</a></li>
</ul>
</li>
<li><a href="#managing-dma-resources">2.39. Managing DMA Resources</a>
<ul class="sectlevel3">
<li><a href="#object-locking">2.39.1. Object Locking</a></li>
<li><a href="#allocating-a-dma-handle">2.39.2. Allocating a DMA Handle</a></li>
<li><a href="#allocating-dma-resources">2.39.3. Allocating DMA Resources</a></li>
<li><a href="#determining-maximum-burst-sizes">2.39.4. Determining Maximum Burst Sizes</a></li>
<li><a href="#allocating-private-dma-buffers">2.39.5. Allocating Private DMA Buffers</a></li>
<li><a href="#handling-resource-allocation-failures">2.39.6. Handling Resource Allocation Failures</a></li>
<li><a href="#programming-the-dma-engine">2.39.7. Programming the DMA Engine</a></li>
<li><a href="#freeing-the-dma-resources">2.39.8. Freeing the DMA Resources</a></li>
<li><a href="#freeing-the-dma-handle">2.39.9. Freeing the DMA Handle</a></li>
<li><a href="#canceling-dma-callbacks">2.39.10. Canceling DMA Callbacks</a></li>
<li><a href="#synchronizing-memory-objects">2.39.11. Synchronizing Memory Objects</a></li>
</ul>
</li>
<li><a href="#dma-windows">2.40. DMA Windows</a></li>
<li><a href="#mapping-device-and-kernel-memory">2.41. Mapping Device and Kernel Memory</a></li>
<li><a href="#memory-mapping-overview">2.42. Memory Mapping Overview</a></li>
<li><a href="#exporting-the-mapping">2.43. Exporting the Mapping</a>
<ul class="sectlevel3">
<li><a href="#the-segmap9e-entry-point">2.43.1. The <code>segmap</code>(9E) Entry Point</a></li>
<li><a href="#the-devmap9e-entry-point">2.43.2. The <code>devmap</code>(9E) Entry Point</a></li>
</ul>
</li>
<li><a href="#associating-device-memory-with-user-mappings">2.44. Associating Device Memory With User Mappings</a></li>
<li><a href="#associating-kernel-memory-with-user-mappings">2.45. Associating Kernel Memory With User Mappings</a>
<ul class="sectlevel3">
<li><a href="#allocating-kernel-memory-for-user-access">2.45.1. Allocating Kernel Memory for User Access</a></li>
<li><a href="#exporting-kernel-memory-to-applications">2.45.2. Exporting Kernel Memory to Applications</a></li>
<li><a href="#freeing-kernel-memory-exported-for-user-access">2.45.3. Freeing Kernel Memory Exported for User Access</a></li>
</ul>
</li>
<li><a href="#device-context-management">2.46. Device Context Management</a></li>
<li><a href="#introduction-to-device-context">2.47. Introduction to Device Context</a>
<ul class="sectlevel3">
<li><a href="#what-is-a-device-context">2.47.1. What Is a Device Context?</a></li>
<li><a href="#context-management-model">2.47.2. Context Management Model</a></li>
</ul>
</li>
<li><a href="#context-management-operation">2.48. Context Management Operation</a>
<ul class="sectlevel3">
<li><a href="#devmapcallbackctl-structure">2.48.1. <code>devmap_callback_ctl</code> Structure</a></li>
<li><a href="#entry-points-for-device-context-management">2.48.2. Entry Points for Device Context Management</a></li>
<li><a href="#associating-user-mappings-with-driver-notifications">2.48.3. Associating User Mappings With Driver Notifications</a></li>
<li><a href="#managing-mapping-accesses">2.48.4. Managing Mapping Accesses</a></li>
</ul>
</li>
<li><a href="#power-management">2.49. Power Management</a></li>
<li><a href="#power-management-framework">2.50. Power Management Framework</a>
<ul class="sectlevel3">
<li><a href="#device-power-management">2.50.1. Device Power Management</a></li>
<li><a href="#system-power-management">2.50.2. System Power Management</a></li>
</ul>
</li>
<li><a href="#device-power-management-model">2.51. Device Power Management Model</a>
<ul class="sectlevel3">
<li><a href="#power-management-components">2.51.1. Power Management Components</a></li>
<li><a href="#power-management-states">2.51.2. Power Management States</a></li>
<li><a href="#power-levels">2.51.3. Power Levels</a></li>
<li><a href="#power-management-dependencies">2.51.4. Power Management Dependencies</a></li>
<li><a href="#automatic-power-management-for-devices">2.51.5. Automatic Power Management for Devices</a></li>
<li><a href="#device-power-management-interfaces">2.51.6. Device Power Management Interfaces</a></li>
<li><a href="#power-entry-point">2.51.7. <code>power</code> Entry Point</a></li>
</ul>
</li>
<li><a href="#system-power-management-model">2.52. System Power Management Model</a>
<ul class="sectlevel3">
<li><a href="#autoshutdown-threshold">2.52.1. Autoshutdown Threshold</a></li>
<li><a href="#busy-state">2.52.2. Busy State</a></li>
<li><a href="#hardware-state">2.52.3. Hardware State</a></li>
<li><a href="#automatic-power-management-for-systems">2.52.4. Automatic Power Management for Systems</a></li>
<li><a href="#entry-points-used-by-system-power-management">2.52.5. Entry Points Used by System Power Management</a></li>
</ul>
</li>
<li><a href="#power-management-device-access-example">2.53. Power Management Device Access Example</a></li>
<li><a href="#power-management-flow-of-control">2.54. Power Management Flow of Control</a></li>
<li><a href="#changes-to-power-management-interfaces">2.55. Changes to Power Management Interfaces</a></li>
<li><a href="#hardening-illumos-drivers">2.56. Hardening illumos Drivers</a></li>
<li><a href="#illumos-fault-management-architecture-io-fault-services">2.57. illumos Fault Management Architecture I/O Fault Services</a>
<ul class="sectlevel3">
<li><a href="#what-is-predictive-self-healing">2.57.1. What Is Predictive Self-Healing?</a></li>
<li><a href="#illumos-fault-manager">2.57.2. illumos Fault Manager</a></li>
<li><a href="#error-handling">2.57.3. Error Handling</a></li>
<li><a href="#diagnosing-faults">2.57.4. Diagnosing Faults</a></li>
<li><a href="#event-registry">2.57.5. Event Registry</a></li>
<li><a href="#glossary">2.57.6. Glossary</a></li>
<li><a href="#resources">2.57.7. Resources</a></li>
</ul>
</li>
<li><a href="#defensive-programming-techniques-for-illumos-device-drivers">2.58. Defensive Programming Techniques for illumos Device Drivers</a>
<ul class="sectlevel3">
<li><a href="#using-separate-device-driver-instances">2.58.1. Using Separate Device Driver Instances</a></li>
<li><a href="#exclusive-use-of-ddi-access-handles">2.58.2. Exclusive Use of DDI Access Handles</a></li>
<li><a href="#_detecting_corrupted_data">2.58.3. Detecting Corrupted Data</a></li>
<li><a href="#_dma_isolation">2.58.4. DMA Isolation</a></li>
<li><a href="#handling-stuck-interrupts">2.58.5. Handling Stuck Interrupts</a></li>
<li><a href="#additional-programming-considerations">2.58.6. Additional Programming Considerations</a></li>
</ul>
</li>
<li><a href="#driver-hardening-test-harness">2.59. Driver Hardening Test Harness</a>
<ul class="sectlevel3">
<li><a href="#_fault_injection">2.59.1. Fault Injection</a></li>
<li><a href="#setting-up-the-test-harness">2.59.2. Setting Up the Test Harness</a></li>
<li><a href="#testing-the-driver">2.59.3. Testing the Driver</a></li>
<li><a href="#using-scripts-to-automate-the-test-process">2.59.4. Using Scripts to Automate the Test Process</a></li>
</ul>
</li>
<li><a href="#layered-driver-interface-ldi">2.60. Layered Driver Interface (LDI)</a></li>
<li><a href="#ldi-overview">2.61. LDI Overview</a></li>
<li><a href="#kernel-interfaces">2.62. Kernel Interfaces</a>
<ul class="sectlevel3">
<li><a href="#layered-identifiers-kernel-device-consumers">2.62.1. Layered Identifiers – Kernel Device Consumers</a></li>
<li><a href="#layered-driver-handles-target-devices">2.62.2. Layered Driver Handles – Target Devices</a></li>
<li><a href="#ldi-kernel-interfaces-example">2.62.3. LDI Kernel Interfaces Example</a></li>
</ul>
</li>
<li><a href="#user-interfaces">2.63. User Interfaces</a>
<ul class="sectlevel3">
<li><a href="#device-information-library-interfaces">2.63.1. Device Information Library Interfaces</a></li>
<li><a href="#print-system-configuration-command-interfaces">2.63.2. Print System Configuration Command Interfaces</a></li>
<li><a href="#device-user-command-interfaces">2.63.3. Device User Command Interfaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_designing_specific_kinds_of_device_drivers">3. Designing Specific Kinds of Device Drivers</a>
<ul class="sectlevel2">
<li><a href="#drivers-for-character-devices">3.1. Drivers for Character Devices</a></li>
<li><a href="#overview-of-the-character-driver-structure">3.2. Overview of the Character Driver Structure</a></li>
<li><a href="#character-device-autoconfiguration">3.3. Character Device Autoconfiguration</a></li>
<li><a href="#device-access-character-drivers">3.4. Device Access (Character Drivers)</a>
<ul class="sectlevel3">
<li><a href="#open-entry-point-character-drivers">3.4.1. <code>open</code> Entry Point (Character Drivers)</a></li>
<li><a href="#close-entry-point-character-drivers">3.4.2. <code>close</code> Entry Point (Character Drivers)</a></li>
</ul>
</li>
<li><a href="#io-request-handling">3.5. I/O Request Handling</a>
<ul class="sectlevel3">
<li><a href="#user-addresses">3.5.1. User Addresses</a></li>
<li><a href="#vectored-io">3.5.2. Vectored I/O</a></li>
<li><a href="#differences-between-synchronous-and-asynchronous-io">3.5.3. Differences Between Synchronous and Asynchronous I/O</a></li>
<li><a href="#data-transfer-methods">3.5.4. Data Transfer Methods</a></li>
</ul>
</li>
<li><a href="#mapping-device-memory-1">3.6. Mapping Device Memory</a></li>
<li><a href="#multiplexing-io-on-file-descriptors">3.7. Multiplexing I/O on File Descriptors</a></li>
<li><a href="#miscellaneous-io-control">3.8. Miscellaneous I/O Control</a>
<ul class="sectlevel3">
<li><a href="#ioctl-entry-point-character-drivers">3.8.1. <code>ioctl</code> Entry Point (Character Drivers)</a></li>
<li><a href="#io-control-support-for-64-bit-capable-device-drivers">3.8.2. I/O Control Support for 64-Bit Capable Device Drivers</a></li>
<li><a href="#handling-copyout-overflow">3.8.3. Handling <code>copyout</code> Overflow</a></li>
<li><a href="#how-do-the-structure-macros-work">3.8.4. How Do the Structure Macros Work?</a></li>
<li><a href="#when-to-use-structure-macros">3.8.5. When to Use Structure Macros</a></li>
<li><a href="#declaring-and-initializing-structure-handles">3.8.6. Declaring and Initializing Structure Handles</a></li>
<li><a href="#operations-on-structure-handles">3.8.7. Operations on Structure Handles</a></li>
<li><a href="#other-operations">3.8.8. Other Operations</a></li>
</ul>
</li>
<li><a href="#drivers-for-block-devices">3.9. Drivers for Block Devices</a></li>
<li><a href="#block-driver-structure-overview">3.10. Block Driver Structure Overview</a></li>
<li><a href="#file-io">3.11. File I/O</a></li>
<li><a href="#block-device-autoconfiguration">3.12. Block Device Autoconfiguration</a></li>
<li><a href="#controlling-device-access">3.13. Controlling Device Access</a>
<ul class="sectlevel3">
<li><a href="#open-entry-point-block-drivers">3.13.1. <code>open</code> Entry Point (Block Drivers)</a></li>
<li><a href="#close-entry-point-block-drivers">3.13.2. <code>close</code> Entry Point (Block Drivers)</a></li>
<li><a href="#strategy-entry-point-1">3.13.3. <code>strategy</code> Entry Point</a></li>
<li><a href="#buf-structure">3.13.4. <code>buf</code> Structure</a></li>
</ul>
</li>
<li><a href="#synchronous-data-transfers-block-drivers">3.14. Synchronous Data Transfers (Block Drivers)</a></li>
<li><a href="#asynchronous-data-transfers-block-drivers">3.15. Asynchronous Data Transfers (Block Drivers)</a>
<ul class="sectlevel3">
<li><a href="#checking-for-invalid-buf-requests">3.15.1. Checking for Invalid <code>buf</code> Requests</a></li>
<li><a href="#enqueuing-the-request">3.15.2. Enqueuing the Request</a></li>
<li><a href="#starting-the-first-transfer">3.15.3. Starting the First Transfer</a></li>
<li><a href="#handling-the-interrupting-device">3.15.4. Handling the Interrupting Device</a></li>
</ul>
</li>
<li><a href="#dump-and-print-entry-points">3.16. <code>dump</code> and <code>print</code> Entry Points</a>
<ul class="sectlevel3">
<li><a href="#dump-entry-point-block-drivers">3.16.1. <code>dump</code> Entry Point (Block Drivers)</a></li>
<li><a href="#print-entry-point-block-drivers">3.16.2. <code>print</code> Entry Point (Block Drivers)</a></li>
</ul>
</li>
<li><a href="#disk-device-drivers">3.17. Disk Device Drivers</a>
<ul class="sectlevel3">
<li><a href="#disk-ioctls">3.17.1. Disk `ioctl`s</a></li>
<li><a href="#disk-performance">3.17.2. Disk Performance</a></li>
</ul>
</li>
<li><a href="#scsi-target-drivers">3.18. SCSI Target Drivers</a></li>
<li><a href="#introduction-to-target-drivers">3.19. Introduction to Target Drivers</a></li>
<li><a href="#sun-common-scsi-architecture-overview">3.20. Sun Common SCSI Architecture Overview</a>
<ul class="sectlevel3">
<li><a href="#general-flow-of-control">3.20.1. General Flow of Control</a></li>
<li><a href="#scsa-functions">3.20.2. SCSA Functions</a></li>
</ul>
</li>
<li><a href="#hardware-configuration-file">3.21. Hardware Configuration File</a></li>
<li><a href="#declarations-and-data-structures">3.22. Declarations and Data Structures</a>
<ul class="sectlevel3">
<li><a href="#scsi_device-structure">3.22.1. <code>scsi_device</code> Structure</a></li>
<li><a href="#scsi_pkt-structure-target-drivers">3.22.2. <code>scsi_pkt</code> Structure (Target Drivers)</a></li>
</ul>
</li>
<li><a href="#autoconfiguration-for-scsi-target-drivers">3.23. Autoconfiguration for SCSI Target Drivers</a>
<ul class="sectlevel3">
<li><a href="#probe-entry-point-scsi-target-drivers">3.23.1. <code>probe</code> Entry Point (SCSI Target Drivers)</a></li>
<li><a href="#attach-entry-point-scsi-target-drivers">3.23.2. <code>attach</code> Entry Point (SCSI Target Drivers)</a></li>
<li><a href="#detach-entry-point-scsi-target-drivers">3.23.3. <code>detach</code> Entry Point (SCSI Target Drivers)</a></li>
<li><a href="#getinfo-entry-point-scsi-target-drivers">3.23.4. <code>getinfo</code> Entry Point (SCSI Target Drivers)</a></li>
</ul>
</li>
<li><a href="#resource-allocation">3.24. Resource Allocation</a>
<ul class="sectlevel3">
<li><a href="#scsiinitpkt-function">3.24.1. <code>scsi_init_pkt</code> Function</a></li>
<li><a href="#scsisyncpkt-function">3.24.2. <code>scsi_sync_pkt</code> Function</a></li>
<li><a href="#scsidestroypkt-function">3.24.3. <code>scsi_destroy_pkt</code> Function</a></li>
<li><a href="#scsiallocconsistent_buf-function">3.24.4. <code>scsi_alloc_consistent_buf</code> Function</a></li>
<li><a href="#scsifreeconsistent_buf-function">3.24.5. <code>scsi_free_consistent_buf</code> Function</a></li>
</ul>
</li>
<li><a href="#building-and-transporting-a-command">3.25. Building and Transporting a Command</a>
<ul class="sectlevel3">
<li><a href="#building-a-command">3.25.1. Building a Command</a></li>
<li><a href="#setting-target-capabilities">3.25.2. Setting Target Capabilities</a></li>
<li><a href="#transporting-a-command">3.25.3. Transporting a Command</a></li>
<li><a href="#command-completion">3.25.4. Command Completion</a></li>
<li><a href="#reuse-of-packets">3.25.5. Reuse of Packets</a></li>
<li><a href="#auto-request-sense-mode">3.25.6. Auto-Request Sense Mode</a></li>
<li><a href="#dump-handling">3.25.7. Dump Handling</a></li>
</ul>
</li>
<li><a href="#scsi-options">3.26. SCSI Options</a></li>
<li><a href="#scsi-host-bus-adapter-drivers">3.27. SCSI Host Bus Adapter Drivers</a></li>
<li><a href="#introduction-to-host-bus-adapter-drivers">3.28. Introduction to Host Bus Adapter Drivers</a></li>
<li><a href="#scsi-interface">3.29. SCSI Interface</a></li>
<li><a href="#scsa-hba-interfaces">3.30. SCSA HBA Interfaces</a>
<ul class="sectlevel3">
<li><a href="#scsa-hba-entry-point-summary">3.30.1. SCSA HBA Entry Point Summary</a></li>
<li><a href="#scsa-hba-data-structures">3.30.2. SCSA HBA Data Structures</a></li>
<li><a href="#per-target-instance-data">3.30.3. Per-Target Instance Data</a></li>
<li><a href="#transport-structure-cloning">3.30.4. Transport Structure Cloning</a></li>
<li><a href="#scsa-hba-functions">3.30.5. SCSA HBA Functions</a></li>
</ul>
</li>
<li><a href="#hba-driver-dependency-and-configuration-issues">3.31. HBA Driver Dependency and Configuration Issues</a>
<ul class="sectlevel3">
<li><a href="#declarations-and-structures">3.31.1. Declarations and Structures</a></li>
<li><a href="#entry-points-for-module-initialization">3.31.2. Entry Points for Module Initialization</a></li>
<li><a href="#autoconfiguration-entry-points-1">3.31.3. Autoconfiguration Entry Points</a></li>
</ul>
</li>
<li><a href="#entry-points-for-scsa-hba-drivers">3.32. Entry Points for SCSA HBA Drivers</a>
<ul class="sectlevel3">
<li><a href="#target-driver-instance-initialization">3.32.1. Target Driver Instance Initialization</a></li>
<li><a href="#resource-allocation-1">3.32.2. Resource Allocation</a></li>
<li><a href="#command-transport">3.32.3. Command Transport</a></li>
<li><a href="#capability-management">3.32.4. Capability Management</a></li>
<li><a href="#abort-and-reset-management">3.32.5. Abort and Reset Management</a></li>
<li><a href="#dynamic-reconfiguration">3.32.6. Dynamic Reconfiguration</a></li>
</ul>
</li>
<li><a href="#scsi-hba-driver-specific-issues">3.33. SCSI HBA Driver Specific Issues</a>
<ul class="sectlevel3">
<li><a href="#installing-hba-drivers">3.33.1. Installing HBA Drivers</a></li>
<li><a href="#hba-configuration-properties">3.33.2. HBA Configuration Properties</a></li>
<li><a href="#x86-target-driver-configuration-properties">3.33.3. x86 Target Driver Configuration Properties</a></li>
</ul>
</li>
<li><a href="#support-for-queuing">3.34. Support for Queuing</a></li>
<li><a href="#drivers-for-network-devices">3.35. Drivers for Network Devices</a></li>
<li><a href="#generic-lan-driver-overview">3.36. Generic LAN Driver Overview</a>
<ul class="sectlevel3">
<li><a href="#type-dl_ether-ethernet-v2-and-iso-8802-3-ieee-8023">3.36.1. Type <code>DL_ETHER</code>: Ethernet V2 and ISO 8802-3 (IEEE 802.3)</a></li>
<li><a href="#types-dltpr-and-dlfddi-snap-processing">3.36.2. Types <code>DL_TPR</code> and <code>DL_FDDI</code>: SNAP Processing</a></li>
<li><a href="#type-dl_tpr-source-routing">3.36.3. Type <code>DL_TPR</code>: Source Routing</a></li>
<li><a href="#style-1-and-style-2-dlpi-providers">3.36.4. Style 1 and Style 2 DLPI Providers</a></li>
<li><a href="#implemented-dlpi-primitives">3.36.5. Implemented DLPI Primitives</a></li>
<li><a href="#implemented-ioctl-functions">3.36.6. Implemented <code>ioctl</code> Functions</a></li>
<li><a href="#gld-driver-requirements">3.36.7. GLD Driver Requirements</a></li>
<li><a href="#network-statistics">3.36.8. Network Statistics</a></li>
</ul>
</li>
<li><a href="#declarations-and-data-structures-1">3.37. Declarations and Data Structures</a>
<ul class="sectlevel3">
<li><a href="#gldmacinfo-structure">3.37.1. <code>gld_mac_info</code> Structure</a></li>
<li><a href="#gld_stats-structure">3.37.2. <code>gld_stats</code> Structure</a></li>
</ul>
</li>
<li><a href="#gld-arguments">3.38. GLD Arguments</a></li>
<li><a href="#gld-entry-points">3.39. GLD Entry Points</a>
<ul class="sectlevel3">
<li><a href="#gldm_reset-entry-point">3.39.1. <code>gldm_reset</code> Entry Point</a></li>
<li><a href="#gldm_start-entry-point">3.39.2. <code>gldm_start</code> Entry Point</a></li>
<li><a href="#gldm_stop-entry-point">3.39.3. <code>gldm_stop</code> Entry Point</a></li>
<li><a href="#gldmsetmac_addr-entry-point">3.39.4. <code>gldm_set_mac_addr</code> Entry Point</a></li>
<li><a href="#gldmsetmulticast-entry-point">3.39.5. <code>gldm_set_multicast</code> Entry Point</a></li>
<li><a href="#gldmsetpromiscuous-entry-point">3.39.6. <code>gldm_set_promiscuous</code> Entry Point</a></li>
<li><a href="#gldm_send-entry-point">3.39.7. <code>gldm_send</code> Entry Point</a></li>
<li><a href="#gldm_intr-entry-point">3.39.8. <code>gldm_intr</code> Entry Point</a></li>
<li><a href="#gldmgetstats-entry-point">3.39.9. <code>gldm_get_stats</code> Entry Point</a></li>
<li><a href="#gldm_ioctl-entry-point">3.39.10. <code>gldm_ioctl</code> Entry Point</a></li>
<li><a href="#gld-return-values">3.39.11. GLD Return Values</a></li>
</ul>
</li>
<li><a href="#gld-service-routines">3.40. GLD Service Routines</a>
<ul class="sectlevel3">
<li><a href="#gldmacalloc-function">3.40.1. <code>gld_mac_alloc</code> Function</a></li>
<li><a href="#gldmacfree-function">3.40.2. <code>gld_mac_free</code> Function</a></li>
<li><a href="#gld_register-function">3.40.3. <code>gld_register</code> Function</a></li>
<li><a href="#gld_unregister-function">3.40.4. <code>gld_unregister</code> Function</a></li>
<li><a href="#gld_recv-function">3.40.5. <code>gld_recv</code> Function</a></li>
<li><a href="#gld_sched-function">3.40.6. <code>gld_sched</code> Function</a></li>
<li><a href="#gld_intr-function">3.40.7. <code>gld_intr</code> Function</a></li>
</ul>
</li>
<li><a href="#usb-drivers">3.41. USB Drivers</a></li>
<li><a href="#usb-in-the-illumos-environment">3.42. USB in the illumos Environment</a>
<ul class="sectlevel3">
<li><a href="#usba-20-framework">3.42.1. USBA 2.0 Framework</a></li>
<li><a href="#usb-client-drivers">3.42.2. USB Client Drivers</a></li>
</ul>
</li>
<li><a href="#binding-client-drivers">3.43. Binding Client Drivers</a>
<ul class="sectlevel3">
<li><a href="#how-usb-devices-appear-to-the-system">3.43.1. How USB Devices Appear to the System</a></li>
<li><a href="#usb-devices-and-the-illumos-device-tree">3.43.2. USB Devices and the illumos Device Tree</a></li>
<li><a href="#compatible-device-names">3.43.3. Compatible Device Names</a></li>
<li><a href="#devices-with-multiple-interfaces">3.43.4. Devices With Multiple Interfaces</a></li>
<li><a href="#devices-with-interface-association-descriptors">3.43.5. Devices With Interface-Association Descriptors</a></li>
<li><a href="#checking-device-driver-bindings">3.43.6. Checking Device Driver Bindings</a></li>
</ul>
</li>
<li><a href="#basic-device-access">3.44. Basic Device Access</a>
<ul class="sectlevel3">
<li><a href="#before-the-client-driver-is-attached">3.44.1. Before the Client Driver Is Attached</a></li>
<li><a href="#the-descriptor-tree">3.44.2. The Descriptor Tree</a></li>
<li><a href="#registering-drivers-to-gain-device-access">3.44.3. Registering Drivers to Gain Device Access</a></li>
</ul>
</li>
<li><a href="#device-communication">3.45. Device Communication</a>
<ul class="sectlevel3">
<li><a href="#usb-endpoints">3.45.1. USB Endpoints</a></li>
<li><a href="#the-default-pipe">3.45.2. The Default Pipe</a></li>
<li><a href="#pipe-states">3.45.3. Pipe States</a></li>
<li><a href="#opening-pipes">3.45.4. Opening Pipes</a></li>
<li><a href="#closing-pipes">3.45.5. Closing Pipes</a></li>
<li><a href="#data-transfer">3.45.6. Data Transfer</a></li>
<li><a href="#flushing-pipes">3.45.7. Flushing Pipes</a></li>
</ul>
</li>
<li><a href="#device-state-management">3.46. Device State Management</a>
<ul class="sectlevel3">
<li><a href="#hotplugging-usb-devices">3.46.1. Hotplugging USB Devices</a></li>
<li><a href="#power-management-1">3.46.2. Power Management</a></li>
<li><a href="#serialization">3.46.3. Serialization</a></li>
</ul>
</li>
<li><a href="#utility-functions">3.47. Utility Functions</a>
<ul class="sectlevel3">
<li><a href="#device-configuration-facilities">3.47.1. Device Configuration Facilities</a></li>
<li><a href="#other-utility-functions">3.47.2. Other Utility Functions</a></li>
</ul>
</li>
<li><a href="#sample-usb-device-driver">3.48. Sample USB Device Driver</a></li>
</ul>
</li>
<li><a href="#_building_a_device_driver">4. Building a Device Driver</a>
<ul class="sectlevel2">
<li><a href="#compiling-loading-packaging-and-testing-drivers">4.1. Compiling, Loading, Packaging, and Testing Drivers</a></li>
<li><a href="#driver-development-summary">4.2. Driver Development Summary</a></li>
<li><a href="#driver-code-layout">4.3. Driver Code Layout</a>
<ul class="sectlevel3">
<li><a href="#header-files">4.3.1. Header Files</a></li>
<li><a href="#source-files">4.3.2. Source Files</a></li>
<li><a href="#configuration-files">4.3.3. Configuration Files</a></li>
</ul>
</li>
<li><a href="#preparing-for-driver-installation">4.4. Preparing for Driver Installation</a>
<ul class="sectlevel3">
<li><a href="#compiling-and-linking-the-driver">4.4.1. Compiling and Linking the Driver</a></li>
<li><a href="#module-dependencies">4.4.2. Module Dependencies</a></li>
<li><a href="#writing-a-hardware-configuration-file">4.4.3. Writing a Hardware Configuration File</a></li>
</ul>
</li>
<li><a href="#installing-updating-and-removing-drivers">4.5. Installing, Updating, and Removing Drivers</a>
<ul class="sectlevel3">
<li><a href="#copying-the-driver-to-a-module-directory">4.5.1. Copying the Driver to a Module Directory</a></li>
<li><a href="#installing-drivers-with-add_drv">4.5.2. Installing Drivers with <code>add_drv</code></a></li>
<li><a href="#updating-driver-information">4.5.3. Updating Driver Information</a></li>
<li><a href="#removing-the-driver">4.5.4. Removing the Driver</a></li>
</ul>
</li>
<li><a href="#loading-and-unloading-drivers">4.6. Loading and Unloading Drivers</a></li>
<li><a href="#driver-packaging">4.7. Driver Packaging</a>
<ul class="sectlevel3">
<li><a href="#package-postinstall">4.7.1. Package Postinstall</a></li>
<li><a href="#package-preremove">4.7.2. Package Preremove</a></li>
</ul>
</li>
<li><a href="#criteria-for-testing-drivers">4.8. Criteria for Testing Drivers</a>
<ul class="sectlevel3">
<li><a href="#configuration-testing">4.8.1. Configuration Testing</a></li>
<li><a href="#functionality-testing">4.8.2. Functionality Testing</a></li>
<li><a href="#error-handling-1">4.8.3. Error Handling</a></li>
<li><a href="#testing-loading-and-unloading">4.8.4. Testing Loading and Unloading</a></li>
<li><a href="#stress-performance-and-interoperability-testing">4.8.5. Stress, Performance, and Interoperability Testing</a></li>
<li><a href="#ddidki-compliance-testing">4.8.6. DDI/DKI Compliance Testing</a></li>
<li><a href="#installation-and-packaging-testing">4.8.7. Installation and Packaging Testing</a></li>
<li><a href="#testing-specific-types-of-drivers">4.8.8. Testing Specific Types of Drivers</a></li>
</ul>
</li>
<li><a href="#debugging-testing-and-tuning-device-drivers">4.9. Debugging, Testing, and Tuning Device Drivers</a></li>
<li><a href="#testing-drivers">4.10. Testing Drivers</a>
<ul class="sectlevel3">
<li><a href="#enable-the-deadman-feature-to-avoid-a-hard-hang">4.10.1. Enable the Deadman Feature to Avoid a Hard Hang</a></li>
<li><a href="#testing-with-a-serial-connection">4.10.2. Testing With a Serial Connection</a></li>
<li><a href="#setting-up-test-modules">4.10.3. Setting Up Test Modules</a></li>
<li><a href="#avoiding-data-loss-on-a-test-system">4.10.4. Avoiding Data Loss on a Test System</a></li>
<li><a href="#recovering-the-device-directory">4.10.5. Recovering the Device Directory</a></li>
</ul>
</li>
<li><a href="#debugging-tools">4.11. Debugging Tools</a>
<ul class="sectlevel3">
<li><a href="#postmortem-debugging">4.11.1. Postmortem Debugging</a></li>
<li><a href="#using-the-kmdb-kernel-debugger">4.11.2. Using the <code>kmdb</code> Kernel Debugger</a></li>
<li><a href="#using-the-mdb-modular-debugger">4.11.3. Using the <code>mdb</code> Modular Debugger</a></li>
<li><a href="#useful-debugging-tasks-with-kmdb-and-mdb">4.11.4. Useful Debugging Tasks With <code>kmdb</code> and <code>mdb</code></a></li>
</ul>
</li>
<li><a href="#tuning-drivers">4.12. Tuning Drivers</a>
<ul class="sectlevel3">
<li><a href="#kernel-statistics">4.12.1. Kernel Statistics</a></li>
<li><a href="#dtrace-for-dynamic-instrumentation">4.12.2. DTrace for Dynamic Instrumentation</a></li>
</ul>
</li>
<li><a href="#recommended-coding-practices">4.13. Recommended Coding Practices</a></li>
<li><a href="#debugging-preparation-techniques">4.14. Debugging Preparation Techniques</a>
<ul class="sectlevel3">
<li><a href="#use-a-unique-prefix-to-avoid-kernel-symbol-collisions">4.14.1. Use a Unique Prefix to Avoid Kernel Symbol Collisions</a></li>
<li><a href="#use-cmn_err-to-log-driver-activity">4.14.2. Use <code>cmn_err</code> to Log Driver Activity</a></li>
<li><a href="#use-assert-to-catch-invalid-assumptions">4.14.3. Use <code>ASSERT</code> to Catch Invalid Assumptions</a></li>
<li><a href="#use-mutex_owned-to-validate-and-document-locking-requirements">4.14.4. Use <code>mutex_owned</code> to Validate and Document Locking Requirements</a></li>
<li><a href="#use-conditional-compilation-to-toggle-costly-debugging-features">4.14.5. Use Conditional Compilation to Toggle Costly Debugging Features</a></li>
</ul>
</li>
<li><a href="#declaring-a-variable-volatile">4.15. Declaring a Variable Volatile</a></li>
<li><a href="#_serviceability">4.16. Serviceability</a>
<ul class="sectlevel3">
<li><a href="#_periodic_health_checks">4.16.1. Periodic Health Checks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_appendixes">5. Appendixes</a>
<ul class="sectlevel2">
<li><a href="#hardware-overview">5.1. Hardware Overview</a></li>
<li><a href="#sparc-processor-issues">5.2. SPARC Processor Issues</a>
<ul class="sectlevel3">
<li><a href="#sparc-data-alignment">5.2.1. SPARC Data Alignment</a></li>
<li><a href="#member-alignment-in-sparc-structures">5.2.2. Member Alignment in SPARC Structures</a></li>
<li><a href="#sparc-byte-ordering">5.2.3. SPARC Byte Ordering</a></li>
<li><a href="#sparc-register-windows">5.2.4. SPARC Register Windows</a></li>
<li><a href="#sparc-multiply-and-divide-instructions">5.2.5. SPARC Multiply and Divide Instructions</a></li>
</ul>
</li>
<li><a href="#x86-processor-issues">5.3. x86 Processor Issues</a>
<ul class="sectlevel3">
<li><a href="#x86-byte-ordering">5.3.1. x86 Byte Ordering</a></li>
<li><a href="#x86-architecture-manuals">5.3.2. x86 Architecture Manuals</a></li>
</ul>
</li>
<li><a href="#endianness">5.4. Endianness</a></li>
<li><a href="#store-buffers">5.5. Store Buffers</a></li>
<li><a href="#system-memory-model">5.6. System Memory Model</a>
<ul class="sectlevel3">
<li><a href="#total-store-ordering-tso">5.6.1. Total Store Ordering (TSO)</a></li>
<li><a href="#partial-store-ordering-pso">5.6.2. Partial Store Ordering (PSO)</a></li>
</ul>
</li>
<li><a href="#bus-architectures">5.7. Bus Architectures</a>
<ul class="sectlevel3">
<li><a href="#device-identification">5.7.1. Device Identification</a></li>
<li><a href="#supported-interrupt-types">5.7.2. Supported Interrupt Types</a></li>
</ul>
</li>
<li><a href="#bus-specifics">5.8. Bus Specifics</a>
<ul class="sectlevel3">
<li><a href="#pci-local-bus">5.8.1. PCI Local Bus</a></li>
<li><a href="#pci-address-domain">5.8.2. PCI Address Domain</a></li>
<li><a href="#pci-express">5.8.3. PCI Express</a></li>
<li><a href="#sbus">5.8.4. SBus</a></li>
</ul>
</li>
<li><a href="#device-issues">5.9. Device Issues</a>
<ul class="sectlevel3">
<li><a href="#timing-critical-sections">5.9.1. Timing-Critical Sections</a></li>
<li><a href="#delays">5.9.2. Delays</a></li>
<li><a href="#internal-sequencing-logic">5.9.3. Internal Sequencing Logic</a></li>
<li><a href="#interrupt-issues">5.9.4. Interrupt Issues</a></li>
</ul>
</li>
<li><a href="#prom-on-sparc-machines">5.10. PROM on SPARC Machines</a>
<ul class="sectlevel3">
<li><a href="#open-boot-prom-3">5.10.1. Open Boot PROM 3</a></li>
<li><a href="#reading-and-writing">5.10.2. Reading and Writing</a></li>
</ul>
</li>
<li><a href="#summary-of-illumos-ddidki-services">5.11. Summary of illumos DDI/DKI Services</a></li>
<li><a href="#module-functions">5.12. Module Functions</a></li>
<li><a href="#device-information-tree-node-devinfot-functions">5.13. Device Information Tree Node (<code>dev_info_t</code>) Functions</a></li>
<li><a href="#device-dev_t-functions">5.14. Device (<code>dev_t</code>) Functions</a></li>
<li><a href="#property-functions">5.15. Property Functions</a></li>
<li><a href="#device-software-state-functions">5.16. Device Software State Functions</a></li>
<li><a href="#memory-allocation-and-deallocation-functions">5.17. Memory Allocation and Deallocation Functions</a></li>
<li><a href="#kernel-thread-control-and-synchronization-functions">5.18. Kernel Thread Control and Synchronization Functions</a></li>
<li><a href="#task-queue-management-functions">5.19. Task Queue Management Functions</a></li>
<li><a href="#interrupt-functions">5.20. Interrupt Functions</a></li>
<li><a href="#programmed-io-functions">5.21. Programmed I/O Functions</a></li>
<li><a href="#direct-memory-access-dma-functions">5.22. Direct Memory Access (DMA) Functions</a></li>
<li><a href="#user-space-access-functions">5.23. User Space Access Functions</a></li>
<li><a href="#user-process-event-functions">5.24. User Process Event Functions</a></li>
<li><a href="#user-process-information-functions">5.25. User Process Information Functions</a></li>
<li><a href="#user-application-kernel-and-device-access-functions">5.26. User Application Kernel and Device Access Functions</a></li>
<li><a href="#time-related-functions">5.27. Time-Related Functions</a></li>
<li><a href="#power-management-functions">5.28. Power Management Functions</a></li>
<li><a href="#fault-management-functions">5.29. Fault Management Functions</a></li>
<li><a href="#kernel-statistics-functions-1">5.30. Kernel Statistics Functions</a></li>
<li><a href="#kernel-logging-and-printing-functions">5.31. Kernel Logging and Printing Functions</a></li>
<li><a href="#buffered-io-functions">5.32. Buffered I/O Functions</a></li>
<li><a href="#virtual-memory-functions">5.33. Virtual Memory Functions</a></li>
<li><a href="#device-id-functions">5.34. Device ID Functions</a></li>
<li><a href="#scsi-functions">5.35. SCSI Functions</a></li>
<li><a href="#resource-map-management-functions">5.36. Resource Map Management Functions</a></li>
<li><a href="#system-global-state">5.37. System Global State</a></li>
<li><a href="#utility-functions-1">5.38. Utility Functions</a></li>
<li><a href="#making-a-device-driver-64-bit-ready">5.39. Making a Device Driver 64-Bit Ready</a></li>
<li><a href="#introduction-to-64-bit-driver-design">5.40. Introduction to 64-Bit Driver Design</a></li>
<li><a href="#general-conversion-steps">5.41. General Conversion Steps</a>
<ul class="sectlevel3">
<li><a href="#use-fixed-width-types-for-hardware-registers">5.41.1. Use Fixed-Width Types for Hardware Registers</a></li>
<li><a href="#use-fixed-width-common-access-functions">5.41.2. Use Fixed-Width Common Access Functions</a></li>
<li><a href="#check-and-extend-use-of-derived-types">5.41.3. Check and Extend Use of Derived Types</a></li>
<li><a href="#check-changed-fields-in-ddi-data-structures">5.41.4. Check Changed Fields in DDI Data Structures</a></li>
<li><a href="#check-changed-arguments-of-ddi-functions">5.41.5. Check Changed Arguments of DDI Functions</a></li>
<li><a href="#modify-routines-that-handle-data-sharing">5.41.6. Modify Routines That Handle Data Sharing</a></li>
<li><a href="#check-structures-with-64-bit-long-data-types-on-x86-based-platforms">5.41.7. Check Structures with 64-bit Long Data Types on x86-Based Platforms</a></li>
</ul>
</li>
<li><a href="#well-known-ioctl-interfaces">5.42. Well Known <code>ioctl</code> Interfaces</a>
<ul class="sectlevel3">
<li><a href="#device-sizes">5.42.1. Device Sizes</a></li>
</ul>
</li>
<li><a href="#console-frame-buffer-drivers">5.43. Console Frame Buffer Drivers</a></li>
<li><a href="#illumos-consoles-and-the-kernel-terminal-emulator">5.44. illumos Consoles and the Kernel Terminal Emulator</a>
<ul class="sectlevel3">
<li><a href="#x86-platform-console-communication">5.44.1. x86 Platform Console Communication</a></li>
<li><a href="#sparc-platform-console-communication">5.44.2. SPARC Platform Console Communication</a></li>
</ul>
</li>
<li><a href="#console-visual-io-interfaces">5.45. Console Visual I/O Interfaces</a>
<ul class="sectlevel3">
<li><a href="#io-control-interfaces">5.45.1. I/O Control Interfaces</a></li>
<li><a href="#polled-io-interfaces">5.45.2. Polled I/O Interfaces</a></li>
<li><a href="#video-mode-change-callback-interface">5.45.3. Video Mode Change Callback Interface</a></li>
</ul>
</li>
<li><a href="#implementing-the-visual-io-interfaces-in-console-frame-buffer-drivers">5.46. Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers</a>
<ul class="sectlevel3">
<li><a href="#vis_devinit">5.46.1. <code>VIS_DEVINIT</code></a></li>
<li><a href="#vis_defini">5.46.2. <code>VIS_DEFINI</code></a></li>
<li><a href="#vis_consdisplay">5.46.3. <code>VIS_CONSDISPLAY</code></a></li>
<li><a href="#vis_conscopy">5.46.4. <code>VIS_CONSCOPY</code></a></li>
<li><a href="#vis_conscursor">5.46.5. <code>VIS_CONSCURSOR</code></a></li>
<li><a href="#vis_putcmap">5.46.6. <code>VIS_PUTCMAP</code></a></li>
<li><a href="#vis_getcmap">5.46.7. <code>VIS_GETCMAP</code></a></li>
</ul>
</li>
<li><a href="#implementing-polled-io-in-console-frame-buffer-drivers">5.47. Implementing Polled I/O in Console Frame Buffer Drivers</a></li>
<li><a href="#frame-buffer-specific-configuration-module">5.48. Frame Buffer Specific Configuration Module</a></li>
<li><a href="#the-x-window-system-frame-buffer-specific-ddx-module">5.49. The X Window System Frame Buffer Specific DDX Module</a></li>
<li><a href="#developing-testing-and-debugging-console-frame-buffer-drivers">5.50. Developing, Testing, and Debugging Console Frame Buffer Drivers</a>
<ul class="sectlevel3">
<li><a href="#testing-the-io-control-interfaces">5.50.1. Testing the I/O Control Interfaces</a></li>
<li><a href="#testing-the-polled-io-interfaces">5.50.2. Testing the Polled I/O Interfaces</a></li>
<li><a href="#testing-the-video-mode-change-callback-function">5.50.3. Testing the Video Mode Change Callback Function</a></li>
<li><a href="#additional-suggestions-for-testing-console-frame-buffer-drivers">5.50.4. Additional Suggestions for Testing Console Frame Buffer Drivers</a></li>
</ul>
</li>
<li><a href="#document-license">5.51. Document License</a></li>
<li><a href="#_public_documentation_license_pdl_version_1_01">5.52. Public Documentation License (PDL), Version 1.01</a></li>
<li><a href="#_public_documentation_license_notice">5.53. Public Documentation License Notice</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_preface"><a class="anchor" href="#_preface"></a>1. Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Writing Device Drivers provides information on developing drivers for
character-oriented devices, block-oriented devices, network devices,
SCSI target and HBA devices, and USB devices for the illumos Operating
System (illumos). This book discusses how to develop multithreaded
reentrant device drivers for all architectures that conform to the
illumos DDI/DKI (Device Driver Interface, Driver-Kernel Interface). A
common driver programming approach is described that enables drivers to
be written without concern for platform-specific issues such as
endianness and data ordering.</p>
</div>
<div class="paragraph">
<p>Additional topics include hardening illumos drivers; power management;
driver autoconfiguration; programmed I/O; Direct Memory Access (DMA);
device context management; compilation, installation, and testing
drivers; debugging drivers; and porting illumos drivers to a 64-bit
environment.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This illumos release supports systems that use the SPARC and x86
families of processor architectures: UltraSPARC, SPARC64, AMD64,
Pentium, and Xeon EM64T. For supported systems, see the illumos Hardware
Compatibility Lists at <a href="http://www.illumos.org/hcl/" class="bare">http://www.illumos.org/hcl/</a>. This document cites
any implementation differences between the platform types.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="whats-new"><a class="anchor" href="#whats-new"></a>1.1. What&#8217;s New</h3>
<div class="paragraph">
<p><strong>SX build 96:</strong> Rewrote the description of the sleep-flag flag on page
86.</p>
</div>
<div class="paragraph">
<p><strong>SX build 88:</strong> Added the <code>strnlen</code> function to
<a href="#utility-functions">Utility Functions</a>. Added the
<code>ddi_periodic_add</code> and <code>ddi_periodic_delete</code> functions
to <a href="#time-related-functions">Time-Related Functions</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="who-should-use-this-book"><a class="anchor" href="#who-should-use-this-book"></a>1.2. Who Should Use This Book</h3>
<div class="paragraph">
<p>This book is written for UNIX programmers who are familiar with UNIX
device drivers. Overview information is provided, but the book is not
intended to serve as a general tutorial on device drivers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The illumos operating system (illumos) runs on both SPARC and x86
architectures. illumos also runs on both 64-bit and 32-bit address
spaces. The information in this document applies to all platforms and
address spaces unless specifically noted.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-this-book-is-organized"><a class="anchor" href="#how-this-book-is-organized"></a>1.3. How This Book Is Organized</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#overview-of-illumos-device-drivers">Overview of illumos Device Drivers</a> provides an
introduction to device drivers and associated entry points on the
illumos platform. The entry points for each device driver type are
presented in tables.</p>
</li>
<li>
<p><a href="#illumos-kernel-and-device-tree">illumos Kernel and Device Tree</a> provides an
overview of the illumos kernel with an explanation of how devices are
represented as nodes in a device tree.</p>
</li>
<li>
<p><a href="#multithreading">Multithreading</a> describes the aspects of the illumos
multithreaded kernel that are relevant for device driver developers.</p>
</li>
<li>
<p><a href="#properties">Properties</a> describes the set of interfaces for
using device properties.</p>
</li>
<li>
<p><a href="#managing-events-and-queueing-tasks">Managing Events and Queueing Tasks</a> describes how
device drivers log events and how to use task queues to perform a task
at a later time.</p>
</li>
<li>
<p><a href="#driver-autoconfiguration">Driver Autoconfiguration</a> explains the support that
a driver must provide for autoconfiguration.</p>
</li>
<li>
<p><a href="#device-access-programmed-io">Device Access: Programmed I/O</a> describes the
interfaces and methodologies for drivers to read or write to device
memory.</p>
</li>
<li>
<p><a href="#interrupt-handlers">Interrupt Handlers</a> describes the mechanisms for
handling interrupts. These mechanisms include registering, servicing,
and removing interrupts.</p>
</li>
<li>
<p><a href="#direct-memory-access-dma">Direct Memory Access (DMA)</a> describes direct memory
access (DMA) and the DMA interfaces.</p>
</li>
<li>
<p><a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel Memory</a> describes
interfaces for managing device and kernel memory.</p>
</li>
<li>
<p><a href="#device-context-management">Device Context Management</a> describes the set of
interfaces that enable device drivers to manage user access to devices.</p>
</li>
<li>
<p><a href="#power-management">Power Management</a> explains the interfaces for
Power Management, a framework for managing power consumption.</p>
</li>
<li>
<p><a href="#hardening-illumos-drivers">Hardening illumos Drivers</a> describes how to integrate
fault management capabilities into I/O device drivers, how to
incorporate defensive programming practices, and how to use the driver
hardening test harness.</p>
</li>
<li>
<p><a href="#layered-driver-interface-ldi">Layered Driver Interface (LDI)</a> describes the LDI, which
enables kernel modules to access other devices in the system.</p>
</li>
<li>
<p><a href="#drivers-for-character-devices">Drivers for Character Devices</a> describes drivers
for character-oriented devices.</p>
</li>
<li>
<p><a href="#drivers-for-block-devices">Drivers for Block Devices</a> describes drivers for a
block-oriented devices.</p>
</li>
<li>
<p><a href="#scsi-target-drivers">SCSI Target Drivers</a> outlines the Sun Common SCSI
Architecture (SCSA) and the requirements for SCSI target drivers.</p>
</li>
<li>
<p><a href="#scsi-host-bus-adapter-drivers">SCSI Host Bus Adapter Drivers</a> explains how to
apply SCSA to SCSI Host Bus Adapter (HBA) drivers.</p>
</li>
<li>
<p><a href="#drivers-for-network-devices">Drivers for Network Devices</a> describes the Generic LAN
driver (GLD), an illumos network driver that uses STREAMS technology and
the Data Link Provider Interface (DLPI).</p>
</li>
<li>
<p><a href="#usb-drivers">USB Drivers</a> describes how to write a client USB device
driver using the USBA 2.0 framework.</p>
</li>
<li>
<p><a href="#compiling-loading-packaging-and-testing-drivers">Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers</a> provides information on compiling, linking, and
installing a driver.</p>
</li>
<li>
<p><a href="#debugging-testing-and-tuning-device-drivers">Debugging&#44; Testing&#44; and Tuning Device Drivers</a>
describes techniques for debugging, testing, and tuning drivers.</p>
</li>
<li>
<p><a href="#recommended-coding-practices">Recommended Coding Practices</a> describes the
recommended coding practices for writing drivers.</p>
</li>
<li>
<p><a href="#hardware-overview">appendix_title</a> discusses multi-platform
hardware issues for device drivers.</p>
</li>
<li>
<p><a href="#summary-of-illumos-ddidki-services">appendix_title</a> provides tables of kernel
functions for device drivers. Deprecated functions are indicated as
well.</p>
</li>
<li>
<p><a href="#making-a-device-driver-64-bit-ready">appendix_title</a> provides guidelines for updating
a device driver to run in a 64-bit environment.</p>
</li>
<li>
<p><a href="#console-frame-buffer-drivers">appendix_title</a> describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="related-books-and-papers"><a class="anchor" href="#related-books-and-papers"></a>1.4. Related Books and Papers</h3>
<div class="paragraph">
<p>For detailed reference information about the device driver interfaces,
see the section 9 man pages. Section 9E, <code>Intro(9E)</code>, describes DDI/DKI
(Device Driver Interface, Driver-Kernel Interface) driver entry points.
Section 9F, <code>Intro(9F)</code>, describes DDI/DKI kernel functions. Sections 9P
and 9S, <code>Intro(9S)</code>, describe DDI/DKI properties and data structures.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Device Driver Tutorial. Sun Microsystems, Inc., 2008.</p>
</li>
<li>
<p>Application Packaging Developer’s Guide. Sun Microsystems, Inc., 2005.</p>
</li>
<li>
<p>Open Boot PROM Toolkit User&#8217;s Guide. Sun Microsystems, Inc., 1996.</p>
</li>
<li>
<p>STREAMS Programming Guide. Sun Microsystems, Inc., 2005.</p>
</li>
<li>
<p>Multithreaded Programming Guide. Sun Microsystems, Inc., 2008.</p>
</li>
<li>
<p>Solaris 64-bit Developer’s Guide. Sun Microsystems, Inc., 2005.</p>
</li>
<li>
<p>Modular Debugger Guide. Sun Microsystems, Inc., 2008.</p>
</li>
<li>
<p>Dynamic Tracing Guide. Sun Microsystems, Inc., 2007.</p>
</li>
<li>
<p>DTrace User Guide. Sun Microsystems, Inc., 2006.</p>
</li>
<li>
<p>The SPARC Architecture Manual, Version 9. Prentice Hall, 1998. ISBN
0-13-099227-5.</p>
</li>
<li>
<p>The SPARC Architecture Manual, Version 8. Prentice Hall, 1994. ISBN
0-13-825001-4.</p>
</li>
<li>
<p>Pentium Pro Family Developer&#8217;s Manual, Volumes 1-3. Intel Corporation, 1996. Volume 1, ISBN 1-55512-259-0; Volume 2, ISBN 1-55512-260-4; Volume 3, ISBN 1-55512-261-2.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_typographic_conventions"><a class="anchor" href="#_typographic_conventions"></a>1.5. Typographic Conventions</h3>
<div class="paragraph">
<p>The following table describes the typographic conventions that are used
in this book.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Typographic Conventions</caption>
<colgroup>
<col style="width: 21%;">
<col style="width: 45%;">
<col style="width: 34%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Typeface</th>
<th class="tableblock halign-left valign-top">Meaning</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AaBbCc123</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The names of commands, files, and directories, and
onscreen computer output</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Edit your <code>.login</code> file.</p>
</div>
<div class="paragraph">
<p>Use <code>ls</code> <code>a</code> to list all files.</p>
</div>
<div class="paragraph">
<p><code>machine_name% you have mail.</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AaBbCc123</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">What you type, contrasted with onscreen computer output</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>machine_name%</code> <code>su</code></p>
</div>
<div class="paragraph">
<p><code>Password:</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;aabbcc123&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Placeholder: replace with a real name or value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The command to remove a file is <code>rm</code> &lt;filename&gt;.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>AaBbCc123</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Book titles, new terms, and terms to be emphasized</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Read Chapter 6 in the User&#8217;s Guide.</p>
</div>
<div class="paragraph">
<p>A <em>cache</em> is a copy that is stored locally.</p>
</div>
<div class="paragraph">
<p>Do <em>not</em> save the file.</p>
</div>
<div class="paragraph">
<p><strong>Note:</strong> Some emphasized items appear bold online.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="shell-prompts-in-command-examples"><a class="anchor" href="#shell-prompts-in-command-examples"></a>1.6. Shell Prompts in Command Examples</h3>
<div class="paragraph">
<p>The following table shows the default UNIX system prompt and superuser
prompt for the C shell, Bourne shell, and Korn shell.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Shell Prompts</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Shell</th>
<th class="tableblock halign-left valign-top">Prompt</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C shell</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>machine_name%</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C shell for superuser</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>machine_name#</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bourne shell and Korn shell</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bourne shell and Korn shell for superuser</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_designing_device_drivers_for_the_illumos_platform"><a class="anchor" href="#_designing_device_drivers_for_the_illumos_platform"></a>2. Designing Device Drivers for the illumos Platform</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first part of this manual provides general information for
developing device drivers on the illumos platform. This part includes
the following chapters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#overview-of-illumos-device-drivers">Overview of illumos Device Drivers</a> provides an
introduction to device drivers and associated entry points on the
illumos platform. The entry points for each device driver type are
presented in tables.</p>
</li>
<li>
<p><a href="#illumos-kernel-and-device-tree">illumos Kernel and Device Tree</a> provides an
overview of the illumos kernel with an explanation of how devices are
represented as nodes in a device tree.</p>
</li>
<li>
<p><a href="#multithreading">Multithreading</a> describes the aspects of the illumos
multithreaded kernel that are relevant for device driver developers.</p>
</li>
<li>
<p><a href="#properties">Properties</a> describes the set of interfaces for
using device properties.</p>
</li>
<li>
<p><a href="#managing-events-and-queueing-tasks">Managing Events and Queueing Tasks</a> describes how
device drivers log events and how to use task queues to perform a task
at a later time.</p>
</li>
<li>
<p><a href="#driver-autoconfiguration">Driver Autoconfiguration</a> explains the support that
a driver must provide for autoconfiguration.</p>
</li>
<li>
<p><a href="#device-access-programmed-io">Device Access: Programmed I/O</a> describes the
interfaces and methodologies for drivers to read or write to device
memory.</p>
</li>
<li>
<p><a href="#interrupt-handlers">Interrupt Handlers</a> describes the mechanisms for
handling interrupts. These mechanisms include registering, servicing,
and removing interrupts.</p>
</li>
<li>
<p><a href="#direct-memory-access-dma">Direct Memory Access (DMA)</a> describes direct memory
access (DMA) and the DMA interfaces.</p>
</li>
<li>
<p><a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel Memory</a> describes
interfaces for managing device and kernel memory.</p>
</li>
<li>
<p><a href="#device-context-management">Device Context Management</a> describes the set of
interfaces that enable device drivers to manage user access to devices.</p>
</li>
<li>
<p><a href="#power-management">Power Management</a> explains the interfaces for the
Power Management feature, a framework for managing power consumption.</p>
</li>
<li>
<p><a href="#hardening-illumos-drivers">Hardening illumos Drivers</a> describes how to integrate
fault management capabilities into I/O device drivers, how to
incorporate defensive programming practices, and how to use the driver
hardening test harness.</p>
</li>
<li>
<p><a href="#layered-driver-interface-ldi">Layered Driver Interface (LDI)</a> describes the LDI, which
enables kernel modules to access other devices in the system.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="overview-of-illumos-device-drivers"><a class="anchor" href="#overview-of-illumos-device-drivers"></a>2.1. Overview of illumos Device Drivers</h3>
<div class="paragraph">
<p>This chapter gives an overview of illumos device drivers. The chapter
provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#device-driver-basics">Device Driver Basics</a></p>
</li>
<li>
<p><a href="#device-driver-entry-points">Device Driver Entry Points</a></p>
</li>
<li>
<p><a href="#considerations-in-device-driver-design">Considerations in Device Driver Design</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="device-driver-basics"><a class="anchor" href="#device-driver-basics"></a>2.2. Device Driver Basics</h3>
<div class="paragraph">
<p>This section introduces you to device drivers and their entry points on
the illumos platform.</p>
</div>
<div class="sect3">
<h4 id="what-is-a-device-driver"><a class="anchor" href="#what-is-a-device-driver"></a>2.2.1. What Is a Device Driver?</h4>
<div class="paragraph">
<p>A <em>device driver</em> is a
kernel module that is responsible for managing the low-level I/O
operations of a hardware device. Device drivers are written with
standard interfaces that the kernel can call to interface with a device.
Device drivers can also be software-only, emulating a device that exists
only in software, such as RAM disks, buses, and pseudo-terminals.</p>
</div>
<div class="paragraph">
<p>A device driver contains all the device-specific code necessary to
communicate with a device. This code includes a standard set of
interfaces to the rest of the system. This interface shields the kernel
from device specifics just as the system call interface protects
application programs from platform specifics. Application programs and
the rest of the kernel need little, if any, device-specific code to
address the device. In this way, device drivers make the system more
portable and easier to maintain.</p>
</div>
<div class="paragraph">
<p>When illumos is initialized, devices identify themselves and are
organized into the <em>device tree</em>, a hierarchy of devices. In effect, the
device tree is a hardware model for the kernel. An individual device
driver is represented as a node in the tree with no children. This type
of node is referred to as a <em>leaf driver</em>. A driver that provides
services to other drivers is called a <em>bus nexus driver</em> and is shown as
a node with children. As part of the boot process, physical devices are
mapped to drivers in the tree so that the drivers can be located when
needed. For more information on how illumos accommodates devices, see
<a href="#illumos-kernel-and-device-tree">illumos Kernel and Device Tree</a>.</p>
</div>
<div class="paragraph">
<p>Device drivers are classified by how they handle I/O. Device drivers
fall into three broad categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Block device drivers</strong> – For cases where handling I/O data as
asynchronous chunks is appropriate. Typically, block drivers are used to
manage devices with physically addressable storage media, such as disks.</p>
</li>
<li>
<p><strong>Character device drivers</strong> – For devices that perform I/O on a
continuous flow of bytes.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A driver can be both block and character at the same time if you set up
two different interfaces to the file system. See
<a href="#devices-as-special-files">Devices as Special Files</a>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Included in the character category are drivers that use the STREAMS
model (see below), programmed I/O, direct memory access, SCSI buses,
USB, and other network I/O.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>STREAMS device drivers</strong> – Subset of character drivers that uses the
<code>streamio(4I)</code> set of routines for character I/O within the kernel.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="what-is-a-device-driver-entry-point"><a class="anchor" href="#what-is-a-device-driver-entry-point"></a>2.2.2. What Is a Device Driver Entry Point?</h4>
<div class="paragraph">
<p>An <em>entry point</em> is a
function within a device driver that can be called by an external entity
to get access to some driver functionality or to operate a device. Each
device driver provides a standard set of functions as entry points. For
the complete list of entry points for all driver types, see the
<code>Intro(9E)</code> man page. The illumos kernel uses entry points for these
general task areas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Loading and unloading the driver</strong></p>
</li>
<li>
<p><strong>Autoconfiguring the device</strong> – Autoconfiguration is the process of
loading a device driver&#8217;s code and static data into memory so that the
driver is registered with the system.</p>
</li>
<li>
<p><strong>Providing I/O services for the driver</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Drivers for different types of devices have different sets of entry
points according to the kinds of operations the devices perform. A
driver for a memory-mapped character-oriented device, for example,
supports a <code>devmap(9E)</code> entry point, while a block driver does not
support this entry.</p>
</div>
<div class="paragraph">
<p>Use a prefix based on the name of your
driver to give driver functions unique names. Typically, this prefix is
the name of the driver, such as <code>xx_open</code> for the <code>open(9E)</code> routine
of driver <code>xx</code>. See <a href="#use-a-unique-prefix-to-avoid-kernel-symbol-collisions">Use a Unique Prefix to Avoid Kernel
Symbol Collisions</a> for more information. In subsequent examples in this
book, <code>xx</code> is used as the driver prefix.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-driver-entry-points"><a class="anchor" href="#device-driver-entry-points"></a>2.3. Device Driver Entry Points</h3>
<div class="paragraph">
<p>This section provides lists of entry points for the following
categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#entry-points-common-to-all-drivers">Entry Points Common to All Drivers</a></p>
</li>
<li>
<p><a href="#entry-points-for-block-device-drivers">Entry Points for Block Device Drivers</a></p>
</li>
<li>
<p><a href="#entry-points-for-character-device-drivers">Entry Points for Character Device Drivers</a></p>
</li>
<li>
<p><a href="#entry-points-for-streams-device-drivers">Entry Points for STREAMS Device Drivers</a></p>
</li>
<li>
<p><a href="#entry-points-for-memory-mapped-devices">Entry Points for Memory Mapped Devices</a></p>
</li>
<li>
<p><a href="#entry-points-for-the-generic-lan-device-gld-driver">Entry Points for the Generic LAN Device (GLD) Driver</a></p>
</li>
<li>
<p><a href="#entry-points-for-scsi-hba-drivers">Entry Points for SCSI HBA Drivers</a></p>
</li>
<li>
<p><a href="#entry-points-for-pc-card-drivers">Entry Points for PC Card Drivers</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="entry-points-common-to-all-drivers"><a class="anchor" href="#entry-points-common-to-all-drivers"></a>2.3.1. Entry Points Common to All Drivers</h4>
<div class="paragraph">
<p>Some operations can be performed by any type of driver, such as the
functions that are required for module loading and for the required
autoconfiguration entry points. This section discusses types of entry
points that are common to all drivers. The common entry points are
listed in <a href="#summary-of-common-entry-points">Summary of Common Entry Points</a> with links to man
pages and other relevant discussions.</p>
</div>
<div class="sect4">
<h5 id="device-access-entry-points"><a class="anchor" href="#device-access-entry-points"></a>Device Access Entry Points</h5>
<div class="paragraph">
<p>Drivers for character and block devices export the <code>cb_ops(9S)</code>
structure, which defines the driver entry points for block device access
and character device access. Both types of drivers are required to
support the <code>open(9E)</code> and <code>close(9E)</code> entry points. Block drivers are
required to support <code>strategy(9E)</code>, while character drivers can choose
to implement whatever mix of <code>read(9E)</code>, <code>write(9E)</code>, <code>ioctl(9E)</code>,
<code>mmap(9E)</code>, or <code>devmap(9E)</code> entry points is appropriate for the type of
device. Character drivers can also support a polling interface through
<code>chpoll(9E)</code>. Asynchronous I/O is supported through <code>aread(9E)</code> and
<code>awrite(9E)</code> for block drivers and those drivers that can use both block
and character file systems.</p>
</div>
</div>
<div class="sect4">
<h5 id="loadable-module-entry-points"><a class="anchor" href="#loadable-module-entry-points"></a>Loadable Module Entry Points</h5>
<div class="paragraph">
<p>All drivers
are required to implement the loadable module entry points
<code>_init(9E)</code>, <code>_fini(9E)</code>, and <code>_info(9E)</code> to load, unload,
and report information about the driver module.</p>
</div>
<div class="paragraph">
<p>Drivers should allocate and initialize any global resources in
<code>_init(9E)</code>. Drivers should release their resources in
<code>_fini(9E)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In illumos, only the loadable module routines must be visible outside
the driver object module. Other routines can have the storage class
<code>static</code>.
===
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="autoconfiguration-entry-points"><a class="anchor" href="#autoconfiguration-entry-points"></a>Autoconfiguration Entry Points</h5>
<div class="paragraph">
<p>Drivers are required to implement the <code>attach(9E)</code>, <code>detach(9E)</code>, and
<code>getinfo(9E)</code> entry points for device autoconfiguration. Drivers can
also implement the optional entry point <code>probe(9E)</code> in cases where
devices do not identify themselves during boot-up, such as SCSI target
devices. See <a href="#driver-autoconfiguration">Driver Autoconfiguration</a> for more
information on these routines.</p>
</div>
</div>
<div class="sect4">
<h5 id="kernel-statistics-entry-points"><a class="anchor" href="#kernel-statistics-entry-points"></a>Kernel Statistics Entry Points</h5>
<div class="paragraph">
<p>The illumos platform provides a rich set of interfaces to maintain and
export kernel-level statistics, also known as <em>kstats</em>. Drivers are free
to use these interfaces to export driver and device statistics that can
be used by user applications to observe the internal state of the
driver. Two entry points are provided for working with kernel
statistics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ks_snapshot(9E)</code> captures kstats at a specific time.</p>
</li>
<li>
<p><code>ks_update(9E)</code> can be used to update kstat data at will.
<code>ks_update</code> is useful in situations where a device is set up to
track kernel data but extracting that data is time-consuming.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For further information, see the <code>kstat_create(9F)</code> and <code>kstat(9S)</code>
man pages. See also <a href="#kernel-statistics">Kernel Statistics</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="power-management-entry-point"><a class="anchor" href="#power-management-entry-point"></a>Power Management Entry Point</h5>
<div class="paragraph">
<p>Drivers for hardware devices that provide Power Management functionality
can support the optional <code>power(9E)</code> entry point. See
<a href="#power-management">Power Management</a> for details about this entry
point.</p>
</div>
</div>
<div class="sect4">
<h5 id="summary-of-common-entry-points"><a class="anchor" href="#summary-of-common-entry-points"></a>Summary of Common Entry Points</h5>
<div class="paragraph">
<p>The following table lists entry points that can be used by all types of
drivers.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Entry Points for All Driver Types</caption>
<colgroup>
<col style="width: 29%;">
<col style="width: 11%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Category / Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cb_ops</code> <strong>Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>open(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Gets access to a device. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#open-entry-point-character-drivers"> Entry Point (Character Drivers)</a></p>
</li>
<li>
<p><a href="#open-entry-point-block-drivers"> Entry Point (Block Drivers)</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>close(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Gives up access to a device. The version of <code>close</code> for STREAMS drivers
has a different signature than character and block drivers. Additional
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#close-entry-point-character-drivers"> Entry Point (Character Drivers)</a></p>
</li>
<li>
<p><a href="#close-entry-point-block-drivers"> Entry Point (Block Drivers)</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Loadable Module Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_init(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initializes a loadable module. Additional
information: <a href="#loadable-driver-interfaces">Loadable Driver Interfaces</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_fini(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Prepares a loadable module for unloading.
Required for all driver types. Additional information:
<a href="#loadable-driver-interfaces">Loadable Driver Interfaces</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_info(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns information about a loadable module.
Additional information: <a href="#loadable-driver-interfaces">Loadable Driver Interfaces</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Autoconfiguration Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attach(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adds a device to the system as part of
initialization. Also used to resume a system that has been suspended.
Additional information: <a href="#attach-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>detach(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detaches a device from the system. Also, used
to suspend a device temporarily. Additional information:
<a href="#detach-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getinfo(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Gets device information that is specific to the driver, such as the
mapping between a device number and the corresponding instance.
Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getinfo-entry-point"> Entry Point</a></p>
</li>
<li>
<p><a href="#getinfo-entry-point-scsi-target-drivers"> Entry Point (SCSI Target Drivers)</a>.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>probe(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See Description</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Determines if a non-self-identifying device is present. Required for a
device that cannot identify itself. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#probe-entry-point"> Entry Point</a></p>
</li>
<li>
<p><a href="#probe-entry-point-scsi-target-drivers"> Entry Point (SCSI Target Drivers)</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kernel Statistics Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ks_snapshot(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Takes a snapshot of <code>kstat(9S)</code> data.
Additional information: <a href="#kernel-statistics">Kernel Statistics</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ks_update(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates <code>kstat(9S)</code> data dynamically.
Additional information: <a href="#kernel-statistics">Kernel Statistics</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Power Management Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>power(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the power level of a device. If not used,
set to <code>NULL</code>. Additional information: <a href="#power-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Miscellaneous Entry Points</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prop_op(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See Description</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Reports driver property information. Required unless
<code>ddi_prop_op(9F)</code> is substituted. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#creating-and-updating-properties">Creating and Updating Properties</a></p>
</li>
<li>
<p><a href="#prop_op-entry-point"> Entry Point</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dump(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See Description</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Dumps memory to a device during system failure. Required for any device
that is to be used as the dump device during a panic. Additional
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#dump-entry-point-block-drivers"> Entry Point (Block Drivers)</a></p>
</li>
<li>
<p><a href="#dump-handling">Dump Handling</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>identify</code>(9E)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Obsolete</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Do not use this entry point. Assign
<code>nulldev(9F)</code> to this entry point in the <code>dev_ops</code> structure.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="entry-points-for-block-device-drivers"><a class="anchor" href="#entry-points-for-block-device-drivers"></a>2.3.2. Entry Points for Block Device Drivers</h4>
<div class="paragraph">
<p>Devices that
support a file system are known as <em>block devices</em>. Drivers written for
these devices are known as block device drivers. Block device drivers
take a file system request, in the form of a <code>buf(9S)</code> structure, and
issue the I/O operations to the disk to transfer the specified block.
The main interface to the file system is the <code>strategy(9E)</code> routine. See
<a href="#drivers-for-block-devices">Drivers for Block Devices</a> for more information.</p>
</div>
<div class="paragraph">
<p>A block device driver can also provide a character driver interface to
enable utility programs to bypass the file system and to access the
device directly. This device access is commonly referred to as the <em>raw</em>
interface to a block device.</p>
</div>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
block device drivers. See also <a href="#entry-points-common-to-all-drivers">Entry Points Common to All
Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Additional Entry Points for Block Drivers</caption>
<colgroup>
<col style="width: 29%;">
<col style="width: 11%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aread(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Performs an asynchronous read. Drivers that do not support an <code>aread</code>
entry point should use the <code>nodev(9F)</code> error return function. Additional
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#differences-between-synchronous-and-asynchronous-io">Differences Between Synchronous and Asynchronous
I/O</a></p>
</li>
<li>
<p><a href="#dma-transfers-asynchronous">DMA Transfers (Asynchronous)</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>awrite(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Performs an asynchronous write. Drivers that do not support an <code>awrite</code>
entry point should use the <code>nodev(9F)</code> error return function. Additional
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#differences-between-synchronous-and-asynchronous-io">Differences Between Synchronous and Asynchronous
I/O</a></p>
</li>
<li>
<p><a href="#dma-transfers-asynchronous">DMA Transfers (Asynchronous)</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>print(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays a driver message on the system console.
Additional information: <a href="#print-entry-point-block-drivers"> Entry Point (Block Drivers)</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>strategy(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Perform block I/O. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#canceling-dma-callbacks">Canceling DMA Callbacks</a></p>
</li>
<li>
<p><a href="#dma-transfers-synchronous">DMA Transfers (Synchronous)</a></p>
</li>
<li>
<p><a href="#strategy-entry-point"> Entry Point</a></p>
</li>
<li>
<p><a href="#dma-transfers-asynchronous">DMA Transfers (Asynchronous)</a></p>
</li>
<li>
<p><a href="#general-flow-of-control">General Flow of Control</a></p>
</li>
<li>
<p><a href="#x86-target-driver-configuration-properties">x86 Target Driver Configuration Properties</a></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-character-device-drivers"><a class="anchor" href="#entry-points-for-character-device-drivers"></a>2.3.3. Entry Points for Character Device Drivers</h4>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>standard character driver</p>
</div>
<div class="paragraph">
<p>character device driver</p>
</div>
<div class="paragraph">
<p>Character device drivers normally perform I/O in a byte stream. Examples
of devices that use character drivers include tape drives and serial
ports. Character device drivers can also provide additional interfaces
not present in block drivers, such as I/O control (<code>ioctl</code>) commands,
memory mapping, and device polling. See <a href="#drivers-for-character-devices">Drivers
for Character Devices</a> for more information.</p>
</div>
<div class="paragraph">
<p>The main task of any device driver is to perform I/O,
and many character device drivers do what is called <em>byte-stream</em> or
<em>character</em> I/O. The driver transfers data to and from the device
without using a specific device address. This type of transfer is in
contrast to block device drivers, where part of the file system request
identifies a specific location on the device.</p>
</div>
<div class="paragraph">
<p>The <code>read(9E)</code> and <code>write(9E)</code> entry points handle byte-stream I/O for
standard character drivers. See <a href="#io-request-handling">I/O Request
Handling</a> for more information.</p>
</div>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
character device drivers. For other entry points, see <a href="#entry-points-common-to-all-drivers">Entry
Points Common to All Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Additional Entry Points for Character Drivers</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 11%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>chpoll(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Polls events for a non-STREAMS character
driver. Additional information: <a href="#multiplexing-io-on-file-descriptors">Multiplexing I/O
on File Descriptors</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ioctl(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Performs a range of I/O commands for character drivers. <code>ioctl</code> routines
must make sure that user data is copied into or out of the kernel
address space explicitly using <code>copyin(9F)</code>, <code>copyout(9F)</code>,
<code>ddi_copyin(9F)</code>, and <code>ddi_copyout(9F)</code>, as appropriate.
Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#ioctl-entry-point-character-drivers"> Entry Point (Character Drivers)</a></p>
</li>
<li>
<p><a href="#implemented-ioctl-functions">Implemented Functions</a></p>
</li>
<li>
<p><a href="#well-known-ioctl-interfaces">Well Known Interfaces</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>read(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Reads data from a device. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#vectored-io">Vectored I/O</a></p>
</li>
<li>
<p><a href="#differences-between-synchronous-and-asynchronous-io">Differences Between Synchronous and Asynchronous
I/O</a></p>
</li>
<li>
<p><a href="#programmed-io-transfers">Programmed I/O Transfers</a></p>
</li>
<li>
<p><a href="#dma-transfers-synchronous">DMA Transfers (Synchronous)</a></p>
</li>
<li>
<p><a href="#general-flow-of-control">General Flow of Control</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>segmap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Maps device memory into user space. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#exporting-the-mapping">Exporting the Mapping</a></p>
</li>
<li>
<p><a href="#allocating-kernel-memory-for-user-access">Allocating Kernel Memory for User Access</a></p>
</li>
<li>
<p><a href="#associating-user-mappings-with-driver-notifications">Associating User Mappings With Driver Notifications</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>write(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Writes data to a device. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#device-access-functions">Device Access Functions</a></p>
</li>
<li>
<p><a href="#vectored-io">Vectored I/O</a></p>
</li>
<li>
<p><a href="#differences-between-synchronous-and-asynchronous-io">Differences Between Synchronous and Asynchronous
I/O</a></p>
</li>
<li>
<p><a href="#programmed-io-transfers">Programmed I/O Transfers</a></p>
</li>
<li>
<p><a href="#dma-transfers-synchronous">DMA Transfers (Synchronous)</a></p>
</li>
<li>
<p><a href="#general-flow-of-control">General Flow of Control</a></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-streams-device-drivers"><a class="anchor" href="#entry-points-for-streams-device-drivers"></a>2.3.4. Entry Points for STREAMS Device Drivers</h4>
<div class="paragraph">
<p>STREAMS is a separate programming model
for writing a character driver. Devices that receive data
asynchronously, such as terminal and network devices, are suited to a
STREAMS implementation. STREAMS device drivers must provide the loading
and autoconfiguration support described in <a href="#driver-autoconfiguration">Driver
Autoconfiguration</a>. See the STREAMS Programming Guide for additional
information on how to write STREAMS drivers.</p>
</div>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
STREAMS device drivers. For other entry points, see <a href="#entry-points-common-to-all-drivers">Entry
Points Common to All Drivers</a> and <a href="#entry-points-for-character-device-drivers">Entry Points for Character
Device Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Entry Points for STREAMS Drivers</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 11%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>put(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Coordinates the passing of messages from
one queue to the next queue in a stream. Required, except for the side
of the driver that reads data. Additional information: STREAMS
Programming Guide</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>srv(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manipulate messages in a queue. Additional
information: STREAMS Programming Guide</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-memory-mapped-devices"><a class="anchor" href="#entry-points-for-memory-mapped-devices"></a>2.3.5. Entry Points for Memory Mapped Devices</h4>
<div class="paragraph">
<p>For certain
devices, such as frame buffers, providing application programs with
direct access to device memory is more efficient than byte-stream I/O.
Applications can map device memory into their address spaces using the
<code>mmap(2)</code> system call. To support memory mapping, device drivers
implement <code>segmap(9E)</code> and <code>devmap(9E)</code> entry points. For information on
<code>devmap(9E)</code>, see <a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel Memory</a>.
For information on <code>segmap(9E)</code>, see <a href="#drivers-for-character-devices">Drivers for
Character Devices</a>.</p>
</div>
<div class="paragraph">
<p>Drivers that define the <code>devmap(9E)</code> entry point usually do not define
<code>read(9E)</code> and <code>write(9E)</code> entry points, because application programs
perform I/O directly to the devices after calling <code>mmap(2)</code>.</p>
</div>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
character device drivers that use the <code>devmap</code> framework to perform
memory mapping. For other entry points, see <a href="#entry-points-common-to-all-drivers">Entry Points
Common to All Drivers</a> and <a href="#entry-points-for-character-device-drivers">Entry Points for Character Device
Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Entry Points for Character Drivers That Use <code>devmap</code> for Memory Mapping</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 11%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validates and translates virtual mapping for a
memory-mapped device. Additional information: <a href="#exporting-the-mapping">Exporting
the Mapping</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_access(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Notifies drivers when an access is
made to a mapping with validation or protection problems. Additional
information: <a href="#devmap_access-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_contextmgt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performs device context
switching on a mapping. Additional information: <a href="#devmap_contextmgt-entry-point"> Entry
Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_dup(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Duplicates a device mapping. Additional
information: <a href="#devmap_dup-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_map(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates a device mapping. Additional
information: <a href="#devmap_map-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_unmap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cancels a device mapping. Additional
information: <a href="#devmap_unmap-entry-point"> Entry Point</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-the-generic-lan-device-gld-driver"><a class="anchor" href="#entry-points-for-the-generic-lan-device-gld-driver"></a>2.3.6. Entry Points for the Generic LAN Device (GLD) Driver</h4>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
the general LAN driver (GLD). For more information on GLD drivers, see
the <code>gld(9E)</code>, <code>gld(4D)</code>, and <code>gld_mac_info(9S)</code> man pages. For
other entry points, see <a href="#entry-points-common-to-all-drivers">Entry Points Common to All Drivers</a>
and <a href="#entry-points-for-character-device-drivers">Entry Points for Character Device Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Additional Entry Points for the Generic LAN Driver</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 11%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_get_stats(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gathers statistics from private
counters in a generic LAN driver. Updates the <code>gld_stats(9S)</code>
structure. Additional information: <a href="#gldmgetstats-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_intr(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receives calls for potential
interrupts to a generic LAN driver (GLD). Required if <code>gld_intr(9F)</code>
is used as interrupt handler. Additional information: <a href="#gldm_intr-entry-point"> Entry
Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_ioctl(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implements device-specific commands for
a generic LAN driver (GLD). Additional information: <a href="#gldm_ioctl-entry-point"> Entry
Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resets a generic LAN driver (GLD) to
the initial state. Additional information: <a href="#gldm_reset-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_send(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Queues a packet to a generic LAN driver
(GLD) for transmission. Additional information: <a href="#gldm_send-entry-point"> Entry
Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_set_mac_addr(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the physical
address that the generic LAN driver (GLD) uses to receive data.
Additional information: <a href="#gldmsetmac_addr-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_set_multicast(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables and disables
device-level reception of specific multicast addresses for generic LAN
driver (GLD). Additional information: <a href="#gldmsetmulticast-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_set_promiscuous(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables and disables
promiscuous mode for a generic LAN driver (GLD) to receive packets on
the medium. Additional information: <a href="#gldmsetpromiscuous-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_start(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables a generic LAN driver (GLD) to
generate interrupts. Prepares the driver to call <code>gld_recv(9F)</code> to
deliver received data packets. Additional information: <a href="#gldm_start-entry-point">
Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gldm_stop(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disables a generic LAN driver (GLD) from
generating interrupts and from calling <code>gld_recv(9F)</code>. Additional
information: <a href="#gldm_stop-entry-point"> Entry Point</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-scsi-hba-drivers"><a class="anchor" href="#entry-points-for-scsi-hba-drivers"></a>2.3.7. Entry Points for SCSI HBA Drivers</h4>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by
SCSI HBA device drivers. For information on the SCSI HBA transport
structure, see <code>scsi_hba_tran(9S)</code>. For other entry points, see
<a href="#entry-points-common-to-all-drivers">Entry Points Common to All Drivers</a> and <a href="#entry-points-for-character-device-drivers">Entry
Points for Character Device Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Additional Entry Points for SCSI HBA Drivers</caption>
<colgroup>
<col style="width: 29%;">
<col style="width: 12%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_abort(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aborts a specified SCSI command that
has been transported to a SCSI Host Bus Adapter (HBA) driver. Additional
information: <a href="#tran_abort-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_bus_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resets a SCSI bus. Additional
information: <a href="#tranbusreset-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_destroy_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frees resources that are
allocated for a SCSI packet. Additional information: <a href="#trandestroypkt-entry-point">
Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_dmafree(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frees DMA resources that have been
allocated for a SCSI packet. Additional information: <a href="#tran_dmafree-entry-point">
Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_getcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the current value of a specific
capability that is provided by the HBA driver. Additional information:
<a href="#tran_getcap-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_init_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allocate and initialize
resources for a SCSI packet. Additional information:
<a href="#resource-allocation">Resource Allocation</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_quiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stop all activity on a SCSI bus,
typically for dynamic reconfiguration. Additional information:
<a href="#dynamic-reconfiguration">Dynamic Reconfiguration</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resets a SCSI bus or target device.
Additional information: <a href="#tran_reset-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset_notify(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requests notification of a
SCSI target device for a bus reset. Additional information:
<a href="#tranresetnotify-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_setcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the value of a specific
capability that is provided by the SCSI HBA driver. Additional
information: <a href="#tran_setcap-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_start(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requests the transport of a SCSI
command. Additional information: <a href="#tran_start-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_sync_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Synchronizes the view of data by
an HBA driver or device. Additional information: <a href="#transyncpkt-entry-point"> Entry
Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_free(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Requests allocated SCSI HBA resources to be freed on behalf of a target
device. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#trantgtfree-entry-point"> Entry Point</a></p>
</li>
<li>
<p><a href="#transport-structure-cloning">Transport Structure Cloning</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_init(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Requests SCSI HBA resources to be initialized on behalf of a target
device. Additional information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#trantgtinit-entry-point"> Entry Point</a></p>
</li>
<li>
<p><a href="#scsi_device-structure"> Structure</a></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_probe(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Probes a specified target on a
SCSI bus. Additional information: <a href="#trantgtprobe-entry-point"> Entry Point</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_unquiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resumes I/O activity on a SCSI bus
after <code>tran_quiesce(9E)</code> has been called, typically for dynamic
reconfiguration. Additional information: <a href="#dynamic-reconfiguration">Dynamic
Reconfiguration</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="entry-points-for-pc-card-drivers"><a class="anchor" href="#entry-points-for-pc-card-drivers"></a>2.3.8. Entry Points for PC Card Drivers</h4>
<div class="paragraph">
<p>The following table lists additional entry points that can be used by PC
Card device drivers. For other entry points, see <a href="#entry-points-common-to-all-drivers">Entry
Points Common to All Drivers</a> and <a href="#entry-points-for-character-device-drivers">Entry Points for Character
Device Drivers</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Entry Points for PC Card Drivers Only</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 11%;">
<col style="width: 59%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Entry Point</th>
<th class="tableblock halign-left valign-top">Usage</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>csx_event_handler(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handles events for a PC Card
driver. The driver must call the <code>csx_RegisterClient(9F)</code> function
explicitly to set the entry point instead of using a structure field
like <code>cb_ops</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="considerations-in-device-driver-design"><a class="anchor" href="#considerations-in-device-driver-design"></a>2.4. Considerations in Device Driver Design</h3>
<div class="paragraph">
<p>A device driver must be compatible with illumos, both as a consumer and
provider of services. This section discusses the following issues, which
should be considered in device driver design:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#ddidki-facilities">DDI/DKI Facilities</a></p>
</li>
<li>
<p><a href="#driver-context">Driver Context</a></p>
</li>
<li>
<p><a href="#returning-errors">Returning Errors</a></p>
</li>
<li>
<p><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></p>
</li>
<li>
<p><a href="#hotplugging">Hotplugging</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="ddidki-facilities"><a class="anchor" href="#ddidki-facilities"></a>2.4.1. DDI/DKI Facilities</h4>
<div class="paragraph">
<p>The illumos DDI/DKI interfaces are provided for
driver portability. With DDI/DKI, developers can write driver code in a
standard fashion without having to worry about hardware or platform
differences. This section describes aspects of the DDI/DKI interfaces.</p>
</div>
<div class="sect4">
<h5 id="device-ids"><a class="anchor" href="#device-ids"></a>Device IDs</h5>
<div class="paragraph">
<p>The DDI interfaces enable drivers to provide a persistent, unique
identifier for a device. The device ID can be used to identify or locate
a device. The ID is independent of the device&#8217;s name or number
(<code>dev_t</code>). Applications can use the functions defined in
<code>libdevid(3LIB)</code> to read and manipulate the device IDs registered by the
drivers.</p>
</div>
</div>
<div class="sect4">
<h5 id="device-properties"><a class="anchor" href="#device-properties"></a>Device Properties</h5>
<div class="paragraph">
<p>The attributes of a device or device driver are specified by
<em>properties</em>. A property is a name-value pair. The name is a string that
identifies the property with an associated value. Properties can be
defined by the FCode of a self-identifying device, by a hardware
configuration file (see the <code>driver.conf(5)</code> man page), or by the driver
itself using the <code>ddi_prop_update(9F)</code> family of routines.</p>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-handling"><a class="anchor" href="#interrupt-handling"></a>Interrupt Handling</h5>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>The DDI/DKI addresses the following aspects of device interrupt
handling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Registering device interrupts with the system</p>
</li>
<li>
<p>Removing device interrupts</p>
</li>
<li>
<p>Dispatching interrupts to interrupt handlers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Device interrupt sources are contained in
a property called <em>interrupt</em>, which is either provided by the PROM of a
self-identifying device, in a hardware configuration file, or by the
booting system on the x86 platform.</p>
</div>
</div>
<div class="sect4">
<h5 id="callback-functions"><a class="anchor" href="#callback-functions"></a>Callback Functions</h5>
<div class="paragraph">
<p>Certain DDI mechanisms provide a <em>callback</em> mechanism. DDI functions
provide a mechanism for scheduling a callback when a condition is met.
Callback functions can be used for the following typical conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A transfer has completed</p>
</li>
<li>
<p>A resource has become available</p>
</li>
<li>
<p>A time-out period has expired</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Callback functions are somewhat similar to
entry points, for example, interrupt handlers. DDI functions that allow
callbacks expect the callback function to perform certain tasks. In the
case of DMA routines, a callback function must return a value indicating
whether the callback function needs to be rescheduled in case of a
failure.</p>
</div>
<div class="paragraph">
<p>Callback functions execute as a separate interrupt thread. Callbacks
must handle all the usual multithreading issues.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A driver must cancel all scheduled callback functions before detaching a
device.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="software-state-management"><a class="anchor" href="#software-state-management"></a>Software State Management</h5>
<div class="paragraph">
<p>To assist device driver writers in allocating state
structures, the DDI/DKI provides a set of memory management routines
called the <em>software state management routines</em>, also known as the
<em>soft-state routines</em>. These routines dynamically allocate, retrieve,
and destroy memory items of a specified size, and hide the details of
list management. An <em>instance number</em> is used to identify the desired
memory item. This number is typically the instance number assigned by
the system.</p>
</div>
<div class="paragraph">
<p>Routines are provided for the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a driver&#8217;s soft-state list</p>
</li>
<li>
<p>Allocate space for an instance of a driver&#8217;s soft state</p>
</li>
<li>
<p>Retrieve a pointer to an instance of a driver&#8217;s soft state</p>
</li>
<li>
<p>Free the memory for an instance of a driver&#8217;s soft state</p>
</li>
<li>
<p>Finish using a driver&#8217;s soft-state list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#loadable-driver-interfaces">Loadable Driver Interfaces</a> for an example of
how to use these routines.</p>
</div>
</div>
<div class="sect4">
<h5 id="programmed-io-device-access"><a class="anchor" href="#programmed-io-device-access"></a>Programmed I/O Device Access</h5>
<div class="paragraph">
<p>Programmed I/O device access is the act of reading and writing of device
registers or device memory by the host CPU. The illumos DDI provides
interfaces for mapping a device&#8217;s registers or memory by the kernel as
well as interfaces for reading and writing to device memory from the
driver. These interfaces enable drivers to be developed that are
platform and bus independent, by automatically managing any difference
in device and host endianness as well as by enforcing any memory-store
sequence requirements imposed by the device.</p>
</div>
</div>
<div class="sect4">
<h5 id="direct-memory-access-dma"><a class="anchor" href="#direct-memory-access-dma"></a>Direct Memory Access (DMA)</h5>
<div class="paragraph">
<p>The illumos platform defines a high-level, architecture-independent
model for supporting DMA-capable devices. The illumos DDI shields
drivers from platform-specific details. This concept enables a common
driver to run on multiple platforms and architectures.</p>
</div>
</div>
<div class="sect4">
<h5 id="layered-driver-interfaces"><a class="anchor" href="#layered-driver-interfaces"></a>Layered Driver Interfaces</h5>
<div class="paragraph">
<p>The DDI/DKI provides a group of interfaces referred to as layered device
interfaces (LDI). These interfaces enable a device to be accessed from
within the illumos kernel. This capability enables developers to write
applications that observe kernel device usage. For example, both the
<code>prtconf(8)</code> and <code>fuser(8)</code> commands use LDI to enable system
administrators to track aspects of device usage. The LDI is covered in
more detail in <a href="#layered-driver-interface-ldi">Layered Driver Interface (LDI)</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="driver-context"><a class="anchor" href="#driver-context"></a>2.4.2. Driver Context</h4>
<div class="paragraph">
<p>The driver context refers to
the condition under which a driver is currently operating. The context
limits the operations that a driver can perform. The driver context
depends on the executing code that is invoked. Driver code executes in
four contexts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>User context</strong>. A driver entry point has <em>user context</em> when invoked
by a user thread in a synchronous fashion. That is, the user thread
waits for the system to return from the entry point that was invoked.
For example, the <code>read(9E)</code> entry point of the driver has user context
when invoked by a <code>read(2)</code> system call. In this case, the driver has
access to the user area for copying data into and out of the user
thread.</p>
</li>
<li>
<p><strong>Kernel context</strong>. A driver function has <em>kernel context</em> when invoked
by some part of the kernel. In a block device driver, the <code>strategy(9E)</code>
entry point can be called by the <code>pageout</code> daemon to write pages to the
device. Because the page daemon has no relation to the current user
thread, <code>strategy(9E)</code> has kernel context in this case.</p>
</li>
<li>
<p><strong>Interrupt context</strong>. <em>Interrupt context</em> is a more restrictive form of
kernel context. Interrupt context is invoked as a result of the
servicing of an interrupt. Driver interrupt routines operate in
interrupt context with an associated interrupt level. Callback routines
also operate in an interrupt context. See
<a href="#interrupt-handlers">Interrupt Handlers</a> for more information.</p>
</li>
<li>
<p><strong>High-level interrupt context</strong>. <em>High-level interrupt context</em> is a
more restricted form of interrupt context. If
<code>ddi_intr_hilevel(9F)</code> indicates that an interrupt is high
level, the driver interrupt handler runs in high-level interrupt
context. See <a href="#interrupt-handlers">Interrupt Handlers</a> for more
information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The manual pages in section 9F document the allowable contexts for each
function. For example, in kernel context the driver must not call
<code>copyin(9F)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="returning-errors"><a class="anchor" href="#returning-errors"></a>2.4.3. Returning Errors</h4>
<div class="paragraph">
<p>drivers do not usually print messages, except for unexpected errors such
as data corruption. Instead, the driver entry points should return error
codes so that the application can determine how to handle the error. Use
the <code>cmn_err(9F)</code> function to write messages to a system log that
can then be displayed on the console.</p>
</div>
<div class="paragraph">
<p>The format string specifier interpreted by <code>cmn_err(9F)</code> is similar
to the <code>printf(3C)</code> format string specifier, with the addition of the
format <code>%b</code>, which prints bit fields. The first character of the format
string can have a special meaning. Calls to <code>cmn_err(9F)</code> also
specify the message &lt;level&gt;, which indicates the severity label
to be printed. See the <code>cmn_err(9F)</code> man page for more details.</p>
</div>
<div class="paragraph">
<p>The level <code>CE_PANIC</code> has the side effect of crashing the system.
This level should be used only if the system is in such an unstable
state that to continue would cause more problems. The level can also be
used to get a system core dump when debugging. <code>CE_PANIC</code> should not
be used in production device drivers.</p>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-memory-allocation"><a class="anchor" href="#dynamic-memory-allocation"></a>2.4.4. Dynamic Memory Allocation</h4>
<div class="paragraph">
<p>Device drivers must be prepared to
simultaneously handle all attached devices that the drivers claim to
drive. The number of devices that the driver handles should not be
limited. All per-device information must be dynamically allocated.</p>
</div>
<div class="paragraph">
<p><code>void *kmem_alloc(size_t size, int flag);</code></p>
</div>
<div class="paragraph">
<p>standard kernel memory allocation routine is <code>kmem_alloc(9F)</code>.
<code>kmem_alloc</code> is similar to the C library routine <code>malloc(3C)</code>, with
the addition of the <code>flag</code> argument. The <code>flag</code> argument can be either
<code>KM_SLEEP</code> or <code>KM_NOSLEEP</code>, indicating whether the caller is
willing to block if the requested size is not available. If
<code>KM_NOSLEEP</code> is set and memory is not available,
<code>kmem_alloc(9F)</code> returns <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p><code>kmem_zalloc(9F)</code> is similar to <code>kmem_alloc(9F)</code>, but also
clears the contents of the allocated memory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kernel memory is a limited resource, not pageable, and competes with
user applications and the rest of the kernel for physical memory.
Drivers that allocate a large amount of kernel memory can cause system
performance to degrade.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>void kmem_free(void *cp, size_t size);</code></p>
</div>
<div class="paragraph">
<p>Memory allocated by <code>kmem_alloc(9F)</code> or by <code>kmem_zalloc(9F)</code> is
returned to the system with <code>kmem_free(9F)</code>. <code>kmem_free</code> is
similar to the C library routine <code>free(3C)</code>, with the addition of the
<code>size</code> argument. Drivers <em>must</em> keep track of the size of each allocated
object in order to call <code>kmem_free(9F)</code> later.</p>
</div>
</div>
<div class="sect3">
<h4 id="hotplugging"><a class="anchor" href="#hotplugging"></a>2.4.5. Hotplugging</h4>
<div class="paragraph">
<p>hot-plug</p>
</div>
<div class="paragraph">
<p>hotpluggable drivers</p>
</div>
<div class="paragraph">
<p>This manual does not highlight hotplugging
information. If you follow the rules and suggestions for writing device
drivers given in this book, your driver should be able to handle
hotplugging. In particular, make sure that both autoconfiguration (see
<a href="#driver-autoconfiguration">Driver Autoconfiguration</a>) and <code>detach(9E)</code> work
correctly in your driver. In addition, if you are designing a driver
that uses power management, you should follow the information given in
<a href="#power-management">Power Management</a>. SCSI HBA drivers might need to
add a <code>cb_ops</code> structure to their <code>dev_ops</code> structure (see
<a href="#scsi-host-bus-adapter-drivers">SCSI Host Bus Adapter Drivers</a>) to take advantage of
hotplugging capabilities.</p>
</div>
<div class="paragraph">
<p>Previous versions of the Solaris OS required hotpluggable drivers to
include a DT_HOTPLUG property, but this property is no longer
required. Driver writers are free, however, to include and use the
DT_HOTPLUG property as they see fit.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="illumos-kernel-and-device-tree"><a class="anchor" href="#illumos-kernel-and-device-tree"></a>2.5. illumos Kernel and Device Tree</h3>
<div class="paragraph">
<p>A device driver needs to work transparently as an integral part of the
operating system. Understanding how the kernel works is a prerequisite
for learning about device drivers. This chapter provides an overview of
the illumos kernel and device tree. For an overview of how device
drivers work, see <a href="#overview-of-illumos-device-drivers">Overview of illumos Device Drivers</a>.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#what-is-the-kernel">What Is the Kernel?</a></p>
</li>
<li>
<p><a href="#multithreaded-execution-environment">Multithreaded Execution Environment</a></p>
</li>
<li>
<p><a href="#virtual-memory">Virtual Memory</a></p>
</li>
<li>
<p><a href="#devices-as-special-files">Devices as Special Files</a></p>
</li>
<li>
<p><a href="#ddidki-interfaces">DDI/DKI Interfaces</a></p>
</li>
<li>
<p><a href="#device-tree-components">Device Tree Components</a></p>
</li>
<li>
<p><a href="#displaying-the-device-tree">Displaying the Device Tree</a></p>
</li>
<li>
<p><a href="#binding-a-driver-to-a-device">Binding a Driver to a Device</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="what-is-the-kernel"><a class="anchor" href="#what-is-the-kernel"></a>2.6. What Is the Kernel?</h3>
<div class="paragraph">
<p>The illumos kernel is a program that
manages system resources. The kernel insulates applications from the
system hardware and provides them with essential system services such as
input/output (I/O) management, virtual memory, and scheduling. The
kernel consists of object modules that are dynamically loaded into
memory when needed.</p>
</div>
<div class="paragraph">
<p>The illumos kernel can be divided logically into two parts: the first
part, referred to as the <em>kernel</em>, manages file systems, scheduling, and
virtual memory. The second part, referred to as the <em>I/O subsystem</em>,
manages the physical components.</p>
</div>
<div class="paragraph">
<p>The kernel provides a set
of interfaces for applications to use that are accessible through
<em>system calls</em>. System calls are documented in section 2 of the
Reference Manual Collection (see <code>Intro(2)</code>). Some system calls are used
to invoke device drivers to perform I/O. <em>Device drivers</em> are loadable
kernel modules that manage data transfers while insulating the rest of
the kernel from the device hardware. To be compatible with the operating
system, device drivers need to be able to accommodate such features as
multithreading, virtual memory addressing, and both 32-bit and 64-bit
operation.</p>
</div>
<div class="paragraph">
<p>The following figure illustrates the kernel. The kernel modules handle
system calls from application programs. The I/O modules communicate with
hardware.</p>
</div>
<div id="kernelovr-fig-19" class="imageblock">
<div class="content">
<img src="figures/kernelovr-arch.png" alt="Diagram shows calls from user-level applications to specific kernel-level modules" width="and calls between drivers and other modules to devices.">
</div>
<div class="title">Figure 1. illumos Kernel</div>
</div>
<div class="paragraph">
<p>The kernel provides access to device drivers through the following
features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Device-to-driver mapping</strong>. The kernel
maintains the <em>device tree</em>. Each node in the tree represents a virtual
or a physical device. The kernel binds each node to a driver by matching
the device node name with the set of drivers installed in the system.
The device is made accessible to applications only if there is a driver
binding.</p>
</li>
<li>
<p><strong>DDI/DKI interfaces</strong>. DDI/DKI (Device
Driver Interface/Driver-Kernel Interface) interfaces standardize
interactions between the driver and the kernel, the device hardware, and
the boot/configuration software. These interfaces keep the driver
independent from the kernel and improve the driver&#8217;s portability across
successive releases of the operating system on a particular machine.</p>
</li>
<li>
<p><strong>LDI</strong>. The LDI (Layered Driver Interface) is an extension of the
DDI/DKI. The LDI enables a kernel module to access other devices in the
system. The LDI also enables you to determine which devices are
currently being used by the kernel. See <a href="#layered-driver-interface-ldi">Layered Driver
Interface (LDI)</a>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="multithreaded-execution-environment"><a class="anchor" href="#multithreaded-execution-environment"></a>2.6.1. Multithreaded Execution Environment</h4>
<div class="paragraph">
<p>The illumos kernel is multithreaded. On a multiprocessor
machine, multiple kernel threads can be running kernel code, and can do
so concurrently. Kernel threads can also be preempted by other kernel
threads at any time.</p>
</div>
<div class="paragraph">
<p>The multithreading of the kernel imposes some additional restrictions on
device drivers. For more information on multithreading considerations,
see <a href="#multithreading">Multithreading</a>. Device drivers must be coded to run
as needed at the request of many different threads. For each thread, a
driver must handle contention problems from overlapping I/O requests.</p>
</div>
</div>
<div class="sect3">
<h4 id="virtual-memory"><a class="anchor" href="#virtual-memory"></a>2.6.2. Virtual Memory</h4>
<div class="paragraph">
<p>A complete overview of the illumos virtual memory system is beyond the
scope of this book, but two virtual memory terms of special importance
are used when discussing device drivers: virtual address and address
space.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Virtual
address</strong>. A <em>virtual address</em> is an address that is mapped by the memory
management unit (MMU) to a physical hardware address. All addresses
directly accessible by the driver are kernel virtual addresses. Kernel
virtual addresses refer to the <em>kernel address space</em>.</p>
</li>
<li>
<p><strong>Address
space</strong>. An <em>address space</em> is a set of <em>virtual address segments</em>. Each
segment is a contiguous range of virtual addresses. Each user process
has an address space called the <em>user address space</em>. The kernel has its
own address space, called the <em>kernel address space</em>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="devices-as-special-files"><a class="anchor" href="#devices-as-special-files"></a>2.6.3. Devices as Special Files</h4>
<div class="paragraph">
<p>Devices are represented in
the file system by <em>special files</em>. In illumos, these files reside in
the <code>/devices</code> directory hierarchy.</p>
</div>
<div class="paragraph">
<p>Special files can be of type <em>block</em> or <em>character</em>. The type indicates
which kind of device driver operates the device. Drivers can be
implemented to operate on both types. For example, disk drivers export a
character interface for use by the <code>fsck(1)</code> and <code>mkfs(1)</code> utilities,
and a block interface for use by the file system.</p>
</div>
<div class="paragraph">
<p>with each special file is a <em>device number</em> (<code>dev_t</code>). A device
number consists of a <em>major number</em> and a <em>minor number</em>. The <em>major</em>
number identifies the device driver associated with the special file.
The <em>minor</em> number is created and used by the device driver to further
identify the special file. Usually, the minor number is an encoding that
is used to identify which device instance the driver should access and
which type of access should be performed. For example, the minor number
can identify a tape device used for backup and can specify that the tape
needs to be rewound when the backup operation is complete.</p>
</div>
</div>
<div class="sect3">
<h4 id="ddidki-interfaces"><a class="anchor" href="#ddidki-interfaces"></a>2.6.4. DDI/DKI Interfaces</h4>
<div class="paragraph">
<p>In System V Release 4 (SVR4), the interface between device drivers and
the rest of the UNIX kernel was standardized as the DDI/DKI. The DDI/DKI
is documented in section 9 of the Reference Manual Collection. Section
9E documents driver entry points, section 9F documents driver-callable
functions, and section 9S documents kernel data structures used by
device drivers. See <code>Intro(9E)</code>, <code>Intro(9F)</code>, and <code>Intro(9S)</code>.</p>
</div>
<div class="paragraph">
<p>DDI/DKI is intended to standardize and document all interfaces between
device drivers and the rest of the kernel. In addition, the DDI/DKI
enables source and binary compatibility for drivers on any machine that
runs illumos, regardless of the processor architecture, whether SPARC or
x86. Drivers that use only kernel facilities that are part of the
DDI/DKI are known as <em>DDI/DKI-compliant device drivers</em>.</p>
</div>
<div class="paragraph">
<p>The DDI/DKI enables you to write platform-independent device drivers for
any machine that runs illumos. These binary-compatible drivers enable
you to more easily integrate third-party hardware and software into any
machine that runs illumos. The DDI/DKI is architecture independent,
which enables the same driver to work across a diverse set of machine
architectures.</p>
</div>
<div class="paragraph">
<p>Platform independence is accomplished by the design of DDI in the
following areas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dynamic loading and unloading of modules</p>
</li>
<li>
<p>Power management</p>
</li>
<li>
<p>Interrupt handling</p>
</li>
<li>
<p>Accessing the device space from the kernel or a user process, that is,
register mapping and memory mapping</p>
</li>
<li>
<p>Accessing kernel or user process space from the device using DMA</p>
</li>
<li>
<p>Managing device properties</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="overview-of-the-device-tree"><a class="anchor" href="#overview-of-the-device-tree"></a>2.7. Overview of the Device Tree</h3>
<div class="paragraph">
<p>Devices in illumos are represented as a tree of interconnected device
information nodes. The device tree describes the configuration of loaded
devices for a particular machine.</p>
</div>
<div class="sect3">
<h4 id="device-tree-components"><a class="anchor" href="#device-tree-components"></a>2.7.1. Device Tree Components</h4>
<div class="paragraph">
<p>system builds a tree structure that contains information about the
devices connected to the machine at boot time. The device tree can also
be modified by dynamic reconfiguration operations while the system is in
normal operation. The tree begins at the root device node, which
represents the platform.</p>
</div>
<div class="paragraph">
<p>Below the root node are the branches of the device tree. A branch
consists of one or more bus nexus devices and a terminating leaf device.</p>
</div>
<div class="paragraph">
<p>A <em>bus nexus device</em> provides bus mapping and translation services to
subordinate devices in the device tree. PCI - PCI bridges, PCMCIA
adapters, and SCSI HBAs are all examples of nexus devices. The
discussion of writing drivers for nexus devices is limited to the
development of SCSI HBA drivers (see <a href="#scsi-host-bus-adapter-drivers">SCSI Host Bus
Adapter Drivers</a>).</p>
</div>
<div class="paragraph">
<p><em>Leaf devices</em> are typically peripheral devices such as disks, tapes,
network adapters, frame buffers, and so forth. Leaf device drivers
export the traditional character driver interfaces and block driver
interfaces. The interfaces enable user processes to read data from and
write data to either storage or communication devices.</p>
</div>
<div class="paragraph">
<p>The system goes through the following steps to build the tree:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The CPU is initialized and searches for firmware.</p>
</li>
<li>
<p>The main firmware (OpenBoot, Basic Input/Output System (BIOS), or
<code>Bootconf</code>) initializes and creates the device tree with known or
self-identifying hardware.</p>
</li>
<li>
<p>When the main firmware finds compatible firmware on a device, the main
firmware initializes the device and retrieves the device&#8217;s properties.</p>
</li>
<li>
<p>The firmware locates and boots the operating system.</p>
</li>
<li>
<p>The kernel starts at the root node of the tree, searches for a
matching device driver, and binds that driver to the device.</p>
</li>
<li>
<p>If the device is a nexus, the kernel looks for child devices that have
not been detected by the firmware. The kernel adds any child devices to
the tree below the nexus node.</p>
</li>
<li>
<p>The kernel repeats the process from Step 5 until no further device
nodes need to be created.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each driver exports a device operations structure <code>dev_ops(9S)</code> to
define the operations that the device driver can perform. The device
operations structure contains function pointers for generic operations
such as <code>attach(9E)</code>, <code>detach(9E)</code>, and <code>getinfo(9E)</code>. The structure
also contains a pointer to a set of operations specific to bus nexus
drivers and a pointer to a set of operations specific to leaf drivers.</p>
</div>
<div class="paragraph">
<p>The tree structure creates a parent-child relationship between nodes.
This parent-child relationship is the key to architectural independence.
When a leaf or bus nexus driver requires a service that is
architecturally dependent in nature, that driver requests its parent to
provide the service. This approach enables drivers to function
regardless of the architecture of the machine or the processor. A
typical device tree is shown in the following figure.</p>
</div>
<div id="kernelovr-fig-9" class="imageblock">
<div class="content">
<img src="figures/kernelovr-devtree.png" alt="Diagram shows leaves and nodes in a typical device tree.">
</div>
<div class="title">Figure 2. Example Device Tree</div>
</div>
<div class="paragraph">
<p>The nexus nodes can have one or more children. The leaf nodes represent
individual devices.</p>
</div>
</div>
<div class="sect3">
<h4 id="displaying-the-device-tree"><a class="anchor" href="#displaying-the-device-tree"></a>2.7.2. Displaying the Device Tree</h4>
<div class="paragraph">
<p>The device tree can be displayed in three ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>libdevinfo</code> library provides interfaces to access the contents of
the device tree programmatically.</p>
</li>
<li>
<p>The <code>prtconf(8)</code> command displays the complete contents of the device
tree.</p>
</li>
<li>
<p>The <code>/devices</code> hierarchy is a representation of the device tree. Use
the <code>ls(1)</code> command to view the hierarchy.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>/devices</code> displays only devices that have drivers configured into the
system. The <code>prtconf(8)</code> command shows all device nodes regardless of
whether a driver for the device exists on the system.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="libdevinfo-library"><a class="anchor" href="#libdevinfo-library"></a><code>libdevinfo</code> Library</h5>
<div class="paragraph">
<p>The <code>libdevinfo</code> library provides interfaces for
accessing all public device configuration data. See the
<code>libdevinfo(3LIB)</code> man page for a list of interfaces.</p>
</div>
</div>
<div class="sect4">
<h5 id="prtconf-command"><a class="anchor" href="#prtconf-command"></a><code>prtconf</code> Command</h5>
<div class="paragraph">
<p>The following excerpted <code>prtconf(8)</code> command example
displays all the devices in the system.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>System Configuration:  Sun Microsystems  sun4u
Memory size: 128 Megabytes
System Peripherals (Software Nodes):

SUNW,Ultra-5_10
    packages (driver not attached)
        terminal-emulator (driver not attached)
        deblocker (driver not attached)
        obp-tftp (driver not attached)
        disk-label (driver not attached)
        SUNW,builtin-drivers (driver not attached)
        sun-keyboard (driver not attached)
        ufs-file-system (driver not attached)
    chosen (driver not attached)
    openprom (driver not attached)
        client-services (driver not attached)
    options, instance #0
    aliases (driver not attached)
    memory (driver not attached)
    virtual-memory (driver not attached)
    pci, instance #0
        pci, instance #0
            ebus, instance #0
                auxio (driver not attached)
                power, instance #0
                SUNW,pll (driver not attached)
                se, instance #0
                su, instance #0
                su, instance #1
                ecpp (driver not attached)
                fdthree, instance #0
                eeprom (driver not attached)
                flashprom (driver not attached)
                SUNW,CS4231 (driver not attached)
            network, instance #0
            SUNW,m64B (driver not attached)
            ide, instance #0
                disk (driver not attached)
                cdrom (driver not attached)
                dad, instance #0
                sd, instance #15
        pci, instance #1
            pci, instance #0
                pci108e,1000 (driver not attached)
                SUNW,hme, instance #1
                SUNW,isptwo, instance #0
                    sd (driver not attached)
                    st (driver not attached)
                    sd, instance #0 (driver not attached)
                    sd, instance #1 (driver not attached)
                    sd, instance #2 (driver not attached)
                    ...
    SUNW,UltraSPARC-IIi (driver not attached)
    SUNW,ffb, instance #0
    pseudo, instance #0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="devices-directory"><a class="anchor" href="#devices-directory"></a><code>/devices</code> Directory</h5>
<div class="paragraph">
<p>The <code>/devices</code> hierarchy provides a namespace that
represents the device tree. Following is an abbreviated listing of the
<code>/devices</code> namespace. The sample output corresponds to the example
device tree and <code>prtconf(8)</code> output shown previously.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/devices
/devices/pseudo
/devices/pci@1f,0:devctl
/devices/SUNW,ffb@1e,0:ffb0
/devices/pci@1f,0
/devices/pci@1f,0/pci@1,1
/devices/pci@1f,0/pci@1,1/SUNW,m64B@2:m640
/devices/pci@1f,0/pci@1,1/ide@3:devctl
/devices/pci@1f,0/pci@1,1/ide@3:scsi
/devices/pci@1f,0/pci@1,1/ebus@1
/devices/pci@1f,0/pci@1,1/ebus@1/power@14,724000:power_button
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:a
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:b
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:0,hdlc
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:1,hdlc
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:a,cu
/devices/pci@1f,0/pci@1,1/ebus@1/se@14,400000:b,cu
/devices/pci@1f,0/pci@1,1/ebus@1/ecpp@14,3043bc:ecpp0
/devices/pci@1f,0/pci@1,1/ebus@1/fdthree@14,3023f0:a
/devices/pci@1f,0/pci@1,1/ebus@1/fdthree@14,3023f0:a,raw
/devices/pci@1f,0/pci@1,1/ebus@1/SUNW,CS4231@14,200000:sound,audio
/devices/pci@1f,0/pci@1,1/ebus@1/SUNW,CS4231@14,200000:sound,audioctl
/devices/pci@1f,0/pci@1,1/ide@3
/devices/pci@1f,0/pci@1,1/ide@3/sd@2,0:a
/devices/pci@1f,0/pci@1,1/ide@3/sd@2,0:a,raw
/devices/pci@1f,0/pci@1,1/ide@3/dad@0,0:a
/devices/pci@1f,0/pci@1,1/ide@3/dad@0,0:a,raw
/devices/pci@1f,0/pci@1
/devices/pci@1f,0/pci@1/pci@2
/devices/pci@1f,0/pci@1/pci@2/SUNW,isptwo@4:devctl
/devices/pci@1f,0/pci@1/pci@2/SUNW,isptwo@4:scsi</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="binding-a-driver-to-a-device"><a class="anchor" href="#binding-a-driver-to-a-device"></a>2.7.3. Binding a Driver to a Device</h4>
<div class="paragraph">
<p>In addition
to constructing the device tree, the kernel determines the drivers that
are used to manage the devices.</p>
</div>
<div class="paragraph">
<p>Binding a driver to a device refers to
the process by which the system selects a driver to manage a particular
device. The binding name is the name that links a driver to a unique
device node in the device information tree. For each device in the
device tree, the system attempts to choose a driver from a list of
installed drivers.</p>
</div>
<div class="paragraph">
<p>Each device node has an
associated <em>name</em> property. This property can be assigned either from an
external agent, such as the PROM, during system boot or from a
<code>driver.conf</code> configuration file. In any case, the <code>name</code> property
represents the <code>node name</code> assigned to a device in the device tree. The
<code>node name</code> is the name visible in <code>/devices</code> and listed in the
<code>prtconf(8)</code> output.</p>
</div>
<div id="kernelovr-fig-15" class="imageblock">
<div class="content">
<img src="figures/kernelovr-devnodenames.png" alt="Diagram shows a simple example of device node names.">
</div>
<div class="title">Figure 3. Device Node Names</div>
</div>
<div class="paragraph">
<p>A device node can have an associated <em>compatible</em>
property as well. The <em>compatible</em> property contains an ordered list of
one or more possible driver names or driver aliases for the device.</p>
</div>
<div class="paragraph">
<p>The system uses both the <em>compatible</em> and the <em>name</em> properties to
select a driver for the device. The system first attempts to match the
contents of the <em>compatible</em> property, if the <em>compatible</em> property
exists, to a driver on the system. Beginning with the first driver name
on the <em>compatible</em> property list, the system attempts to match the
driver name to a known driver on the system. Each entry on the list is
processed until the system either finds a match or reaches the end of
the list.</p>
</div>
<div class="paragraph">
<p>If the contents of either the <em>name</em> property or the <em>compatible</em>
property match a driver on the system, then that driver is bound to the
device node. If no match is found, no driver is bound to the device
node.</p>
</div>
<div class="sect4">
<h5 id="generic-device-names"><a class="anchor" href="#generic-device-names"></a>Generic Device Names</h5>
<div class="paragraph">
<p>Some devices specify a <em>generic</em> device name as the
value for the <em>name</em> property. Generic device names describe the
function of a device without actually identifying a specific driver for
the device. For example, a SCSI host bus adapter might have a generic
device name of <code>scsi</code>. An Ethernet device might have a generic device
name of <code>ethernet</code>.</p>
</div>
<div class="paragraph">
<p>The <em>compatible</em> property enables the system to determine alternate
driver names for devices with a generic device name, for example, <code>glm</code>
for <code>scsi</code> HBA device drivers or <code>hme</code> for <code>ethernet</code> device drivers.</p>
</div>
<div class="paragraph">
<p>Devices with generic device names are required to supply a <em>compatible</em>
property.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For a complete description of <em>generic device names</em>, see the IEEE 1275
Open Firmware Boot Standard.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following figure shows a device node with a specific device name.
The driver binding name <code>SUNW,ffb</code> is the same name as the device node
name.</p>
</div>
<div id="kernelovr-fig-17" class="imageblock">
<div class="content">
<img src="figures/kernelovr-specdevnodebinding.png" alt="Diagram shows a device node using a specific device name: SUNW" width="ffb.">
</div>
<div class="title">Figure 4. Specific Driver Node Binding</div>
</div>
<div class="paragraph">
<p>The following figure shows a device node with the generic device name
<code>display</code>. The driver binding name <code>SUNW,ffb</code> is the first name on the
<em>compatible</em> property driver list that matches a driver on the system
driver list. In this case, <code>display</code> is a generic device name for frame
buffers.</p>
</div>
<div id="kernelovr-fig-18" class="imageblock">
<div class="content">
<img src="figures/kernelovr-gendevnodebinding.png" alt="Diagram shows a device node using a generic device name: display.">
</div>
<div class="title">Figure 5. Generic Driver Node Binding</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multithreading"><a class="anchor" href="#multithreading"></a>2.8. Multithreading</h3>
<div class="paragraph">
<p>This chapter describes the locking primitives and thread synchronization
mechanisms of the illumos multithreaded kernel. You should design device
drivers to take advantage of multithreading. This chapter provides
information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#locking-primitives">Locking Primitives</a></p>
</li>
<li>
<p><a href="#thread-synchronization">Thread Synchronization</a></p>
</li>
<li>
<p><a href="#choosing-a-locking-scheme">Choosing a Locking Scheme</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="locking-primitives"><a class="anchor" href="#locking-primitives"></a>2.9. Locking Primitives</h3>
<div class="paragraph">
<p>traditional UNIX systems, every section of kernel code terminates either
through an explicit call to <code>sleep(1)</code> to give up the processor or
through a hardware interrupt. illumos operates differently. A kernel
thread can be preempted at any time to run another thread. Because all
kernel threads share kernel address space and often need to read and
modify the same data, the kernel provides a number of locking primitives
to prevent threads from corrupting shared data. These mechanisms include
mutual exclusion locks, which are also known as <em>mutexes</em>,
readers/writer locks, and semaphores.</p>
</div>
<div class="sect3">
<h4 id="storage-classes-of-driver-data"><a class="anchor" href="#storage-classes-of-driver-data"></a>2.9.1. Storage Classes of Driver Data</h4>
<div class="paragraph">
<p>The storage class of data is a
guide to whether the driver might need to take explicit steps to control
access to the data. The three data storage classes are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Automatic (stack) data</strong>. Every thread has a private stack, so drivers
never need to lock automatic variables.</p>
</li>
<li>
<p><strong>Global static data</strong>. Global static data can be shared by any number
of threads in the driver. The driver might need to lock this type of
data at times.</p>
</li>
<li>
<p><strong>Kernel heap data</strong>. Any number of threads in the driver can share
kernel heap data, such as data allocated by <code>kmem_alloc(9F)</code>. The
driver needs to protect shared data at all times.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mutual-exclusion-locks"><a class="anchor" href="#mutual-exclusion-locks"></a>2.9.2. Mutual-Exclusion Locks</h4>
<div class="paragraph">
<p>thread synchronization</p>
</div>
<div class="paragraph">
<p>mutex locks</p>
</div>
<div class="paragraph">
<p>mutual-exclusion locks</p>
</div>
<div class="paragraph">
<p>A mutual-exclusion lock, or <em>mutex</em>, is
usually associated with a set of data and regulates access to that data.
Mutexes provide a way to allow only one thread at a time access to that
data. The mutex functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mutex_destroy(9F)</code></dt>
<dd>
<p>Releases any associated storage.</p>
</dd>
<dt class="hdlist1"><code>mutex_enter(9F)</code></dt>
<dd>
<p>Acquires a mutex.</p>
</dd>
<dt class="hdlist1"><code>mutex_exit(9F)</code></dt>
<dd>
<p>Releases a mutex.</p>
</dd>
<dt class="hdlist1"><code>mutex_init(9F)</code></dt>
<dd>
<p>Initializes a mutex.</p>
</dd>
<dt class="hdlist1"><code>mutex_owned(9F)</code></dt>
<dd>
<p>Tests to determine whether the mutex is held by the current thread. To
be used in <code>ASSERT(9F)</code> only.</p>
</dd>
<dt class="hdlist1"><code>mutex_tryenter(9F)</code></dt>
<dd>
<p>Acquires a mutex if available, but does not block.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="setting-up-mutexes"><a class="anchor" href="#setting-up-mutexes"></a>Setting Up Mutexes</h5>
<div class="paragraph">
<p>Device drivers usually
allocate a mutex for each driver data structure. The mutex is typically
a field in the structure of type <code>kmutex_t</code>. <code>mutex_init(9F)</code> is
called to prepare the mutex for use. This call is usually made at
<code>attach(9E)</code> time for per-device mutexes and <code>_init(9E)</code> time for
global driver mutexes.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct xxstate *xsp;
/* ... */
mutex_init(&amp;xsp-&gt;mu, NULL, MUTEX_DRIVER, NULL);
/* ... */</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a more complete example of mutex initialization, see
<a href="#driver-autoconfiguration">Driver Autoconfiguration</a>.</p>
</div>
<div class="paragraph">
<p>The driver must destroy the mutex with <code>mutex_destroy(9F)</code> before
being unloaded. Destroying the mutex is usually done at <code>detach(9E)</code>
time for per-device mutexes and <code>_fini(9E)</code> time for global driver
mutexes.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-mutexes"><a class="anchor" href="#using-mutexes"></a>Using Mutexes</h5>
<div class="paragraph">
<p>Every section of the driver code that needs to read or write the shared
data structure must do the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Acquire the mutex</p>
</li>
<li>
<p>Access the data</p>
</li>
<li>
<p>Release the mutex</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The scope of a mutex, that is, the data the mutex protects, is entirely
up to the programmer. A mutex protects a data structure only if every
code path that accesses the data structure does so while holding the
mutex.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="readerswriter-locks"><a class="anchor" href="#readerswriter-locks"></a>2.9.3. Readers/Writer Locks</h4>
<div class="paragraph">
<p>thread synchronization</p>
</div>
<div class="paragraph">
<p>readers/writer locks</p>
</div>
<div class="paragraph">
<p>A <em>readers/writer lock</em>
regulates access to a set of data. The readers/writer lock is so called
because many threads can hold the lock simultaneously for reading, but
only one thread can hold the lock for writing.</p>
</div>
<div class="paragraph">
<p>Most device drivers do not use readers/writer locks. These locks are
slower than mutexes. The locks provide a performance gain only when they
protect commonly read data that is not frequently written. In this case,
contention for a mutex could become a bottleneck, so using a
readers/writer lock might be more efficient. The readers/writer
functions are summarized in the following table. See the <code>rwlock(9F)</code>
man page for detailed information. The readers/writer lock functions
are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>rw_destroy(9F)</code></dt>
<dd>
<p>Destroys a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_downgrade(9F)</code></dt>
<dd>
<p>Downgrades a readers/writer lock holder from writer to reader</p>
</dd>
<dt class="hdlist1"><code>rw_enter(9F)</code></dt>
<dd>
<p>Acquires a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_exit(9F)</code></dt>
<dd>
<p>Releases a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_init(9F)</code></dt>
<dd>
<p>Initializes a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_read_locked(9F)</code></dt>
<dd>
<p>Determines whether a readers/writer lock is held for read or write</p>
</dd>
<dt class="hdlist1"><code>rw_tryenter(9F)</code></dt>
<dd>
<p>Attempts to acquire a readers/writer lock without waiting</p>
</dd>
<dt class="hdlist1"><code>rw_tryupgrade(9F)</code></dt>
<dd>
<p>Attempts to upgrade readers/writer lock holder from reader to writer</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="semaphores"><a class="anchor" href="#semaphores"></a>2.9.4. Semaphores</h4>
<div class="paragraph">
<p>Counting semaphores are available as an alternative primitive for
managing threads within device drivers. See the <code>semaphore(9F)</code> man page
for more information. The semaphore functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>sema_destroy(9F)</code></dt>
<dd>
<p>Destroys a semaphore.</p>
</dd>
<dt class="hdlist1"><code>sema_init(9F)</code></dt>
<dd>
<p>Initialize a semaphore.</p>
</dd>
<dt class="hdlist1"><code>sema_p(9F)</code></dt>
<dd>
<p>Decrement semaphore and possibly block.</p>
</dd>
<dt class="hdlist1"><code>sema_p_sig(9F)</code></dt>
<dd>
<p>Decrement semaphore but do not block if signal is pending. See
<a href="#threads-unable-to-receive-signals">Threads Unable to Receive Signals</a>.</p>
</dd>
<dt class="hdlist1"><code>sema_tryp(9F)</code></dt>
<dd>
<p>Attempt to decrement semaphore, but do not block.</p>
</dd>
<dt class="hdlist1"><code>sema_v(9F)</code></dt>
<dd>
<p>Increment semaphore and possibly unblock waiter.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="thread-synchronization"><a class="anchor" href="#thread-synchronization"></a>2.10. Thread Synchronization</h3>
<div class="paragraph">
<p>In addition to protecting shared data, drivers often need to synchronize
execution among multiple threads.</p>
</div>
<div class="sect3">
<h4 id="condition-variables-in-thread-synchronization"><a class="anchor" href="#condition-variables-in-thread-synchronization"></a>2.10.1. Condition Variables in Thread Synchronization</h4>
<div class="paragraph">
<p>thread synchronization</p>
</div>
<div class="paragraph">
<p>condition variables</p>
</div>
<div class="paragraph">
<p>Condition variables
are a standard form of thread synchronization. They are designed to be
used with mutexes. The associated mutex is used to ensure that a
condition can be checked atomically, and that the thread can block on
the associated condition variable without missing either a change to the
condition or a signal that the condition has changed.</p>
</div>
<div class="paragraph">
<p>The <code>condvar(9F)</code> functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>cv_broadcast(9F)</code></dt>
<dd>
<p>Signals all threads waiting on the condition variable.</p>
</dd>
<dt class="hdlist1"><code>cv_destroy(9F)</code></dt>
<dd>
<p>Destroys a condition variable.</p>
</dd>
<dt class="hdlist1"><code>cv_init(9F)</code></dt>
<dd>
<p>Initializes a condition variable.</p>
</dd>
<dt class="hdlist1"><code>cv_signal(9F)</code></dt>
<dd>
<p>Signals one thread waiting on the condition variable.</p>
</dd>
<dt class="hdlist1"><code>cv_timedwait(9F)</code></dt>
<dd>
<p>Waits for condition, time-out, or signal. See <a href="#threads-unable-to-receive-signals">Threads
Unable to Receive Signals</a>.</p>
</dd>
<dt class="hdlist1"><code>cv_timedwait_sig(9F)</code></dt>
<dd>
<p>Waits for condition or time-out.</p>
</dd>
<dt class="hdlist1"><code>cv_wait(9F)</code></dt>
<dd>
<p>Waits for condition.</p>
</dd>
<dt class="hdlist1"><code>cv_wait_sig(9F)</code></dt>
<dd>
<p>Waits for condition or return zero on receipt of a signal. See
<a href="#threads-unable-to-receive-signals">Threads Unable to Receive Signals</a>.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="initializing-condition-variables"><a class="anchor" href="#initializing-condition-variables"></a>Initializing Condition Variables</h5>
<div class="paragraph">
<p>a condition variable of type <code>kcondvar_t</code> for each condition.
Usually, the condition variables are declared in the driver&#8217;s soft-state
structure. Use <code>cv_init(9F)</code> to initialize each condition variable.
Similar to mutexes, condition variables are usually initialized at
<code>attach(9E)</code> time. A typical example of initializing a condition
variable is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cv_init(&amp;xsp-&gt;cv, NULL, CV_DRIVER, NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>For a more complete example of condition
variable initialization, see <a href="#driver-autoconfiguration">Driver
Autoconfiguration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="waiting-for-the-condition"><a class="anchor" href="#waiting-for-the-condition"></a>Waiting for the Condition</h5>
<div class="paragraph">
<p>To use condition variables, follow these steps in the code path waiting
for the condition:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acquire the mutex guarding the condition.</p>
</li>
<li>
<p>Test the condition.</p>
</li>
<li>
<p>If the test results do not allow the thread
to continue, use <code>cv_wait(9F)</code> to block the current thread on the
condition. The <code>cv_wait(9F)</code> function releases the mutex before
blocking the thread and reacquires the mutex before returning. On return
from <code>cv_wait(9F)</code>, repeat the test.</p>
</li>
<li>
<p>After the test allows the thread to continue, set the condition to its
new value. For example, set a device flag to busy.</p>
</li>
<li>
<p>Release the mutex.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="signaling-the-condition"><a class="anchor" href="#signaling-the-condition"></a>Signaling the Condition</h5>
<div class="paragraph">
<p>Follow these steps in the code path to signal the condition:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acquire the mutex guarding the condition.</p>
</li>
<li>
<p>Set the condition.</p>
</li>
<li>
<p>Signal the blocked thread with
<code>cv_broadcast(9F)</code>.</p>
</li>
<li>
<p>Release the mutex.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example uses a busy flag along with mutex and condition
variables to force the <code>read(9E)</code> routine to wait until the device is no
longer busy before starting a transfer.</p>
</div>
<div id="mt-28544" class="paragraph">
<p>Using Mutexes and Condition Variables</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxread(dev_t dev, struct uio *uiop, cred_t *credp)
{
        struct xxstate *xsp;
        /* ... */
        mutex_enter(&amp;xsp-&gt;mu);
        while (xsp-&gt;busy)
                cv_wait(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu);
        xsp-&gt;busy = 1;
        mutex_exit(&amp;xsp-&gt;mu);
        /* perform the data access */
}

static uint_t
xxintr(caddr_t arg)
{
        struct xxstate *xsp = (struct xxstate *)arg;
        mutex_enter(&amp;xsp-&gt;mu);
        xsp-&gt;busy = 0;
        cv_broadcast(&amp;xsp-&gt;cv);
        mutex_exit(&amp;xsp-&gt;mu);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cvwait-and-cvtimedwait-functions"><a class="anchor" href="#cvwait-and-cvtimedwait-functions"></a>2.10.2. <code>cv_wait</code> and <code>cv_timedwait</code> Functions</h4>
<div class="paragraph">
<p>If a thread is blocked on a condition with
<code>cv_wait(9F)</code> and that condition does not occur, the thread would
wait forever. To avoid that situation, use <code>cv_timedwait(9F)</code>, which
depends upon another thread to perform a wakeup. <code>cv_timedwait</code>
takes an absolute wait time as an argument. <code>cv_timedwait</code> returns
<code>-1</code> if the time is reached and the event has not occurred.
<code>cv_timedwait</code> returns a positive value if the condition is met.</p>
</div>
<div class="paragraph">
<p><code>cv_timedwait(9F)</code> requires an absolute wait time expressed in clock
ticks since the system was last rebooted. The wait time can be
determined by retrieving the current value with
<code>ddi_get_lbolt(9F)</code>. The driver usually has a maximum number of
seconds or microseconds to wait, so this value is converted to clock
ticks with <code>drv_usectohz(9F)</code> and added to the value from
<code>ddi_get_lbolt(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>cv_timedwait(9F)</code> to wait up
to five seconds to access the device before returning <code>EIO</code> to the
caller.</p>
</div>
<div id="mt-14239" class="paragraph">
<p>Using <code>cv_timedwait</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">clock_t            cur_ticks, to;
mutex_enter(&amp;xsp-&gt;mu);
while (xsp-&gt;busy) {
        cur_ticks = ddi_get_lbolt();
        to = cur_ticks + drv_usectohz(5000000); /* 5 seconds from now */
        if (cv_timedwait(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu, to) == -1) {
                /*
                 * The timeout time 'to' was reached without the
                 * condition being signaled.
                 */
                /* tidy up and exit */
                mutex_exit(&amp;xsp-&gt;mu);
                return (EIO);
        }
}
xsp-&gt;busy = 1;
mutex_exit(&amp;xsp-&gt;mu);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although device driver writers generally prefer to use
<code>cv_timedwait(9F)</code> over <code>cv_wait(9F)</code>, sometimes
<code>cv_wait(9F)</code> is a better choice. For example, <code>cv_wait(9F)</code> is
better if a driver is waiting on the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Internal driver state changes, where such a state change might require
some command to be executed, or a set amount of time to pass</p>
</li>
<li>
<p>Something the driver needs to single-thread</p>
</li>
<li>
<p>Some situation that is already managing a possible timeout, as when
“A” depends on “B,” and “B” is using <code>cv_timedwait(9F)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="cvwaitsig-function"><a class="anchor" href="#cvwaitsig-function"></a>2.10.3. <code>cv_wait_sig</code> Function</h4>
<div class="paragraph">
<p>A driver might be waiting for a condition that cannot occur or will not
happen for a long time. In such cases, the user can send a signal to
abort the thread. Depending on the driver design, the signal might not
cause the driver to wake up.</p>
</div>
<div class="paragraph">
<p><code>cv_wait_sig(9F)</code> allows a signal to
unblock the thread. This capability enables the user to break out of
potentially long waits by sending a signal to the thread with <code>kill(1)</code>
or by typing the interrupt character. <code>cv_wait_sig(9F)</code> returns
zero if it is returning because of a signal, or nonzero if the condition
occurred. However, see <a href="#threads-unable-to-receive-signals">Threads Unable to Receive Signals</a>
for cases in which signals might not be received.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>cv_wait_sig(9F)</code> to
allow a signal to unblock the thread.</p>
</div>
<div id="mt-41633" class="paragraph">
<p>Using <code>cv_wait_sig</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">mutex_enter(&amp;xsp-&gt;mu);
while (xsp-&gt;busy) {
        if (cv_wait_sig(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu) == 0) {
        /* Signaled while waiting for the condition */
                /* tidy up and exit */
                mutex_exit(&amp;xsp-&gt;mu);
                return (EINTR);
        }
}
xsp-&gt;busy = 1;
mutex_exit(&amp;xsp-&gt;mu);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cvtimedwaitsig-function"><a class="anchor" href="#cvtimedwaitsig-function"></a>2.10.4. <code>cv_timedwait_sig</code> Function</h4>
<div class="paragraph">
<p><code>cv_timedwait_sig(9F)</code>
is similar to <code>cv_timedwait(9F)</code> and <code>cv_wait_sig(9F)</code>,
except that <code>cv_timedwait_sig</code> returns <code>-1</code> without the
condition being signaled after a timeout has been reached, or <code>0</code> if a
signal (for example, <code>kill(2)</code>) is sent to the thread.</p>
</div>
<div class="paragraph">
<p>For both <code>cv_timedwait(9F)</code> and <code>cv_timedwait_sig(9F)</code>, time
is measured in absolute clock ticks since the last system reboot.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="choosing-a-locking-scheme"><a class="anchor" href="#choosing-a-locking-scheme"></a>2.11. Choosing a Locking Scheme</h3>
<div class="paragraph">
<p>The locking scheme for most device drivers
should be kept straightforward. Using additional locks allows more
concurrency but increases overhead. Using fewer locks is less time
consuming but allows less concurrency. Generally, use one mutex per data
structure, a condition variable for each event or condition the driver
must wait for, and a mutex for each major set of data global to the
driver. Avoid holding mutexes for long periods of time. Use the
following guidelines when choosing a locking scheme:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the multithreading semantics of the entry point to your advantage.</p>
</li>
<li>
<p>Make all entry points re-entrant. You can reduce the amount of shared
data by changing a static variable to automatic.</p>
</li>
<li>
<p>If your driver acquires multiple mutexes, acquire and release the
mutexes in the same order in all code paths.</p>
</li>
<li>
<p>Hold and release locks within the same functional space.</p>
</li>
<li>
<p>Avoid holding driver mutexes when calling DDI interfaces that can
block, for example, <code>kmem_alloc(9F)</code> with <code>KM_SLEEP</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To look at lock usage, use <code>lockstat(8)</code>. <code>lockstat(8)</code> monitors all
kernel lock events, gathers frequency and timing data about the events,
and displays the data.</p>
</div>
<div class="paragraph">
<p>See the Multithreaded Programming Guide for more details on
multithreaded operations.</p>
</div>
<div class="sect3">
<h4 id="potential-locking-pitfalls"><a class="anchor" href="#potential-locking-pitfalls"></a>2.11.1. Potential Locking Pitfalls</h4>
<div class="paragraph">
<p>Mutexes are not re-entrant by the same thread. If you
already own the mutex, attempting to claim this mutex a second time
leads to the following panic:</p>
</div>
<div class="paragraph">
<p><code>panic: recursive mutex_enter. mutex %x caller %x</code></p>
</div>
<div class="paragraph">
<p>Releasing a mutex that the current thread does not hold causes this
panic:</p>
</div>
<div class="paragraph">
<p><code>panic: mutex_adaptive_exit: mutex not held by thread</code></p>
</div>
<div class="paragraph">
<p>The following panic occurs only on uniprocessors:</p>
</div>
<div class="paragraph">
<p><code>panic: lock_set: lock held and only one CPU</code></p>
</div>
<div class="paragraph">
<p>The <code>lock_set</code> panic indicates that a spin mutex is held and will
spin forever, because no other CPU can release this mutex. This
situation can happen if the driver forgets to release the mutex on one
code path or becomes blocked while holding the mutex.</p>
</div>
<div class="paragraph">
<p>A common cause of the <code>lock_set</code> panic occurs when a device with a
high-level interrupt calls a routine that blocks, such as
<code>cv_wait(9F)</code>. Another typical cause is a high-level handler
grabbing an adaptive mutex by calling <code>mutex_enter(9F)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="threads-unable-to-receive-signals"><a class="anchor" href="#threads-unable-to-receive-signals"></a>2.11.2. Threads Unable to Receive Signals</h4>
<div class="paragraph">
<p>The <code>sema_p_sig</code>, <code>cv_wait_sig</code>, and
<code>cv_timedwait_sig</code> functions can be awakened when the thread
receives a signal. A problem can arise because some threads are unable
to receive signals. For example, when <code>close(9E)</code> is called as a result
of the application calling <code>close(2)</code>, signals can be received. However,
when <code>close(9E)</code> is called from within the <code>exit(2)</code> processing that
closes all open file descriptors, the thread cannot receive signals.
When the thread cannot receive signals, <code>sema_p_sig</code> behaves as
<code>sema_p</code>, <code>cv_wait_sig</code> behaves as <code>cv_wait</code>, and
<code>cv_timedwait_sig</code> behaves as <code>cv_timedwait</code>.</p>
</div>
<div class="paragraph">
<p>Use caution to avoid sleeping forever on events that might never occur.
Events that never occur create unkillable (<code>defunct</code>) threads and make
the device unusable until the system is rebooted. Signals cannot be
received by defunct processes.</p>
</div>
<div class="paragraph">
<p>To detect whether the current thread is able to receive a signal, use
the <code>ddi_can_receive_sig(9F)</code> function. If the
<code>ddi_can_receive_sig`function returns `B_TRUE</code>, then the
above functions can wake up on a received signal. If the
<code>ddi_can_receive_sig`function returns `B_FALSE</code>, then
the above functions cannot wake up on a received signal. If the
<code>ddi_can_receive_sig`function returns `B_FALSE</code>, then
the driver should use an alternate means, such as the <code>timeout(9F)</code>
function, to reawaken.</p>
</div>
<div class="paragraph">
<p>One important case where this problem occurs is with serial ports. If
the remote system asserts flow control and the <code>close(9E)</code> function
blocks while attempting to drain the output data, a port can be stuck
until the flow control condition is resolved or the system is rebooted.
Such drivers should detect this case and set up a timer to abort the
drain operation when the flow control condition persists for an
excessive period of time.</p>
</div>
<div class="paragraph">
<p>This issue also affects the <code>qwait_sig(9F)</code> function, which is
described in Chapter 7, STREAMS Framework – Kernel Level, in STREAMS
Programming Guide.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="properties"><a class="anchor" href="#properties"></a>2.12. Properties</h3>
<div class="paragraph">
<p>Properties are user-defined, name-value pair structures that are managed
using the DDI/DKI interfaces. This chapter provides information on the
following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#device-property-names">Device Property Names</a></p>
</li>
<li>
<p><a href="#creating-and-updating-properties">Creating and Updating Properties</a></p>
</li>
<li>
<p><a href="#looking-up-properties">Looking Up Properties</a></p>
</li>
<li>
<p><a href="#prop_op-entry-point"> Entry Point</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="device-properties-1"><a class="anchor" href="#device-properties-1"></a>2.13. Device Properties</h3>
<div class="paragraph">
<p>Device attribute information can be represented by a <em>name-value</em> pair
notation called a <em>property</em>.</p>
</div>
<div class="paragraph">
<p>For example, device registers and onboard memory can be represented by
the reg property. The reg property is a software abstraction that
describes device hardware registers. The value of the reg property
encodes the device register address location and size. Drivers use the
reg property to access device registers.</p>
</div>
<div class="paragraph">
<p>Another example is the interrupt property. An interrupt property
represents the device interrupt. The value of the interrupt property
encodes the device-interrupt PIN.</p>
</div>
<div class="paragraph">
<p>Five types of values can be assigned to properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Byte array</strong> – Series of bytes of an arbitrary length</p>
</li>
<li>
<p><strong>Integer property</strong> – An integer value</p>
</li>
<li>
<p><strong>Integer array property</strong> – An array of integers</p>
</li>
<li>
<p><strong>String property</strong> – A null-terminated string</p>
</li>
<li>
<p><strong>String array property</strong> – A list of null-terminated strings</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A property that has no value
is considered to be a Boolean property. A Boolean property that exists
is true. A Boolean value that does not exist is false.</p>
</div>
<div class="sect3">
<h4 id="device-property-names"><a class="anchor" href="#device-property-names"></a>2.13.1. Device Property Names</h4>
<div class="paragraph">
<p>Strictly speaking, DDI/DKI software property names have no restrictions.
Certain uses are recommended, however. The IEEE 1275-1994 Standard for
Boot Firmware defines properties as follows:</p>
</div>
<div class="paragraph">
<p>A property is a human readable text string consisting of from 1 to 31
printable characters. Property names cannot contain upper case
characters or the characters “/”, “\”, “:”, “[“, “]” and
“@”. Property names beginning with the character “&#43;” are reserved
for use by future revisions of IEEE 1275-1994.</p>
</div>
<div class="paragraph">
<p>By convention, underbars (<code>_</code>) are not used in property names. Use a
hyphen (<code>-</code>) instead. By convention, property names ending with the
question mark character (<code>?</code>) contain values that are strings, typically
TRUE or FALSE, for example <code>auto-boot?</code>.</p>
</div>
<div class="paragraph">
<p>Predefined property names are listed in publications of the IEEE 1275
Working Group. See <a href="http://playground.sun.com/1275/" class="bare">http://playground.sun.com/1275/</a> for information about
how to obtain these publications. For a discussion of adding properties
in driver configuration files, see the <code>driver.conf(5)</code> man page. The
<code>pm(9P)</code> and <code>pm-components(9P)</code> man pages show how properties are used
in power management. Read the <code>sd(4D)</code> man page as an example of how
properties should be documented in device driver man pages.</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-and-updating-properties"><a class="anchor" href="#creating-and-updating-properties"></a>2.13.2. Creating and Updating Properties</h4>
<div class="paragraph">
<p>To create a property for a driver, or to update an existing property,
use an interface from the DDI driver update interfaces such as
<code>ddi_prop_update_int(9F)</code> or
<code>ddi_prop_update_string(9F)</code> with the appropriate property
type. See <a href="#properties-tbl-3">Property Interface Uses</a> for a list of
available property interfaces. These interfaces are typically called
from the driver&#8217;s <code>attach(9E)</code> entry point. In the following example,
<code>ddi_prop_update_string`creates a string property called
`pm-hardware-state</code> with a value of <code>needs-suspend-resume</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* The following code is to tell cpr that this device
 * needs to be suspended and resumed.
 */
(void) ddi_prop_update_string(device, dip,
    "pm-hardware-state", "needs-suspend-resume");</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases, using a <code>ddi_prop_update</code> routine is sufficient
for updating a property. Sometimes, however, the overhead of updating a
property value that is subject to frequent change can cause performance
problems. See <a href="#prop_op-entry-point"> Entry Point</a> for a description of
using a local instance of a property value to avoid using
<code>ddi_prop_update</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="looking-up-properties"><a class="anchor" href="#looking-up-properties"></a>2.13.3. Looking Up Properties</h4>
<div class="paragraph">
<p>A driver can request a property from its parent, which in turn can ask
its parent. The driver can control whether the request can go higher
than its parent.</p>
</div>
<div class="paragraph">
<p>For example, the <code>esp</code> driver in the
following example maintains an integer property called
<code>targetx-sync-speed</code> for each target. The <code>x</code> in <code>targetx-sync-speed</code>
represents the target number. The <code>prtconf(8)</code> command displays driver
properties in verbose mode. The following example shows a partial
listing for the <code>esp</code> driver.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf -v
...
       esp, instance #0
            Driver software properties:
                name &lt;target2-sync-speed&gt; length <i class="conum" data-value="4"></i><b>(4)</b>
                    value &lt;0x00000fa0&gt;.
...</pre>
</div>
</div>
<div class="paragraph">
<p>The following table provides a summary of the property
interfaces.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Property Interface Uses</caption>
<colgroup>
<col style="width: 23%;">
<col style="width: 41%;">
<col style="width: 36%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Family</th>
<th class="tableblock halign-left valign-top">Property Interfaces</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_exists(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up a
property and returns successfully if the property exists. Fails if the
property does not exist</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_get_int(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and returns an integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_get_int64(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and returns a 64-bit
integer property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup_int_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and returns
an integer array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup_int64_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and
returns a 64-bit integer array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup_string(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and returns a
string property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup_string_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and
returns a string array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup_byte_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Looks up and
returns a byte array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_int(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates an integer property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_int64(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates a single
64-bit integer property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_int_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates
an integer array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_string(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates a string</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_string_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or
creates a string array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_int64_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates
a 64-bit integer array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_update_byte_array(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updates or creates
a byte array property</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_remove</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_remove(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_remove_all(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removes all properties that
are associated with a device</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Whenever possible, use 64-bit versions of <code>int</code> property interfaces such
as <code>ddi_prop_update_int64(9F)</code> instead of 32-bit versions
such as <code>ddi_prop_update_int(9F)</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="prop_op-entry-point"><a class="anchor" href="#prop_op-entry-point"></a>2.13.4. <code>prop_op</code> Entry Point</h4>
<div class="paragraph">
<p>The <code>prop_op(9E)</code> entry point is generally required for reporting
device properties or driver properties to the system. If the driver does
not need to create or manage its own properties, then the
<code>ddi_prop_op(9F)</code> function can be used for this entry point.</p>
</div>
<div class="paragraph">
<p><code>ddi_prop_op(9F)</code> can be used as the <code>prop_op(9E)</code> entry
point for a device driver when <code>ddi_prop_op</code> is defined in the
driver&#8217;s <code>cb_ops(9S)</code> structure. <code>ddi_prop_op</code> enables a
leaf device to search for and obtain property values from the device&#8217;s
property list.</p>
</div>
<div class="paragraph">
<p>If the driver has to maintain a property whose value changes frequently,
you should define a driver-specific <code>prop_op</code> routine within the
<code>cb_ops</code> structure instead of calling <code>ddi_prop_op</code>. This
technique avoids the inefficiency of using <code>ddi_prop_update</code>
repeatedly. The driver should then maintain a copy of the property value
either within its soft-state structure or in a driver variable.</p>
</div>
<div class="paragraph">
<p><code>prop_op(9E)</code> entry point reports the values of specific driver
properties and device properties to the system. In many cases, the
<code>ddi_prop_op(9F)</code> routine can be used as the driver&#8217;s
<code>prop_op</code> entry point in the <code>cb_ops(9S)</code> structure.
<code>ddi_prop_op</code> performs all of the required processing.
<code>ddi_prop_op</code> is sufficient for drivers that do not require
special processing when handling device property requests.</p>
</div>
<div class="paragraph">
<p>However, sometimes the driver must provide a <code>prop_op</code> entry point.
For example, if a driver maintains a property whose value changes
frequently, updating the property with <code>ddi_prop_update(9F)</code> for
each change is not efficient. Instead, the driver should maintain a
shadow copy of the property in the instance&#8217;s soft state. The driver
would then update the shadow copy when the value changes without using
any of the <code>ddi_prop_update</code> routines. The <code>prop_op</code> entry
point must intercept requests for this property and use one of the
<code>ddi_prop_update</code> routines to update the value of the property
before passing the request to <code>ddi_prop_op</code> to process the
property request.</p>
</div>
<div class="paragraph">
<p>In the following example, <code>prop_op</code> intercepts requests for the
<code>temperature</code> property. The driver updates a variable in the state
structure whenever the property changes. However, the property is
updated only when a request is made. The driver then uses
<code>ddi_prop_op</code> to process the property request. If the property
request is not specific to a device, the driver does not intercept the
request. This situation is indicated when the value of the <code>dev</code>
parameter is equal to <code>DDI_DEV_T_ANY</code>, the wildcard device
number.</p>
</div>
<div id="properties-ex-5" class="paragraph">
<p><code>prop_op</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xx_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
        minor_t instance;
        struct xxstate *xsp;
        if (dev != DDI_DEV_T_ANY) {
                return (ddi_prop_op(dev, dip, prop_op, flags, name,
                    valuep, lengthp));
        }

        instance = getminor(dev);
        xsp = ddi_get_soft_state(statep, instance);
        if (xsp == NULL)
                return (DDI_PROP_NOTFOUND);
        if (strcmp(name, "temperature") == 0) {
                ddi_prop_update_int(dev, dip, name, temperature);
        }

        /* other cases */
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-events-and-queueing-tasks"><a class="anchor" href="#managing-events-and-queueing-tasks"></a>2.14. Managing Events and Queueing Tasks</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#introduction-to-events">Introduction to Events</a></p>
</li>
<li>
<p><a href="#using-ddilogsysevent-to-log-events">Using to Log Events</a></p>
</li>
<li>
<p><a href="#defining-event-attributes">Defining Event Attributes</a></p>
</li>
<li>
<p><a href="#introduction-to-task-queues">Introduction to Task Queues</a></p>
</li>
<li>
<p><a href="#task-queue-interfaces">Task Queue Interfaces</a></p>
</li>
<li>
<p><a href="#using-task-queues">Using Task Queues</a></p>
</li>
<li>
<p><a href="#observing-task-queues">Observing Task Queues</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="managing-events"><a class="anchor" href="#managing-events"></a>2.15. Managing Events</h3>
<div class="paragraph">
<p>A system often needs to respond to a condition change such as a user
action or system request. For example, a device might issue a warning
when a component begins to overheat, or might start a movie player when
a DVD is inserted into a drive. Device drivers can use a special message
called an <em>event</em> to inform the system that a change in state has taken
place.</p>
</div>
<div class="sect3">
<h4 id="introduction-to-events"><a class="anchor" href="#introduction-to-events"></a>2.15.1. Introduction to Events</h4>
<div class="paragraph">
<p>An <em>event</em> is a message that a device driver sends to interested
entities to indicate that a change of state has taken place. Events are
implemented in illumos as user-defined, name-value pair structures that
are managed using the <code>nvlist*</code> functions. (See the
<code>nvlist_alloc(9F)</code> man page.) Events are organized by vendor, class,
and subclass. For example, you could define a class for monitoring
environmental conditions. An environmental class could have subclasses
to indicate changes in temperature, fan status, and power.</p>
</div>
<div class="paragraph">
<p>When a change in state occurs, the device notifies the driver. The
driver then uses the <code>ddi_log_sysevent(9F)</code> function to log this
event in a queue called <code>sysevent</code>. The <code>sysevent</code> queue passes events
to the user level for handling by either the <code>syseventd</code> daemon or
<code>syseventconfd</code> daemon. These daemons send notifications to any
applications that have subscribed for notification of the specified
event.</p>
</div>
<div class="paragraph">
<p>Two methods for designers of user-level applications deal with events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An application can use the routines in <code>libsysevent(3LIB)</code> to
subscribe with the <code>syseventd</code> daemon for notification when a specific
event occurs.</p>
</li>
<li>
<p>A developer can write a separate user-level application to respond to
an event. This type of application needs to be registered with
<code>syseventadm(8)</code>. When <code>syseventconfd</code> encounters the specified event,
the application is run and deals with the event accordingly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This process is illustrated in the following figure.</p>
</div>
<div id="esbjc" class="imageblock">
<div class="content">
<img src="figures/EventPlumbing.png" alt="Diagram shows how events are logged into the sysevent queue for notification of user-level applications.">
</div>
<div class="title">Figure 6. Event Plumbing</div>
</div>
</div>
<div class="sect3">
<h4 id="using-ddilogsysevent-to-log-events"><a class="anchor" href="#using-ddilogsysevent-to-log-events"></a>2.15.2. Using <code>ddi_log_sysevent</code> to Log Events</h4>
<div class="paragraph">
<p>Device drivers use the
<code>ddi_log_sysevent(9F)</code> interface to generate and log events with
the system.</p>
</div>
<div class="sect4">
<h5 id="ddilogsysevent-syntax"><a class="anchor" href="#ddilogsysevent-syntax"></a><code>ddi_log_sysevent</code> Syntax</h5>
<div class="paragraph">
<p><code>ddi_log_sysevent</code> uses the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_log_sysevent(dev_info_t *dip, char *vendor, char *class,
    char *subclass, nvlist_t *attr-list, sysevent_id_t *eidp, int sleep-flag);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;dip&gt;</dt>
<dd>
<p>A pointer to the &lt;dev_info&gt; node for this driver.</p>
</dd>
<dt class="hdlist1">&lt;vendor&gt;</dt>
<dd>
<p>A pointer to a string that defines the driver&#8217;s vendor. Third-party
drivers should use their company&#8217;s stock symbol or a similarly
enduring identifier. Sun-supplied drivers use
<code>DDI_VENDOR_SUNW</code>.</p>
</dd>
<dt class="hdlist1">&lt;class&gt;</dt>
<dd>
<p>A pointer to a string defining the event&#8217;s class. <code>class</code> is a
driver-specific value. An example of a class might be a string that
represents a set of environmental conditions that affect a device.
This value must be understood by the event consumer.</p>
</dd>
<dt class="hdlist1">&lt;subclass&gt;</dt>
<dd>
<p>A driver-specific string that represents a subset of the <code>class</code>
argument. For example, within a class that represents environmental
conditions, an event subclass might refer to the device&#8217;s temperature.
This value must be intelligible to the event consumer.</p>
</dd>
<dt class="hdlist1">&lt;attr-list&gt;</dt>
<dd>
<p>A pointer to an <code>nvlist_t</code> structure that lists name-value
attributes associated with the event. Name-value attributes are
driver-defined and can refer to a specific attribute or condition of
the device.
+
For example, consider a device that reads both CD-ROMs and DVDs. That
device could have an attribute with the name <code>disc_type</code> and the
value equal to either <code>cd_rom</code> or <code>dvd</code>.
+
As with <code>class</code> and <code>subclass</code>, an event consumer must be able to
interpret the name-value pairs.
+
For more information on name-value pairs and the <code>nvlist_t</code>
structure, see <a href="#defining-event-attributes">Defining Event Attributes</a>, as well as the
<code>nvlist_alloc(9F)</code> man page.
+
If the event has no attributes, then this argument should be set to
<code>NULL</code>.</p>
</dd>
<dt class="hdlist1">&lt;eidp&gt;</dt>
<dd>
<p>The address of a <code>sysevent_id_t</code> structure. The
<code>sysevent_id_t</code> structure is used to provide a unique
identification for the event. <code>ddi_log_sysevent(9F)</code> returns
this structure with a system-provided event sequence number and time
stamp. See the <code>ddi_log_sysevent(9F)</code> man page for more
information on the <code>sysevent_id_t</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;sleep-flag&gt;</dt>
<dd>
<p>A flag that indicates how the caller wants to handle the possibility
of resources not being available. If &lt;sleep-flag&gt; is set to
<code>DDI_SLEEP</code>, the driver blocks until the resources become
available. With <code>DDI_NOSLEEP</code>, an allocation will not sleep and
cannot be guaranteed to succeed. If <code>DDI_ENOMEM</code> is returned, the
driver would need to retry the operation at a later time.
+
Even with <code>DDI_SLEEP</code>, other error returns are possible with this
interface, such as system busy, the <code>syseventd</code> daemon not responding,
or trying to log an event in interrupt context.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sample-code-for-logging-events"><a class="anchor" href="#sample-code-for-logging-events"></a>Sample Code for Logging Events</h5>
<div class="paragraph">
<p>A device driver performs the following tasks to log events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocate memory for the attribute list using <code>nvlist_alloc(9F)</code></p>
</li>
<li>
<p>Add name-value pairs to the attribute list</p>
</li>
<li>
<p>Use the <code>ddi_log_sysevent(9F)</code> function to log the event in
the <code>sysevent</code> queue</p>
</li>
<li>
<p>Call <code>nvlist_free(9F)</code> when the attribute list is no longer needed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example demonstrates how to use
<code>ddi_log_sysevent</code>.</p>
</div>
<div id="esqew" class="paragraph">
<p>Calling <code>ddi_log_sysevent</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">char *vendor_name = "DDI_VENDOR_JGJG"
char *my_class = "JGJG_event";
char *my_subclass = "JGJG_alert";
nvlist_t *nvl;
/* ... */
nvlist_alloc(&amp;nvl, nvflag, kmflag);
/* ... */
(void) nvlist_add_byte_array(nvl, propname, (uchar_t *)propval, proplen + 1);
/* ... */
if (ddi_log_sysevent(dip, vendor_name, my_class,
    my_subclass, nvl, NULL, DDI_SLEEP)!= DDI_SUCCESS)
    cmn_err(CE_WARN, "error logging system event");
nvlist_free(nvl);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="defining-event-attributes"><a class="anchor" href="#defining-event-attributes"></a>2.15.3. Defining Event Attributes</h4>
<div class="paragraph">
<p>Event attributes are defined as a list of name-value pairs. The illumos
DDI provides routines and structures for storing information in
name-value pairs. Name-value pairs are retained in an <code>nvlist_t</code>
structure, which is opaque to the driver. The value for a name-value
pair can be a Boolean, an <code>int</code>, a byte, a string, an <code>nvlist</code>, or an
array of these data types. An <code>int</code> can be defined as 16 bits, 32 bits,
or 64 bits and can be signed or unsigned.</p>
</div>
<div class="paragraph">
<p>The steps in creating a list of name-value pairs are as follows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create an <code>nvlist_t</code> structure with
<code>nvlist_alloc(9F)</code>.</p>
<div class="paragraph">
<p>The <code>nvlist_alloc</code> interface takes three arguments:
* &lt;nvlp&gt; – Pointer to a pointer to an <code>nvlist_t</code> structure
* &lt;nvflag&gt; – Flag to indicate the uniqueness of the names of the
pairs. If this flag is set to <code>NV_UNIQUE_NAME_TYPE</code>, any
existing pair that matches the name and type of a new pair is removed
from the list. If the flag is set to <code>NV_UNIQUE_NAME</code>, then any
existing pair with a duplicate name is removed, regardless of its type.
Specifying <code>NV_UNIQUE_NAME_TYPE</code> allows a list to contain
two or more pairs with the same name as long as their types are
different, whereas with <code>NV_UNIQUE_NAME</code> only one instance of a
pair name can be in the list. If the flag is not set, then no uniqueness
checking is done and the consumer of the list is responsible for dealing
with duplicates.
* &lt;kmflag&gt; – Flag to indicate the allocation policy for kernel
memory. If this argument is set to <code>KM_SLEEP</code>, then the driver
blocks until the requested memory is available for allocation.
<code>KM_SLEEP</code> allocations might sleep but are guaranteed to succeed.
<code>KM_NOSLEEP</code> allocations are guaranteed not to sleep but might
return <code>NULL</code> if no memory is currently available.</p>
</div>
</li>
<li>
<p>Populate the <code>nvlist</code> with name-value pairs. For example, to add a
string, use <code>nvlist_add_string(9F)</code>. To add an array of 32-bit
integers, use <code>nvlist_add_int32_array(9F)</code>. The
<code>nvlist_add_boolean(9F)</code> man page contains a complete list of
interfaces for adding pairs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To deallocate a list, use <code>nvlist_free(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The following code sample illustrates the creation of a name-value list.</p>
</div>
<div id="properties-ex-16" class="paragraph">
<p>Creating and Populating a Name-Value Pair List</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">nvlist_t*
    {
    int err;
    char *str = "child";
    int32_t ints[] = {0, 1, 2};
    nvlist_t *nvl;

    err = nvlist_alloc(&amp;nvl, NV_UNIQUE_NAME, 0);    /* allocate list */
    if (err)
        return (NULL);
    if ((nvlist_add_string(nvl, "name", str) != 0) ||
        (nvlist_add_int32_array(nvl, "prop", ints, 3) != 0)) {
        nvlist_free(nvl);
        return (NULL);
    }
    return (nvl);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Drivers can retrieve the elements of an <code>nvlist</code> by using a lookup
function for that type, such as
<code>nvlist_lookup_int32_array(9F)</code>, which takes as an argument
the name of the pair to be searched for.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These interfaces work only if either <code>NV_UNIQUE_NAME</code> or
<code>NV_UNIQUE_NAME_TYPE</code> is specified when
<code>nvlist_alloc(9F)</code> is called. Otherwise, ENOTSUP is returned,
because the list cannot contain multiple pairs with the same name.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A list of name-value list pairs can be placed in contiguous memory. This
approach is useful for passing the list to an entity that has subscribed
for notification. The first step is to get the size of the memory block
that is needed for the list with <code>nvlist_size(9F)</code>. The next step is
to pack the list into the buffer with <code>nvlist_pack(9F)</code>. The
consumer receiving the buffer&#8217;s content can unpack the buffer with
<code>nvlist_unpack(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The functions for manipulating name-value pairs are available to both
user-level and kernel-level developers. You can find identical man pages
for these functions in both <a href="https://illumos.org/man/3f">manual pages
section 3F: Library Interfaces and Headers</a> and in
<a href="https://illumos.org/man/9f">man pages section 9: DDI and DKI Kernel
Functions</a>. For a list of functions that operate on name-value pairs,
see the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Functions for Using Name-Value Pairs</caption>
<colgroup>
<col style="width: 32%;">
<col style="width: 68%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Man Page</th>
<th class="tableblock halign-left valign-top">Purpose / Functions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvlist_add_boolean(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Add name-value pairs to the list. Functions include:</p>
</div>
<div class="paragraph">
<p><code>nvlist_add_boolean</code>, <code>nvlist_add_boolean_value</code>,
<code>nvlist_add_byte</code>, <code>nvlist_add_int8</code>,
<code>nvlist_add_uint8</code>, <code>nvlist_add_int16</code>,
<code>nvlist_add_uint16</code>, <code>nvlist_add_int32</code>,
<code>nvlist_add_uint32</code>, <code>nvlist_add_int64</code>,
<code>nvlist_add_uint64</code>, <code>nvlist_add_string</code>,
<code>nvlist_add_nvlist</code>, <code>nvlist_add_nvpair</code>,
<code>nvlist_add_boolean_array</code>,
<code>nvlist_add_int8_array, nvlist_add_uint8_array</code>,
<code>nvlist_add_nvlist_array</code>,
<code>nvlist_add_byte_array</code>,
<code>nvlist_add_int16_array</code>,
<code>nvlist_add_uint16_array</code>,
<code>nvlist_add_int32_array</code>,
<code>nvlist_add_uint32_array</code>,
<code>nvlist_add_int64_array</code>,
<code>nvlist_add_uint64_array</code>,
<code>nvlist_add_string_array</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvlist_alloc(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Manipulate the name-value list buffer. Functions include:</p>
</div>
<div class="paragraph">
<p><code>nvlist_alloc</code>, <code>nvlist_free</code>, <code>nvlist_size</code>,
<code>nvlist_pack</code>, <code>nvlist_unpack</code>, <code>nvlist_dup</code>,
<code>nvlist_merge</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvlist_lookup_boolean(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Search for name-value pairs. Functions include:</p>
</div>
<div class="paragraph">
<p><code>nvlist_lookup_boolean</code>,
<code>nvlist_lookup_boolean_value</code>, <code>nvlist_lookup_byte</code>,
<code>nvlist_lookup_int8</code>, <code>nvlist_lookup_int16</code>,
<code>nvlist_lookup_int32</code>, <code>nvlist_lookup_int64</code>,
<code>nvlist_lookup_uint8</code>, <code>nvlist_lookup_uint16</code>,
<code>nvlist_lookup_uint32</code>, <code>nvlist_lookup_uint64</code>,
<code>nvlist_lookup_string</code>, <code>nvlist_lookup_nvlist</code>,
<code>nvlist_lookup_boolean_array, nvlist_lookup_byte_array</code>,
<code>nvlist_lookup_int8_array</code>,
<code>nvlist_lookup_int16_array</code>,
<code>nvlist_lookup_int32_array</code>,
<code>nvlist_lookup_int64_array</code>,
<code>nvlist_lookup_uint8_array</code>,
<code>nvlist_lookup_uint16_array</code>,
<code>nvlist_lookup_uint32_array</code>,
<code>nvlist_lookup_uint64_array</code>,
<code>nvlist_lookup_string_array</code>,
<code>nvlist_lookup_nvlist_array</code>, <code>nvlist_lookup_pairs</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvlist_next_nvpair(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Get name-value pair data. Functions include:</p>
</div>
<div class="paragraph">
<p><code>nvlist_next_nvpair</code>, <code>nvpair_name</code>, <code>nvpair_type</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvlist_remove(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Remove name-value pairs. Functions include:</p>
</div>
<div class="paragraph">
<p><code>nv_remove</code>, <code>nv_remove_all</code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="queueing-tasks"><a class="anchor" href="#queueing-tasks"></a>2.16. Queueing Tasks</h3>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>scheduling tasks</p>
</div>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>This section discusses how to use <em>task queues</em> to postpone processing
of some tasks and delegate their execution to another kernel thread.</p>
</div>
<div class="sect3">
<h4 id="introduction-to-task-queues"><a class="anchor" href="#introduction-to-task-queues"></a>2.16.1. Introduction to Task Queues</h4>
<div class="paragraph">
<p>A common operation in kernel programming is to schedule a task to be
performed at a later time, by a different thread. The following examples
give some reasons that you might want a different thread to perform a
task at a later time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Your current code path is time critical. The additional task you want
to perform is not time critical.</p>
</li>
<li>
<p>The additional task might require grabbing a lock that another thread
is currently holding.</p>
</li>
<li>
<p>You cannot block in your current context. The additional task might
need to block, for example to wait for memory.</p>
</li>
<li>
<p>A condition is preventing your code path from completing, but your
current code path cannot sleep or fail. You need to queue the current
task to execute after the condition disappears.</p>
</li>
<li>
<p>You need to launch multiple tasks in parallel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In each of these cases, a task is executed in a different <em>context</em>. A
different context is usually a different kernel thread with a different
set of locks held and possibly a different priority. Task queues provide
a generic kernel API for scheduling asynchronous tasks.</p>
</div>
<div class="paragraph">
<p>A <em>task queue</em> is a list of tasks with one or more
threads to service the list. If a task queue has a single service
thread, all tasks are guaranteed to execute in the order in which they
are added to the list. If a task queue has more than one service thread,
the order in which the tasks will execute is not known.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the task queue has more than one service thread, make sure that the
execution of one task does not depend on the execution of any other
task. Dependencies between tasks can cause a deadlock to occur.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="task-queue-interfaces"><a class="anchor" href="#task-queue-interfaces"></a>2.16.2. Task Queue Interfaces</h4>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>The following DDI interfaces manage task queues. These interfaces are
defined in the <code>sys/sunddi.h</code> header file. See the <code>taskq(9F)</code> man page
for more information about these interfaces.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 38%;">
<col style="width: 62%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_t</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opaque handle</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TASKQ_DEFAULTPRI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System default priority</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_SLEEP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can block for memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NOSLEEP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cannot block for memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create a task queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_destroy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destroy a task queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_dispatch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add a task to a task queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_wait</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wait for pending tasks to complete</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_suspend</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suspend a task queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_suspended</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check whether a task queue is suspended</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_taskq_resume</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resume a suspended task queue</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="using-task-queues"><a class="anchor" href="#using-task-queues"></a>2.16.3. Using Task Queues</h4>
<div class="paragraph">
<p>The typical usage in drivers is to create task queues at <code>attach(9E)</code>.
Most <code>taskq_dispatch</code> invocations are from interrupt context.</p>
</div>
<div class="paragraph">
<p>To study task queues used in illumos drivers, go to
<a href="http://www.opensolaris.org/os/" class="bare">http://www.opensolaris.org/os/</a>. In the left margin menu, click Source
Browser. In the Symbol field of the search area, enter
<code>ddi_taskq_create</code>. In the Project list, select <code>onnv</code>. Click
the Search button. In your search results you should see the USB generic
serial driver (<code>usbser.c</code>), the 1394 mass storage HBA FireWire driver
(<code>scsa1394/hba.c</code>), and the SCSI HBA driver for Dell PERC
3DC/4SC/4DC/4Di RAID devices (<code>amr.c</code>).</p>
</div>
<div class="paragraph">
<p>Click the file name <code>amr.c</code>. The <code>ddi_taskq_create</code> function is
called in the <code>amr_attach</code> entry point. The
<code>ddi_taskq_destroy</code> function is called in the <code>amr_detach</code>
entry point and also in the error handling section of the
<code>amr_attach</code> entry point. The <code>ddi_taskq_dispatch</code> function
is called in the <code>amr_done</code> function, which is called in the
<code>amr_intr</code> function. The <code>amr_intr</code> function is an
interrupt-handling function that is an argument to the
<code>ddi_add_intr(9F)</code> function in the <code>amr_attach</code> entry point.</p>
</div>
</div>
<div class="sect3">
<h4 id="observing-task-queues"><a class="anchor" href="#observing-task-queues"></a>2.16.4. Observing Task Queues</h4>
<div class="paragraph">
<p>This section describes two techniques that you can use to monitor the
system resources that are consumed by a task queue. Task queues export
statistics on the use of system time by task queue threads. Task queues
also use DTrace SDT probes to determine when a task queue starts and
finishes execution of a task.</p>
</div>
<div class="sect4">
<h5 id="task-queue-kernel-statistics-counters"><a class="anchor" href="#task-queue-kernel-statistics-counters"></a>Task Queue Kernel Statistics Counters</h5>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>Every task queue has an associated set of <code>kstat</code> counters. Examine the
output of the following <code>kstat(8)</code> command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ kstat -c taskq
module: unix                            instance: 0
name:   ata_nexus_enum_tq               class:    taskq
        crtime                          53.877907833
        executed                        0
        maxtasks                        0
        nactive                         1
        nalloc                          0
        priority                        60
        snaptime                        258059.249256749
        tasks                           0
        threads                         1
        totaltime                       0

module: unix                            instance: 0
name:   callout_taskq                   class:    taskq
        crtime                          0
        executed                        13956358
        maxtasks                        4
        nactive                         4
        nalloc                          0
        priority                        99
        snaptime                        258059.24981709
        tasks                           13956358
        threads                         2
        totaltime                       120247890619</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>kstat</code> output shown above includes the following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The name of the task queue and its instance number</p>
</li>
<li>
<p>The number of scheduled (<code>tasks</code>) and executed (<code>executed</code>) tasks</p>
</li>
<li>
<p>The number of kernel threads processing the task queue (<code>threads</code>) and
their priority (<code>priority</code>)</p>
</li>
<li>
<p>The total time (in nanoseconds) spent processing all the tasks
(<code>totaltime</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how you can use the <code>kstat</code> command to
observe how a counter (number of scheduled tasks) increases over time:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ kstat -p unix:0:callout_taskq:tasks 1 5
unix:0:callout_taskq:tasks      13994642

unix:0:callout_taskq:tasks      13994711

unix:0:callout_taskq:tasks      13994784

unix:0:callout_taskq:tasks      13994855

unix:0:callout_taskq:tasks      13994926</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="task-queue-dtrace-sdt-probes"><a class="anchor" href="#task-queue-dtrace-sdt-probes"></a>Task Queue DTrace SDT Probes</h5>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>Task queues provide several useful SDT probes. All the probes described
in this section have the following two arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The task queue pointer returned by <code>ddi_taskq_create</code></p>
</li>
<li>
<p>The pointer to the <code>taskq_ent_t</code> structure. Use this pointer
in your D script to extract the function and the argument.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can use these probes to collect precise timing information about
individual task queues and individual tasks being executed through them.
For example, the following script prints the functions that were
scheduled through task queues for every 10 seconds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#!/usr/sbin/dtrace -qs

sdt:genunix::taskq-enqueue
{
  this-&gt;tq  = (taskq_t *)arg0;
  this-&gt;tqe = (taskq_ent_t *) arg1;
  @[this-&gt;tq-&gt;tq_name,
    this-&gt;tq-&gt;tq_instance,
    this-&gt;tqe-&gt;tqent_func] = count();
}

tick-10s
{
  printa ("%s(%d): %a called %@d times\n", @);
  trunc(@);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On a particular machine, the above D script produced the following
output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>callout_taskq(1): genunix`callout_execute called 51 times
callout_taskq(0): genunix`callout_execute called 701 times
kmem_taskq(0): genunix`kmem_update_timeout called 1 times
kmem_taskq(0): genunix`kmem_hash_rescale called 4 times
callout_taskq(1): genunix`callout_execute called 40 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 256 times
callout_taskq(0): genunix`callout_execute called 702 times
kmem_taskq(0): genunix`kmem_update_timeout called 1 times
kmem_taskq(0): genunix`kmem_hash_rescale called 4 times
callout_taskq(1): genunix`callout_execute called 28 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 228 times
callout_taskq(0): genunix`callout_execute called 706 times
callout_taskq(1): genunix`callout_execute called 24 times
USB_hid_81_pipehndl_tq_1(14): usba`hcdi_cb_thread called 141 times
callout_taskq(0): genunix`callout_execute called 708 times</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="driver-autoconfiguration"><a class="anchor" href="#driver-autoconfiguration"></a>2.17. Driver Autoconfiguration</h3>
<div class="paragraph">
<p>Autoconfiguration means the driver loads code and static data into
memory. This information is then registered with the system.
Autoconfiguration also involves attaching individual device instances
that are controlled by the driver.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#driver-loading-and-unloading">Driver Loading and Unloading</a></p>
</li>
<li>
<p><a href="#data-structures-required-for-drivers">Data Structures Required for Drivers</a></p>
</li>
<li>
<p><a href="#loadable-driver-interfaces">Loadable Driver Interfaces</a></p>
</li>
<li>
<p><a href="#device-configuration-concepts">Device Configuration Concepts</a></p>
</li>
<li>
<p><a href="#using-device-ids">Using Device IDs</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="driver-loading-and-unloading"><a class="anchor" href="#driver-loading-and-unloading"></a>2.18. Driver Loading and Unloading</h3>
<div class="paragraph">
<p>The system loads driver binary modules
from the <code>drv</code> subdirectory of the kernel module directory for
autoconfiguration. See <a href="#copying-the-driver-to-a-module-directory">Copying the Driver to a Module
Directory</a>.</p>
</div>
<div class="paragraph">
<p>After a module is read into memory with all symbols resolved, the system
calls the <code>_init(9E)</code> entry point for that module. The <code>_init</code>
function calls <code>mod_install(9F)</code>, which actually loads the module.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
During the call to <code>mod_install</code>, other threads are able to call
<code>attach(9E)</code> as soon as <code>mod_install</code> is called. From a programming
standpoint, all <code>_init</code> initialization must occur before
<code>mod_install</code> is called. If <code>mod_install</code> fails (that is a
nonzero value is returned), then the initialization must be backed out.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Upon successful completion of <code>_init</code>, the driver is properly
registered with the system. At this point, the driver is not actively
managing any device. Device management happens as part of device
configuration.</p>
</div>
<div class="paragraph">
<p>The system unloads driver binary modules either to conserve system
memory or at the explicit request of a user. Before deleting the driver
code and data from memory, the <code>_fini(9E)</code> entry point of the driver
is invoked. The driver is unloaded, if and only if <code>_fini</code> returns
success.</p>
</div>
<div class="paragraph">
<p>The following figure provides a structural overview of a device driver.
The shaded area highlights the driver data structures and entry points.
The upper half of the shaded area contains data structures and entry
points that support driver loading and unloading. The lower half is
concerned with driver configuration.</p>
</div>
<div id="autoconf-fig-4" class="imageblock">
<div class="content">
<img src="figures/autoconf-entrypoints.png" alt="Diagram shows structures and entry points used in autoconfiguration and module loading.">
</div>
<div class="title">Figure 7. Module Loading and Autoconfiguration Entry Points</div>
</div>
</div>
<div class="sect2">
<h3 id="data-structures-required-for-drivers"><a class="anchor" href="#data-structures-required-for-drivers"></a>2.19. Data Structures Required for Drivers</h3>
<div class="paragraph">
<p>To support autoconfiguration, drivers are required to statically
initialize the following data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>modlinkage(9S)</code></p>
</li>
<li>
<p><code>modldrv(9S)</code></p>
</li>
<li>
<p><code>dev_ops(9S)</code></p>
</li>
<li>
<p><code>cb_ops(9S)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The data structures in Figure 5-1 are relied on by the driver. These
structures must be provided and be initialized correctly. Without these
data structures, the driver might not load properly. As a result, the
necessary routines might not be loaded. If an operation is not supported
by the driver, the address of the <code>nodev(9F)</code> routine can be used as a
placeholder. In some instances, the driver supports the entry point and
only needs to return success or failure. In such cases, the address of
the routine <code>nulldev(9F)</code> can be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These structures should be initialized at compile-time. The driver
should not access or change the structures at any other time.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="modlinkage-structure"><a class="anchor" href="#modlinkage-structure"></a>2.19.1. <code>modlinkage</code> Structure</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct modlinkage xxmodlinkage = {
    MODREV_1,       /* ml_rev */
    &amp;xxmodldrv,     /* ml_linkage[] */
    NULL            /* NULL termination */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first field is the version number of the module that loads the
subsystem. This field should be <code>MODREV_1</code>. The second field points
to driver&#8217;s <code>modldrv</code> structure defined next. The last element of the
structure should always be <code>NULL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="modldrv-structure"><a class="anchor" href="#modldrv-structure"></a>2.19.2. <code>modldrv</code> Structure</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct modldrv xxmodldrv = {
    &amp;mod_driverops,           /* drv_modops */
    "generic driver v1.1",    /* drv_linkinfo */
    &amp;xx_dev_ops               /* drv_dev_ops */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This structure describes the module in more detail. The first field
provides information regarding installation of the module. This field
should be set to <code>&amp;mod_driverops</code> for driver modules. The second
field is a string to be displayed by <code>modinfo(8)</code>. The second field
should contain sufficient information for identifying the version of
source code that generated the driver binary. The last field points to
the driver&#8217;s <code>dev_ops</code> structure defined in the following section.</p>
</div>
</div>
<div class="sect3">
<h4 id="dev_ops-structure"><a class="anchor" href="#dev_ops-structure"></a>2.19.3. <code>dev_ops</code> Structure</h4>
<div class="paragraph">
<p>dev_ops</p>
</div>
<div class="paragraph">
<p>dev_ops</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct dev_ops xx_dev_ops = {
    DEVO_REV,       /* devo_rev, */
    0,              /* devo_refcnt  */
    xxgetinfo,      /* getinfo(9E) */
    nulldev,        /* identify(9E) */
    xxprobe,        /* probe(9E) */
    xxattach,       /* attach(9E) */
    xxdetach,       /* detach(9E) */
    nodev,          /* devo_reset */
    &amp;xx_cb_ops,     /* devo_cb_ops */
    NULL,           /* devo_bus_ops */
    &amp;xxpower        /* power(9E) */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>dev_ops(9S)</code> structure enables the kernel to find the
autoconfiguration entry points of the device driver. The <code>devo_rev</code>
field identifies the revision number of the structure. This field must
be set to <code>DEVO_REV</code>. The <code>devo_refcnt</code> field must be
initialized to zero. The function address fields should be filled in
with the address of the appropriate driver entry point, except in the
following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the <code>devo_probe</code> field to <code>nulldev(9F)</code> if a <code>probe(9E)</code>
routine is not needed.</p>
</li>
<li>
<p>Set the <code>identify</code> field to <code>nulldev(9F)</code>. The <code>identify</code> entry point
is obsolete.</p>
</li>
<li>
<p>Set the <code>devo_reset</code> field to <code>nodev(9F)</code>.</p>
</li>
<li>
<p>Set the <code>power(9E)</code> field to <code>NULL</code> if a <code>power</code> routine is not
needed. Drivers for devices that provide Power Management functionality
must have a <code>power</code> entry point.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>devo_cb_ops</code> member should include the address of the
<code>cb_ops(9S)</code> structure. The <code>devo_bus_ops</code> field must be set
to <code>NULL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="cb_ops-structure"><a class="anchor" href="#cb_ops-structure"></a>2.19.4. <code>cb_ops</code> Structure</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct cb_ops xx_cb_ops = {
    xxopen,         /* open(9E) */
    xxclose,        /* close(9E) */
    xxstrategy,     /* strategy(9E) */
    xxprint,        /* print(9E) */
    xxdump,         /* dump(9E) */
    xxread,         /* read(9E) */
    xxwrite,        /* write(9E) */
    xxioctl,        /* ioctl(9E) */
    xxdevmap,       /* devmap(9E) */
    nodev,          /* mmap(9E) */
    xxsegmap,       /* segmap(9E) */
    xxchpoll,       /* chpoll(9E) */
    xxprop_op,      /* prop_op(9E) */
    NULL,           /* streamtab(9S) */
    D_MP | D_64BIT, /* cb_flag */
    CB_REV,         /* cb_rev */
    xxaread,        /* aread(9E) */
    xxawrite        /* awrite(9E) */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cb_ops(9S)</code> structure contains the entry points for the character
operations and block operations of the device driver. Any entry points
that the driver does not support should be initialized to <code>nodev(9F)</code>.
For example, character device drivers should set all the block-only
fields, such as <code>cb_stategy</code>, to <code>nodev(9F)</code>. Note that the
<code>mmap(9E)</code> entry point is maintained for compatibility with previous
releases. Drivers should use the <code>devmap(9E)</code> entry point for device
memory mapping. If <code>devmap(9E)</code> is supported, set <code>mmap(9E)</code> to
<code>nodev(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>streamtab</code> field indicates whether
the driver is STREAMS-based. Only the network device drivers that are
discussed in <a href="#drivers-for-network-devices">Drivers for Network Devices</a> are STREAMS-based.
All non-STREAMS-based drivers <em>must</em> set the <code>streamtab</code> field to
<code>NULL</code>.</p>
</div>
<div class="paragraph">
<p>The <code>cb_flag</code> member contains the following flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>D_MP</code> flag indicates that the
driver is safe for multithreading. illumos supports only thread-safe
drivers so <code>D_MP</code> must be set.</p>
</li>
<li>
<p>The <code>D_64BIT</code> flag causes the driver to use the <code>uio_loffset</code>
field of the <code>uio(9S)</code> structure. The driver should set the
<code>D_64BIT</code> flag in the <code>cb_flag</code> field to handle 64-bit offsets
properly.</p>
</li>
<li>
<p>The <code>D_DEVMAP</code> flag supports the
<code>devmap(9E)</code> entry point. For information on <code>devmap(9E)</code>, see
<a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel Memory</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>cb_rev</code> is the <code>cb_ops</code> structure revision number. This field
must be set to <code>CB_REV</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loadable-driver-interfaces"><a class="anchor" href="#loadable-driver-interfaces"></a>2.20. Loadable Driver Interfaces</h3>
<div class="paragraph">
<p>Device drivers must be dynamically loadable. Drivers should also be
unloadable to help conserve memory resources. Drivers that can be
unloaded are also easier to test, debug, and patch.</p>
</div>
<div class="paragraph">
<p>Each device driver is required to
implement <code>_init(9E)</code>, <code>_fini(9E)</code>, and <code>_info(9E)</code> entry
points to support driver loading and unloading. The following example
shows a typical implementation of loadable driver interfaces.</p>
</div>
<div id="autoconf-ex-9" class="paragraph">
<p>Loadable Interface Section</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void *statep;                /* for soft state routines */
static struct cb_ops xx_cb_ops;     /* forward reference */
static struct dev_ops xx_ops = {
    DEVO_REV,
    0,
    xxgetinfo,
    nulldev,
    xxprobe,
    xxattach,
    xxdetach,
    xxreset,
    nodev,
    &amp;xx_cb_ops,
    NULL,
};

static struct modldrv modldrv = {
    &amp;mod_driverops,
    "xx driver v1.0",
    &amp;xx_ops
};

static struct modlinkage modlinkage = {
    MODREV_1,
    &amp;modldrv,
};

_init(void)
{
    int error;
    ddi_soft_state_init(&amp;statep, sizeof (struct xxstate),
        estimated_number_of_instances);
    /* further per-module initialization if necessary */
    error = mod_install(&amp;modlinkage);
    if (error != 0) {
        /* undo any per-module initialization done earlier */
        ddi_soft_state_fini(&amp;statep);
    }
    return (error);
}

_fini(void)
{
    int error;
    error = mod_remove(&amp;modlinkage);
    if (error == 0) {
        /* release per-module resources if any were allocated */
        ddi_soft_state_fini(&amp;statep);
    }
    return (error);
}

_info(struct modinfo *modinfop)
{
    return (mod_info(&amp;modlinkage, modinfop));
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_init-example"><a class="anchor" href="#_init-example"></a>2.20.1. <code>_init</code> Example</h4>
<div class="paragraph">
<p>The following example shows a typical <code>_init(9E)</code> interface.</p>
</div>
<div id="autoconf-ex-38" class="paragraph">
<p><code>_init</code> Function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void *xxstatep;
_init(void)
{
    int error;
    const int max_instance = 20;    /* estimated max device instances */

    ddi_soft_state_init(&amp;xxstatep, sizeof (struct xxstate), max_instance);
    error = mod_install(&amp;xxmodlinkage);
    if (error != 0) {
        /*
         * Cleanup after a failure
         */
        ddi_soft_state_fini(&amp;xxstatep);
    }
    return (error);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The driver should perform any one-time
resource allocation or data initialization during driver loading in
<code>_init</code>. For example, the driver should initialize any mutexes
global to the driver in this routine. The driver should not, however,
use <code>_init(9E)</code> to allocate or initialize anything that has to do
with a particular instance of the device. Per-instance initialization
must be done in <code>attach(9E)</code>. For example, if a driver for a printer can
handle more than one printer at the same time, that driver should
allocate resources specific to each printer instance in <code>attach</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Once <code>_init(9E)</code> has called <code>mod_install(9F)</code>, the driver should
not change any of the data structures attached to the <code>modlinkage(9S)</code>
structure because the system might make copies or change the data
structures.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fini-example"><a class="anchor" href="#_fini-example"></a>2.20.2. <code>_fini</code> Example</h4>
<div class="paragraph">
<p>The following example demonstrates the <code>_fini</code> routine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">_fini(void)
{
    int error;
    error = mod_remove(&amp;modlinkage);
    if (error != 0) {
        return (error);
    }
    /*
     * Cleanup resources allocated in _init()
     */
    ddi_soft_state_fini(&amp;xxstatep);
    return (0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, in <code>_fini</code>, the driver should release any
resources that were allocated in <code>_init</code>. The driver must remove
itself from the system module list.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>_fini</code> might be called when the driver is attached to hardware
instances. In this case, <code>mod_remove(9F)</code> returns failure.
Therefore, driver resources should not be released until
<code>mod_remove</code> returns success.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_info-example"><a class="anchor" href="#_info-example"></a>2.20.3. <code>_info</code> Example</h4>
<div class="paragraph">
<p>The following example demonstrates the <code>_info(9E)</code> routine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">_info(struct modinfo *modinfop)
{
    return (mod_info(&amp;xxmodlinkage, modinfop));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The driver is called to return module information. The
entry point should be implemented as shown above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-configuration-concepts"><a class="anchor" href="#device-configuration-concepts"></a>2.21. Device Configuration Concepts</h3>
<div class="paragraph">
<p>For each node in the kernel device tree, the system selects a driver for
the node based on the node name and the <code>compatible</code> property (see
<a href="#binding-a-driver-to-a-device">Binding a Driver to a Device</a>). The same driver might
bind to multiple device nodes. The driver can differentiate different
nodes by instance numbers assigned by the system.</p>
</div>
<div class="paragraph">
<p>After a driver is selected for a device node, the driver&#8217;s <code>probe(9E)</code>
entry point is called to determine the presence of the device on the
system. If <code>probe</code> is successful, the driver&#8217;s <code>attach(9E)</code> entry point
is invoked to set up and manage the device. The device can be opened if
and only if <code>attach</code> returns success (see <a href="#attach-entry-point"> Entry
Point</a>).</p>
</div>
<div class="paragraph">
<p>A device might be unconfigured to conserve system memory resources or to
enable the device to be removed while the system is still running. To
enable the device to be unconfigured, the system first checks whether
the device instance is referenced. This check involves calling the
driver&#8217;s <code>getinfo(9E)</code> entry point to obtain information known only to
the driver (see <a href="#getinfo-entry-point"> Entry Point</a>). If the device
instance is not referenced, the driver&#8217;s <code>detach(9E)</code> routine is invoked
to unconfigure the device (see <a href="#detach-entry-point"> Entry Point</a>).</p>
</div>
<div class="paragraph">
<p>To recap,
each driver must define the following entry points that are used by the
kernel for device configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>probe(9E)</code></p>
</li>
<li>
<p><code>attach(9E)</code></p>
</li>
<li>
<p><code>detach(9E)</code></p>
</li>
<li>
<p><code>getinfo(9E)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that <code>attach</code>, <code>detach</code>, and <code>getinfo</code> are required. <code>probe</code> is
only required for devices that cannot identify themselves. For
self-identifying devices, an explicit <code>probe</code> routine can be provided,
or <code>nulldev(9F)</code> can be specified in the <code>dev_ops</code> structure for the
<code>probe</code> entry point.</p>
</div>
<div class="sect3">
<h4 id="device-instances-and-instance-numbers"><a class="anchor" href="#device-instances-and-instance-numbers"></a>2.21.1. Device Instances and Instance Numbers</h4>
<div class="paragraph">
<p>The system assigns an instance number to
each device. The driver might not reliably predict the value of the
instance number assigned to a particular device. The driver should
retrieve the particular instance number that has been assigned by
calling <code>ddi_get_instance(9F)</code>.</p>
</div>
<div class="paragraph">
<p>Instance numbers represent the system&#8217;s notion of devices. Each
<code>dev_info</code>, that is, each node in the device tree, for a particular
driver is assigned an instance number by the kernel. Furthermore,
instance numbers provide a convenient mechanism for indexing data
specific to a particular physical device. The most common use of
instance numbers is <code>ddi_get_soft_state(9F)</code>, which uses
instance numbers to retrieve soft state data for specific physical
devices.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
For pseudo devices, that is, the children of pseudo nexuses, the
instance numbers are defined in the <code>driver.conf(5)</code> file using the
<code>instance</code> property. If the <code>driver.conf</code> file does not contain the
<code>instance</code> property, the behavior is undefined. For hardware device
nodes, the system assigns instance numbers when the device is first seen
by the OS. The instance numbers persist across system reboots and OS
upgrades.
===
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="minor-nodes-and-minor-numbers"><a class="anchor" href="#minor-nodes-and-minor-numbers"></a>2.21.2. Minor Nodes and Minor Numbers</h4>
<div class="paragraph">
<p>Drivers are responsible for managing their minor number namespace. For
example, the <code>sd</code> driver needs to export eight character minor nodes and
eight block minor nodes to the file system for each disk. Each minor
node represents either a block interface or a character interface to a
portion of the disk. The <code>getinfo(9E)</code> entry point informs the system
about the mapping from minor number to device instance (see
<a href="#getinfo-entry-point"> Entry Point</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="probe-entry-point"><a class="anchor" href="#probe-entry-point"></a>2.21.3. <code>probe</code> Entry Point</h4>
<div class="paragraph">
<p>For non-self-identifying devices, the <code>probe(9E)</code> entry point should
determine whether the hardware device is present on the system.</p>
</div>
<div class="paragraph">
<p>For <code>probe</code> to determine whether the instance of the device is present,
<code>probe</code> needs to perform many tasks that are also commonly done by
<code>attach(9E)</code>. In particular, <code>probe</code> might need to map the device
registers.</p>
</div>
<div class="paragraph">
<p>Probing the device registers is device-specific. The driver often has to
perform a series of tests of the hardware to assure that the hardware is
really present. The test criteria must be rigorous enough to avoid
misidentifying devices. For example, a device might appear to be present
when in fact that device is not available, because a different device
seems to behave like the expected device.</p>
</div>
<div class="paragraph">
<p>The test returns the following flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DDI_PROBE_SUCCESS if the probe was successful</p>
</li>
<li>
<p>DDI_PROBE_FAILURE if the probe failed</p>
</li>
<li>
<p>DDI_PROBE_DONTCARE if the probe was unsuccessful yet
<code>attach(9E)</code> still needs to be called</p>
</li>
<li>
<p>DDI_PROBE_PARTIAL if the instance is not present now, but
might be present in the future</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a given device instance, <code>attach(9E)</code> will not be called until
<code>probe(9E)</code> has succeeded at least once on that device.</p>
</div>
<div class="paragraph">
<p><code>probe(9E)</code> must free all the resources that <code>probe</code> has allocated,
because <code>probe</code> might be called multiple times. However, <code>attach(9E)</code> is
not necessarily called even if <code>probe(9E)</code> has succeeded</p>
</div>
<div class="paragraph">
<p><code>ddi_dev_is_sid(9F)</code> can be used in a driver&#8217;s <code>probe(9E)</code>
routine to determine whether the device is self-identifying.
<code>ddi_dev_is_sid</code> is useful in drivers written for
self-identifying and non-self-identifying versions of the same device.</p>
</div>
<div class="paragraph">
<p>The following example is a sample <code>probe</code> routine.</p>
</div>
<div id="autoconf-27640" class="paragraph">
<p><code>probe(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxprobe(dev_info_t *dip)
{
    ddi_acc_handle_t dev_hdl;
    ddi_device_acc_attr_t dev_attr;
    Pio_csr *csrp;
    uint8_t csrval;

    /*
     * if the device is self identifying, no need to probe
     */
    if (ddi_dev_is_sid(dip) == DDI_SUCCESS)
    return (DDI_PROBE_DONTCARE);

    /*
     * Initalize the device access attributes and map in
     * the devices CSR register (register 0)
     */
    dev_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
    dev_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;

    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&amp;csrp, 0, sizeof (Pio_csr),
    &amp;dev_attr, &amp;dev_hdl) != DDI_SUCCESS)
    return (DDI_PROBE_FAILURE);

    /*
     * Reset the device
     * Once the reset completes the CSR should read back
     * (PIO_DEV_READY | PIO_IDLE_INTR)
     */
    ddi_put8(dev_hdl, csrp, PIO_RESET);
    csrval = ddi_get8(dev_hdl, csrp);

    /*
     * tear down the mappings and return probe success/failure
     */
    ddi_regs_map_free(&amp;dev_hdl);
    if ((csrval &amp; 0xff) == (PIO_DEV_READY | PIO_IDLE_INTR))
    return (DDI_PROBE_SUCCESS);
    return (DDI_PROBE_FAILURE);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the driver&#8217;s <code>probe(9E)</code> routine is called, the driver does not
know whether the device being probed exists on the bus. Therefore, the
driver might attempt to access device registers for a nonexistent
device. A bus fault might be generated on some buses as a result.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>probe(9E)</code> routine that uses
<code>ddi_poke8(9F)</code> to check for the existence of the device.
<code>ddi_poke8</code> cautiously attempts to write a value to a specified
virtual address, using the parent nexus driver to assist in the process
where necessary. If the address is not valid or the value cannot be
written without an error occurring, an error code is returned. See also
<code>ddi_peek(9F)</code>.</p>
</div>
<div class="paragraph">
<p>In this example, <code>ddi_regs_map_setup(9F)</code> is used to map the
device registers.</p>
</div>
<div id="autoconf-42737" class="paragraph">
<p><code>probe(9E)</code> Routine Using <code>ddi_poke8(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxprobe(dev_info_t *dip)
{
    ddi_acc_handle_t dev_hdl;
    ddi_device_acc_attr_t dev_attr;
    Pio_csr *csrp;
    uint8_t csrval;

    /*
     * if the device is self-identifying, no need to probe
     */
    if (ddi_dev_is_sid(dip) == DDI_SUCCESS)
    return (DDI_PROBE_DONTCARE);

    /*
     * Initialize the device access attrributes and map in
     * the device's CSR register (register 0)
     */
    dev_attr.devacc_attr_version - DDI_DEVICE_ATTR_V0;
    dev_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;

    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&amp;csrp, 0, sizeof (Pio_csr),
    &amp;dev_attr, &amp;dev_hdl) != DDI_SUCCESS)
    return (DDI_PROBE_FAILURE);

    /*
     * The bus can generate a fault when probing for devices that
     * do not exist.  Use ddi_poke8(9F) to handle any faults that
     * might occur.
     *
     * Reset the device.  Once the reset completes the CSR should read
     * back (PIO_DEV_READY | PIO_IDLE_INTR)
     */
    if (ddi_poke8(dip, csrp, PIO_RESET) != DDI_SUCCESS) {
    ddi_regs_map_free(&amp;dev_hdl);
    return (DDI_FAILURE);

    csrval = ddi_get8(dev_hdl, csrp);
    /*
     * tear down the mappings and return probe success/failure
     */
    ddi_regs_map_free(&amp;dev_hdl);
    if ((csrval &amp; 0xff) == (PIO_DEV_READY | PIO_IDLE_INTR))
    return (DDI_PROBE_SUCCESS);
    return (DDI_PROBE_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="attach-entry-point"><a class="anchor" href="#attach-entry-point"></a>2.21.4. <code>attach</code> Entry Point</h4>
<div class="paragraph">
<p>The kernel calls a driver&#8217;s <code>attach(9E)</code>
entry point to attach an instance of a device or to resume operation for
an instance of a device that has been suspended or has been shut down by
the power management framework. This section discusses only the
operation of attaching device instances. Power management is discussed
in <a href="#power-management">Power Management</a>.</p>
</div>
<div class="paragraph">
<p>A driver&#8217;s <code>attach(9E)</code> entry point is called to attach each instance of
a device that is bound to the driver. The entry point is called with the
instance of the device node to attach, with <code>DDI_ATTACH</code> specified
as the <code>cmd</code> argument to <code>attach(9E)</code>. The attach entry point typically
includes the following types of processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocating a soft-state structure for the device instance</p>
</li>
<li>
<p>Initializing per-instance mutexes</p>
</li>
<li>
<p>Initializing condition variables</p>
</li>
<li>
<p>Registering the device&#8217;s interrupts</p>
</li>
<li>
<p>Mapping the registers and memory of
the device instance</p>
</li>
<li>
<p>Creating minor device nodes for the device instance</p>
</li>
<li>
<p>Reporting that the device instance has attached</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="driver-soft-state-management"><a class="anchor" href="#driver-soft-state-management"></a>Driver Soft-State Management</h5>
<div class="paragraph">
<p>To assist device driver writers in allocating state
structures, the illumos DDI/DKI provides a set of memory management
routines called <em>software state management routines</em>, which are also
known as the <em>soft-state routines</em>. These routines dynamically allocate,
retrieve, and destroy memory items of a specified size, and hide the
details of list management. An <em>instance number</em> identifies the desired
memory item. This number is typically the instance number assigned by
the system.</p>
</div>
<div class="paragraph">
<p>Drivers typically allocate a soft-state structure for each device
instance that attaches to the driver by calling
<code>ddi_soft_state_zalloc(9F)</code>, passing the instance number of
the device. Because no two device nodes can have the same instance
number, <code>ddi_soft_state_zalloc(9F)</code> fails if an allocation
already exists for a given instance number.</p>
</div>
<div class="paragraph">
<p>A driver&#8217;s character or block entry point (<code>cb_ops(9S)</code>) references
a particular soft state structure by first decoding the device&#8217;s
instance number from the <code>dev_t</code> argument that is passed to the
entry point function. The driver then calls
<code>ddi_get_soft_state(9F)</code>, passing the per-driver soft-state
list and the instance number that was derived. A <code>NULL</code> return value
indicates that effectively the device does not exist and the appropriate
code should be returned by the driver.</p>
</div>
<div class="paragraph">
<p>See <a href="#creating-minor-device-nodes">Creating Minor Device Nodes</a> for additional
information on how instance numbers and device numbers, or
`dev_t&#8217;s, are related.</p>
</div>
</div>
<div class="sect4">
<h5 id="lock-variable-and-conditional-variable-initialization"><a class="anchor" href="#lock-variable-and-conditional-variable-initialization"></a>Lock Variable and Conditional Variable Initialization</h5>
<div class="paragraph">
<p>Drivers should initialize any per-instance locks and condition variables
during attach. The initialization of any locks that are acquired by the
driver&#8217;s interrupt handler <em>must</em> be initialized prior to adding any
interrupt handlers. See <a href="#multithreading">Multithreading</a> for a description
of lock initialization and usage. See <a href="#interrupt-handlers">Interrupt
Handlers</a> for a discussion of interrupt handler and lock issues.</p>
</div>
</div>
<div class="sect4">
<h5 id="creating-minor-device-nodes"><a class="anchor" href="#creating-minor-device-nodes"></a>Creating Minor Device Nodes</h5>
<div class="paragraph">
<p>An important part of the attach process
is the creation of <em>minor nodes</em> for the device instance. A minor node
contains the information exported by the device and the DDI framework.
The system uses this information to create a <em>special file</em> for the
minor node under <code>/devices</code>.</p>
</div>
<div class="paragraph">
<p>Minor nodes are created when the driver calls
<code>ddi_create_minor_node(9F)</code>. The driver supplies a <em>minor
number</em>, a <em>minor name</em>, a <em>minor node type</em>, and whether the minor node
represents a block or character device.</p>
</div>
<div class="paragraph">
<p>Drivers can create any number of minor nodes for a device. The illumos
DDI/DKI expects certain classes of devices to have minor nodes created
in a particular format. For example, disk drivers are expected to create
16 minor nodes for each physical disk instance attached. Eight minor
nodes are created, representing the <code>a - h</code> block device interfaces,
with an additional eight minor nodes for the <code>a,raw - h,raw</code> character
device interfaces.</p>
</div>
<div class="paragraph">
<p>The <em>minor number</em> passed to <code>ddi_create_minor_node(9F)</code> is
defined wholly by the driver. The minor number is usually an encoding of
the instance number of the device with a minor node identifier. In the
preceding example, the driver creates minor numbers for each of the
minor nodes by shifting the instance number of the device left by three
bits and using the OR of that result with the minor node index. The
values of the minor node index range from 0 to 7. Note that minor nodes
<code>a</code> and <code>a,raw</code> share the same minor number. These minor nodes are
distinguished by the <code>spec_type</code> argument passed to
<code>ddi_create_minor_node</code>.</p>
</div>
<div class="paragraph">
<p>The <em>minor
node type</em> passed to <code>ddi_create_minor_node(9F)</code> classifies
the type of device, such as disks, tapes, network interfaces, frame
buffers, and so forth.</p>
</div>
<div class="paragraph">
<p>The following table lists the types of possible nodes that might be
created.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Possible Node Types</caption>
<colgroup>
<col style="width: 29%;">
<col style="width: 71%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Constant</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_SERIAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Serial port</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_SERIAL_DO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dialout ports</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_BLOCK</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hard disks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_BLOCK_CHAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hard disks with channel or target</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_CD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ROM drives (CD-ROM)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_CD_CHAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ROM drives with channel or target numbers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_FD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floppy disks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_TAPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tape drives</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_NET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Network devices</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_DISPLAY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display devices</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_MOUSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mouse</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_KEYBOARD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keyboard</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_NT_AUDIO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Audio Device</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DDI_PSEUDO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">General pseudo devices</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The node types <code>DDI_NT_BLOCK</code>, <code>DDI_NT_BLOCK_CHAN</code>,
<code>DDI_NT_CD</code>, and <code>DDI_NT_CD_CHAN</code> cause
<code>devfsadm(8)</code> to identify the device instance as a disk and to create
names in the <code>/dev/dsk</code> or <code>/dev/rdsk</code> directory.</p>
</div>
<div class="paragraph">
<p>The node type <code>DDI_NT_TAPE</code> causes <code>devfsadm(8)</code> to identify the
device instance as a tape and to create names in the <code>/dev/rmt</code>
directory.</p>
</div>
<div class="paragraph">
<p>The node types <code>DDI_NT_SERIAL</code> and
<code>DDI_NT_SERIAL_DO</code> cause <code>devfsadm(8)</code> to perform these
actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the device instance as a serial port</p>
</li>
<li>
<p>Create names in the <code>/dev/term</code> directory</p>
</li>
<li>
<p>Add entries to the <code>/etc/inittab</code> file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vendor-supplied strings should include an identifying value such as a
name or stock symbol to make the strings unique. The string can be used
in conjunction with <code>devfsadm(8)</code> and the <code>devlinks.tab</code> file (see the
<code>devlinks(8)</code> man page) to create logical names in <code>/dev</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="deferred-attach"><a class="anchor" href="#deferred-attach"></a>Deferred Attach</h5>
<div class="paragraph">
<p><code>open(9E)</code> might be called on a minor device before <code>attach(9E)</code> has
succeeded on the corresponding instance. <code>open</code> must then return
<code>ENXIO</code>, which causes the system to attempt to attach the device. If the
<code>attach</code> succeeds, the <code>open</code> is retried automatically.</p>
</div>
<div id="autoconf-ex-35" class="paragraph">
<p>Typical <code>attach</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * Attach an instance of the driver.  We take all the knowledge we
 * have about our board and check it against what has been filled in
 * for us from our FCode or from our driver.conf(4) file.
 */
static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance;
    Pio *pio_p;
    ddi_device_acc_attr_t   da_attr;
    static int pio_validate_device(dev_info_t *);

    switch (cmd) {
    case DDI_ATTACH:
    /*
     * first validate the device conforms to a configuration this driver
     * supports
     */
    if (pio_validate_device(dip) == 0)
        return (DDI_FAILURE);
    /*
     * Allocate a soft state structure for this device instance
     * Store a pointer to the device node in our soft state structure
     * and a reference to the soft state structure in the device
     * node.
     */
    instance = ddi_get_instance(dip);
    if (ddi_soft_state_zalloc(pio_softstate, instance) != 0)
        return (DDI_FAILURE);
    pio_p = ddi_get_soft_state(pio_softstate, instance);
    ddi_set_driver_private(dip, (caddr_t)pio_p);
    pio_p-&gt;dip = dip;
    /*
     * Before adding the interrupt, get the interrupt block
     * cookie associated with the interrupt specification to
     * initialize the mutex used by the interrupt handler.
     */
    if (ddi_get_iblock_cookie(dip, 0, &amp;pio_p-&gt;iblock_cookie) !=
      DDI_SUCCESS) {
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }

    mutex_init(&amp;pio_p-&gt;mutex, NULL, MUTEX_DRIVER, pio_p-&gt;iblock_cookie);
    /*
     * Now that the mutex is initialized, add the interrupt itself.
     */
    if (ddi_add_intr(dip, 0, NULL, NULL, pio_intr, (caddr_t)instance) !=
      DDI_SUCCESS) {
        mutex_destroy(&amp;pio_p&gt;mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Initialize the device access attributes for the register mapping
     */
    dev_acc_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
    dev_acc_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
    dev_acc_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
    /*
     * Map in the csr register (register 0)
     */
    if (ddi_regs_map_setup(dip, 0, (caddr_t *)&amp;(pio_p-&gt;csr), 0,
        sizeof (Pio_csr), &amp;dev_acc_attr, &amp;pio_p-&gt;csr_handle) !=
        DDI_SUCCESS) {
        ddi_remove_intr(pio_p-&gt;dip, 0, pio_p-&gt;iblock_cookie);
        mutex_destroy(&amp;pio_p-&gt;mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Map in the data register (register 1)
     */
    if (ddi_regs_map_setup(dip, 1, (caddr_t *)&amp;(pio_p-&gt;data), 0,
        sizeof (uchar_t), &amp;dev_acc_attr, &amp;pio_p-&gt;data_handle) !=
        DDI_SUCCESS) {
        ddi_remove_intr(pio_p-&gt;dip, 0, pio_p-&gt;iblock_cookie);
        ddi_regs_map_free(&amp;pio_p-&gt;csr_handle);
        mutex_destroy(&amp;pio_p-&gt;mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * Create an entry in /devices for user processes to open(2)
     * This driver will create a minor node entry in /devices
     * of the form:  /devices/..../pio@X,Y:pio
     */
    if (ddi_create_minor_node(dip, ddi_get_name(dip), S_IFCHR,
        instance, DDI_PSEUDO, 0) == DDI_FAILURE) {
        ddi_remove_intr(pio_p-&gt;dip, 0, pio_p-&gt;iblock_cookie);
        ddi_regs_map_free(&amp;pio_p-&gt;csr_handle);
        ddi_regs_map_free(&amp;pio_p-&gt;data_handle);
        mutex_destroy(&amp;pio_p-&gt;mutex);
        ddi_soft_state_free(pio_softstate, instance);
        return (DDI_FAILURE);
    }
    /*
     * reset device (including disabling interrupts)
     */
    ddi_put8(pio_p-&gt;csr_handle, pio_p-&gt;csr, PIO_RESET);
    /*
     * report the name of the device instance which has attached
     */
    ddi_report_dev(dip);
    return (DDI_SUCCESS);

    case DDI_RESUME:
    return (DDI_SUCCESS);

    default:
    return (DDI_FAILURE);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>attach</code> routine must not make any assumptions about the order of
invocations on different device instances. The system might invoke
<code>attach</code> concurrently on different device instances. The system might
also invoke <code>attach</code> and <code>detach</code> concurrently on different device
instances.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="detach-entry-point"><a class="anchor" href="#detach-entry-point"></a>2.21.5. <code>detach</code> Entry Point</h4>
<div class="paragraph">
<p>The kernel calls a driver&#8217;s <code>detach(9E)</code>
entry point to detach an instance of a device or to suspend operation
for an instance of a device by power management. This section discusses
the operation of detaching device instances. Refer to
<a href="#power-management">Power Management</a> for a discussion of power
management issues.</p>
</div>
<div class="paragraph">
<p>A driver&#8217;s <code>detach</code> entry point is called to detach an instance of a
device that is bound to the driver. The entry point is called with the
instance of the device node to be detached and with <code>DDI_DETACH</code>,
which is specified as the <code>cmd</code> argument to the entry point.</p>
</div>
<div class="paragraph">
<p>A driver is required to cancel or wait for any time outs or callbacks to
complete, then release any resources that are allocated to the device
instance before returning. If for some reason a driver cannot cancel
outstanding callbacks for free resources, the driver is required to
return the device to its original state and return <code>DDI_FAILURE</code>
from the entry point, leaving the device instance in the attached state.</p>
</div>
<div class="paragraph">
<p>There are two types of callback routines: those callbacks that can be
canceled and those that cannot be canceled. <code>timeout(9F)</code> and
<code>bufcall(9F)</code> callbacks can be atomically cancelled by the driver during
<code>detach(9E)</code>. Other types of callbacks such as
<code>scsi_init_pkt(9F)</code> and
<code>ddi_dma_buf_bind_handle(9F)</code> cannot be canceled. The
driver must either block in <code>detach</code> until the callback completes or
else fail the request to detach.</p>
</div>
<div id="autoconf-ex-15" class="paragraph">
<p>Typical <code>detach</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * detach(9E)
 * free the resources that were allocated in attach(9E)
 */
static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    Pio     *pio_p;
    int     instance;

    switch (cmd) {
    case DDI_DETACH:

    instance = ddi_get_instance(dip);
    pio_p = ddi_get_soft_state(pio_softstate, instance);

    /*
     * turn off the device
     * free any resources allocated in attach
     */
    ddi_put8(pio_p-&gt;csr_handle, pio_p-&gt;csr, PIO_RESET);
    ddi_remove_minor_node(dip, NULL);
    ddi_regs_map_free(&amp;pio_p-&gt;csr_handle);
    ddi_regs_map_free(&amp;pio_p-&gt;data_handle);
    ddi_remove_intr(pio_p-&gt;dip, 0, pio_p-&gt;iblock_cookie);
    mutex_destroy(&amp;pio_p-&gt;mutex);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_SUCCESS);

    case DDI_SUSPEND:
    default:
    return (DDI_FAILURE);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getinfo-entry-point"><a class="anchor" href="#getinfo-entry-point"></a>2.21.6. <code>getinfo</code> Entry Point</h4>
<div class="paragraph">
<p>The system calls <code>getinfo(9E)</code> to obtain
configuration information that only the driver knows. The mapping of
minor numbers to device instances is entirely under the control of the
driver. The system sometimes needs to ask the driver which device a
particular <code>dev_t</code> represents.</p>
</div>
<div class="paragraph">
<p><code>getinfo</code> function can take either <code>DDI_INFO_DEVT2INSTANCE</code> or
<code>DDI_INFO_DEVT2DEVINFO</code> as its &lt;infocmd&gt; argument. The
<code>DDI_INFO_DEVT2INSTANCE</code> command requests the instance number of
a device. The <code>DDI_INFO_DEVT2DEVINFO</code> command requests a pointer
to the <code>dev_info</code> structure of a device.</p>
</div>
<div class="paragraph">
<p>In the <code>DDI_INFO_DEVT2INSTANCE</code> case, &lt;arg&gt; is a
<code>dev_t</code>, and <code>getinfo</code> must translate the minor number in
<code>dev_t</code> to an instance number. In the following example, the minor
number <em>is</em> the instance number, so <code>getinfo</code> simply passes back the
minor number. In this case, the driver must not assume that a state
structure is available, since <code>getinfo</code> might be called before <code>attach</code>.
The mapping defined by the driver between the minor device number and
the instance number does not necessarily follow the mapping shown in the
example. In all cases, however, the mapping must be static.</p>
</div>
<div class="paragraph">
<p>In the <code>DDI_INFO_DEVT2DEVINFO</code> case, &lt;arg&gt; is again a
<code>dev_t</code>, so <code>getinfo</code> first decodes the instance number for the
device. <code>getinfo</code> then passes back the <code>dev_info</code> pointer saved in
the driver&#8217;s soft state structure for the appropriate device, as shown
in the following example.</p>
</div>
<div id="autoconf-16720" class="paragraph">
<p>Typical <code>getinfo</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * getinfo(9E)
 * Return the instance number or device node given a dev_t
 */
static int
xxgetinfo(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
{
    int error;
    Pio *pio_p;
    int instance = getminor((dev_t)arg);

    switch (infocmd) {
    /*
     * return the device node if the driver has attached the
     * device instance identified by the dev_t value which was passed
     */
    case DDI_INFO_DEVT2DEVINFO:
    pio_p = ddi_get_soft_state(pio_softstate, instance);
    if (pio_p == NULL) {
        *result = NULL;
        error = DDI_FAILURE;
    } else {
        mutex_enter(&amp;pio_p-&gt;mutex);
        *result = pio_p-&gt;dip;
        mutex_exit(&amp;pio_p-&gt;mutex);
        error = DDI_SUCCESS;
    }
    break;
    /*
     * the driver can always return the instance number given a dev_t
     * value, even if the instance is not attached.
     */
    case DDI_INFO_DEVT2INSTANCE:
    *result = (void *)instance;
    error = DDI_SUCCESS;
    break;
    default:
    *result = NULL;
    error = DDI_FAILURE;
    }
    return (error);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>getinfo</code> routine must be kept in sync with the minor nodes that the
driver creates. If the minor nodes get out of sync, any hotplug
operations might fail and cause a system panic.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-device-ids"><a class="anchor" href="#using-device-ids"></a>2.22. Using Device IDs</h3>
<div class="paragraph">
<p>The illumos DDI interfaces enable drivers to provide the <em>device ID</em>, a
persistent unique identifier for a device. The <em>device ID</em> can be used
to identify or locate a device. The <em>device ID</em> is independent of the
<code>/devices</code> name or device number (<code>dev_t</code>). Applications can use the
functions defined in <code>libdevid(3LIB)</code> to read and manipulate the device
IDs registered by the drivers.</p>
</div>
<div class="paragraph">
<p>Before a driver can export a <em>device ID</em>, the driver needs to verify the
device is capable of either providing a unique ID or of storing a
host-generated unique ID in a not normally accessible area. WWN
(world-wide number) is an example of a unique ID that is provided by the
device. Device NVRAM and reserved sectors are examples of non-accessible
areas where host-generated unique IDs can be safely stored.</p>
</div>
<div class="sect3">
<h4 id="registering-device-ids"><a class="anchor" href="#registering-device-ids"></a>2.22.1. Registering Device IDs</h4>
<div class="paragraph">
<p>Drivers typically initialize and register device IDs in the driver&#8217;s
<code>attach(9E)</code> handler. As mentioned above, the driver is responsible for
registering a <em>device ID</em> that is persistent. As such, the driver might
be required to handle both devices that can provide a unique ID directly
(WWN) and devices where fabricated IDs are written to and read from
stable storage.</p>
</div>
<div class="sect4">
<h5 id="registering-a-device-supplied-id"><a class="anchor" href="#registering-a-device-supplied-id"></a>Registering a Device-Supplied ID</h5>
<div class="paragraph">
<p>If the device can supply the driver with an identifier that is unique,
the driver can simply initialize the <em>device ID</em> with this identifier
and register the ID with the illumos DDI.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * The device provides a guaranteed unique identifier,
 * in this case a SCSI3-WWN.  The WWN for the device has been
 * stored in the device's soft state.
 */
if (ddi_devid_init(dip, DEVID_SCSI3_WWN, un-&gt;un_wwn_len, un-&gt;un_wwn,
    &amp;un-&gt;un_devid) != DDI_SUCCESS)
    return (DDI_FAILURE);

(void) ddi_devid_register(dip, un-&gt;un_devid);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="registering-a-fabricated-id"><a class="anchor" href="#registering-a-fabricated-id"></a>Registering a Fabricated ID</h5>
<div class="paragraph">
<p>A driver might also register device IDs for devices that do not directly
supply a unique ID. Registering these IDs requires the device to be
capable of storing and retrieving a small amount of data in a reserved
area. The driver can then create a fabricated device ID and write it to
the reserved area.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * the device doesn't supply a unique ID, attempt to read
 * a fabricated ID from the device's reserved data.
 */
if (xxx_read_deviceid(un, &amp;devid_buf) == XXX_OK) {
    if (ddi_devid_valid(devid_buf) == DDI_SUCCESS) {
        devid_sz = ddi_devi_sizeof(devid_buf);
        un-&gt;un_devid = kmem_alloc(devid_sz, KM_SLEEP);
        bcopy(devid_buf, un-&gt;un_devid, devid_sz);
        ddi_devid_register(dip, un-&gt;un_devid);
        return (XXX_OK);
    }
}
/*
 * we failed to read a valid device ID from the device
 * fabricate an ID, store it on the device, and register
 * it with the DDI
 */
if (ddi_devid_init(dip, DEVID_FAB, 0, NULL, &amp;un-&gt;un_devid)
    == DDI_FAILURE) {
    return (XXX_FAILURE);
}
if (xxx_write_deviceid(un) != XXX_OK) {
    ddi_devid_free(un-&gt;un_devid);
    un-&gt;un_devid = NULL;
    return (XXX_FAILURE);
}
ddi_devid_register(dip, un-&gt;un_devid);
return (XXX_OK);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unregistering-device-ids"><a class="anchor" href="#unregistering-device-ids"></a>2.22.2. Unregistering Device IDs</h4>
<div class="paragraph">
<p>Drivers typically unregister and free any <em>device IDs</em> that are
allocated as part of the <code>detach(9E)</code> handling. The driver first calls
<code>ddi_devid_unregister(9F)</code> to unregister the <em>device ID</em> for the
device instance. The driver must then free the <em>device ID</em> handle itself
by calling <code>ddi_devid_free(9F)</code>, and then passing the handle
that had been returned by <code>ddi_devid_init(9F)</code>. The driver is
responsible for managing any space allocated for WWN or Serial Number
data.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-access-programmed-io"><a class="anchor" href="#device-access-programmed-io"></a>2.23. Device Access: Programmed I/O</h3>
<div class="paragraph">
<p>illumos provides driver developers with a comprehensive set of
interfaces for accessing device memory. These interfaces are designed to
shield the driver from platform-specific dependencies by handling
mismatches between processor and device endianness as well as enforcing
any data order dependencies the device might have. By using these
interfaces, you can develop a single-source driver that runs on both the
SPARC and x86 processor architectures as well as the various platforms
from each respective processor family.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#managing-differences-in-device-and-host-endianness">Managing Differences in Device and Host Endianness</a></p>
</li>
<li>
<p><a href="#managing-data-ordering-requirements">Managing Data Ordering Requirements</a></p>
</li>
<li>
<p><a href="#ddideviceacc_attr-structure"> Structure</a></p>
</li>
<li>
<p><a href="#mapping-device-memory">Mapping Device Memory</a></p>
</li>
<li>
<p><a href="#mapping-setup-example">Mapping Setup Example</a></p>
</li>
<li>
<p><a href="#alternate-device-access-interfaces">Alternate Device Access Interfaces</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="device-memory"><a class="anchor" href="#device-memory"></a>2.24. Device Memory</h3>
<div class="paragraph">
<p>Devices that support programmed I/O are assigned one or more regions of
bus address space that map to addressable regions of the device. These
mappings are described as pairs of values in the <code>reg</code> property
associated with the device. Each value pair describes a segment of a bus
address.</p>
</div>
<div class="paragraph">
<p>Drivers identify a particular bus address mapping by specifying the
register number, or <code>regspec</code>, which is an index into the devices' <code>reg</code>
property. The <code>reg</code> property identifies the <code>busaddr</code> and <code>size</code> for the
device. Drivers pass the register number when making calls to DDI
functions such as <code>ddi_regs_map_setup(9F)</code>. Drivers can
determine how many mappable regions have been assigned to the device by
calling <code>ddi_dev_nregs(9F)</code>.</p>
</div>
<div class="sect3">
<h4 id="managing-differences-in-device-and-host-endianness"><a class="anchor" href="#managing-differences-in-device-and-host-endianness"></a>2.24.1. Managing Differences in Device and Host Endianness</h4>
<div class="paragraph">
<p>The data format of the host can have different endian characteristics
than the data format of the device. In such a case, data transferred
between the host and device would need to be byte-swapped to conform to
the data format requirements of the destination location. Devices with
the same endian characteristics of the host require no byte-swapping of
the data.</p>
</div>
<div class="paragraph">
<p>Drivers specify the endian characteristics of the device by setting the
appropriate flag in the <code>ddi_device_acc_attr(9S)</code> structure
that is passed to <code>ddi_regs_map_setup(9F)</code>. The DDI
framework then performs any required byte-swapping when the driver calls
a <code>ddi_get`<em>X</em> routine like `ddi_get8(9F)</code> or a <code>ddi_put`<em>X</em>
routine like `ddi_put16(9F)</code> to read or write to device memory.</p>
</div>
</div>
<div class="sect3">
<h4 id="managing-data-ordering-requirements"><a class="anchor" href="#managing-data-ordering-requirements"></a>2.24.2. Managing Data Ordering Requirements</h4>
<div class="paragraph">
<p>Platforms can reorder loads and stores of data to optimize performance
of the platform. Because reordering might not be allowed by certain
devices, the driver is required to specify the device&#8217;s ordering
requirements when setting up mappings to the device.</p>
</div>
</div>
<div class="sect3">
<h4 id="ddideviceacc_attr-structure"><a class="anchor" href="#ddideviceacc_attr-structure"></a>2.24.3. <code>ddi_device_acc_attr</code> Structure</h4>
<div class="paragraph">
<p>This structure describes the endian and data order
requirements of the device. The driver is required to initialize and
pass this structure as an argument to
<code>ddi_regs_map_setup(9F)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct ddi_device_acc_attr {
    ushort_t    devacc_attr_version;
    uchar_t     devacc_attr_endian_flags;
    uchar_t     devacc_attr_dataorder;
} ddi_device_acc_attr_t;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>devacc_attr_version</code></dt>
<dd>
<p>Specifies <code>DDI_DEVICE_ATTR_V0</code></p>
</dd>
<dt class="hdlist1"><code>devacc_attr_endian_flags</code></dt>
<dd>
<p>Describes the endian characteristics of the device. Specified as a bit
value whose possible values are:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>DDI_NEVERSWAP_ACC</code> – Never swap data</p>
</li>
<li>
<p><code>DDI_STRUCTURE_BE_ACC</code> – The device data format is
big-endian</p>
</li>
<li>
<p><code>DDI_STRUCTURE_LE_ACC</code> – The device data format is
little-endian</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>devacc_attr_dataorder</code></dt>
<dd>
<p>Describes the order in which the CPU must reference data as required
by the device. Specified as an enumerated value, where data access
restrictions are ordered from most strict to least strict.
+</p>
<div class="ulist">
<ul>
<li>
<p><code>DDI_STRICTORDER_ACC</code> – The host must issue the references
in order, as specified by the programmer. This flag is the default
behavior.</p>
</li>
<li>
<p><code>DDI_UNORDERED_OK_ACC</code> – The host is allowed to reorder
loads and stores to device memory.</p>
</li>
<li>
<p><code>DDI_MERGING_OK_ACC</code> – The host is allowed to merge
individual stores to consecutive locations. This setting also implies
reordering.</p>
</li>
<li>
<p><code>DDI_LOADCACHING_OK_ACC</code> – The host is allowed to read
data from the device until a store occurs.</p>
</li>
<li>
<p><code>DDI_STORECACHING_OK_ACC</code> – The host is allowed to cache
data written to the device. The host can then defer writing the data
to the device until a future time.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The system can access data more strictly than the driver specifies in
<code>devacc_attr_dataorder</code>. The restriction to the host diminishes
while moving from strict data ordering to cache storing in terms of data
accesses by the driver.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mapping-device-memory"><a class="anchor" href="#mapping-device-memory"></a>2.24.4. Mapping Device Memory</h4>
<div class="paragraph">
<p>Drivers typically map all regions of a device during <code>attach(9E)</code>. The
driver maps a region of device memory by calling
<code>ddi_regs_map_setup(9F)</code>, specifying the register number of
the region to map, the device access attributes for the region, an
offset, and size. The DDI framework sets up the mappings for the device
region and returns an opaque handle to the driver. This data access
handle is passed as an argument to the <code>ddi_get8(9F)</code> or
<code>ddi_put8(9F)</code> family of routines when reading data from or writing
data to that region of the device.</p>
</div>
<div class="paragraph">
<p>The driver verifies that the shape of the device mappings match what the
driver is expecting by checking the number of mappings exported by the
device. The driver calls <code>ddi_dev_nregs(9F)</code> and then verifies
the size of each mapping by calling <code>ddi_dev_regsize(9F)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mapping-setup-example"><a class="anchor" href="#mapping-setup-example"></a>2.24.5. Mapping Setup Example</h4>
<div class="paragraph">
<p>The following simple example demonstrates the DDI data access
interfaces. This driver is for a fictional little endian device that
accepts one character at a time and generates an interrupt when ready
for another character. This device implements two register sets: the
first is an 8-bit CSR register, and the second is an 8-bit data
register.</p>
</div>
<div id="devaccess-ex-24" class="paragraph">
<p>Mapping Setup</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define CSR_REG 0
#define DATA_REG 1
/*
 * Initialize the device access attributes for the register
 * mapping
 */
dev_acc_attr.devacc_attr_version = DDI_DEVICE_ATTR_V0;
dev_acc_attr.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;
dev_acc_attr.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
/*
 * Map in the csr register (register 0)
 */
if (ddi_regs_map_setup(dip, CSR_REG, (caddr_t *)&amp;(pio_p-&gt;csr), 0,
  sizeof (Pio_csr), &amp;dev_acc_attr, &amp;pio_p-&gt;csr_handle) != DDI_SUCCESS) {
    mutex_destroy(&amp;pio_p-&gt;mutex);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_FAILURE);
}
/*
 * Map in the data register (register 1)
 */
if (ddi_regs_map_setup(dip, DATA_REG, (caddr_t *)&amp;(pio_p-&gt;data), 0,
  sizeof (uchar_t), &amp;dev_acc_attr, &amp;pio_p-&gt;data_handle) \
  != DDI_SUCCESS) {
    mutex_destroy(&amp;pio_p-&gt;mutex);
    ddi_regs_map_free(&amp;pio_p-&gt;csr_handle);
    ddi_soft_state_free(pio_softstate, instance);
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-access-functions"><a class="anchor" href="#device-access-functions"></a>2.25. Device Access Functions</h3>
<div class="paragraph">
<p>Drivers use the <code>ddi_get8(9F)</code> and <code>ddi_put8(9F)</code> family of
routines in conjunction with the handle returned by
<code>ddi_regs_map_setup(9F)</code> to transfer data to and from a
device. The DDI framework automatically handles any byte-swapping that
is required to meet the endian format for the host or device, and
enforces any store-ordering constraints the device might have.</p>
</div>
<div class="paragraph">
<p>The DDI provides interfaces for transferring data in 8-bit, 16-bit,
32-bit, and 64-bit quantities, as well as interfaces for transferring
multiple values repeatedly. See the man pages for the
<code>ddi_get8(9F)</code>, <code>ddi_put8(9F)</code>, <code>ddi_rep_get8(9F)</code> and
<code>ddi_rep_put8(9F)</code> families of routines for a complete listing
and description of these interfaces.</p>
</div>
<div class="paragraph">
<p>The following example builds on <a href="#devaccess-ex-24">example_title</a>
where the driver mapped the device&#8217;s CSR and data registers. Here, the
driver&#8217;s <code>write(9E)</code> entry point, when called, writes a buffer of data
to the device one byte at a time.</p>
</div>
<div id="devaccess-ex-26" class="paragraph">
<p>Mapping Setup: Buffer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static  int
pio_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    int  retval;
    int  error = OK;
    Pio *pio_p = ddi_get_soft_state(pio_softstate, getminor(dev));

    if (pio_p == NULL)
        return (ENXIO);
    mutex_enter(&amp;pio_p-&gt;mutex);
    /*
     * enable interrupts from the device by setting the Interrupt
     * Enable bit in the devices CSR register
     */
    ddi_put8(pio_p-&gt;csr_handle, pio_p-&gt;csr,
      (ddi_get8(pio_p-&gt;csr_handle, pio_p-&gt;csr) | PIO_INTR_ENABLE));

    while (uiop-&gt;uio_resid &gt; 0) {
    /*
     * This device issues an IDLE interrupt when it is ready
     * to accept a character; the interrupt can be cleared
     * by setting PIO_INTR_CLEAR.  The interrupt is reasserted
     * after the next character is written or the next time
     * PIO_INTR_ENABLE is toggled on.
     *
     * wait for interrupt (see pio_intr)
     */
        cv_wait(&amp;pio_p-&gt;cv, &amp;pio_p-&gt;mutex);

    /*
     * get a character from the user's write request
     * fail the write request if any errors are encountered
     */
        if ((retval = uwritec(uiop)) == -1) {
            error = retval;
            break;
        }

    /*
     * pass the character to the device by writing it to
     * the device's data register
     */
        ddi_put8(pio_p-&gt;data_handle, pio_p-&gt;data, (uchar_t)retval);
    }

    /*
     * disable interrupts by clearing the Interrupt Enable bit
     * in the CSR
     */
    ddi_put8(pio_p-&gt;csr_handle, pio_p-&gt;csr,
      (ddi_get8(pio_p-&gt;csr_handle, pio_p-&gt;csr) &amp; ~PIO_INTR_ENABLE));

    mutex_exit(&amp;pio_p-&gt;mutex);
    return (error);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="alternate-device-access-interfaces"><a class="anchor" href="#alternate-device-access-interfaces"></a>2.25.1. Alternate Device Access Interfaces</h4>
<div class="paragraph">
<p>In addition to implementing all device accesses through the
<code>ddi_get8(9F)</code> and <code>ddi_put8(9F)</code> families of interfaces,
illumos provides interfaces that are specific to particular bus
implementations. While these functions can be more efficient on some
platforms, use of these routines can limit the ability of the driver to
remain portable across different bus versions of the device.</p>
</div>
<div class="sect4">
<h5 id="memory-space-access"><a class="anchor" href="#memory-space-access"></a>Memory Space Access</h5>
<div class="paragraph">
<p>With memory mapped access, device registers appear in memory address
space. The `ddi_get`<em>X</em> family of routines and the `ddi_put`<em>X</em>
family are available for use by drivers as an alternative to the
standard device access interfaces.</p>
</div>
</div>
<div class="sect4">
<h5 id="io-space-access"><a class="anchor" href="#io-space-access"></a>I/O Space Access</h5>
<div class="paragraph">
<p>With I/O space access, the device registers appear in I/O space, where
each addressable element is called an I/O port. The
<code>ddi_io_get8(9F)</code> and <code>ddi_io_put8(9F)</code> routines are
available for use by drivers as an alternative to the standard device
access interfaces.</p>
</div>
</div>
<div class="sect4">
<h5 id="pci-configuration-space-access"><a class="anchor" href="#pci-configuration-space-access"></a>PCI Configuration Space Access</h5>
<div class="paragraph">
<p>To access PCI configuration space without using the normal device access
interfaces, a driver is required to map PCI configuration space by
calling <code>pci_config_setup(9F)</code> in place of
<code>ddi_regs_map_setup(9F)</code>. The driver can then call the
<code>pci_config_get8(9F)</code> and <code>pci_config_put8(9F)</code> families
of interfaces to access PCI configuration space.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-handlers"><a class="anchor" href="#interrupt-handlers"></a>2.26. Interrupt Handlers</h3>
<div class="paragraph">
<p>writing handlers</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>This chapter describes mechanisms for handling interrupts, such as
registering, servicing, and removing interrupts. This chapter provides
information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#interrupt-handler-overview">Interrupt Handler Overview</a></p>
</li>
<li>
<p><a href="#device-interrupts">Device Interrupts</a></p>
</li>
<li>
<p><a href="#registering-interrupts">Registering Interrupts</a></p>
</li>
<li>
<p><a href="#interrupt-handler-functionality">Interrupt Handler Functionality</a></p>
</li>
<li>
<p><a href="#handling-high-level-interrupts">Handling High-Level Interrupts</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-handler-overview"><a class="anchor" href="#interrupt-handler-overview"></a>2.27. Interrupt Handler Overview</h3>
<div class="paragraph">
<p>An interrupt is a hardware signal from a
device to a CPU. An interrupt tells the CPU that the device needs
attention and that the CPU should stop any current activity and respond
to the device. If the CPU is not performing a task that has higher
priority than the priority of the interrupt, then the CPU suspends the
current thread. The CPU then invokes the interrupt handler for the
device that sent the interrupt signal. The job of the interrupt handler
is to service the device and stop the device from interrupting. When the
interrupt handler returns, the CPU resumes the work it was doing before
the interrupt occurred.</p>
</div>
<div class="paragraph">
<p>The illumos DDI/DKI provides interfaces for performing the following
tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Determining interrupt type and registration requirements</p>
</li>
<li>
<p>Registering interrupts</p>
</li>
<li>
<p>Servicing interrupts</p>
</li>
<li>
<p>Masking interrupts</p>
</li>
<li>
<p>Getting interrupt pending information</p>
</li>
<li>
<p>Getting and setting priority information</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="device-interrupts"><a class="anchor" href="#device-interrupts"></a>2.28. Device Interrupts</h3>
<div class="paragraph">
<p>device interrupts</p>
</div>
<div class="paragraph">
<p>interrupts; interrupt handling</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  I/O buses implement interrupts in two
common ways: _vectored_ and _polled_. Both methods commonly supply a
bus-interrupt priority level. Vectored devices also supply an interrupt
vector. Polled devices do not supply interrupt vectors.</pre>
</div>
</div>
<div class="paragraph">
<p>To stay current with changing bus technologies, illumos has been
enhanced to accommodate both newer types of interrupts and more
traditional interrupts that have been in use for many years.
Specifically, the operating system now recognizes three types of
interrupts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Legacy interrupts</strong> –
<em>Legacy</em> or <em>fixed interrupts</em> refer to interrupts that use older bus
technologies. With these technologies, interrupts are signaled by using
one or more external pins that are wired “out-of-band,” that is,
separately from the main lines of the bus. Newer bus technologies such
as PCI Express maintain software compatibility by emulating legacy
interrupts through in-band mechanisms. These emulated interrupts are
treated as legacy interrupts by the host OS.</p>
</li>
<li>
<p><strong>Message-signaled
interrupts</strong> – Instead of using pins, message-signaled interrupts (MSI)
are in-band messages and can target addresses in the host bridge. (See
<a href="#pci-local-bus">PCI Local Bus</a> for more information on host bridges.)
MSIs can send data along with the interrupt message. Each MSI is
unshared so that an MSI that is assigned to a device is guaranteed to be
unique within the system. A PCI function can request up to 32 MSI
messages.</p>
</li>
<li>
<p><strong>Extended message-signaled
interrupts</strong> – Extended message-signaled interrupts (MSI-X) are an
enhanced version of MSIs. MSI-X interrupts have the following added
advantages:</p>
<div class="ulist">
<ul>
<li>
<p>Support 2048 messages rather than 32 messages</p>
</li>
<li>
<p>Support independent message address and message data for each message</p>
</li>
<li>
<p>Support per-message masking</p>
</li>
<li>
<p>Enable more flexibility when software allocates fewer vectors than
hardware requests. The software can reuse the same MSI-X address and
data in multiple MSI-X slots.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some newer bus technologies such as PCI Express require MSIs but can
accommodate legacy interrupts by using INTx emulation. INTx emulation is
used for compatibility purposes, but is not considered to be good
practice.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="high-level-interrupts"><a class="anchor" href="#high-level-interrupts"></a>2.28.1. High-Level Interrupts</h4>
<div class="paragraph">
<p>A bus prioritizes a device interrupt at a
<em>bus-interrupt level</em>. The bus interrupt level is then mapped to a
processor-interrupt level. A bus interrupt level that maps to a CPU
interrupt priority above the scheduler priority level is called a
<em>high-level interrupt</em>. High-level interrupt handlers are restricted to
calling the following DDI interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mutex_enter(9F)</code> and
<code>mutex_exit(9F)</code> on a mutex that is initialized with an interrupt
priority associated with the high-level interrupt
*
<code>ddi_intr_trigger_softint(9F)</code></p>
</li>
<li>
<p>The following DDI <code>get</code> and <code>put</code> routines: <code>ddi_get8(9F)</code>,
<code>ddi_put8(9F)</code>, <code>ddi_get16(9F)</code>, <code>ddi_put16(9F)</code>,
<code>ddi_get32(9F)</code>, <code>ddi_put32(9F)</code>, <code>ddi_get64(9F)</code>, and
<code>ddi_put64(9F)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A bus-interrupt level by itself does not determine whether a device
interrupts at a high level. A particular bus-interrupt level can map to
a high-level interrupt on one platform, but map to an ordinary interrupt
on another platform.</p>
</div>
<div class="paragraph">
<p>A driver is not required to support
devices that have high-level interrupts. However, the driver is required
to check the interrupt level. If the interrupt priority is greater than
or equal to the highest system priority, the interrupt handler runs in
high-level interrupt context. In this case, the driver can fail to
attach, or the driver can use a two-level scheme to handle interrupts.
For more information, see <a href="#handling-high-level-interrupts">Handling High-Level
Interrupts</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="legacy-interrupts"><a class="anchor" href="#legacy-interrupts"></a>2.28.2. Legacy Interrupts</h4>
<div class="paragraph">
<p>legacy interrupts</p>
</div>
<div class="paragraph">
<p>using legacy</p>
</div>
<div class="paragraph">
<p>The only information that the system has about a device interrupt is the
priority level of the bus interrupt and the interrupt request number. An
example of the priority level for a bus interrupt is the IPL on an SBus
in a SPARC machine. An example of an interrupt request number is the IRQ
on an ISA bus in an x86 machine.</p>
</div>
<div class="paragraph">
<p>When an interrupt handler is registered, the system adds the handler to
a list of potential interrupt handlers for each IPL or IRQ. When the
interrupt occurs, the system must determine which device actually caused
the interrupt, among all devices that are associated with a given IPL or
IRQ. The system calls all the interrupt handlers for the designated IPL
or IRQ until one handler claims the interrupt.</p>
</div>
<div class="paragraph">
<p>The following buses are capable of supporting polled interrupts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SBus</p>
</li>
<li>
<p>ISA</p>
</li>
<li>
<p>PCI</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="standard-and-extended-message-signaled-interrupts"><a class="anchor" href="#standard-and-extended-message-signaled-interrupts"></a>2.28.3. Standard and Extended Message-Signaled Interrupts</h4>
<div class="paragraph">
<p>Both standard (MSI) and extended (MSI-X) message-signaled interrupts are
implemented as in-band messages. A message-signaled interrupt is posted
as a write with an address and value that are specified by the software.</p>
</div>
<div class="sect4">
<h5 id="msi-interrupts"><a class="anchor" href="#msi-interrupts"></a>MSI Interrupts</h5>
<div class="paragraph">
<p>Conventional PCI
specifications include optional support for Message Signaled Interrupts
(MSI). An MSI is an in-band message that is implemented as a posted
write. The address and the data for the MSI are specified by software
and are specific to the host bridge. Because the messages are in-band,
the receipt of the message can be used to “push” data that is associated
with the interrupt. By definition, MSI interrupts are unshared. Each MSI
message that is assigned to a device is guaranteed to be a unique
message in the system. PCI functions can request 1, 2, 4, 8, 16, or 32
MSI messages. Note that the system software can allocate fewer MSI
messages to a function than the function requested. The host bridge can
be limited in the number of unique MSI messages that are allocated for
devices.</p>
</div>
</div>
<div class="sect4">
<h5 id="msi-x-interrupts"><a class="anchor" href="#msi-x-interrupts"></a>MSI-X Interrupts</h5>
<div class="paragraph">
<p>MSI-X interrupts are
enhanced versions of MSI interrupts that have the same features as MSI
interrupts with the following key differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A maximum of 2048 MSI-X interrupt vectors are supported per device.</p>
</li>
<li>
<p>Address and data entries are unique per interrupt vector.</p>
</li>
<li>
<p>MSI-X supports per function masking and per vector masking.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>MSI-X interrupts, an unallocated interrupt vector of a device can use a
previously added or initialized MSI-X interrupt vector to share the same
vector address, vector data, interrupt handler, and handler arguments.
Use the <code>ddi_intr_dup_handler(9F)</code> function to alias the
resources provided by illumos to the unallocated interrupt vectors on an
associated device. For example, if 2 MSI-X interrupts are allocated to a
driver and 32 interrupts are supported on the device, then the driver
can use <code>ddi_intr_dup_handler</code> to alias the 2 interrupts it
received to the 30 additional interrupts on the device.</p>
</div>
<div class="paragraph">
<p>The <code>ddi_intr_dup_handler</code> function can duplicate interrupts
that were added with <code>ddi_intr_add_handler(9F)</code> or
initialized with <code>ddi_intr_enable(9F)</code>.</p>
</div>
<div class="paragraph">
<p>A duplicated interrupt is disabled initially. Use
<code>ddi_intr_enable</code> to enable the duplicated interrupt. You cannot
remove the original MSI-X interrupt handler until all duplicated
interrupt handlers that are associated with this original interrupt
handler are removed. To remove a duplicated interrupt handler, first
call <code>ddi_intr_disable(9F)</code>, and then call
<code>ddi_intr_free(9F)</code>. When all duplicated interrupt handlers that
are associated with this original interrupt handler are removed, then
you can use <code>ddi_intr_remove_handler(9F)</code> to remove the
original MSI-X interrupt handler. See the
<code>ddi_intr_dup_handler(9F)</code> man page for examples.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="software-interrupts"><a class="anchor" href="#software-interrupts"></a>2.28.4. Software Interrupts</h4>
<div class="literalblock">
<div class="content">
<pre>  The illumos DDI/DKI supports software
interrupts, also known as _soft interrupts_. Soft interrupts are
initiated by software rather than by a hardware device. Handlers for
these interrupts must also be added to and removed from the system. Soft
interrupt handlers run in interrupt context and therefore can be used to
do many of the tasks that belong to an interrupt handler.</pre>
</div>
</div>
<div class="paragraph">
<p>Hardware interrupt handlers must perform their tasks quickly, because
the handlers might have to suspend other system activity while doing
these tasks. This requirement is particularly true for high-level
interrupt handlers, which operate at priority levels greater than the
priority level of the system scheduler. High-level interrupt handlers
mask the operations of all lower-priority interrupts, including the
interrupt operations of the system clock. Consequently, the interrupt
handler must avoid involvement in activities that might cause it to
sleep, such as acquiring a mutex.</p>
</div>
<div class="paragraph">
<p>If the handler sleeps, then the system might hang because
the clock is masked and incapable of scheduling the sleeping thread. For
this reason, high-level interrupt handlers normally perform a minimum
amount of work at high-priority levels and delegate other tasks to
software interrupts, which run below the priority level of the
high-level interrupt handler. Because software interrupt handlers run
below the priority level of the system scheduler, software interrupt
handlers can do the work that the high-level interrupt handler was
incapable of doing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ddi-interrupt-functions"><a class="anchor" href="#ddi-interrupt-functions"></a>2.29. DDI Interrupt Functions</h3>
<div class="paragraph">
<p>illumos provides a framework for registering and unregistering
interrupts and provides support for Message Signaled Interrupts (MSIs).
Interrupt management interfaces enable you to manipulate priorities,
capabilities, and interrupt masking, and to obtain pending information.</p>
</div>
<div class="sect3">
<h4 id="interrupt-capability-functions"><a class="anchor" href="#interrupt-capability-functions"></a>2.29.1. Interrupt Capability Functions</h4>
<div class="paragraph">
<p>Use the following functions to obtain interrupt
information:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_intr_get_navail(9F)</code></dt>
<dd>
<p>Returns the number of interrupts available for a specified hardware
device and interrupt type.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_nintrs(9F)</code></dt>
<dd>
<p>Returns the number of interrupts that the device supports for the
specified interrupt type.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_supported_types(9F)</code></dt>
<dd>
<p>Returns the hardware interrupt types that are supported by both the
device and the host.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_cap(9F)</code></dt>
<dd>
<p>Returns interrupt capability flags for the specified interrupt.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="interrupt-initialization-and-destruction-functions"><a class="anchor" href="#interrupt-initialization-and-destruction-functions"></a>2.29.2. Interrupt Initialization and Destruction Functions</h4>
<div class="literalblock">
<div class="content">
<pre>   Use the following functions
to create and remove interrupts:</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_intr_alloc(9F)</code></dt>
<dd>
<p>Allocates system resources and interrupt vectors for the specified
type of interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_free(9F)</code></dt>
<dd>
<p>Releases the system resources and interrupt vectors for a specified
interrupt handle.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_cap(9F)</code></dt>
<dd>
<p>Sets the capability of the specified interrupt through the use of the
DDI_INTR_FLAG_LEVEL and DDI_INTR_FLAG_EDGE
flags.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_add_handler(9F)</code></dt>
<dd>
<p>Adds an interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_dup_handler(9F)</code></dt>
<dd>
<p>Use with MSI-X only. Copies an address and data pair for an allocated
interrupt vector to an unused interrupt vector on the same device.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_remove_handler(9F)</code></dt>
<dd>
<p>Removes the specified interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_enable(9F)</code></dt>
<dd>
<p>Enables the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_disable(9F)</code></dt>
<dd>
<p>Disables the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_block_enable(9F)</code></dt>
<dd>
<p>Use with MSI only. Enables the specified range of interrupts.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_block_disable(9F)</code></dt>
<dd>
<p>Use with MSI only. Disables the specified range of interrupts.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_mask(9F)</code></dt>
<dd>
<p>Sets an interrupt mask if the specified interrupt is enabled.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_clr_mask(9F)</code></dt>
<dd>
<p>Clears an interrupt mask if the specified interrupt is enabled.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_pending(9F)</code></dt>
<dd>
<p>Reads the interrupt pending bit if such a bit is supported by either
the host bridge or the device.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="priority-management-functions"><a class="anchor" href="#priority-management-functions"></a>2.29.3. Priority Management Functions</h4>
<div class="literalblock">
<div class="content">
<pre>   Use the following functions
to obtain and set priority information:</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_intr_get_pri(9F)</code></dt>
<dd>
<p>Returns the current software priority setting for the specified
interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_pri(9F)</code></dt>
<dd>
<p>Sets the interrupt priority level for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_hilevel_pri(9F)</code></dt>
<dd>
<p>Returns the minimum priority level for a high-level interrupt.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="soft-interrupt-functions"><a class="anchor" href="#soft-interrupt-functions"></a>2.29.4. Soft Interrupt Functions</h4>
<div class="literalblock">
<div class="content">
<pre>   Use the following functions
to manipulate soft interrupts and soft interrupt handlers:</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_intr_add_softint(9F)</code></dt>
<dd>
<p>Adds a soft interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_trigger_softint(9F)</code></dt>
<dd>
<p>Triggers the specified soft interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_remove_softint(9F)</code></dt>
<dd>
<p>Removes the specified soft interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_softint_pri(9F)</code></dt>
<dd>
<p>Returns the soft interrupt priority for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_softint_pri(9F)</code></dt>
<dd>
<p>Changes the relative soft interrupt priority for the specified soft
interrupt.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="interrupt-function-examples"><a class="anchor" href="#interrupt-function-examples"></a>2.29.5. Interrupt Function Examples</h4>
<div class="paragraph">
<p>This section provides examples for performing the
following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changing soft interrupt priority</p>
</li>
<li>
<p>Checking for pending interrupts</p>
</li>
<li>
<p>Setting interrupt masks</p>
</li>
<li>
<p>Clearing interrupt masks</p>
</li>
</ul>
</div>
<div id="fxjor" class="paragraph">
<p>Changing Soft Interrupt Priority</p>
</div>
<div class="paragraph">
<p>ddi_intr_set_softint_pri</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>ddi_intr_set_softint_pri</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>software interrupts</p>
</div>
<div class="paragraph">
<p>software interrupts</p>
</div>
<div class="paragraph">
<p>changing priority</p>
</div>
<div class="paragraph">
<p>Use the <code>ddi_intr_set_softint_pri(9F)</code> function to
change the soft interrupt priority to 9.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_intr_set_softint_pri(mydev-&gt;mydev_softint_hdl, 9) != DDI_SUCCESS)
    cmn_err (CE_WARN, "ddi_intr_set_softint_pri failed");</code></pre>
</div>
</div>
<div id="fxjpd" class="paragraph">
<p>Checking for Pending Interrupts</p>
</div>
<div class="paragraph">
<p>ddi_intr_get_pending</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>ddi_intr_get_pending</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>pending interrupts</p>
</div>
<div class="paragraph">
<p>Use the <code>ddi_intr_get_pending(9F)</code> function to check whether
an interrupt is pending.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_intr_get_pending(mydevp-&gt;htable[0], &amp;pending) != DDI_SUCCESS)
    cmn_err(CE_WARN, "ddi_intr_get_pending() failed");
else if (pending)
    cmn_err(CE_NOTE, "ddi_intr_get_pending(): Interrupt pending");</code></pre>
</div>
</div>
<div id="fxjpb" class="paragraph">
<p>Setting Interrupt Masks</p>
</div>
<div class="paragraph">
<p>ddi_intr_set_mask</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>ddi_intr_set_mask</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>setting masks</p>
</div>
<div class="paragraph">
<p>Use the <code>ddi_intr_set_mask(9F)</code> function to set interrupt
masking to prevent the device from receiving interrupts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if ((ddi_intr_set_mask(mydevp-&gt;htable[0]) != DDI_SUCCESS))
    cmn_err(CE_WARN, "ddi_intr_set_mask() failed");</code></pre>
</div>
</div>
<div id="fxjqj" class="paragraph">
<p>Clearing Interrupt Masks</p>
</div>
<div class="paragraph">
<p>ddi_intr_clr_mask</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>ddi_intr_clr_mask</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>clearing masks</p>
</div>
<div class="paragraph">
<p>Use the <code>ddi_intr_clr_mask(9F)</code> function to clear interrupt
masking. The <code>ddi_intr_clr_mask(9F)</code> function fails if the
specified interrupt is not enabled. If the
<code>ddi_intr_clr_mask(9F)</code> function succeeds, the device starts
generating interrupts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_intr_clr_mask(mydevp-&gt;htable[0]) != DDI_SUCCESS)
    cmn_err(CE_WARN, "ddi_intr_clr_mask() failed");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="registering-interrupts"><a class="anchor" href="#registering-interrupts"></a>2.30. Registering Interrupts</h3>
<div class="paragraph">
<p>Before a device driver can
receive and service interrupts, the driver must call
<code>ddi_intr_add_handler(9F)</code> to register an interrupt handler
with the system. Registering interrupt handlers provides the system with
a way to associate an interrupt handler with an interrupt specification.
The interrupt handler is called when the device might have been
responsible for the interrupt. The handler has the responsibility of
determining whether it should handle the interrupt and, if so, of
claiming that interrupt.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use the <code>::interrupts</code> command in the <code>mdb</code> or <code>kmdb</code> debugger to
retrieve the registered interrupt information of a device on supported
SPARC and x86 systems.
===
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="registering-legacy-interrupts"><a class="anchor" href="#registering-legacy-interrupts"></a>2.30.1. Registering Legacy Interrupts</h4>
<div class="paragraph">
<p>registering legacy interrupts</p>
</div>
<div class="paragraph">
<p>To register a driver&#8217;s interrupt handler, the driver typically performs
the following steps in its <code>attach(9E)</code> entry point:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>ddi_intr_get_supported_types(9F)</code> to determine
which types of interrupts are supported.</p>
</li>
<li>
<p>Use <code>ddi_intr_get_nintrs(9F)</code> to determine the number of
supported interrupt types.</p>
</li>
<li>
<p>Use <code>kmem_zalloc(9F)</code> to allocate memory for DDI interrupt
handles.</p>
</li>
<li>
<p>For each interrupt type that you allocate, take the following steps:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>ddi_intr_get_pri(9F)</code> to get the priority for the
interrupt.</p>
</li>
<li>
<p>If you need to set a new priority for the interrupt, use
<code>ddi_intr_set_pri(9F)</code>.</p>
</li>
<li>
<p>Use <code>mutex_init(9F)</code> to initialize the lock.</p>
</li>
<li>
<p>Use <code>ddi_intr_add_handler(9F)</code> to register the handler
for the interrupt.</p>
</li>
<li>
<p>Use <code>ddi_intr_enable(9F)</code> to enable the interrupt.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Take the following steps to free each interrupt:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Disable each interrupt using <code>ddi_intr_disable(9F)</code>.</p>
</li>
<li>
<p>Remove the interrupt handler using
<code>ddi_intr_remove_handler(9F)</code>.</p>
</li>
<li>
<p>Remove the lock using <code>mutex_destroy(9F)</code>.</p>
</li>
<li>
<p>Free the interrupt using <code>ddi_intr_free(9F)</code> and
<code>kmem_free(9F)</code> to free memory that was allocated for DDI interrupt
handles.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div id="fwbtg" class="paragraph">
<p>Registering a Legacy Interrupt</p>
</div>
<div class="paragraph">
<p>registering legacy interrupt example</p>
</div>
<div class="paragraph">
<p>The following example shows how to install an interrupt handler for a
device called <code>mydev</code>. This example assumes that <code>mydev</code> supportsone
interrupt only.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Determine which types of interrupts supported */
ret = ddi_intr_get_supported_types(mydevp-&gt;mydev_dip, &amp;type);

if ((ret != DDI_SUCCESS) || (!(type &amp; DDI_INTR_TYPE_FIXED))) {
    cmn_err(CE_WARN, "Fixed type interrupt is not supported");
    return (DDI_FAILURE);
}

/* Determine number of supported interrupts */
ret = ddi_intr_get_nintrs(mydevp-&gt;mydev_dip, DDI_INTR_TYPE_FIXED,
    &amp;count);

/*
 * Fixed interrupts can only have one interrupt. Check to make
 * sure that number of supported interrupts and number of
 * available interrupts are both equal to 1.
 */
if ((ret != DDI_SUCCESS) || (count != 1)) {
    cmn_err(CE_WARN, "No fixed interrupts");
    return (DDI_FAILURE);
}

/* Allocate memory for DDI interrupt handles */
mydevp-&gt;mydev_htable = kmem_zalloc(sizeof (ddi_intr_handle_t),
    KM_SLEEP);
ret = ddi_intr_alloc(mydevp-&gt;mydev_dip, mydevp-&gt;mydev_htable,
    DDI_INTR_TYPE_FIXED, 0, count, &amp;actual, 0);

if ((ret != DDI_SUCCESS) || (actual != 1)) {
    cmn_err(CE_WARN, "ddi_intr_alloc() failed 0x%x", ret);
    kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));
    return (DDI_FAILURE);
}

/* Sanity check that count and available are the same. */
ASSERT(count == actual);

/* Get the priority of the interrupt */
if (ddi_intr_get_pri(mydevp-&gt;mydev_htable[0], &amp;mydevp-&gt;mydev_intr_pri)) {
    cmn_err(CE_WARN, "ddi_intr_alloc() failed 0x%x", ret);

    (void) ddi_intr_free(mydevp-&gt;mydev_htable[0]);
    kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

cmn_err(CE_NOTE, "Supported Interrupt pri = 0x%x", mydevp-&gt;mydev_intr_pri);

/* Test for high level mutex */
if (mydevp-&gt;mydev_intr_pri &gt;= ddi_intr_get_hilevel_pri()) {
    cmn_err(CE_WARN, "Hi level interrupt not supported");

    (void) ddi_intr_free(mydevp-&gt;mydev_htable[0]);
    kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

/* Initialize the mutex */
mutex_init(&amp;mydevp-&gt;mydev_int_mutex, NULL, MUTEX_DRIVER,
    DDI_INTR_PRI(mydevp-&gt;mydev_intr_pri));

/* Register the interrupt handler */
if (ddi_intr_add_handler(mydevp-&gt;mydev_htable[0], mydev_intr,
   (caddr_t)mydevp, NULL) !=DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_add_handler() failed");

    mutex_destroy(&amp;mydevp-&gt;mydev_int_mutex);
    (void) ddi_intr_free(mydevp-&gt;mydev_htable[0]);
    kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}

/* Enable the interrupt */
if (ddi_intr_enable(mydevp-&gt;mydev_htable[0]) != DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_enable() failed");

    (void) ddi_intr_remove_handler(mydevp-&gt;mydev_htable[0]);
    mutex_destroy(&amp;mydevp-&gt;mydev_int_mutex);
    (void) ddi_intr_free(mydevp-&gt;mydev_htable[0]);
    kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));

    return (DDI_FAILURE);
}
return (DDI_SUCCESS);
}</code></pre>
</div>
</div>
<div id="fwbjs" class="paragraph">
<p>Removing a Legacy Interrupt</p>
</div>
<div class="paragraph">
<p>removing legacy interrupt example</p>
</div>
<div class="paragraph">
<p>The following example shows how legacy interrupts are removed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* disable interrupt */
(void) ddi_intr_disable(mydevp-&gt;mydev_htable[0]);

/* Remove interrupt handler */
(void) ddi_intr_remove_handler(mydevp-&gt;mydev_htable[0]);

/* free interrupt handle */
(void) ddi_intr_free(mydevp-&gt;mydev_htable[0]);

/* free memory */
kmem_free(mydevp-&gt;mydev_htable, sizeof (ddi_intr_handle_t));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="registering-msi-interrupts"><a class="anchor" href="#registering-msi-interrupts"></a>2.30.2. Registering MSI Interrupts</h4>
<div class="paragraph">
<p>registering MSI interrupts</p>
</div>
<div class="paragraph">
<p>To register a driver&#8217;s interrupt handler, the driver typically performs
the following steps in its <code>attach(9E)</code> entry point:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>ddi_intr_get_supported_types(9F)</code> to determine
which types of interrupts are supported.</p>
</li>
<li>
<p>Use <code>ddi_intr_get_nintrs(9F)</code> to determine the number of
supported MSI interrupt types.</p>
</li>
<li>
<p>Use <code>ddi_intr_alloc(9F)</code> to allocate memory for the MSI
interrupts.</p>
</li>
<li>
<p>For each interrupt type that you allocate, take the following steps:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>ddi_intr_get_pri(9F)</code> to get the priority for the
interrupt.</p>
</li>
<li>
<p>If you need to set a new priority for the interrupt, use
<code>ddi_intr_set_pri(9F)</code>.</p>
</li>
<li>
<p>Use <code>mutex_init(9F)</code> to initialize the lock.</p>
</li>
<li>
<p>Use <code>ddi_intr_add_handler(9F)</code> to register the handler
for the interrupt.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Use one of the following functions to enable all the interrupts:</p>
<div class="ulist">
<ul>
<li>
<p>Use <code>ddi_intr_block_enable(9F)</code> to enable all the
interrupts in a block.</p>
</li>
<li>
<p>Use <code>ddi_intr_enable(9F)</code> in a loop to enable each interrupt
individually.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="fwbiz" class="paragraph">
<p>Registering a Set of MSI Interrupts</p>
</div>
<div class="paragraph">
<p>registering MSI interrupts example</p>
</div>
<div class="paragraph">
<p>The following example illustrates how to register an MSI interrupt for a
device called <code>mydev</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Get supported interrupt types */
if (ddi_intr_get_supported_types(devinfo, &amp;intr_types) != DDI_SUCCESS) {
    cmn_err(CE_WARN, "ddi_intr_get_supported_types failed");
    goto attach_fail;
}

if (intr_types &amp; DDI_INTR_TYPE_MSI)
    mydev_add_msi_intrs(mydevp);

/* Check count, available and actual interrupts */
static int
mydev_add_msi_intrs(mydev_t *mydevp)
{
    dev_info_t    *devinfo = mydevp-&gt;devinfo;
    int           count, avail, actual;
    int           x, y, rc, inum = 0;

    /* Get number of interrupts */
    rc = ddi_intr_get_nintrs(devinfo, DDI_INTR_TYPE_MSI, &amp;count);
    if ((rc != DDI_SUCCESS) || (count == 0)) {
        cmn_err(CE_WARN, "ddi_intr_get_nintrs() failure, rc: %d, "
            "count: %d", rc, count);
        return (DDI_FAILURE);
    }

    /* Get number of available interrupts */
    rc = ddi_intr_get_navail(devinfo, DDI_INTR_TYPE_MSI, &amp;avail);
    if ((rc != DDI_SUCCESS) || (avail == 0)) {
        cmn_err(CE_WARN, "ddi_intr_get_navail() failure, "
            "rc: %d, avail: %d\n", rc, avail);
        return (DDI_FAILURE);
    }
    if (avail &lt; count) {
        cmn_err(CE_NOTE, "nitrs() returned %d, navail returned %d",
            count, avail);
    }

    /* Allocate memory for MSI interrupts */
    mydevp-&gt;intr_size = count * sizeof (ddi_intr_handle_t);
    mydevp-&gt;htable = kmem_alloc(mydevp-&gt;intr_size, KM_SLEEP);

    rc = ddi_intr_alloc(devinfo, mydevp-&gt;htable, DDI_INTR_TYPE_MSI, inum,
        count, &amp;actual, DDI_INTR_ALLOC_NORMAL);

    if ((rc != DDI_SUCCESS) || (actual == 0)) {
        cmn_err(CE_WARN, "ddi_intr_alloc() failed: %d", rc);
        kmem_free(mydevp-&gt;htable, mydevp-&gt;intr_size);
        return (DDI_FAILURE);
    }

    if (actual &lt; count) {
        cmn_err(CE_NOTE, "Requested: %d, Received: %d", count, actual);
    }

    mydevp-&gt;intr_cnt = actual;
    /*
     * Get priority for first msi, assume remaining are all the same
     */
    if (ddi_intr_get_pri(mydevp-&gt;htable[0], &amp;mydev-&gt;intr_pri) !=
        DDI_SUCCESS) {
        cmn_err(CE_WARN, "ddi_intr_get_pri() failed");

        /* Free already allocated intr */
        for (y = 0; y &lt; actual; y++) {
            (void) ddi_intr_free(mydevp-&gt;htable[y]);
        }

        kmem_free(mydevp-&gt;htable, mydevp-&gt;intr_size);
        return (DDI_FAILURE);
    }

    /* Call ddi_intr_add_handler() */
    for (x = 0; x &lt; actual; x++) {
        if (ddi_intr_add_handler(mydevp-&gt;htable[x], mydev_intr,
           (caddr_t)mydevp, NULL) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_add_handler() failed");

            /* Free already allocated intr */
            for (y = 0; y &lt; actual; y++) {
                (void) ddi_intr_free(mydevp-&gt;htable[y]);
            }

            kmem_free(mydevp-&gt;htable, mydevp-&gt;intr_size);
            return (DDI_FAILURE);
        }
    }

    (void) ddi_intr_get_cap(mydevp-&gt;htable[0], &amp;mydevp-&gt;intr_cap);
    if (mydev-&gt;m_intr_cap &amp; DDI_INTR_FLAG_BLOCK) {
        /* Call ddi_intr_block_enable() for MSI */
        (void) ddi_intr_block_enable(mydev-&gt;m_htable, mydev-&gt;m_intr_cnt);
    } else {
        /* Call ddi_intr_enable() for MSI non block enable */
        for (x = 0; x &lt; mydev-&gt;m_intr_cnt; x++) {
            (void) ddi_intr_enable(mydev-&gt;m_htable[x]);
        }
    }
    return (DDI_SUCCESS);
}</code></pre>
</div>
</div>
<div id="fwbqn" class="paragraph">
<p>Removing MSI Interrupts</p>
</div>
<div class="paragraph">
<p>removing MSI interrupts example</p>
</div>
<div class="paragraph">
<p>The following example shows how to remove MSI interrupts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
mydev_rem_intrs(mydev_t *mydev)
{
    int    x;

    /* Disable all interrupts */
    if (mydev-&gt;m_intr_cap &amp; DDI_INTR_FLAG_BLOCK) {
        /* Call ddi_intr_block_disable() */
        (void) ddi_intr_block_disable(mydev-&gt;m_htable, mydev-&gt;m_intr_cnt);
    } else {
        for (x = 0; x &lt; mydev-&gt;m_intr_cnt; x++) {
            (void) ddi_intr_disable(mydev-&gt;m_htable[x]);
        }
    }

    /* Call ddi_intr_remove_handler() */
    for (x = 0; x &lt; mydev-&gt;m_intr_cnt; x++) {
        (void) ddi_intr_remove_handler(mydev-&gt;m_htable[x]);
        (void) ddi_intr_free(mydev-&gt;m_htable[x]);
    }

    kmem_free(mydev-&gt;m_htable, mydev-&gt;m_intr_size);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-handler-functionality"><a class="anchor" href="#interrupt-handler-functionality"></a>2.31. Interrupt Handler Functionality</h3>
<div class="paragraph">
<p>interrupt handlers</p>
</div>
<div class="paragraph">
<p>The driver framework and the device each place demands on the interrupt
handler. All interrupt handlers are required to do the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Determine whether the device is
interrupting and possibly reject the interrupt.</strong></p>
<div class="paragraph">
<p>The interrupt handler first examines the device to determine whether
this device issued the interrupt. If this device did not issue the
interrupt, the handler must return <code>DDI_INTR_UNCLAIMED</code>. This
step enables the implementation of <em>device polling</em>. Any device at the
given interrupt priority level might have issued the interrupt. Device
polling tells the system whether this device issued the interrupt.</p>
</div>
</li>
<li>
<p><strong>Inform the device that the device is being serviced.</strong></p>
<div class="paragraph">
<p>Informing a device about servicing is a device-specific operation that
is required for the majority of devices. For example, SBus devices are
required to interrupt until the driver tells the SBus devices to stop.
This approach guarantees that all SBus devices that interrupt at the
same priority level are serviced.</p>
</div>
</li>
<li>
<p><strong>Perform any I/O request-related processing.</strong></p>
<div class="paragraph">
<p>Devices interrupt for different reasons, such as <em>transfer done</em> or
<em>transfer error</em>. This step can involve using data access functions to
read the device&#8217;s data buffer, examine the device&#8217;s error register, and
set the status field in a data structure accordingly. Interrupt
dispatching and processing are relatively time consuming.</p>
</div>
</li>
<li>
<p><strong>Do any additional processing that could prevent another interrupt.</strong></p>
<div class="paragraph">
<p>For example, read the next item of data from the device.</p>
</div>
</li>
<li>
<p><strong>Return</strong> <code>DDI_INTR_CLAIMED</code>.</p>
</li>
<li>
<p><strong>MSI interrupts must always be claimed.</strong></p>
<div class="paragraph">
<p>Claiming an interrupt is optional for MSI-X interrupts. In either case,
the ownership of the interrupt need not be checked, because MSI and
MSI-X interrupts are not shared with other devices.</p>
</div>
</li>
<li>
<p><strong>Drivers that support hotplugging and multiple MSI or
MSI-X interrupts should retain a separate interrupt for hotplug events
and register a separate ISR (interrupt service routine) for that
interrupt.</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows an interrupt routine
for a device called <code>mydev</code>.</p>
</div>
<div id="interrupt-ex-17" class="paragraph">
<p>Interrupt Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static uint_t
mydev_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate *xsp = (struct mydevstate *)arg1;
    uint8_t     status;
    volatile    uint8_t  temp;

    /*
     * Claim or reject the interrupt. This example assumes
     * that the device's CSR includes this information.
     */
    mutex_enter(&amp;xsp-&gt;high_mu);

    /* use data access routines to read status */
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;high_mu);
        return (DDI_INTR_UNCLAIMED); /* dev not interrupting */
    }
    /*
     * Inform the device that it is being serviced, and re-enable
     * interrupts. The example assumes that writing to the
     * CSR accomplishes this. The driver must ensure that this data
     * access operation makes it to the device before the interrupt
     * service routine returns. For example, using the data access
     * functions to read the CSR, if it does not result in unwanted
     * effects, can ensure this.
     */
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT | ENABLE_INTERRUPTS);

    /* flush store buffers */
    temp = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);

    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the steps performed by the interrupt routine depend on the
specifics of the device itself. Consult the hardware manual for the
device to determine the cause of the interrupt, detect error conditions,
and access the device data registers.</p>
</div>
</div>
<div class="sect2">
<h3 id="handling-high-level-interrupts"><a class="anchor" href="#handling-high-level-interrupts"></a>2.32. Handling High-Level Interrupts</h3>
<div class="paragraph">
<p>High-level
interrupts are those interrupts that interrupt at the level of the
scheduler and above. This level does not allow the scheduler to run.
Therefore, high-level interrupt handlers cannot be preempted by the
scheduler. High-level interrupts cannot block because of the scheduler.
High-level interrupts can only use mutual exclusion locks for locking.</p>
</div>
<div class="paragraph">
<p>The driver must determine whether the
device is using high-level interrupts. Do this test in the driver&#8217;s
<code>attach(9E)</code> entry point when you register interrupts. See
<a href="#high-level-interrupt-handling-example">High-Level Interrupt Handling Example</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the interrupt priority returned from
<code>ddi_intr_get_pri(9F)</code> is greater than or equal to the
priority returned from <code>ddi_intr_get_hilevel_pri(9F)</code>,
the driver can fail to attach, or the driver can implement a high-level
interrupt handler. The high-level interrupt handler uses a
lower-priority software interrupt to handle the device. To allow more
concurrency, use a separate mutex to protect data from the high-level
handler.</p>
</li>
<li>
<p>If the interrupt priority returned from
<code>ddi_intr_get_pri(9F)</code> is less than the priority returned
from <code>ddi_intr_get_hilevel_pri(9F)</code>, the <code>attach(9E)</code>
entry point falls through to regular interrupt registration. In this
case, a soft interrupt is not necessary.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="high-level-mutexes"><a class="anchor" href="#high-level-mutexes"></a>2.32.1. High-Level Mutexes</h4>
<div class="paragraph">
<p>A mutex initialized with an
interrupt priority that represents a high-level interrupt is known as a
<em>high-level mutex</em>. While holding a high-level mutex, the driver is
subject to the same restrictions as a high-level interrupt handler.</p>
</div>
</div>
<div class="sect3">
<h4 id="high-level-interrupt-handling-example"><a class="anchor" href="#high-level-interrupt-handling-example"></a>2.32.2. High-Level Interrupt Handling Example</h4>
<div class="paragraph">
<p>handling high-level interrupts examples</p>
</div>
<div class="paragraph">
<p>In the following example, the high-level mutex (<code>xsp-&gt;high_mu</code>)
is used only to protect data shared between the high-level interrupt
handler and the soft interrupt handler. The protected data includes a
queue used by both the high-level interrupt handler and the low-level
handler, and a flag that indicates that the low-level handler is
running. A separate low-level mutex (<code>xsp-&gt;low_mu</code>) protects the
rest of the driver from the soft interrupt handler.</p>
</div>
<div id="interrupt-ex-21" class="paragraph">
<p>Handling High-Level Interrupts With <code>attach</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
mydevattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct mydevstate *xsp;
    /* ... */

    ret = ddi_intr_get_supported_types(dip, &amp;type);
    if ((ret != DDI_SUCCESS) || (!(type &amp; DDI_INTR_TYPE_FIXED))) {
        cmn_err(CE_WARN, "ddi_intr_get_supported_types() failed");
        return (DDI_FAILURE);
    }

    ret = ddi_intr_get_nintrs(dip, DDI_INTR_TYPE_FIXED, &amp;count);

    /*
     * Fixed interrupts can only have one interrupt. Check to make
     * sure that number of supported interrupts and number of
     * available interrupts are both equal to 1.
     */
    if ((ret != DDI_SUCCESS) || (count != 1)) {
    cmn_err(CE_WARN, "No fixed interrupts found");
            return (DDI_FAILURE);
    }

    xsp-&gt;xs_htable = kmem_zalloc(count * sizeof (ddi_intr_handle_t),
        KM_SLEEP);

    ret = ddi_intr_alloc(dip, xsp-&gt;xs_htable, DDI_INTR_TYPE_FIXED, 0,
        count, &amp;actual, 0);

    if ((ret != DDI_SUCCESS) || (actual != 1)) {
    cmn_err(CE_WARN, "ddi_intr_alloc failed 0x%x", ret");
        kmem_free(xsp-&gt;xs_htable, sizeof (ddi_intr_handle_t));
        return (DDI_FAILURE);
    }

    ret = ddi_intr_get_pri(xsp-&gt;xs_htable[0], &amp;intr_pri);
    if (ret != DDI_SUCCESS) {
        cmn_err(CE_WARN, "ddi_intr_get_pri failed 0x%x", ret");
        (void) ddi_intr_free(xsp-&gt;xs_htable[0]);
        kmem_free(xsp-&gt;xs_htable, sizeof (ddi_intr_handle_t));
        return (DDI_FAILURE);
    }

    if (intr_pri &gt;= ddi_intr_get_hilevel_pri()) {

        mutex_init(&amp;xsp-&gt;high_mu, NULL, MUTEX_DRIVER,
            DDI_INTR_PRI(intr_pri));

        ret = ddi_intr_add_handler(xsp-&gt;xs_htable[0],
            mydevhigh_intr, (caddr_t)xsp, NULL);

        if (ret != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_add_handler failed 0x%x", ret");
            mutex_destroy(&amp;xsp&gt;xs_int_mutex);
                (void) ddi_intr_free(xsp-&gt;xs_htable[0]);
                kmem_free(xsp-&gt;xs_htable, sizeof (ddi_intr_handle_t));
            return (DDI_FAILURE);
        }

        /* add soft interrupt */
        if (ddi_intr_add_softint(xsp-&gt;xs_dip, &amp;xsp-&gt;xs_softint_hdl,
            DDI_INTR_SOFTPRI_MAX, xs_soft_intr, (caddr_t)xsp) !=
            DDI_SUCCESS) {
            cmn_err(CE_WARN, "add soft interrupt failed");
            mutex_destroy(&amp;xsp-&gt;high_mu);
            (void) ddi_intr_remove_handler(xsp-&gt;xs_htable[0]);
            (void) ddi_intr_free(xsp-&gt;xs_htable[0]);
            kmem_free(xsp-&gt;xs_htable, sizeof (ddi_intr_handle_t));
            return (DDI_FAILURE);
        }

        xsp-&gt;low_soft_pri = DDI_INTR_SOFTPRI_MAX;

        mutex_init(&amp;xsp-&gt;low_mu, NULL, MUTEX_DRIVER,
            DDI_INTR_PRI(xsp-&gt;low_soft_pri));

    } else {
    /*
     * regular interrupt registration continues from here
     * do not use a soft interrupt
     */
    }

    return (DDI_SUCCESS);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The high-level interrupt routine services the device and queues the
data. The high-level routine triggers a software interrupt if the
low-level routine is not running, as the following example demonstrates.</p>
</div>
<div id="interrupt-ex-22" class="paragraph">
<p>High-level Interrupt Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static uint_t
mydevhigh_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate    *xsp = (struct mydevstate *)arg1;
    uint8_t    status;
    volatile  uint8_t  temp;
    int    need_softint;

    mutex_enter(&amp;xsp-&gt;high_mu);
    /* read status */
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;high_mu);
        return (DDI_INTR_UNCLAIMED); /* dev not interrupting */
    }

    ddi_put8(xsp-&gt;data_access_handle,&amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT | ENABLE_INTERRUPTS);
    /* flush store buffers */
    temp = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);

    /* read data from device, queue data for low-level interrupt handler */
    if (xsp-&gt;softint_running)
        need_softint = 0;
    else {
        xsp-&gt;softint_count++;
        need_softint = 1;
    }
    mutex_exit(&amp;xsp-&gt;high_mu);

    /* read-only access to xsp-&gt;id, no mutex needed */
    if (need_softint) {
        ret = ddi_intr_trigger_softint(xsp-&gt;xs_softint_hdl, NULL);
        if (ret == DDI_EPENDING) {
            cmn_err(CE_WARN, "ddi_intr_trigger_softint() soft interrupt "
                "already pending for this handler");
        } else if (ret != DDI_SUCCESS) {
            cmn_err(CE_WARN, "ddi_intr_trigger_softint() failed");
        }
    }

    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The low-level interrupt routine is started by the
high-level interrupt routine, which triggers a software interrupt. The
low-level interrupt routine runs until there is nothing left to process,
as the following example shows.</p>
</div>
<div id="interrupt-ex-23" class="paragraph">
<p>Low-Level Soft Interrupt Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static uint_t
mydev_soft_intr(caddr_t arg1, caddr_t arg2)
{
    struct mydevstate *mydevp = (struct mydevstate *)arg1;
    /* ... */
    mutex_enter(&amp;mydevp-&gt;low_mu);
    mutex_enter(&amp;mydevp-&gt;high_mu);
    if (mydevp-&gt;softint_count &gt; 1) {
        mydevp-&gt;softint_count--;
        mutex_exit(&amp;mydevp-&gt;high_mu);
        mutex_exit(&amp;mydevp-&gt;low_mu);
        return (DDI_INTR_CLAIMED);
    }

    if ( /* queue empty */ ) {
        mutex_exit(&amp;mydevp-&gt;high_mu);
        mutex_exit(&amp;mydevp-&gt;low_mu);
        return (DDI_INTR_UNCLAIMED);
    }

    mydevp-&gt;softint_running = 1;
    while (EMBEDDED COMMENT:data on queue) {
        ASSERT(mutex_owned(&amp;mydevp-&gt;high_mu);
        /* Dequeue data from high-level queue. */
        mutex_exit(&amp;mydevp-&gt;high_mu);
        /* normal interrupt processing */
        mutex_enter(&amp;mydevp-&gt;high_mu);
    }

    mydevp-&gt;softint_running = 0;
    mydevp-&gt;softint_count = 0;
    mutex_exit(&amp;mydevp-&gt;high_mu);
    mutex_exit(&amp;mydevp-&gt;low_mu);
    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="direct-memory-access-dma-1"><a class="anchor" href="#direct-memory-access-dma-1"></a>2.33. Direct Memory Access (DMA)</h3>
<div class="paragraph">
<p>Many devices can temporarily take control of the bus. These devices can
perform data transfers that involve main memory and other devices.
Because the device is doing the work without the help of the CPU, this
type of data transfer is known as <em>direct memory access</em> (DMA). The
following types of DMA transfers can be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Between two devices</p>
</li>
<li>
<p>Between a device and memory</p>
</li>
<li>
<p>Between memory and memory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This chapter explains transfers between a device and memory only. The
chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#dma-model">DMA Model</a></p>
</li>
<li>
<p><a href="#types-of-device-dma">Types of Device DMA</a></p>
</li>
<li>
<p><a href="#types-of-host-platform-dma">Types of Host Platform DMA</a></p>
</li>
<li>
<p><a href="#dma-software-components-handles-windows-and-cookies">DMA Software Components: Handles&#44; Windows&#44; and
Cookies</a></p>
</li>
<li>
<p><a href="#dma-operations">DMA Operations</a></p>
</li>
<li>
<p><a href="#managing-dma-resources">Managing DMA Resources</a></p>
</li>
<li>
<p><a href="#dma-windows">DMA Windows</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="dma-model"><a class="anchor" href="#dma-model"></a>2.34. DMA Model</h3>
<div class="paragraph">
<p>The illumos Device Driver Interface/Driver-Kernel Interface (DDI/DKI)
provides a high-level, architecture-independent model for DMA. This
model enables the framework, that is, the DMA routines, to hide
architecture-specific details such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting up DMA mappings</p>
</li>
<li>
<p>Building scatter-gather lists</p>
</li>
<li>
<p>Ensuring that I/O and CPU caches are consistent</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Several abstractions are used in the DDI/DKI to describe aspects of a
DMA transaction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>DMA object</strong> – Memory that is the source or
destination of a DMA transfer.</p>
</li>
<li>
<p><strong>DMA handle</strong> – An opaque object
returned from a successful <code>ddi_dma_alloc_handle(9F)</code> call.
The DMA handle can be used in subsequent DMA subroutine calls to refer
to such DMA objects.</p>
</li>
<li>
<p><strong>DMA cookie</strong> – A
<code>ddi_dma_cookie(9S)</code> structure (<code>ddi_dma_cookie_t</code>)
describes a contiguous portion of a DMA object that is entirely
addressable by the device. The cookie contains DMA addressing
information that is required to program the DMA engine.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Rather than map an object directly into memory, device drivers allocate
DMA <em>resources</em> for a memory object. The DMA routines then perform any
platform-specific operations that are needed to set up the object for
DMA access. The driver receives a DMA <em>handle</em> to identify the DMA
resources that are allocated for the object. This handle is opaque to
the device driver. The driver must save the handle and pass the handle
in subsequent calls to DMA routines. The driver should not interpret the
handle in any way.</p>
</div>
<div class="paragraph">
<p>Operations that provide the following services are defined on a DMA
handle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Manipulating DMA resources</p>
</li>
<li>
<p>Synchronizing DMA objects</p>
</li>
<li>
<p>Retrieving attributes of the allocated resources</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="types-of-device-dma"><a class="anchor" href="#types-of-device-dma"></a>2.35. Types of Device DMA</h3>
<div class="paragraph">
<p>Devices perform one of the following three types of DMA:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bus-master DMA</p>
</li>
<li>
<p>Third-party DMA</p>
</li>
<li>
<p>First-party DMA</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="bus-master-dma"><a class="anchor" href="#bus-master-dma"></a>2.35.1. Bus-Master DMA</h4>
<div class="paragraph">
<p>The driver should program the device&#8217;s DMA registers
directly in cases where the device acts like a true <em>bus master</em>. For
example, a device acts like a bus master when the DMA engine resides on
the device board. The transfer address and count are obtained from the
DMA cookie to be passed on to the device.</p>
</div>
</div>
<div class="sect3">
<h4 id="third-party-dma"><a class="anchor" href="#third-party-dma"></a>2.35.2. Third-Party DMA</h4>
<div class="paragraph">
<p>Third-party DMA uses a system DMA engine resident on the
main system board, which has several DMA channels that are available for
use by devices. The device relies on the system&#8217;s DMA engine to perform
the data transfers between the device and memory. The driver uses DMA
engine routines (see the <code>ddi_dmae(9F)</code> function) to initialize and
program the DMA engine. For each DMA data transfer, the driver programs
the DMA engine and then gives the device a command to initiate the
transfer in cooperation with that engine.</p>
</div>
</div>
<div class="sect3">
<h4 id="first-party-dma"><a class="anchor" href="#first-party-dma"></a>2.35.3. First-Party DMA</h4>
<div class="paragraph">
<p>Under first-party DMA, the device uses a channel from
the system&#8217;s DMA engine to drive that device&#8217;s DMA bus cycles. Use the
<code>ddi_dmae_1stparty(9F)</code> function to configure this channel in a
cascade mode so that the DMA engine does not interfere with the
transfer.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="types-of-host-platform-dma"><a class="anchor" href="#types-of-host-platform-dma"></a>2.36. Types of Host Platform DMA</h3>
<div class="paragraph">
<p>The platform on which the device operates provides either direct memory
access (DMA) or direct virtual memory access (DVMA).</p>
</div>
<div class="paragraph">
<p>On platforms that
support DMA, the system provides the device with a physical address in
order to perform transfers. In this case, the transfer of a DMA object
can actually consist of a number of physically discontiguous transfers.
An example is when an application transfers a buffer that spans several
contiguous virtual pages that map to physically discontiguous pages. To
deal with the discontiguous memory, devices for these platforms usually
have some kind of scatter-gather DMA capability. Typically, x86 systems
provide physical addresses for direct memory transfers.</p>
</div>
<div class="paragraph">
<p>platforms that support DVMA, the system provides the device with a
virtual address to perform transfers. In this case, memory management
units (MMU) provided by the underlying platform translate device
accesses to these virtual addresses into the proper physical addresses.
The device transfers to and from a contiguous virtual image that can be
mapped to discontiguous physical pages. Devices that operate in these
platforms do not need scatter-gather DMA capability. Typically, SPARC
platforms provide virtual addresses for direct memory transfers.</p>
</div>
</div>
<div class="sect2">
<h3 id="dma-software-components-handles-windows-and-cookies"><a class="anchor" href="#dma-software-components-handles-windows-and-cookies"></a>2.37. DMA Software Components: Handles, Windows, and Cookies</h3>
<div class="paragraph">
<p>A DMA <em>handle</em> is an opaque pointer that
represents an object, usually a memory buffer or address. A DMA handle
enables a device to perform DMA transfers. Several different calls to
DMA routines use the handle to identify the DMA resources that are
allocated for the object.</p>
</div>
<div class="paragraph">
<p>An object represented by a DMA handle is
completely covered by one or more <em>DMA cookies</em>. A DMA cookie represents
a contiguous piece of memory that is used in data transfers by the DMA
engine. The system divides objects into multiple cookies based on the
following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ddi_dma_attr(9S)</code> attribute structure provided by the
driver</p>
</li>
<li>
<p>Memory location of the target object</p>
</li>
<li>
<p>Alignment of the target object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an object does
not fit within the limitations of the DMA engine, that object must be
broken into multiple <em>DMA windows</em>. You can only activate and allocate
resources for one window at a time. Use the <code>ddi_dma_getwin(9F)</code>
function to position between windows within an object. Each DMA window
consists of one or more DMA cookies. For more information, see
<a href="#dma-windows">DMA Windows</a>.</p>
</div>
<div class="paragraph">
<p>Some DMA engines can accept
more than one cookie. Such engines perform scatter-gather I/O without
the help of the system. If multiple cookies are returned from a bind,
the driver should call <code>ddi_dma_nextcookie(9F)</code> repeatedly to
retrieve each cookie. These cookies must then be programmed into the
engine. The device can then be programmed to transfer the total number
of bytes covered by the aggregate of these DMA cookies.</p>
</div>
</div>
<div class="sect2">
<h3 id="dma-operations"><a class="anchor" href="#dma-operations"></a>2.38. DMA Operations</h3>
<div class="paragraph">
<p>The steps in a DMA transfer are similar among
the types of DMA. The following sections present methods for performing
DMA transfers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You do not need to ensure that the DMA object is locked in memory in
block drivers for buffers that come from the file system. The file
system has already locked the data in memory.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="performing-bus-master-dma-transfers"><a class="anchor" href="#performing-bus-master-dma-transfers"></a>2.38.1. Performing Bus-Master DMA Transfers</h4>
<div class="paragraph">
<p>The driver should perform the following steps
for bus-master DMA.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Describe the DMA attributes. This step enables the routines to ensure
that the device is able to access the buffer.</p>
</li>
<li>
<p>Allocate a DMA handle.</p>
</li>
<li>
<p>Ensure that the DMA object is locked in memory. See the <code>physio(9F)</code>
or <code>ddi_umem_lock(9F)</code> man page.</p>
</li>
<li>
<p>Allocate DMA resources for the object.</p>
</li>
<li>
<p>Program the DMA engine on the device.</p>
</li>
<li>
<p>Start the engine.</p>
</li>
<li>
<p>When the transfer is complete, continue the bus master operation.</p>
</li>
<li>
<p>Perform any required object synchronizations.</p>
</li>
<li>
<p>Release the DMA resources.</p>
</li>
<li>
<p>Free the DMA handle.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="performing-first-party-dma-transfers"><a class="anchor" href="#performing-first-party-dma-transfers"></a>2.38.2. Performing First-Party DMA Transfers</h4>
<div class="paragraph">
<p>The driver should perform the following steps
for first-party DMA.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocate a DMA channel.</p>
</li>
<li>
<p>Use <code>ddi_dmae_1stparty(9F)</code> to configure the channel.</p>
</li>
<li>
<p>Ensure that the DMA object is locked in memory. See the <code>physio(9F)</code>
or <code>ddi_umem_lock(9F)</code> man page.</p>
</li>
<li>
<p>Allocate DMA resources for the object.</p>
</li>
<li>
<p>Program the DMA engine on the device.</p>
</li>
<li>
<p>Start the engine.</p>
</li>
<li>
<p>When the transfer is complete, continue the bus-master operation.</p>
</li>
<li>
<p>Perform any required object synchronizations.</p>
</li>
<li>
<p>Release the DMA resources.</p>
</li>
<li>
<p>Deallocate the DMA channel.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="performing-third-party-dma-transfers"><a class="anchor" href="#performing-third-party-dma-transfers"></a>2.38.3. Performing Third-Party DMA Transfers</h4>
<div class="paragraph">
<p>The driver should perform these steps for
third-party DMA.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocate a DMA channel.</p>
</li>
<li>
<p>Retrieve the system&#8217;s DMA engine attributes with
<code>ddi_dmae_getattr(9F)</code>.</p>
</li>
<li>
<p>Lock the DMA object in memory. See the <code>physio(9F)</code> or
<code>ddi_umem_lock(9F)</code> man page.</p>
</li>
<li>
<p>Allocate DMA resources for the object.</p>
</li>
<li>
<p>Use <code>ddi_dmae_prog(9F)</code> to program the system DMA engine to
perform the transfer.</p>
</li>
<li>
<p>Perform any required object synchronizations.</p>
</li>
<li>
<p>Use <code>ddi_dmae_stop(9F)</code> to stop the DMA engine.</p>
</li>
<li>
<p>Release the DMA resources.</p>
</li>
<li>
<p>Deallocate the DMA channel.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Certain hardware platforms restrict DMA capabilities in a bus-specific
way. Drivers should use <code>ddi_slaveonly(9F)</code> to determine whether the
device is in a slot in which DMA is possible.</p>
</div>
</div>
<div class="sect3">
<h4 id="dma-attributes"><a class="anchor" href="#dma-attributes"></a>2.38.4. DMA Attributes</h4>
<div class="paragraph">
<p>DMA attributes describe the attributes and
limits of a DMA engine, which include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Limits on addresses that the device can access</p>
</li>
<li>
<p>Maximum transfer count</p>
</li>
<li>
<p>Address alignment restrictions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A device driver must inform the system about any DMA engine limitations
through the <code>ddi_dma_attr(9S)</code> structure. This action ensures
that DMA resources that are allocated by the system can be accessed by
the device&#8217;s DMA engine. The system can impose additional restrictions
on the device attributes, but the system never removes any of the
driver-supplied restrictions.</p>
</div>
<div class="sect4">
<h5 id="ddidmaattr-structure"><a class="anchor" href="#ddidmaattr-structure"></a><code>ddi_dma_attr</code> Structure</h5>
<div class="paragraph">
<p>The DMA attribute structure has the following members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct ddi_dma_attr {
    uint_t      dma_attr_version;       /* version number */
    uint64_t    dma_attr_addr_lo;       /* low DMA address range */
    uint64_t    dma_attr_addr_hi;       /* high DMA address range */
    uint64_t    dma_attr_count_max;     /* DMA counter register */
    uint64_t    dma_attr_align;         /* DMA address alignment */
    uint_t      dma_attr_burstsizes;    /* DMA burstsizes */
    uint32_t    dma_attr_minxfer;       /* min effective DMA size */
    uint64_t    dma_attr_maxxfer;       /* max DMA xfer size */
    uint64_t    dma_attr_seg;           /* segment boundary */
    int         dma_attr_sgllen;        /* s/g length */
    uint32_t    dma_attr_granular;      /* granularity of device */
    uint_t      dma_attr_flags;         /* Bus specific DMA flags */
} ddi_dma_attr_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>dma_attr_version</code></dt>
<dd>
<p>Version number of the attribute structure. <code>dma_attr_version</code>
should be set to DMA_ATTR_V0.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_addr_lo</code></dt>
<dd>
<p>Lowest bus address that the DMA engine can access.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_addr_hi</code></dt>
<dd>
<p>Highest bus address that the DMA engine can access.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_count_max</code></dt>
<dd>
<p>Specifies the maximum transfer count that the DMA engine can handle in
one cookie. The limit is expressed as the maximum count minus one.
This count is used as a bit mask, so the count must also be one less
than a power of two.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_align</code></dt>
<dd>
<p>Specifies alignment requirements when allocating memory from
<code>ddi_dma_mem_alloc(9F)</code>. An example of an alignment
requirement is alignment on a page boundary. The
<code>dma_attr_align</code> field is used only when allocating memory.
This field is ignored during bind operations. For bind operations, the
driver must ensure that the buffer is aligned appropriately.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_burstsizes</code></dt>
<dd>
<p>Specifies the <em>burst sizes</em> that the device supports. A burst size is
the amount of data the device can transfer before relinquishing the
bus. This member is a binary encoding of burst sizes, which are
assumed to be powers of two. For example, if the device is capable of
doing 1-byte, 2-byte, 4-byte, and 16-byte bursts, this field should be
set to 0x17. The system also uses this field to determine alignment
restrictions.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_minxfer</code></dt>
<dd>
<p>Minimum effective transfer size that the device can perform. This size
also influences restrictions on alignment and on padding.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_maxxfer</code></dt>
<dd>
<p>Describes the maximum number of bytes that the DMA engine can
accommodate in one I/O command. This limitation is only significant if
<code>dma_attr_maxxfer</code> is less than
<code>(dma_attr_count_max &#43; 1) * dma_attr_sgllen</code>.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_seg</code></dt>
<dd>
<p>Upper bound of the DMA engine&#8217;s address register.
<code>dma_attr_seg</code> is often used where the upper 8 bits of an
address register are a latch that contains a segment number. The lower
24 bits are used to address a segment. In this case,
<code>dma_attr_seg</code> would be set to 0xFFFFFF, which prevents the
system from crossing a 24-bit segment boundary when allocating
resources for the object.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_sgllen</code></dt>
<dd>
<p>Specifies the maximum number of entries in the scatter-gather list.
<code>dma_attr_sgllen</code> is the number of cookies that the DMA engine
can consume in one I/O request to the device. If the DMA engine has no
scatter-gather list, this field should be set to 1.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_granular</code></dt>
<dd>
<p>This field gives the granularity in bytes of the DMA transfer ability
of the device. An example of how this value is used is to specify the
sector size of a mass storage device. When a bind operation requires a
partial mapping, this field is used to ensure that the sum of the
sizes of the cookies in a DMA window is a whole multiple of
granularity. However, if the device does not have a scatter-gather
capability, it is impossible for the DDI to ensure the granularity.
For this case, the value of the <code>dma_attr_granular</code> field
should be 1.</p>
</dd>
<dt class="hdlist1"><code>dma_attr_flags</code></dt>
<dd>
<p>This field can be set to <code>DDI_DMA_FORCE_PHYSICAL</code>, which
indicates that the system should return physical rather than virtual
I/O addresses if the system supports both. If the system does not
support physical DMA, the return value from
<code>ddi_dma_alloc_handle(9F)</code> is <code>DDI_DMA_BADATTR</code>.
In this case, the driver has to clear
<code>DDI_DMA_FORCE_PHYSICAL</code> and retry the operation.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="sbus-example"><a class="anchor" href="#sbus-example"></a>SBus Example</h5>
<div class="paragraph">
<p>A DMA engine on an SBus in a SPARC machine has the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to addresses ranging from 0xFF000000 to 0xFFFFFFFF only</p>
</li>
<li>
<p>32-bit DMA counter register</p>
</li>
<li>
<p>Ability to handle byte-aligned transfers</p>
</li>
<li>
<p>Support for 1-byte, 2-byte, and 4-byte burst sizes</p>
</li>
<li>
<p>Minimum effective transfer size of 1 byte</p>
</li>
<li>
<p>32-bit address register</p>
</li>
<li>
<p>No scatter-gather list</p>
</li>
<li>
<p>Operation on sectors only, for example, a disk</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A DMA engine on an SBus in a SPARC machine has the following attribute
structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0xFF000000,    /* low address */
    0xFFFFFFFF,    /* high address */
    0xFFFFFFFF,    /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes: 0x1 | 0x2 | 0x4 */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0xFFFFFFFF,    /* address register max */
    1,             /* no scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="isa-bus-example"><a class="anchor" href="#isa-bus-example"></a>ISA Bus Example</h5>
<div class="paragraph">
<p>A DMA engine on an ISA bus in an x86 machine has the following
attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to the first 16 megabytes of memory only</p>
</li>
<li>
<p>Inability to cross a 1-megabyte boundary in a single DMA transfer</p>
</li>
<li>
<p>16-bit counter register</p>
</li>
<li>
<p>Ability to handle byte-aligned transfers</p>
</li>
<li>
<p>Support for 1-byte, 2-byte, and 4-byte burst sizes</p>
</li>
<li>
<p>Minimum effective transfer size of 1 byte</p>
</li>
<li>
<p>Ability to hold up to 17 scatter-gather transfers</p>
</li>
<li>
<p>Operation on sectors only, for example, a disk</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A DMA engine on an ISA bus in an x86 machine has the following attribute
structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static ddi_dma_attr_t attributes = {
    DMA_ATTR_V0,   /* Version number */
    0x00000000,    /* low address */
    0x00FFFFFF,    /* high address */
    0xFFFF,        /* counter register max */
    1,             /* byte alignment */
    0x7,           /* burst sizes */
    0x1,           /* minimum transfer size */
    0xFFFFFFFF,    /* max transfer size */
    0x000FFFFF,    /* address register max */
    17,            /* scatter-gather */
    512,           /* device operates on sectors */
    0,             /* attr flag: set to 0 */
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-dma-resources"><a class="anchor" href="#managing-dma-resources"></a>2.39. Managing DMA Resources</h3>
<div class="paragraph">
<p>This section describes how to manage DMA resources.</p>
</div>
<div class="sect3">
<h4 id="object-locking"><a class="anchor" href="#object-locking"></a>2.39.1. Object Locking</h4>
<div class="paragraph">
<p>Before allocating
the DMA resources for a memory object, the object must be prevented from
moving. Otherwise, the system can remove the object from memory while
the device is trying to write to that object. A missing object would
cause the data transfer to fail and possibly corrupt the system. The
process of preventing memory objects from moving during a DMA transfer
is known as <em>locking down the object</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Buffers coming from the file system through <code>strategy(9E)</code>. These
buffers are already locked by the file system.</p>
</li>
<li>
<p>Kernel memory allocated within the device driver, such as that
allocated by <code>ddi_dma_mem_alloc(9F)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For other objects such as buffers from user space, <code>physio(9F)</code> or
<code>ddi_umem_lock(9F)</code> must be used to lock down the objects.
Locking down objects with these functions is usually performed in the
<code>read(9E)</code> or <code>write(9E)</code> routines of a character device driver. See
<a href="#data-transfer-methods">Data Transfer Methods</a> for an example.</p>
</div>
</div>
<div class="sect3">
<h4 id="allocating-a-dma-handle"><a class="anchor" href="#allocating-a-dma-handle"></a>2.39.2. Allocating a DMA Handle</h4>
<div class="paragraph">
<p>A DMA handle is an opaque object that is
used as a reference to subsequently allocated DMA resources. The DMA
handle is usually allocated in the driver&#8217;s <code>attach</code> entry point that
uses <code>ddi_dma_alloc_handle(9F)</code>. The
<code>ddi_dma_alloc_handle</code> function takes the device information
that is referred to by &lt;dip&gt; and the device&#8217;s DMA attributes
described by a <code>ddi_dma_attr(9S)</code> structure as parameters. The
<code>ddi_dma_alloc_handle</code> function has the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_dma_alloc_handle(dev_info_t *dip,
    ddi_dma_attr_t *attr, int (*callback)(caddr_t),
    caddr_t arg, ddi_dma_handle_t *handlep);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>dip</code></dt>
<dd>
<p>Pointer to the device&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1"><code>attr</code></dt>
<dd>
<p>Pointer to a <code>ddi_dma_attr(9S)</code> structure, as described in
<a href="#dma-attributes">DMA Attributes</a>.</p>
</dd>
<dt class="hdlist1"><code>callback</code></dt>
<dd>
<p>Address of the callback function for handling resource allocation
failures.</p>
</dd>
<dt class="hdlist1"><code>arg</code></dt>
<dd>
<p>Argument to be passed to the callback function.</p>
</dd>
<dt class="hdlist1"><code>handlep</code></dt>
<dd>
<p>Pointer to a DMA handle to store the returned handle.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="allocating-dma-resources"><a class="anchor" href="#allocating-dma-resources"></a>2.39.3. Allocating DMA Resources</h4>
<div class="paragraph">
<p>resource allocation</p>
</div>
<div class="paragraph">
<p>Two interfaces allocate DMA resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ddi_dma_buf_bind_handle(9F)</code> – Used with <code>buf(9S)</code></p>
</li>
<li>
<p><code>ddi_dma_addr_bind_handle(9F)</code> – Used with virtual</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>DMA resources are usually allocated in the driver&#8217;s <code>xxstart</code> routine,
if an <code>xxstart</code> routine exists. See <a href="#asynchronous-data-transfers-block-drivers">Asynchronous Data
Transfers (Block Drivers)</a> for a discussion of <code>xxstart</code>. These two
interfaces have the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_dma_addr_bind_handle(ddi_dma_handle_t handle,
    struct as *as, caddr_t addr,
    size_t len, uint_t flags, int (*callback)(caddr_t),
    caddr_t arg, ddi_dma_cookie_t *cookiep, uint_t *ccountp);

int ddi_dma_buf_bind_handle(ddi_dma_handle_t handle,
    struct buf *bp, uint_t flags,
    int (*callback)(caddr_t), caddr_t arg,
    ddi_dma_cookie_t *cookiep, uint_t *ccountp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following arguments are common to both
<code>ddi_dma_addr_bind_handle(9F)</code> and
<code>ddi_dma_buf_bind_handle(9F)</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>handle</code></dt>
<dd>
<p>DMA handle and the object for allocating resources.</p>
</dd>
<dt class="hdlist1"><code>flags</code></dt>
<dd>
<p>Set of flags that indicate the transfer direction and other
attributes. <code>DDI_DMA_READ</code> indicates a data transfer from
device to memory. <code>DDI_DMA_WRITE</code> indicates a data transfer
from memory to device. See the
<code>ddi_dma_addr_bind_handle(9F)</code> or
<code>ddi_dma_buf_bind_handle(9F)</code> man page for a complete
discussion of the available flags.</p>
</dd>
<dt class="hdlist1"><code>callback</code></dt>
<dd>
<p>Address of callback function for handling resource allocation
failures. See the <code>ddi_dma_alloc_handle(9F)</code> man page.</p>
</dd>
<dt class="hdlist1"><code>arg</code></dt>
<dd>
<p>Argument to pass to the callback function.</p>
</dd>
<dt class="hdlist1"><code>cookiep</code></dt>
<dd>
<p>Pointer to the first DMA cookie for this object.</p>
</dd>
<dt class="hdlist1"><code>ccountp</code></dt>
<dd>
<p>Pointer to the number of DMA cookies for this object.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For <code>ddi_dma_addr_bind_handle(9F)</code>, the object is
described by an address range with the following parameters:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>as</code></dt>
<dd>
<p>Pointer to an address space structure. The value of <code>as</code> must be
<code>NULL</code>.</p>
</dd>
<dt class="hdlist1"><code>addr</code></dt>
<dd>
<p>Base kernel address of the object.</p>
</dd>
<dt class="hdlist1"><code>len</code></dt>
<dd>
<p>Length of the object in bytes.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For <code>ddi_dma_buf_bind_handle(9F)</code>, the object is
described by a <code>buf(9S)</code> structure pointed to by <code>bp</code>.</p>
</div>
<div class="sect4">
<h5 id="device-register-structure"><a class="anchor" href="#device-register-structure"></a>Device Register Structure</h5>
<div class="paragraph">
<p>DMA-capable devices require
more registers than were used in the previous examples.</p>
</div>
<div class="paragraph">
<p>The following fields are used in the device register structure to
support DMA-capable device with no scatter-gather support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t      dma_addr;      /* starting address for DMA */
uint32_t      dma_size;      /* amount of data to transfer */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following fields are used in the device register structure to
support DMA-capable devices with scatter-gather support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct sglentry {
    uint32_t    dma_addr;
    uint32_t    dma_size;
} sglist[SGLLEN];

caddr_t       iopb_addr;     /* When written, informs the device of the next */
                             /* command's parameter block address. */
                             /* When read after an interrupt, contains */
                             /* the address of the completed command. */</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="dma-callback-example"><a class="anchor" href="#dma-callback-example"></a>DMA Callback Example</h5>
<div class="paragraph">
<p>In <a href="#dma-17617">example_title</a>,
<code>xxstart</code> is used as the callback function. The per-device state
structure is used as the argument to <code>xxstart</code>. The <code>xxstart</code> function
attempts to start the command. If the command cannot be started because
resources are not available, <code>xxstart</code> is scheduled to be called later
when resources are available.</p>
</div>
<div class="paragraph">
<p>Because <code>xxstart</code> is used as a DMA callback, <code>xxstart</code> must adhere to
the following rules, which are imposed on DMA callbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resources cannot be assumed to be available. The callback must try to
allocate resources again.</p>
</li>
<li>
<p>The callback must indicate to the system whether allocation succeeded.
DDI_DMA_CALLBACK_RUNOUT should be returned if the callback
fails to allocate resources, in which case <code>xxstart</code> needs to be called
again later. DDI_DMA_CALLBACK_DONE indicates success, so
that no further callback is necessary.</p>
</li>
</ul>
</div>
<div id="dma-17617" class="paragraph">
<p>DMA Callback Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct device_reg *regp;
    int flags;
    mutex_enter(&amp;xsp-&gt;mu);
    if (xsp-&gt;busy) {
        /* transfer in progress */
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    xsp-&gt;busy = 1;
    regp = xsp-&gt;regp;
    if ( /* transfer is a read */ ) {
        flags = DDI_DMA_READ;
    } else {
        flags = DDI_DMA_WRITE;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    if (ddi_dma_buf_bind_handle(xsp-&gt;handle,xsp-&gt;bp,flags, xxstart,
        (caddr_t)xsp, &amp;cookie, &amp;ccount) != DDI_DMA_MAPPED) {
        /* really should check all return values in a switch */
        mutex_enter(&amp;xsp-&gt;mu);
        xsp-&gt;busy=0;
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    /* Program the DMA engine. */
    return (DDI_DMA_CALLBACK_DONE);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="determining-maximum-burst-sizes"><a class="anchor" href="#determining-maximum-burst-sizes"></a>2.39.4. Determining Maximum Burst Sizes</h4>
<div class="paragraph">
<p>Drivers specify the DMA burst sizes that
their device supports in the <code>dma_attr_burstsizes`field of the
`ddi_dma_attr(9S)</code> structure. This field is a bitmap of the
supported burst sizes. However, when DMA resources are allocated, the
system might impose further restrictions on the burst sizes that might
be actually used by the device. The <code>ddi_dma_burstsizes(9F)</code>
routine can be used to obtain the allowed burst sizes. This routine
returns the appropriate burst size bitmap for the device. When DMA
resources are allocated, a driver can ask the system for appropriate
burst sizes to use for its DMA engine.</p>
</div>
<div id="dma-ex-3" class="paragraph">
<p>Determining Burst Size</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define BEST_BURST_SIZE 0x20 /* 32 bytes */

    if (ddi_dma_buf_bind_handle(xsp-&gt;handle,xsp-&gt;bp, flags, xxstart,
        (caddr_t)xsp, &amp;cookie, &amp;ccount) != DDI_DMA_MAPPED) {
        /* error handling */
    }
    burst = ddi_dma_burstsizes(xsp-&gt;handle);
    /* check which bit is set and choose one burstsize to */
    /* program the DMA engine */
    if (burst &amp; BEST_BURST_SIZE) {
        /* program DMA engine to use this burst size */
    } else {
        /* other cases */
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="allocating-private-dma-buffers"><a class="anchor" href="#allocating-private-dma-buffers"></a>2.39.5. Allocating Private DMA Buffers</h4>
<div class="paragraph">
<p>private buffer allocation</p>
</div>
<div class="paragraph">
<p>Some device drivers might need
to allocate memory for DMA transfers in addition to performing transfers
requested by user threads and the kernel. Some examples of allocating
private DMA buffers are setting up shared memory for communication with
the device and allocating intermediate transfer buffers. Use
<code>ddi_dma_mem_alloc(9F)</code> to allocate memory for DMA
transfers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_dma_mem_alloc(ddi_dma_handle_t handle, size_t length,
    ddi_device_acc_attr_t *accattrp, uint_t flags,
    int (*waitfp)(caddr_t), caddr_t arg, caddr_t *kaddrp,
    size_t *real_length, ddi_acc_handle_t *handlep);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>handle</code></dt>
<dd>
<p>DMA handle</p>
</dd>
<dt class="hdlist1"><code>length</code></dt>
<dd>
<p>Length in bytes of the desired allocation</p>
</dd>
<dt class="hdlist1"><code>accattrp</code></dt>
<dd>
<p>Pointer to a device access attribute structure</p>
</dd>
<dt class="hdlist1"><code>flags</code></dt>
<dd>
<p>Data transfer mode flags. Possible values are
<code>DDI_DMA_CONSISTENT</code> and <code>DDI_DMA_STREAMING</code>.</p>
</dd>
<dt class="hdlist1"><code>waitfp</code></dt>
<dd>
<p>Address of callback function for handling resource allocation
failures. See the <code>ddi_dma_alloc_handle(9F)</code> man page.</p>
</dd>
<dt class="hdlist1"><code>arg</code></dt>
<dd>
<p>Argument to pass to the callback function</p>
</dd>
<dt class="hdlist1"><code>kaddrp</code></dt>
<dd>
<p>Pointer on a successful return that contains the address of the
allocated storage</p>
</dd>
<dt class="hdlist1"><code>real_length</code></dt>
<dd>
<p>Length in bytes that was allocated</p>
</dd>
<dt class="hdlist1"><code>handlep</code></dt>
<dd>
<p>Pointer to a data access handle</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>flags</code> parameter should be set to <code>DDI_DMA_CONSISTENT</code> if
the device accesses in a nonsequential fashion. Synchronization steps
that use <code>ddi_dma_sync(9F)</code> should be as lightweight as possible
due to frequent application to small objects. This type of access is
commonly known as <em>consistent</em> access. Consistent access is particularly
useful for I/O parameter blocks that are used for communication between
a device and the driver.</p>
</div>
<div class="paragraph">
<p>On the x86 platform, allocation of DMA memory that is physically
contiguous has these requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The length of the scatter-gather list <code>dma_attr_sgllen</code> in the
<code>ddi_dma_attr(9S)</code> structure must be set to 1.</p>
</li>
<li>
<p>Do not specify <code>DDI_DMA_PARTIAL</code>. <code>DDI_DMA_PARTIAL</code>
allows partial resource allocation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to allocate IOPB memory and the
necessary DMA resources to access this memory. DMA resources must still
be allocated, and the <code>DDI_DMA_CONSISTENT</code> flag must be passed
to the allocation function.</p>
</div>
<div id="dma-35641" class="paragraph">
<p>Using <code>ddi_dma_mem_alloc(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_dma_mem_alloc(xsp-&gt;iopb_handle, size, &amp;accattr,
    DDI_DMA_CONSISTENT, DDI_DMA_SLEEP, NULL, &amp;xsp-&gt;iopb_array,
    &amp;real_length, &amp;xsp-&gt;acchandle) != DDI_SUCCESS) {
    /* error handling */
    goto failure;
}
if (ddi_dma_addr_bind_handle(xsp-&gt;iopb_handle, NULL,
    xsp-&gt;iopb_array, real_length,
    DDI_DMA_READ | DDI_DMA_CONSISTENT, DDI_DMA_SLEEP,
    NULL, &amp;cookie, &amp;count) != DDI_DMA_MAPPED) {
    /* error handling */
    ddi_dma_mem_free(&amp;xsp-&gt;acchandle);
    goto failure;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>flags</code> parameter should be set to
<code>DDI_DMA_STREAMING</code> for memory transfers that are sequential,
unidirectional, block-sized, and block-aligned. This type of access is
commonly known as <em>streaming</em> access.</p>
</div>
<div class="paragraph">
<p>In some cases, an I/O transfer can be sped up by using an I/O cache. I/O
cache transfers one cache line at a minimum. The
<code>ddi_dma_mem_alloc(9F)</code> routine rounds <code>size</code> to a multiple
of the cache line to avoid data corruption.</p>
</div>
<div class="paragraph">
<p>The <code>ddi_dma_mem_alloc(9F)</code> function returns the actual size
of the allocated memory object. Because of padding and alignment
requirements, the actual size might be larger than the requested size.
The <code>ddi_dma_addr_bind_handle(9F)</code> function requires the
actual length.</p>
</div>
<div class="paragraph">
<p>Use the <code>ddi_dma_mem_free(9F)</code> function to free the memory
allocated by <code>ddi_dma_mem_alloc(9F)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Drivers must ensure that buffers are aligned appropriately. Drivers for
devices that have alignment requirements on down bound DMA buffers might
need to copy the data into a driver intermediate buffer that meets the
requirements, and then bind that intermediate buffer to the DMA handle
for DMA. Use <code>ddi_dma_mem_alloc(9F)</code> to allocate the driver
intermediate buffer. Always use <code>ddi_dma_mem_alloc(9F)</code>
instead of <code>kmem_alloc(9F)</code> to allocate memory for the device to
access.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="handling-resource-allocation-failures"><a class="anchor" href="#handling-resource-allocation-failures"></a>2.39.6. Handling Resource Allocation Failures</h4>
<div class="paragraph">
<p>The resource-allocation routines provide the driver with several options
when handling allocation failures. The <code>waitfp</code> argument indicates
whether the allocation routines block, return immediately, or schedule a
callback, as shown in the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Resource Allocation Handling</caption>
<colgroup>
<col style="width: 34%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>waitfp</code> value</th>
<th class="tableblock halign-left valign-top">Indicated Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDI_DMA_DONTWAIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Driver does not want to wait for resources to
become available</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDI_DMA_SLEEP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Driver is willing to wait indefinitely for
resources to become available</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other values</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The address of a function to be called when resources are
likely to be available</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="programming-the-dma-engine"><a class="anchor" href="#programming-the-dma-engine"></a>2.39.7. Programming the DMA Engine</h4>
<div class="paragraph">
<p>When the resources have been successfully allocated, the device must be
programmed. Although programming a DMA engine is device specific, all
DMA engines require a starting address and a transfer count. Device
drivers retrieve these two values from the <em>DMA cookie</em> returned by a
successful call from <code>ddi_dma_addr_bind_handle(9F)</code>,
<code>ddi_dma_buf_bind_handle(9F)</code>, or
<code>ddi_dma_getwin(9F)</code>. These functions all return the first DMA
cookie and a cookie count indicating whether the DMA object consists of
more than one cookie. If the cookie count &lt;N&gt; is greater than 1,
<code>ddi_dma_nextcookie(9F)</code> must be called &lt;N&gt;-1 times to
retrieve all the remaining cookies.</p>
</div>
<div class="paragraph">
<p>A DMA cookie is of type <code>ddi_dma_cookie(9S)</code>. This type of
cookie has the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint64_t    _dmac_ll;       /* 64-bit DMA address */
uint32_t    _dmac_la[2];    /* 2 x 32-bit address */
size_t      dmac_size;      /* DMA cookie size */
uint_t      dmac_type;      /* bus specific type bits */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>dmac_laddress</code> specifies a 64-bit I/O address that is
appropriate for programming the device&#8217;s DMA engine. If a device has a
64-bit DMA address register, a driver should use this field to program
the DMA engine. The <code>dmac_address</code> field specifies a 32-bit I/O
address that should be used for devices that have a 32-bit DMA address
register. The <code>dmac_size</code> field contains the transfer count.
Depending on the bus architecture, the <code>dmac_type</code> field in the
cookie might be required by the driver. The driver should not perform
any manipulations, such as logical or arithmetic, on the cookie.</p>
</div>
<div id="dma-ex-4" class="paragraph">
<p><code>ddi_dma_cookie(9S)</code> Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ddi_dma_cookie_t            cookie;

     if (ddi_dma_buf_bind_handle(xsp-&gt;handle,xsp-&gt;bp, flags, xxstart,
     (caddr_t)xsp, &amp;cookie, &amp;xsp-&gt;ccount) != DDI_DMA_MAPPED) {
         /* error handling */
      }
     sglp = regp-&gt;sglist;
     for (cnt = 1; cnt &lt;= SGLLEN; cnt++, sglp++) {
     /* store the cookie parms into the S/G list */
     ddi_put32(xsp-&gt;access_hdl, &amp;sglp-&gt;dma_size,
         (uint32_t)cookie.dmac_size);
     ddi_put32(xsp-&gt;access_hdl, &amp;sglp-&gt;dma_addr,
         cookie.dmac_address);
     /* Check for end of cookie list */
     if (cnt == xsp-&gt;ccount)
         break;
     /* Get next DMA cookie */
     (void) ddi_dma_nextcookie(xsp-&gt;handle, &amp;cookie);
     }
     /* start DMA transfer */
     ddi_put8(xsp-&gt;access_hdl, &amp;regp-&gt;csr,
     ENABLE_INTERRUPTS | START_TRANSFER);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="freeing-the-dma-resources"><a class="anchor" href="#freeing-the-dma-resources"></a>2.39.8. Freeing the DMA Resources</h4>
<div class="paragraph">
<p>freeing resources</p>
</div>
<div class="paragraph">
<p>After a DMA transfer is completed, usually in the interrupt routine, the
driver can release DMA resources by calling
<code>ddi_dma_unbind_handle(9F)</code>.</p>
</div>
<div class="paragraph">
<p>As described in <a href="#synchronizing-memory-objects">Synchronizing Memory Objects</a>,
<code>ddi_dma_unbind_handle(9F)</code> calls
<code>ddi_dma_sync(9F)</code>, eliminating the need for any explicit
synchronization. After calling <code>ddi_dma_unbind_handle(9F)</code>,
the DMA resources become invalid, and further references to the
resources have undefined results. The following example shows how to use
<code>ddi_dma_unbind_handle(9F)</code>.</p>
</div>
<div id="dma-34731" class="paragraph">
<p>Freeing DMA Resources</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static uint_t
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     uint8_t    status;
     volatile   uint8_t   temp;
     mutex_enter(&amp;xsp-&gt;mu);
     /* read status */
     status = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
     if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
     }
     ddi_put8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr, CLEAR_INTERRUPT);
     /* for store buffers */
     temp = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
     ddi_dma_unbind_handle(xsp-&gt;handle);
     /* Check for errors. */
     xsp-&gt;busy = 0;
     mutex_exit(&amp;xsp-&gt;mu);
     if ( /* pending transfers */ ) {
        (void) xxstart((caddr_t)xsp);
     }
     return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The DMA resources should be released. The DMA resources should be
reallocated if a different object is to be used in the next transfer.
However, if the same object is always used, the resources can be
allocated once. The resources can then be reused as long as intervening
calls to <code>ddi_dma_sync(9F)</code> remain.</p>
</div>
</div>
<div class="sect3">
<h4 id="freeing-the-dma-handle"><a class="anchor" href="#freeing-the-dma-handle"></a>2.39.9. Freeing the DMA Handle</h4>
<div class="paragraph">
<p>When the driver is detached, the DMA
handle must be freed. The <code>ddi_dma_free_handle(9F)</code> function
destroys the DMA handle and destroys any residual resources that the
system is caching on the handle. Any further references of the DMA
handle will have undefined results.</p>
</div>
</div>
<div class="sect3">
<h4 id="canceling-dma-callbacks"><a class="anchor" href="#canceling-dma-callbacks"></a>2.39.10. Canceling DMA Callbacks</h4>
<div class="paragraph">
<p>DMA callbacks cannot be canceled. Canceling a
DMA callback requires some additional code in the driver&#8217;s <code>detach(9E)</code>
entry point. The <code>detach</code> routine must not return <code>DDI_SUCCESS</code> if
any outstanding callbacks exist. See <a href="#dma-36458">example_title</a>.
When DMA callbacks occur, the <code>detach</code> routine must wait for the
callback to run. When the callback has finished, <code>detach</code> must prevent
the callback from rescheduling itself. Callbacks can be prevented from
rescheduling through additional fields in the state structure, as shown
in the following example.</p>
</div>
<div id="dma-36458" class="paragraph">
<p>Canceling DMA Callbacks</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
     /* ... */
     mutex_enter(&amp;xsp-&gt;callback_mutex);
     xsp-&gt;cancel_callbacks = 1;
     while (xsp-&gt;callback_count &gt; 0) {
        cv_wait(&amp;xsp-&gt;callback_cv, &amp;xsp-&gt;callback_mutex);
     }
     mutex_exit(&amp;xsp-&gt;callback_mutex);
     /* ... */
}

static int
xxstrategy(struct buf *bp)
{
     /* ... */
     mutex_enter(&amp;xsp-&gt;callback_mutex);
       xsp-&gt;bp = bp;
     error = ddi_dma_buf_bind_handle(xsp-&gt;handle, xsp-&gt;bp, flags,
         xxdmacallback, (caddr_t)xsp, &amp;cookie, &amp;ccount);
     if (error == DDI_DMA_NORESOURCES)
       xsp-&gt;callback_count++;
     mutex_exit(&amp;xsp-&gt;callback_mutex);
     /* ... */
}

static int
xxdmacallback(caddr_t callbackarg)
{
     struct xxstate *xsp = (struct xxstate *)callbackarg;
     /* ... */
     mutex_enter(&amp;xsp-&gt;callback_mutex);
     if (xsp-&gt;cancel_callbacks) {
        /* do not reschedule, in process of detaching */
        xsp-&gt;callback_count--;
        if (xsp-&gt;callback_count == 0)
           cv_signal(&amp;xsp-&gt;callback_cv);
        mutex_exit(&amp;xsp-&gt;callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);    /* don't reschedule it */
     }
     /*
      * Presumably at this point the device is still active
      * and will not be detached until the DMA has completed.
      * A return of 0 means try again later
      */
     error = ddi_dma_buf_bind_handle(xsp-&gt;handle, xsp-&gt;bp, flags,
         DDI_DMA_DONTWAIT, NULL, &amp;cookie, &amp;ccount);
     if (error == DDI_DMA_MAPPED) {
        /* Program the DMA engine. */
        xsp-&gt;callback_count--;
        mutex_exit(&amp;xsp-&gt;callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);
     }
     if (error != DDI_DMA_NORESOURCES) {
        xsp-&gt;callback_count--;
        mutex_exit(&amp;xsp-&gt;callback_mutex);
        return (DDI_DMA_CALLBACK_DONE);
     }
     mutex_exit(&amp;xsp-&gt;callback_mutex);
     return (DDI_DMA_CALLBACK_RUNOUT);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="synchronizing-memory-objects"><a class="anchor" href="#synchronizing-memory-objects"></a>2.39.11. Synchronizing Memory Objects</h4>
<div class="paragraph">
<p>In the process of accessing the memory object, the driver might need to
synchronize the memory object with respect to various caches. This
section provides guidelines on when and how to synchronize memory
objects.</p>
</div>
<div class="sect4">
<h5 id="cache"><a class="anchor" href="#cache"></a>Cache</h5>
<div class="paragraph">
<p>CPU cache is a very high-speed memory that
sits between the CPU and the system&#8217;s main memory. I/O cache sits
between the device and the system&#8217;s main memory, as shown in the
following figure.</p>
</div>
<div id="dma-fig-26" class="imageblock">
<div class="content">
<img src="figures/dma-cpucache.png" alt="Diagram shows how the cache is used to speed data transfers involving devices.">
</div>
<div class="title">Figure 8. CPU and System I/O Caches</div>
</div>
<div class="paragraph">
<p>When an attempt is made to read data from main memory, the associated
cache checks for the requested data. If the data is available, the cache
supplies the data quickly. If the cache does not have the data, the
cache retrieves the data from main memory. The cache then passes the
data on to the requester and saves the data in case of a subsequent
request.</p>
</div>
<div class="paragraph">
<p>Similarly, on a write cycle, the data is stored in the cache quickly.
The CPU or device is allowed to continue executing, that is,
transferring data. Storing data in a cache takes much less time than
waiting for the data to be written to memory.</p>
</div>
<div class="paragraph">
<p>With this model, after a device transfer is complete, the data can still
be in the I/O cache with no data in main memory. If the CPU accesses the
memory, the CPU might read the wrong data from the CPU cache. The driver
must call a synchronization routine to flush the data from the I/O cache
and update the CPU cache with the new data. This action ensures a
consistent view of the memory for the CPU. Similarly, a synchronization
step is required if data modified by the CPU is to be accessed by a
device.</p>
</div>
<div class="paragraph">
<p>You can create additional caches and buffers between the device and
memory, such as bus extenders and bridges. Use
<code>ddi_dma_sync(9F)</code> to synchronize <em>all</em> applicable caches.</p>
</div>
</div>
<div class="sect4">
<h5 id="ddidmasync-function"><a class="anchor" href="#ddidmasync-function"></a><code>ddi_dma_sync</code> Function</h5>
<div class="paragraph">
<p>A memory object might have multiple mappings, such as for the CPU and
for a device, by means of a DMA handle. A driver with multiple mappings
needs to call <code>ddi_dma_sync(9F)</code> if any mappings are used to
modify the memory object. Calling <code>ddi_dma_sync</code> ensures that
the modification of the memory object is complete before the object is
accessed through a different mapping. The <code>ddi_dma_sync</code>
function can also inform other mappings of the object if any cached
references to the object are now stale. Additionally,
<code>ddi_dma_sync</code> flushes or invalidates stale cache references as
necessary.</p>
</div>
<div class="paragraph">
<p>Generally, the driver must call <code>ddi_dma_sync</code> when a DMA
transfer completes. The exception to this rule is if deallocating the
DMA resources with <code>ddi_dma_unbind_handle(9F)</code> does an
implicit <code>ddi_dma_sync</code> on behalf of the driver. The syntax for
<code>ddi_dma_sync</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_dma_sync(ddi_dma_handle_t handle, off_t off,
size_t length, uint_t type);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the object is going to be read by the DMA engine of the device, the
device&#8217;s view of the object must be synchronized by setting
&lt;type&gt; to <code>DDI_DMA_SYNC_FORDEV</code>. If the DMA engine
of the device has written to the memory object and the object is going
to be read by the CPU, the CPU&#8217;s view of the object must be synchronized
by setting &lt;type&gt; to <code>DDI_DMA_SYNC_FORCPU</code>.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates synchronizing a DMA object for the
CPU:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_dma_sync(xsp-&gt;handle, 0, length, DDI_DMA_SYNC_FORCPU)
    == DDI_SUCCESS) {
    /* the CPU can now access the transferred data */
    /* ... */
} else {
    /* error handling */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the flag <code>DDI_DMA_SYNC_FORKERNEL</code> if the only mapping is
for the kernel, as in the case of memory that is allocated by
<code>ddi_dma_mem_alloc(9F)</code>. The system tries to synchronize the
kernel&#8217;s view more quickly than the CPU&#8217;s view. If the system cannot
synchronize the kernel view faster, the system acts as if the
<code>DDI_DMA_SYNC_FORCPU</code> flag were set.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dma-windows"><a class="anchor" href="#dma-windows"></a>2.40. DMA Windows</h3>
<div class="paragraph">
<p>If an object does not fit within
the limitations of the DMA engine, the transfer must be broken into a
series of smaller transfers. The driver can break up the transfer
itself. Alternatively, the driver can allow the system to allocate
resources for only part of the object, thereby creating a series of DMA
<em>windows</em>. Allowing the system to allocate resources is the preferred
solution, because the system can manage the resources more effectively
than the driver can manage the resources.</p>
</div>
<div class="paragraph">
<p>A DMA window has two attributes. The &lt;offset&gt; attribute is
measured from the beginning of the object. The &lt;length&gt;
attribute is the number of bytes of memory to be allocated. After a
partial allocation, only a range of &lt;length&gt; bytes that starts
at &lt;offset&gt; has allocated resources.</p>
</div>
<div class="paragraph">
<p>A DMA window is requested by specifying the <code>DDI_DMA_PARTIAL</code>
flag as a parameter to <code>ddi_dma_buf_bind_handle(9F)</code> or
<code>ddi_dma_addr_bind_handle(9F)</code>. Both functions return
<code>DDI_DMA_PARTIAL_MAP</code> if a window can be established.
However, the system might allocate resources for the entire object, in
which case <code>DDI_DMA_MAPPED</code> is returned. The driver should check
the return value to determine whether DMA windows are in use. See the
following example.</p>
</div>
<div id="dma-23815" class="paragraph">
<p>Setting Up DMA Windows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstart (caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct device_reg *regp = xsp-&gt;reg;
    ddi_dma_cookie_t cookie;
    int status;
    mutex_enter(&amp;xsp-&gt;mu);
    if (xsp-&gt;busy) {
        /* transfer in progress */
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_DMA_CALLBACK_RUNOUT);
    }
    xsp-&gt;busy = 1;
    mutex_exit(&amp;xsp-&gt;mu);
    if ( /* transfer is a read */) {
        flags = DDI_DMA_READ;
    } else {
        flags = DDI_DMA_WRITE;
    }
    flags |= DDI_DMA_PARTIAL;
    status = ddi_dma_buf_bind_handle(xsp-&gt;handle, xsp-&gt;bp,
        flags, xxstart, (caddr_t)xsp, &amp;cookie, &amp;ccount);
    if (status != DDI_DMA_MAPPED &amp;&amp;
        status != DDI_DMA_PARTIAL_MAP)
        return (DDI_DMA_CALLBACK_RUNOUT);
    if (status == DDI_DMA_PARTIAL_MAP) {
        ddi_dma_numwin(xsp-&gt;handle, &amp;xsp-&gt;nwin);
        xsp-&gt;partial = 1;
        xsp-&gt;windex = 0;
    } else {
        xsp-&gt;partial = 0;
    }
    /* Program the DMA engine. */
    return (DDI_DMA_CALLBACK_DONE);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two functions operate with DMA windows. The first,
<code>ddi_dma_numwin(9F)</code>, returns the number of DMA windows for a
particular DMA object. The other function, <code>ddi_dma_getwin(9F)</code>,
allows repositioning within the object, that is, reallocation of system
resources. The <code>ddi_dma_getwin</code> function shifts the current
window to a new window within the object. Because
<code>ddi_dma_getwin</code> reallocates system resources to the new window,
the previous window becomes invalid.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Do not move the DMA windows with a call to <code>ddi_dma_getwin</code>
before transfers into the current window are complete. Wait until the
transfer to the current window is complete, which is when the interrupt
arrives. Then call <code>ddi_dma_getwin</code> to avoid data corruption.
===
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ddi_dma_getwin</code> function is normally called from an
interrupt routine, as shown in <a href="#dma-41452">example_title</a>. The
first DMA transfer is initiated as a result of a call to the driver.
Subsequent transfers are started from the interrupt routine.</p>
</div>
<div class="paragraph">
<p>The interrupt routine examines the status of the device to determine
whether the device completes the transfer successfully. If not, normal
error recovery occurs. If the transfer is successful, the routine must
determine whether the logical transfer is complete. A complete transfer
includes the entire object as specified by the <code>buf(9S)</code> structure. In a
partial transfer, only one DMA window is moved. In a partial transfer,
the interrupt routine moves the window with
<code>ddi_dma_getwin(9F)</code>, retrieves a new cookie, and starts another
DMA transfer.</p>
</div>
<div class="paragraph">
<p>If the logical request has been completed, the interrupt routine checks
for pending requests. If necessary, the interrupt routine starts a
transfer. Otherwise, the routine returns without invoking another DMA
transfer. The following example illustrates the usual flow control.</p>
</div>
<div id="dma-41452" class="paragraph">
<p>Interrupt Handler Using DMA Windows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static uint_t
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    uint8_t    status;
    volatile   uint8_t   temp;
    mutex_enter(&amp;xsp-&gt;mu);
    /* read status */
    status = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    ddi_put8(xsp-&gt;access_hdl,&amp;xsp-&gt;regp-&gt;csr, CLEAR_INTERRUPT);
    /* for store buffers */
    temp = ddi_get8(xsp-&gt;access_hdl, &amp;xsp-&gt;regp-&gt;csr);
    if ( /* an error occurred during transfer */ ) {
        bioerror(xsp-&gt;bp, EIO);
        xsp-&gt;partial = 0;
    } else {
        xsp-&gt;bp-&gt;b_resid -= /* amount transferred */ ;
    }

    if (xsp-&gt;partial &amp;&amp; (++xsp-&gt;windex &lt; xsp-&gt;nwin)) {
        /* device still marked busy to protect state */
        mutex_exit(&amp;xsp-&gt;mu);
        (void) ddi_dma_getwin(xsp-&gt;handle, xsp-&gt;windex,
            &amp;offset, &amp;len, &amp;cookie, &amp;ccount);
        /* Program the DMA engine with the new cookie(s). */
        return (DDI_INTR_CLAIMED);
    }
    ddi_dma_unbind_handle(xsp-&gt;handle);
    biodone(xsp-&gt;bp);
    xsp-&gt;busy = 0;
    xsp-&gt;partial = 0;
    mutex_exit(&amp;xsp-&gt;mu);
    if ( /* pending transfers */ ) {
        (void) xxstart((caddr_t)xsp);
    }
    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-device-and-kernel-memory"><a class="anchor" href="#mapping-device-and-kernel-memory"></a>2.41. Mapping Device and Kernel Memory</h3>
<div class="paragraph">
<p>memory mapping</p>
</div>
<div class="paragraph">
<p>device memory management</p>
</div>
<div class="paragraph">
<p>device memory</p>
</div>
<div class="paragraph">
<p>Some device drivers allow applications to access device or kernel memory
through <code>mmap(2)</code>. Frame buffer drivers, for example, enable the frame
buffer to be mapped into a user thread. Another example would be a
pseudo driver that uses a shared kernel memory pool to communicate with
an application. This chapter provides information on the following
subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#memory-mapping-overview">Memory Mapping Overview</a></p>
</li>
<li>
<p><a href="#exporting-the-mapping">Exporting the Mapping</a></p>
</li>
<li>
<p><a href="#associating-device-memory-with-user-mappings">Associating Device Memory With User Mappings</a></p>
</li>
<li>
<p><a href="#associating-kernel-memory-with-user-mappings">Associating Kernel Memory With User Mappings</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="memory-mapping-overview"><a class="anchor" href="#memory-mapping-overview"></a>2.42. Memory Mapping Overview</h3>
<div class="paragraph">
<p>The steps that a driver must take to export device or kernel memory are
as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set the <code>D_DEVMAP</code> flag in the <code>cb_flag</code> flag of the
<code>cb_ops(9S)</code> structure.</p>
</li>
<li>
<p>Define a <code>devmap(9E)</code> driver entry point and optional <code>segmap(9E)</code>
entry point to export the mapping.</p>
</li>
<li>
<p>Use <code>devmap_devmem_setup(9F)</code> to set up user mappings to a
device. To set up user mappings to kernel memory, use
<code>devmap_umem_setup(9F)</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="exporting-the-mapping"><a class="anchor" href="#exporting-the-mapping"></a>2.43. Exporting the Mapping</h3>
<div class="paragraph">
<p>This section describes how to use the <code>segmap(9E)</code> and <code>devmap(9E)</code>
entry points.</p>
</div>
<div class="sect3">
<h4 id="the-segmap9e-entry-point"><a class="anchor" href="#the-segmap9e-entry-point"></a>2.43.1. The <code>segmap</code>(9E) Entry Point</h4>
<div class="paragraph">
<p>The <code>segmap(9E)</code> entry point is responsible for setting
up a memory mapping requested by an <code>mmap(2)</code> system call. Drivers for
many memory-mapped devices use <code>ddi_devmap_segmap(9F)</code> as the
entry point rather than defining their own <code>segmap(9E)</code> routine. By
providing a <code>segmap</code> entry point, a driver can take care of general
tasks before or after creating the mapping. For example, the driver can
check mapping permissions and allocate private mapping resources. The
driver can also make adjustments to the mapping to accommodate
non-page-aligned device buffers. The <code>segmap</code> entry point must call the
<code>ddi_devmap_segmap(9F)</code> function before returning. The
<code>ddi_devmap_segmap</code> function calls the driver&#8217;s <code>devmap(9E)</code>
entry point to perform the actual mapping.</p>
</div>
<div class="paragraph">
<p>The <code>segmap</code> function has the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int segmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp,
     off_t len, unsigned int prot, unsigned int maxprot,
     unsigned int flags, cred_t *credp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;dev&gt;</dt>
<dd>
<p>Device whose memory is to be mapped.</p>
</dd>
<dt class="hdlist1">&lt;off&gt;</dt>
<dd>
<p>Offset within device memory at which mapping begins.</p>
</dd>
<dt class="hdlist1">&lt;asp&gt;</dt>
<dd>
<p>Pointer to the address space into which the device memory should be
mapped.
+
Note that this argument can be either a <code>struct as *</code>, as shown in
<a href="#segmap-1">example_title</a>, or a <code>ddi_as_handle_t</code>,
as shown in <a href="#segmap-2">example_title</a>. This is because
<code>ddidevmap.h</code> includes the following declaration:
+</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct as *ddi_as_handle_t</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;addrp&gt;</dt>
<dd>
<p>Pointer to the address in the address space to which the device memory
should be mapped.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length (in bytes) of the memory being mapped.</p>
</dd>
<dt class="hdlist1">&lt;prot&gt;</dt>
<dd>
<p>A bit field that specifies the protections. Possible settings are
PROT_READ, PROT_WRITE, PROT_EXEC, PROT_USER, and
PROT_ALL. See the man page for details.</p>
</dd>
<dt class="hdlist1">&lt;maxprot&gt;</dt>
<dd>
<p>Maximum protection flag possible for attempted mapping. The
PROT_WRITE bit can be masked out if the user opened the special
file read-only.</p>
</dd>
<dt class="hdlist1">&lt;flags&gt;</dt>
<dd>
<p>Flags that indicate the type of mapping. Possible values include
MAP_SHARED and MAP_PRIVATE.</p>
</dd>
<dt class="hdlist1">&lt;credp&gt;</dt>
<dd>
<p>Pointer to the user credentials structure.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In the following example, the driver controls a frame buffer that allows
write-only mappings. The driver returns EINVAL if the application tries
to gain read access and then calls <code>ddi_devmap_segmap(9F)</code> to
set up the user mapping.</p>
</div>
<div id="segmap-1" class="paragraph">
<p><code>segmap(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxsegmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp,
    off_t len, unsigned int prot, unsigned int maxprot,
    unsigned int flags, cred_t *credp)
{
    if (prot &amp; PROT_READ)
        return (EINVAL);
    return (ddi_devmap_segmap(dev, off, as, addrp,
        len, prot, maxprot, flags, cred));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to handle a device that has a buffer
that is not page-aligned in its register space. This example maps a
buffer that starts at offset 0x800, so that <code>mmap(2)</code> returns an address
that corresponds to the start of the buffer. The
<code>devmap_devmem_setup(9F)</code> function maps entire pages, requires
the mapping to be page aligned, and returns an address to the start of a
page. If this address is passed through <code>segmap(9E)</code>, or if no <code>segmap</code>
entry point is defined, <code>mmap</code> returns the address that corresponds to
the start of the page, not the address that corresponds to the start of
the buffer. In this example, the buffer offset is added to the
page-aligned address that was returned by <code>devmap_devmem_setup</code>
so that the resulting address returned is the desired start of the
buffer.</p>
</div>
<div id="segmap-2" class="paragraph">
<p>Using the <code>segmap</code> Function to Change the Address Returned by the <code>mmap</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define BUFFER_OFFSET 0x800

xx_segmap(dev_t dev, off_t off, ddi_as_handle_t as, caddr_t *addrp, off_t len,
    uint_t prot, uint_t maxprot, uint_t flags, cred_t *credp)
{
        int rval;
        unsigned long pagemask = ptob(1L) - 1L;

        if ((rval = ddi_devmap_segmap(dev, off, as, addrp, len, prot, maxprot,
            flags, credp)) == DDI_SUCCESS) {
                /*
                 * The address returned by ddi_devmap_segmap is the start of the page
                 * that contains the buffer.  Add the offset of the buffer to get the
                 * final address.
                 */
                *addrp += BUFFER_OFFSET &amp; pagemask);
        }
        return (rval);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the-devmap9e-entry-point"><a class="anchor" href="#the-devmap9e-entry-point"></a>2.43.2. The <code>devmap</code>(9E) Entry Point</h4>
<div class="paragraph">
<p>The <code>devmap(9E)</code> entry point is called from the
<code>ddi_devmap_segmap(9F)</code> function inside the <code>segmap(9E)</code> entry
point.</p>
</div>
<div class="paragraph">
<p>The <code>devmap(9E)</code> entry point is called as a result of the <code>mmap(2)</code>
system call. The <code>devmap(9E)</code> function is called to export device memory
or kernel memory to user applications. The <code>devmap</code> function is used for
the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Validate the user mapping to the device or kernel memory</p>
</li>
<li>
<p>Translate the logical offset within the application mapping to the
corresponding offset within the device or kernel memory</p>
</li>
<li>
<p>Pass the mapping information to the system for setting up the mapping</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>devmap</code> function has the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int devmap(dev_t dev, devmap_cookie_t handle, offset_t off,
     size_t len, size_t *maplen, uint_t model);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;dev&gt;</dt>
<dd>
<p>Device whose memory is to be mapped.</p>
</dd>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Device-mapping handle that the system creates and uses to describe a
mapping to contiguous memory in the device or kernel.</p>
</dd>
<dt class="hdlist1">&lt;off&gt;</dt>
<dd>
<p>Logical offset within the application mapping that has to be
translated by the driver to the corresponding offset within the device
or kernel memory.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length (in bytes) of the memory being mapped.</p>
</dd>
<dt class="hdlist1">&lt;maplen&gt;</dt>
<dd>
<p>Enables driver to associate different kernel memory regions or
multiple physically discontiguous memory regions with one contiguous
user application mapping.</p>
</dd>
<dt class="hdlist1">&lt;model&gt;</dt>
<dd>
<p>Data model type of the current thread.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The system creates multiple mapping
handles in one <code>mmap(2)</code> system call. For example, the mapping might
contain multiple physically discontiguous memory regions.</p>
</div>
<div class="paragraph">
<p>Initially, <code>devmap(9E)</code> is called with the parameters &lt;off&gt; and
&lt;len&gt;. These parameters are passed by the application to
<code>mmap(2)</code>. <code>devmap(9E)</code> sets <code>*</code>&lt;maplen&gt; to the length from
&lt;off&gt; to the end of a contiguous memory region. The
<code>*</code>&lt;maplen&gt; value must be rounded up to a multiple of a page
size. The <code>*</code>&lt;maplen&gt; value can be set to less than the
original mapping length <code>len</code>. If so, the system uses a new mapping
handle with adjusted &lt;off&gt; and &lt;len&gt; parameters to call
<code>devmap(9E)</code> repeatedly until the initial mapping length is satisfied.</p>
</div>
<div class="paragraph">
<p>If a driver supports multiple application data models, &lt;model&gt;
must be passed to <code>ddi_model_convert_from(9F)</code>. The
<code>ddi_model_convert_from</code> function determines whether a data
model mismatch exists between the current thread and the device driver.
The device driver might have to adjust the shape of data structures
before exporting the structures to a user thread that supports a
different data model. See <a href="#making-a-device-driver-64-bit-ready">appendix_title</a> page for
more details.</p>
</div>
<div class="paragraph">
<p>The <code>devmap(9E)</code> entry point must return <code>-1</code> if the logical offset,
&lt;off&gt;, is out of the range of memory exported by the driver.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="associating-device-memory-with-user-mappings"><a class="anchor" href="#associating-device-memory-with-user-mappings"></a>2.44. Associating Device Memory With User Mappings</h3>
<div class="paragraph">
<p><code>devmap_devmem_setup(9F)</code> from the driver&#8217;s <code>devmap(9E)</code> entry
point to export device memory to user applications.</p>
</div>
<div class="paragraph">
<p>The <code>devmap_devmem_setup(9F)</code> function has the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int devmap_devmem_setup(devmap_cookie_t handle, dev_info_t *dip,
    struct devmap_callback_ctl *callbackops, uint_t rnumber,
    offset_t roff, size_t len, uint_t maxprot, uint_t flags,
    ddi_device_acc_attr_t *accattrp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Opaque device-mapping handle that the system uses to identify the
mapping.</p>
</dd>
<dt class="hdlist1">&lt;dip&gt;</dt>
<dd>
<p>Pointer to the device&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;callbackops&gt;</dt>
<dd>
<p>Pointer to a <code>devmap_callback_ctl(9S)</code> structure that enables
the driver to be notified of user events on the mapping.</p>
</dd>
<dt class="hdlist1">&lt;rnumber&gt;</dt>
<dd>
<p>Index number to the register address space set.</p>
</dd>
<dt class="hdlist1">&lt;roff&gt;</dt>
<dd>
<p>Offset into the device memory.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length in bytes that is exported.</p>
</dd>
<dt class="hdlist1">&lt;maxprot&gt;</dt>
<dd>
<p>Allows the driver to specify different protections for different
regions within the exported device memory.</p>
</dd>
<dt class="hdlist1">&lt;flags&gt;</dt>
<dd>
<p>Must be set to <code>DEVMAP_DEFAULTS</code>.</p>
</dd>
<dt class="hdlist1">&lt;accattrp&gt;</dt>
<dd>
<p>Pointer to a <code>ddi_device_acc_attr(9S)</code> structure.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The &lt;roff&gt; and &lt;len&gt; arguments describe a range within
the device memory specified by the register set &lt;rnumber&gt;. The
register specifications that are referred to by &lt;rnumber&gt; are
described by the <code>reg</code> property. For devices with only one register set,
pass zero for <code>rnumber</code>. The range is defined by &lt;roff&gt; and
&lt;len&gt;. The range is made accessible to the user&#8217;s application
mapping at the &lt;offset&gt; that is passed in by the <code>devmap(9E)</code>
entry point. Usually the driver passes the <code>devmap(9E)</code> offset directly
to <code>devmap_devmem_setup(9F)</code>. The return address of <code>mmap(2)</code>
then maps to the beginning address of the register set.</p>
</div>
<div class="paragraph">
<p>The &lt;maxprot&gt; argument enables the driver to specify different
protections for different regions within the exported device memory. For
example, to disallow write access for a region, set only <code>PROT_READ</code>
and <code>PROT_USER</code> for that region.</p>
</div>
<div class="paragraph">
<p>The following example shows how to export device memory to an
application. The driver first determines whether the requested mapping
falls within the device memory region. The size of the device memory is
determined using <code>ddi_dev_regsize(9F)</code>. The length of the
mapping is rounded up to a multiple of a page size using <code>ptob(9F)</code> and
<code>btopr(9F)</code>. Then <code>devmap_devmem_setup(9F)</code> is called to export
the device memory to the application.</p>
</div>
<div id="devmap-23038" class="paragraph">
<p>Using the <code>devmap_devmem_setup</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off, size_t len,
    size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    int    error, rnumber;
    off_t regsize;

    /* Set up data access attribute structure */
    struct ddi_device_acc_attr xx_acc_attr = {
        DDI_DEVICE_ATTR_V0,
        DDI_NEVERSWAP_ACC,
    };
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (-1);
    /* use register set 0 */
    rnumber = 0;
    /* get size of register set */
    if (ddi_dev_regsize(xsp-&gt;dip, rnumber, &amp;regsize) != DDI_SUCCESS)
        return (-1);
    /* round up len to a multiple of a page size */
       len = ptob(btopr(len));
    if (off + len &gt; regsize)
        return (-1);
    /* Set up the device mapping */
    error = devmap_devmem_setup(handle, xsp-&gt;dip, NULL, rnumber,
    off, len, PROT_ALL, DEVMAP_DEFAULTS, &amp;xx_acc_attr);
    /* acknowledge the entire range */
    *maplen = len;
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="associating-kernel-memory-with-user-mappings"><a class="anchor" href="#associating-kernel-memory-with-user-mappings"></a>2.45. Associating Kernel Memory With User Mappings</h3>
<div class="paragraph">
<p>Some device drivers might
need to allocate kernel memory that is made accessible to user programs
through <code>mmap(2)</code>. One example is setting up shared memory for
communication between two applications. Another example is sharing
memory between a driver and an application.</p>
</div>
<div class="paragraph">
<p>When exporting kernel memory to user applications, follow these steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use <code>ddi_umem_alloc(9F)</code> to allocate kernel memory.</p>
</li>
<li>
<p>Use <code>devmap_umem_setup(9F)</code> to export the memory.</p>
</li>
<li>
<p>Use <code>ddi_umem_free(9F)</code> to free the memory when the memory is
no longer needed.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="allocating-kernel-memory-for-user-access"><a class="anchor" href="#allocating-kernel-memory-for-user-access"></a>2.45.1. Allocating Kernel Memory for User Access</h4>
<div class="paragraph">
<p>Use <code>ddi_umem_alloc(9F)</code> to
allocate kernel memory that is exported to applications.
<code>ddi_umem_alloc</code> uses the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void *ddi_umem_alloc(size_t size, int flag, ddi_umem_cookie_t
*cookiep);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;size&gt;</dt>
<dd>
<p>Number of bytes to allocate.</p>
</dd>
<dt class="hdlist1">&lt;flag&gt;</dt>
<dd>
<p>Used to determine the sleep conditions and the memory type.</p>
</dd>
<dt class="hdlist1">&lt;cookiep&gt;</dt>
<dd>
<p>Pointer to a kernel memory cookie.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>ddi_umem_alloc(9F)</code> allocates page-aligned kernel memory.
<code>ddi_umem_alloc</code> returns a pointer to the allocated memory.
Initially, the memory is filled with zeroes. The number of bytes that
are allocated is a multiple of the system page size, which is rounded up
from the &lt;size&gt; parameter. The allocated memory can be used in
the kernel. This memory can be exported to applications as well.
&lt;cookiep&gt; is a pointer to the kernel memory cookie that
describes the kernel memory being allocated. &lt;cookiep&gt; is used
in <code>devmap_umem_setup(9F)</code> when the driver exports the kernel
memory to a user application.</p>
</div>
<div class="paragraph">
<p>The &lt;flag&gt; argument indicates whether
<code>ddi_umem_alloc(9F)</code> blocks or returns immediately, and whether
the allocated kernel memory is pageable. The values for the <code>flag</code>
argument as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>DDI_UMEM_NOSLEEP</code></dt>
<dd>
<p>Driver does not need to wait for memory to become available. Return
<code>NULL</code> if memory is not available.</p>
</dd>
<dt class="hdlist1"><code>DDI_UMEM_SLEEP</code></dt>
<dd>
<p>Driver can wait indefinitely for memory to become available.</p>
</dd>
<dt class="hdlist1"><code>DDI_UMEM_PAGEABLE</code></dt>
<dd>
<p>Driver allows memory to be paged out. If not set, the memory is locked
down.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>ddi_umem_lock</code> function can perform device-locked-memory
checks. The function checks against the limit value that is specified in
<code>project.max-locked-memory</code>. If the current project locked-memory usage
is below the limit, the project&#8217;s locked-memory byte count is increased.
After the limit check, the memory is locked. The
<code>ddi_umem_unlock</code> function unlocks the memory, and the project&#8217;s
locked-memory byte count is decremented.</p>
</div>
<div class="paragraph">
<p>The accounting method that is used is an imprecise full price model. For
example, two callers of <code>umem_lockmemory</code> within the same project
with overlapping memory regions are charged twice.</p>
</div>
<div class="paragraph">
<p>For information about the <code>project.max-locked-memory</code> and
<code>zone.max-locked_memory</code> resource controls on illumos systems with
zones installed, see illumos Containers: Resource Management and illumos
Zones Developer’s Guide and see <code>resource_controls(7)</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to allocate kernel memory for
application access. The driver exports one page of kernel memory, which
is used by multiple applications as a shared memory area. The memory is
allocated in <code>segmap(9E)</code> when an application maps the shared page the
first time. An additional page is allocated if the driver has to support
multiple application data models. For example, a 64-bit driver might
export memory both to 64-bit applications and to 32-bit applications.
64-bit applications share the first page, and 32-bit applications share
the second page.</p>
</div>
<div id="devmap-25235" class="paragraph">
<p>Using the <code>ddi_umem_alloc</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxsegmap(dev_t dev, off_t off, struct as *asp, caddr_t *addrp, off_t len,
    unsigned int prot, unsigned int maxprot, unsigned int flags,
    cred_t *credp)
{
    int error;
    minor_t instance = getminor(dev);
    struct xxstate *xsp = ddi_get_soft_state(statep, instance);

    size_t mem_size;
        /* 64-bit driver supports 64-bit and 32-bit applications */
    switch (ddi_mmap_get_model()) {
        case DDI_MODEL_LP64:
             mem_size = ptob(2);
             break;
        case DDI_MODEL_ILP32:
             mem_size = ptob(1);
             break;
    }

    mutex_enter(&amp;xsp-&gt;mu);
    if (xsp-&gt;umem == NULL) {
        /* allocate the shared area as kernel pageable memory */
        xsp-&gt;umem = ddi_umem_alloc(mem_size,
            DDI_UMEM_SLEEP | DDI_UMEM_PAGEABLE, &amp;xsp-&gt;ucookie);
    }
    mutex_exit(&amp;xsp-&gt;mu);
    /* Set up the user mapping */
    error = devmap_setup(dev, (offset_t)off, asp, addrp, len,
        prot, maxprot, flags, credp);
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exporting-kernel-memory-to-applications"><a class="anchor" href="#exporting-kernel-memory-to-applications"></a>2.45.2. Exporting Kernel Memory to Applications</h4>
<div class="paragraph">
<p>Use <code>devmap_umem_setup(9F)</code> to
export kernel memory to user applications. <code>devmap_umem_setup</code>
must be called from the driver&#8217;s <code>devmap(9E)</code> entry point. The syntax
for <code>devmap_umem_setup</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int devmap_umem_setup(devmap_cookie_t handle, dev_info_t *dip,
    struct devmap_callback_ctl *callbackops, ddi_umem_cookie_t cookie,
    offset_t koff, size_t len, uint_t maxprot, uint_t flags,
    ddi_device_acc_attr_t *accattrp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Opaque structure used to describe the mapping.</p>
</dd>
<dt class="hdlist1">&lt;dip&gt;</dt>
<dd>
<p>Pointer to the device&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;callbackops&gt;</dt>
<dd>
<p>Pointer to a <code>devmap_callback_ctl(9S)</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;cookie&gt;</dt>
<dd>
<p>Kernel memory cookie returned by <code>ddi_umem_alloc(9F)</code>.</p>
</dd>
<dt class="hdlist1">&lt;koff&gt;</dt>
<dd>
<p>Offset into the kernel memory specified by cookie.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length in bytes that is exported.</p>
</dd>
<dt class="hdlist1">&lt;maxprot&gt;</dt>
<dd>
<p>Specifies the maximum protection possible for the exported mapping.</p>
</dd>
<dt class="hdlist1">&lt;flags&gt;</dt>
<dd>
<p>Must be set to <code>DEVMAP_DEFAULTS</code>.</p>
</dd>
<dt class="hdlist1">&lt;accattrp&gt;</dt>
<dd>
<p>Pointer to a <code>ddi_device_acc_attr(9S)</code> structure.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>&lt;handle&gt; is a device-mapping handle that the system uses to
identify the mapping. &lt;handle&gt; is passed in by the <code>devmap(9E)</code>
entry point. &lt;dip&gt; is a pointer to the device&#8217;s <code>dev_info</code>
structure. &lt;callbackops&gt; enables the driver to be notified of
user events on the mapping. Most drivers set &lt;callbackops&gt; to
<code>NULL</code> when kernel memory is exported.</p>
</div>
<div class="paragraph">
<p>&lt;koff&gt; and &lt;len&gt; specify a range within the kernel
memory allocated by <code>ddi_umem_alloc(9F)</code>. This range is made
accessible to the user&#8217;s application mapping at the offset that is
passed in by the <code>devmap(9E)</code> entry point. Usually, the driver passes
the <code>devmap(9E)</code> offset directly to <code>devmap_umem_setup(9F)</code>. The
return address of <code>mmap(2)</code> then maps to the kernel address returned by
<code>ddi_umem_alloc(9F)</code>. &lt;koff&gt; and &lt;len&gt; must be
page-aligned.</p>
</div>
<div class="paragraph">
<p>&lt;maxprot&gt; enables the driver to specify different protections
for different regions within the exported kernel memory. For example,
one region might not allow write access by only setting <code>PROT_READ</code>
and <code>PROT_USER</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to export kernel memory to an
application. The driver first checks whether the requested mapping falls
within the allocated kernel memory region. If a 64-bit driver receives a
mapping request from a 32-bit application, the request is redirected to
the second page of the kernel memory area. This redirection ensures that
only applications compiled to the same data model share the same page.</p>
</div>
<div id="devmap-19641" class="paragraph">
<p><code>devmap_umem_setup(9F)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off, size_t len,
    size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    int    error;

    /* round up len to a multiple of a page size */
    len = ptob(btopr(len));
    /* check if the requested range is ok */
    if (off + len &gt; ptob(1))
        return (ENXIO);
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);

    if (ddi_model_convert_from(model) == DDI_MODEL_ILP32)
        /* request from 32-bit application. Skip first page */
        off += ptob(1);

    /* export the memory to the application */
    error = devmap_umem_setup(handle, xsp-&gt;dip, NULL, xsp-&gt;ucookie,
        off, len, PROT_ALL, DEVMAP_DEFAULTS, NULL);
    *maplen = len;
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="freeing-kernel-memory-exported-for-user-access"><a class="anchor" href="#freeing-kernel-memory-exported-for-user-access"></a>2.45.3. Freeing Kernel Memory Exported for User Access</h4>
<div class="paragraph">
<p>When the driver is unloaded, the memory
that was allocated by <code>ddi_umem_alloc(9F)</code> must be freed by
calling <code>ddi_umem_free(9F)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_umem_free(ddi_umem_cookie_t cookie);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;cookie&gt; is the kernel memory cookie returned by
<code>ddi_umem_alloc(9F)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-context-management"><a class="anchor" href="#device-context-management"></a>2.46. Device Context Management</h3>
<div class="paragraph">
<p>Some device drivers, such as drivers for graphics hardware, provide user
processes with direct access to the device. These devices often require
that only one process at a time accesses the device.</p>
</div>
<div class="paragraph">
<p>This chapter describes the set of interfaces that enable device drivers
to manage access to such devices. The chapter provides information on
the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#introduction-to-device-context">Introduction to Device Context</a></p>
</li>
<li>
<p><a href="#context-management-model">Context Management Model</a></p>
</li>
<li>
<p><a href="#context-management-operation">Context Management Operation</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="introduction-to-device-context"><a class="anchor" href="#introduction-to-device-context"></a>2.47. Introduction to Device Context</h3>
<div class="paragraph">
<p>This section introduces device context and the context management model.</p>
</div>
<div class="sect3">
<h4 id="what-is-a-device-context"><a class="anchor" href="#what-is-a-device-context"></a>2.47.1. What Is a Device Context?</h4>
<div class="paragraph">
<p><em>context</em> of a device is the current state of the device hardware. The
device driver manages the device context for a process on behalf of the
process. The driver must maintain a separate device context for each
process that accesses the device. The device driver has the
responsibility to restore the correct device context when a process
accesses the device.</p>
</div>
</div>
<div class="sect3">
<h4 id="context-management-model"><a class="anchor" href="#context-management-model"></a>2.47.2. Context Management Model</h4>
<div class="paragraph">
<p>buffers provide a good example of device context management. An
accelerated frame buffer enables user processes to directly manipulate
the control registers of the device through memory-mapped access.
Because these processes do not use traditional system calls, a process
that accesses the device need not call the device driver. However, the
device driver must be notified when a process is about to access a
device. The driver needs to restore the correct device context and needs
to provide any necessary synchronization.</p>
</div>
<div class="paragraph">
<p>To resolve this problem, the device context management interfaces enable
a device driver to be notified when a user process accesses
memory-mapped regions of the device, and to control accesses to the
device&#8217;s hardware. Synchronization and management of the various device
contexts are the responsibility of the device driver. When a user
process accesses a mapping, the device driver must restore the correct
device context for that process.</p>
</div>
<div class="paragraph">
<p>A device driver is notified whenever a user process performs any of the
following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Accesses a mapping</p>
</li>
<li>
<p>Duplicates a mapping</p>
</li>
<li>
<p>Frees a mapping</p>
</li>
<li>
<p>Creates a mapping</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following figure shows multiple user processes that have
memory-mapped a device. The driver has granted process B access to the
device, and process B no longer notifies the driver of accesses.
However, the driver <em>is</em> still notified if either process A or process C
accesses the device.</p>
</div>
<div id="devcnmgt-fig-3" class="imageblock">
<div class="content">
<img src="figures/devcnmgt-view.png" alt="Diagram shows three processes" width="A" height="B">
</div>
<div class="title">Figure 9. Device Context Management</div>
</div>
<div class="paragraph">
<p>At some point in the future, process A accesses the device. The device
driver is notified and blocks future access to the device by process B.
The driver then saves the device context for process B. The driver
restores the device context of process A. The driver then grants access
to process A, as illustrated in the following figure. At this point, the
device driver is notified if either process B or process C accesses the
device.</p>
</div>
<div id="devcnmgt-fig-4" class="imageblock">
<div class="content">
<img src="figures/devcnmgt-contextswitch.png" alt="Diagram continues example in previous figure with sole device access switched to Process A.">
</div>
<div class="title">Figure 10. Device Context Switched to User Process A</div>
</div>
<div class="paragraph">
<p>On a multiprocessor machine, multiple processes could attempt to access
the device at the same time. This situation can cause thrashing. Some
devices require a longer time to restore a device context. To prevent
more CPU time from being used to restore a device context than to
actually use that device context, the minimum time that a process needs
to have access to the device can be set using
<code>devmap_set_ctx_timeout(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The kernel guarantees that once a device driver has
granted access to a process, no other process is allowed to request
access to the same device for the time interval specified by
<code>devmap_set_ctx_timeout(9F)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-management-operation"><a class="anchor" href="#context-management-operation"></a>2.48. Context Management Operation</h3>
<div class="paragraph">
<p>The general steps for performing device context
management are as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define a <code>devmap_callback_ctl(9S)</code> structure.</p>
</li>
<li>
<p>Allocate space to save device context if necessary.</p>
</li>
<li>
<p>Set up user mappings to the device and driver notifications with
<code>devmap_devmem_setup(9F)</code>.</p>
</li>
<li>
<p>Manage user access to the device with <code>devmap_load(9F)</code> and
<code>devmap_unload(9F)</code>.</p>
</li>
<li>
<p>Free the device context structure, if needed.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="devmapcallbackctl-structure"><a class="anchor" href="#devmapcallbackctl-structure"></a>2.48.1. <code>devmap_callback_ctl</code> Structure</h4>
<div class="paragraph">
<p>The device driver must allocate and initialize a
<code>devmap_callback_ctl(9S)</code> structure to inform the system about
the entry point routines for device context management.</p>
</div>
<div class="paragraph">
<p>This structure uses the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct devmap_callback_ctl {
    int devmap_rev;
    int (*devmap_map)(devmap_cookie_t dhp, dev_t dev,
    uint_t flags, offset_t off, size_t len, void **pvtp);
    int (*devmap_access)(devmap_cookie_t dhp, void *pvtp,
    offset_t off, size_t len, uint_t type, uint_t rw);
    int (*devmap_dup)(devmap_cookie_t dhp, void *pvtp,
    devmap_cookie_t new_dhp, void **new_pvtp);
    void (*devmap_unmap)(devmap_cookie_t dhp, void *pvtp,
    offset_t off, size_t len, devmap_cookie_t new_dhp1,
    void **new_pvtp1, devmap_cookie_t new_dhp2,
    void **new_pvtp2);
};</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>devmap_rev</code></dt>
<dd>
<p>The version number of the <code>devmap_callback_ctl</code> structure. The
version number must be set to <code>DEVMAP_OPS_REV</code>.</p>
</dd>
<dt class="hdlist1"><code>devmap_map</code></dt>
<dd>
<p>Must be set to the address of the driver&#8217;s <code>devmap_map(9E)</code> entry
point.</p>
</dd>
<dt class="hdlist1"><code>devmap_access</code></dt>
<dd>
<p>Must be set to the address of the driver&#8217;s <code>devmap_access(9E)</code>
entry point.</p>
</dd>
<dt class="hdlist1"><code>devmap_dup</code></dt>
<dd>
<p>Must be set to the address of the driver&#8217;s <code>devmap_dup(9E)</code> entry
point.</p>
</dd>
<dt class="hdlist1"><code>devmap_unmap</code></dt>
<dd>
<p>Must be set to the address of the driver&#8217;s <code>devmap_unmap(9E)</code>
entry point.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="entry-points-for-device-context-management"><a class="anchor" href="#entry-points-for-device-context-management"></a>2.48.2. Entry Points for Device Context Management</h4>
<div class="paragraph">
<p>The following entry points are used to
manage device context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>devmap(9E)</code></p>
</li>
<li>
<p><code>devmap_access(9E)</code></p>
</li>
<li>
<p><code>devmap_contextmgt(9E)</code></p>
</li>
<li>
<p><code>devmap_dup(9E)</code></p>
</li>
<li>
<p><code>devmap_unmap(9E)</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="devmap_map-entry-point"><a class="anchor" href="#devmap_map-entry-point"></a><code>devmap_map</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>devmap(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxdevmap_map(devmap_cookie_t handle, dev_t dev, uint_t flags,
    offset_t offset, size_t len, void **new-devprivate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>devmap_map</code> entry point is
called after the driver returns from its <code>devmap</code> entry point and the
system has established the user mapping to the device memory. The
<code>devmap</code> entry point enables a driver to perform additional processing
or to allocate mapping specific private data. For example, in order to
support context switching, the driver has to allocate a context
structure. The driver must then associate the context structure with the
mapping.</p>
</div>
<div class="paragraph">
<p>The system expects the driver to return a pointer to the allocated
private data in *&lt;new-devprivate&gt;. The driver must store
&lt;offset&gt; and &lt;len&gt;, which define the range of the
mapping, in its private data. Later, when the system calls
<code>devmap_unmap(9E)</code>, the driver uses this information to determine
how much of the mapping is being unmapped.</p>
</div>
<div class="paragraph">
<p>&lt;flags&gt; indicates whether the driver should allocate a private
context for the mapping. For example, a driver can allocate a memory
region to store the device context if &lt;flags&gt; is set to
<code>MAP_PRIVATE</code>. If <code>MAP_SHARED</code> is set, the driver returns a
pointer to a shared region.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>devmap</code> entry point. The driver allocates
a new context structure. The driver then saves relevant parameters
passed in by the entry point. Next, the mapping is assigned a new
context either through allocation or by attaching the mapping to an
already existing shared context. The minimum time interval that the
mapping should have access to the device is set to one millisecond.</p>
</div>
<div id="devcnmgt-15467" class="paragraph">
<p>Using the <code>devmap</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
int xxdevmap_map(devmap_cookie_t handle, dev_t dev, uint_t flags,
    offset_t offset, size_t len, void **new_devprivate)
{
    struct xxstate *xsp = ddi_get_soft_state(statep,
                  getminor(dev));
    struct xxctx *newctx;

    /* create a new context structure */
    newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
    newctx-&gt;xsp = xsp;
    newctx-&gt;handle = handle;
    newctx-&gt;offset = offset;
    newctx-&gt;flags = flags;
    newctx-&gt;len = len;
    mutex_enter(&amp;xsp-&gt;ctx_lock);
    if (flags &amp; MAP_PRIVATE) {
        /* allocate a private context and initialize it */
        newctx-&gt;context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
        xxctxinit(newctx);
    } else {
        /* set a pointer to the shared context */
        newctx-&gt;context = xsp-&gt;ctx_shared;
    }
    mutex_exit(&amp;xsp-&gt;ctx_lock);
    /* give at least 1 ms access before context switching */
    devmap_set_ctx_timeout(handle, drv_usectohz(1000));
    /* return the context structure */
    *new_devprivate = newctx;
    return(0);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="devmap_access-entry-point"><a class="anchor" href="#devmap_access-entry-point"></a><code>devmap_access</code> Entry Point</h5>
<div class="paragraph">
<p>devmap_</p>
</div>
<div class="paragraph">
<p>devmap_access</p>
</div>
<div class="paragraph">
<p>The <code>devmap_access(9E)</code> entry point is called when an access is made
to a mapping whose translations are invalid. Mapping translations are
invalidated when the mapping is created with
<code>devmap_devmem_setup(9F)</code> in response to <code>mmap(2)</code>, duplicated
by <code>fork(2)</code>, or explicitly invalidated by a call to
<code>devmap_unload(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The syntax for <code>devmap_access</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxdevmap_access(devmap_cookie_t handle, void *devprivate,
    offset_t offset, size_t len, uint_t type, uint_t rw);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Mapping handle of the mapping that was accessed by a user process.</p>
</dd>
<dt class="hdlist1">&lt;devprivate&gt;</dt>
<dd>
<p>Pointer to the driver private data associated with the mapping.</p>
</dd>
<dt class="hdlist1">&lt;offset&gt;</dt>
<dd>
<p>Offset within the mapping that was accessed.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length in bytes of the memory being accessed.</p>
</dd>
<dt class="hdlist1">&lt;type&gt;</dt>
<dd>
<p>Type of access operation.</p>
</dd>
<dt class="hdlist1">&lt;rw&gt;</dt>
<dd>
<p>Specifies the direction of access.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The system expects <code>devmap_access(9E)</code> to call either
<code>devmap_do_ctxmgt(9F)</code> or <code>devmap_default_access(9F)</code> to
load the memory address translations before <code>devmap_access</code> returns.
For mappings that support context switching, the device driver should
call <code>devmap_do_ctxmgt</code>. This routine is passed all parameters
from <code>devmap_access(9E)</code>, as well as a pointer to the driver entry
point <code>devmap_contextmgt(9E)</code>, which handles the context switching.
For mappings that do not support context switching, the driver should
call <code>devmap_default_access(9F)</code>. The purpose of
<code>devmap_default_access</code> is to call <code>devmap_load(9F)</code> to load
the user translation.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>devmap_access(9E)</code> entry point. The
mapping is divided into two regions. The region that starts at offset
<code>OFF_CTXMG</code> with a length of <code>CTXMGT_SIZE</code> bytes supports
context management. The rest of the mapping supports default access.</p>
</div>
<div id="devcnmgt-20766" class="paragraph">
<p>Using the <code>devmap_access</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define OFF_CTXMG      0
#define CTXMGT_SIZE    0x20000
static int
xxdevmap_access(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, uint_t type, uint_t rw)
{
    offset_t diff;
    int    error;

    if ((diff = off - OFF_CTXMG) &gt;= 0 &amp;&amp; diff &lt; CTXMGT_SIZE) {
        error = devmap_do_ctxmgt(handle, devprivate, off,
            len, type, rw, xxdevmap_contextmgt);
    } else {
        error = devmap_default_access(handle, devprivate,
            off, len, type, rw);
    }
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="devmap_contextmgt-entry-point"><a class="anchor" href="#devmap_contextmgt-entry-point"></a><code>devmap_contextmgt</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>devmap_contextmgt(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxdevmap_contextmgt(devmap_cookie_t handle, void *devprivate,
    offset_t offset, size_t len, uint_t type, uint_t rw);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>devmap_contextmgt</code> should call
<code>devmap_unload(9F)</code> with the handle of the mapping that currently
has access to the device. This approach invalidates the translations for
that mapping. The approach ensures that a call to
<code>devmap_access(9E)</code> occurs for the current mapping the next time the
mapping is accessed. The mapping translations for the mapping that
caused the access event to occur need to be validated. Accordingly, the
driver must restore the device context for the process requesting
access. Furthermore, the driver must call <code>devmap_load(9F)</code> on the
&lt;handle&gt; of the mapping that generated the call to this entry
point.</p>
</div>
<div class="paragraph">
<p>Accesses to portions of mappings that have had their mapping
translations validated by a call to <code>devmap_load</code> do not generate a
call to <code>devmap_access</code>. A subsequent call to <code>devmap_unload</code>
invalidates the mapping translations. This call enables
<code>devmap_access</code> to be called again.</p>
</div>
<div class="paragraph">
<p>If either <code>devmap_load</code> or <code>devmap_unload</code> returns an error,
<code>devmap_contextmgt</code> should immediately return that error. If the
device driver encounters a hardware failure while restoring a device
context, a <code>-1</code> should be returned. Otherwise, after successfully
handling the access request, <code>devmap_contextmgt</code> should return zero.
A return of other than zero from <code>devmap_contextmgt</code> causes a
<code>SIGBUS</code> or <code>SIGSEGV</code> to be sent to the process.</p>
</div>
<div class="paragraph">
<p>The following example shows how to manage a one-page device context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>xxctxsave</code> and <code>xxctxrestore</code> are device-dependent context save and
restore functions. <code>xxctxsave</code> reads data from the registers and saves
the data in the soft state structure. <code>xxctxrestore</code> takes data that is
saved in the soft state structure and writes the data to device
registers. Note that the read, write, and save are all performed with
the DDI/DKI data access routines.
</td>
</tr>
</table>
</div>
<div id="devcnmgt-40344" class="paragraph">
<p>Using the <code>devmap_contextmgt</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdevmap_contextmgt(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, uint_t type, uint_t rw)
{
    int    error;
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp-&gt;xsp;
    mutex_enter(&amp;xsp-&gt;ctx_lock);
    /* unload mapping for current context */
    if (xsp-&gt;current_ctx != NULL) {
        if ((error = devmap_unload(xsp-&gt;current_ctx-&gt;handle,
            off, len)) != 0) {
            xsp-&gt;current_ctx = NULL;
            mutex_exit(&amp;xsp-&gt;ctx_lock);
            return (error);
        }
    }
    /* Switch device context - device dependent */
    if (xxctxsave(xsp-&gt;current_ctx, off, len) &lt; 0) {
        xsp-&gt;current_ctx = NULL;
        mutex_exit(&amp;xsp-&gt;ctx_lock);
        return (-1);
    }
    if (xxctxrestore(ctxp, off, len) &lt; 0){
        xsp-&gt;current_ctx = NULL;
        mutex_exit(&amp;xsp-&gt;ctx_lock);
        return (-1);
    }
    xsp-&gt;current_ctx = ctxp;
    /* establish mapping for new context and return */
    error = devmap_load(handle, off, len, type, rw);
    if (error)
        xsp-&gt;current_ctx = NULL;
    mutex_exit(&amp;xsp-&gt;ctx_lock);
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="devmap_dup-entry-point"><a class="anchor" href="#devmap_dup-entry-point"></a><code>devmap_dup</code> Entry Point</h5>
<div class="paragraph">
<p>devmap_</p>
</div>
<div class="paragraph">
<p>devmap_dup</p>
</div>
<div class="paragraph">
<p>The <code>devmap_dup(9E)</code> entry point is called when a device mapping is
duplicated, for example, by a user process that calls <code>fork(2)</code>. The
driver is expected to generate new driver private data for the new
mapping.</p>
</div>
<div class="paragraph">
<p>The syntax for <code>devmap_dup</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxdevmap_dup(devmap_cookie_t handle, void *devprivate,
    devmap_cookie_t new-handle, void **new-devprivate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Mapping handle of the mapping being duplicated.</p>
</dd>
<dt class="hdlist1">&lt;new-handle&gt;</dt>
<dd>
<p>Mapping handle of the mapping that was duplicated.</p>
</dd>
<dt class="hdlist1">&lt;devprivate&gt;</dt>
<dd>
<p>Pointer to the driver private data associated with the mapping being
duplicated.</p>
</dd>
<dt class="hdlist1"><code>*</code>&lt;new-devprivate&gt;</dt>
<dd>
<p>Should be set to point to the new driver private data for the new
mapping.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Mappings that have been created with <code>devmap_dup</code> by default have
their mapping translations invalidated. Invalid mapping translations
force a call to the <code>devmap_access(9E)</code> entry point the first time
the mapping is accessed.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical <code>devmap_dup</code> routine.</p>
</div>
<div id="devcnmgt-32712" class="paragraph">
<p>Using the <code>devmap_dup</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdevmap_dup(devmap_cookie_t handle, void *devprivate,
    devmap_cookie_t new_handle, void **new_devprivate)
{
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp-&gt;xsp;
    struct xxctx *newctx;
    /* Create a new context for the duplicated mapping */
    newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
    newctx-&gt;xsp = xsp;
    newctx-&gt;handle = new_handle;
    newctx-&gt;offset = ctxp-&gt;offset;
    newctx-&gt;flags = ctxp-&gt;flags;
    newctx-&gt;len = ctxp-&gt;len;
    mutex_enter(&amp;xsp-&gt;ctx_lock);
    if (ctxp-&gt;flags &amp; MAP_PRIVATE) {
        newctx-&gt;context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
        bcopy(ctxp-&gt;context, newctx-&gt;context, XXCTX_SIZE);
    } else {
        newctx-&gt;context = xsp-&gt;ctx_shared;
    }
    mutex_exit(&amp;xsp-&gt;ctx_lock);
    *new_devprivate = newctx;
    return(0);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="devmap_unmap-entry-point"><a class="anchor" href="#devmap_unmap-entry-point"></a><code>devmap_unmap</code> Entry Point</h5>
<div class="paragraph">
<p>devmap_</p>
</div>
<div class="paragraph">
<p>devmap_unmap</p>
</div>
<div class="paragraph">
<p>The <code>devmap_unmap(9E)</code> entry point is called when a mapping is
unmapped. Unmapping can be caused by a user process exiting or by
calling the <code>munmap(2)</code> system call.</p>
</div>
<div class="paragraph">
<p>The syntax for <code>devmap_unmap</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void xxdevmap_unmap(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, devmap_cookie_t new-handle1,
    void **new-devprivate1, devmap_cookie_t new-handle2,
    void **new-devprivate2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>Mapping handle of the mapping being freed.</p>
</dd>
<dt class="hdlist1">&lt;devprivate&gt;</dt>
<dd>
<p>Pointer to the driver private data associated with the mapping.</p>
</dd>
<dt class="hdlist1">&lt;off&gt;</dt>
<dd>
<p>Offset within the logical device memory at which the unmapping begins.</p>
</dd>
<dt class="hdlist1">&lt;len&gt;</dt>
<dd>
<p>Length in bytes of the memory being unmapped.</p>
</dd>
<dt class="hdlist1">&lt;new-handle1&gt;</dt>
<dd>
<p>Handle that the system uses to describe the new region that ends at
&lt;off&gt; - 1. The value of &lt;new-handle1&gt; can be <code>NULL</code>.</p>
</dd>
<dt class="hdlist1">&lt;new-devprivate1&gt;</dt>
<dd>
<p>Pointer to be filled in by the driver with the private driver mapping
data for the new region that ends at &lt;off&gt; -1.
&lt;new-devprivate1&gt; is ignored if &lt;new-handle1&gt; is
<code>NULL</code>.</p>
</dd>
<dt class="hdlist1">&lt;new-handle2&gt;</dt>
<dd>
<p>Handle that the system uses to describe the new region that begins at
&lt;off&gt; &#43; &lt;len&gt;. The value of &lt;new-handle2&gt;
can be <code>NULL</code>.</p>
</dd>
<dt class="hdlist1">&lt;new-devprivate2&gt;</dt>
<dd>
<p>Pointer to be filled in by the driver with the driver private mapping
data for the new region that begins at &lt;off&gt; &#43;
&lt;len&gt;. &lt;new-devprivate2&gt; is ignored if
&lt;new-handle2&gt; is <code>NULL</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>devmap_unmap</code> routine is expected to free any driver private
resources that were allocated when this mapping was created, either by
<code>devmap_map(9E)</code> or by <code>devmap_dup(9E)</code>. If the mapping is only
partially unmapped, the driver must allocate new private data for the
remaining mapping before freeing the old private data. Calling
<code>devmap_unload(9F)</code> on the handle of the freed mapping is not
necessary, even if this handle points to the mapping with the valid
translations. However, to prevent future <code>devmap_access(9E)</code>
problems, the device driver should make sure the current mapping
representation is set to “no current mapping”.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical <code>devmap_unmap</code> routine.</p>
</div>
<div id="devcnmgt-29332" class="paragraph">
<p>Using the <code>devmap_unmap</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
xxdevmap_unmap(devmap_cookie_t handle, void *devprivate,
    offset_t off, size_t len, devmap_cookie_t new_handle1,
    void **new_devprivate1, devmap_cookie_t new_handle2,
    void **new_devprivate2)
{
    struct xxctx *ctxp = devprivate;
    struct xxstate *xsp = ctxp-&gt;xsp;
    mutex_enter(&amp;xsp-&gt;ctx_lock);
    /*
     * If new_handle1 is not NULL, we are unmapping
     * at the end of the mapping.
     */
    if (new_handle1 != NULL) {
        /* Create a new context structure for the mapping */
        newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
        newctx-&gt;xsp = xsp;
        if (ctxp-&gt;flags &amp; MAP_PRIVATE) {
            /* allocate memory for the private context and copy it */
            newctx-&gt;context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
            bcopy(ctxp-&gt;context, newctx-&gt;context, XXCTX_SIZE);
        } else {
            /* point to the shared context */
            newctx-&gt;context = xsp-&gt;ctx_shared;
        }
        newctx-&gt;handle = new_handle1;
        newctx-&gt;offset = ctxp-&gt;offset;
        newctx-&gt;len = off - ctxp-&gt;offset;
        *new_devprivate1 = newctx;
    }
    /*
     * If new_handle2 is not NULL, we are unmapping
     * at the beginning of the mapping.
     */
    if (new_handle2 != NULL) {
        /* Create a new context for the mapping */
        newctx = kmem_alloc(sizeof (struct xxctx), KM_SLEEP);
        newctx-&gt;xsp = xsp;
        if (ctxp-&gt;flags &amp; MAP_PRIVATE) {
            newctx-&gt;context = kmem_alloc(XXCTX_SIZE, KM_SLEEP);
            bcopy(ctxp-&gt;context, newctx-&gt;context, XXCTX_SIZE);
        } else {
            newctx-&gt;context = xsp-&gt;ctx_shared;
        }
        newctx-&gt;handle = new_handle2;
        newctx-&gt;offset = off + len;
        newctx-&gt;flags = ctxp-&gt;flags;
        newctx-&gt;len = ctxp-&gt;len - (off + len - ctxp-&gt;off);
        *new_devprivate2 = newctx;
    }
    if (xsp-&gt;current_ctx == ctxp)
        xsp-&gt;current_ctx = NULL;
    mutex_exit(&amp;xsp-&gt;ctx_lock);
    if (ctxp-&gt;flags &amp; MAP_PRIVATE)
        kmem_free(ctxp-&gt;context, XXCTX_SIZE);
    kmem_free(ctxp, sizeof (struct xxctx));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="associating-user-mappings-with-driver-notifications"><a class="anchor" href="#associating-user-mappings-with-driver-notifications"></a>2.48.3. Associating User Mappings With Driver Notifications</h4>
<div class="paragraph">
<p>When a
user process requests a mapping to a device with <code>mmap(2)</code>, the
driver`s <code>segmap(9E)</code> entry point is called. The driver must use
<code>ddi_devmap_segmap(9F)</code> or <code>devmap_setup(9F)</code> when setting
up the memory mapping if the driver needs to manage device contexts.
Both functions call the driver&#8217;s <code>devmap(9E)</code> entry point, which uses
<code>devmap_devmem_setup(9F)</code> to associate the device memory with
the user mapping. See <a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel
Memory</a> for details on how to map device memory.</p>
</div>
<div class="paragraph">
<p>The driver must inform the system of the
<code>devmap_callback_ctl(9S)</code> entry points to get notifications of
accesses to the user mapping. The driver informs the system by providing
a pointer to a <code>devmap_callback_ctl(9S)</code> structure to
<code>devmap_devmem_setup(9F)</code>. A <code>devmap_callback_ctl(9S)</code>
structure describes a set of entry points for context management. These
entry points are called by the system to notify a device driver to
manage events on the device mappings.</p>
</div>
<div class="paragraph">
<p>The system associates each mapping with a mapping handle. This handle is
passed to each of the entry points for context management. The mapping
handle can be used to invalidate and validate the mapping translations.
If the driver <em>invalidates</em> the mapping translations, the driver will be
notified of any future access to the mapping. If the driver <em>validates</em>
the mapping translations, the driver will no longer be notified of
accesses to the mapping. Mappings are always created with the mapping
translations invalidated so that the driver will be notified on first
access to the mapping.</p>
</div>
<div class="paragraph">
<p>The following example shows how to set up a mapping using the device
context management interfaces.</p>
</div>
<div id="devcnmgt-13708" class="paragraph">
<p><code>devmap(9E)</code> Entry Point With Context Management Support</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct devmap_callback_ctl xx_callback_ctl = {
    DEVMAP_OPS_REV, xxdevmap_map, xxdevmap_access,
    xxdevmap_dup, xxdevmap_unmap
};

static int
xxdevmap(dev_t dev, devmap_cookie_t handle, offset_t off,
    size_t len, size_t *maplen, uint_t model)
{
    struct xxstate *xsp;
    uint_t rnumber;
    int    error;

    /* Setup data access attribute structure */
    struct ddi_device_acc_attr xx_acc_attr = {
        DDI_DEVICE_ATTR_V0,
        DDI_NEVERSWAP_ACC,
    };
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);
    len = ptob(btopr(len));
    rnumber = 0;
    /* Set up the device mapping */
    error = devmap_devmem_setup(handle, xsp-&gt;dip, &amp;xx_callback_ctl,
        rnumber, off, len, PROT_ALL, 0, &amp;xx_acc_attr);
    *maplen = len;
    return (error);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="managing-mapping-accesses"><a class="anchor" href="#managing-mapping-accesses"></a>2.48.4. Managing Mapping Accesses</h4>
<div class="paragraph">
<p>The device driver is notified when a user process accesses an address in
the memory-mapped region that does not have valid mapping translations.
When the access event occurs, the mapping translations of the process
that currently has access to the device must be invalidated. The device
context of the process that requested access to the device must be
restored. Furthermore, the translations of the mapping of the process
requesting access must be validated.</p>
</div>
<div class="paragraph">
<p>The functions <code>devmap_load(9F)</code> and <code>devmap_unload(9F)</code> are used
to validate and invalidate mapping translations.</p>
</div>
<div class="sect4">
<h5 id="devmap_load-entry-point"><a class="anchor" href="#devmap_load-entry-point"></a><code>devmap_load</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>devmap_load(9F)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int devmap_load(devmap_cookie_t handle, offset_t offset,
    size_t len, uint_t type, uint_t rw);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>devmap_load</code> validates the mapping
translations for the pages of the mapping specified by
<code>handle<code>,</code>offset</code>, and <code>len</code>. By validating the mapping translations
for these pages, the driver is telling the system not to intercept
accesses to these pages of the mapping. Furthermore, the system must not
allow accesses to proceed without notifying the device driver.</p>
</div>
<div class="paragraph">
<p><code>devmap_load</code> must be called with the offset and the handle of the
mapping that generated the access event for the access to complete. If
<code>devmap_load(9F)</code> is not called on this handle, the mapping
translations are not validated, and the process receives a <code>SIGBUS</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="devmap_unload-entry-point"><a class="anchor" href="#devmap_unload-entry-point"></a><code>devmap_unload</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>devmap_unload(9F)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int devmap_unload(devmap_cookie_t handle, offset_t offset, size_t len);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>devmap_unload</code>
invalidates the mapping translations for the pages of the mapping
specified by &lt;handle&gt;, &lt;offset&gt;, and &lt;len&gt;. By
invalidating the mapping translations for these pages, the device driver
is telling the system to intercept accesses to these pages of the
mapping. Furthermore, the system must notify the device driver the next
time that these mapping pages are accessed by calling the
<code>devmap_access(9E)</code> entry point.</p>
</div>
<div class="paragraph">
<p>For both functions, requests affect the entire page that contains the
&lt;offset&gt; and all pages up to and including the entire page that
contains the last byte, as indicated by &lt;offset&gt; &#43;
&lt;len&gt;. The device driver must ensure that for each page of
device memory being mapped, only one process has valid translations at
any one time.</p>
</div>
<div class="paragraph">
<p>Both functions return zero if successful. If, however, an error occurred
in validating or invalidating the mapping translations, that error is
returned to the device driver. The device driver must return this error
to the system.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="power-management"><a class="anchor" href="#power-management"></a>2.49. Power Management</h3>
<div class="paragraph">
<p>Power management provides the ability to control and manage the
electrical power usage of a computer system or device. Power management
enables systems to conserve energy by using less power when idle and by
shutting down completely when not in use. For example, desktop computer
systems can use a significant amount of power and often are left idle,
particularly at night. Power management software can detect that the
system is not being used. Accordingly, power management can power down
the system or some of its components.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#power-management-framework">Power Management Framework</a></p>
</li>
<li>
<p><a href="#device-power-management-model">Device Power Management Model</a></p>
</li>
<li>
<p><a href="#system-power-management-model">System Power Management Model</a></p>
</li>
<li>
<p><a href="#power-management-device-access-example">Power Management Device Access Example</a></p>
</li>
<li>
<p><a href="#power-management-flow-of-control">Power Management Flow of Control</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="power-management-framework"><a class="anchor" href="#power-management-framework"></a>2.50. Power Management Framework</h3>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>definition of</p>
</div>
<div class="paragraph">
<p>The illumos Power Management framework depends on device drivers to
implement device-specific power management functions. The framework is
implemented in two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Device power management – Automatically turns off unused devices to
reduce power consumption</p>
</li>
<li>
<p>System power management – Automatically turns off the computer when
the entire system is idle</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="device-power-management"><a class="anchor" href="#device-power-management"></a>2.50.1. Device Power Management</h4>
<div class="paragraph">
<p>The framework enables devices to reduce
their energy consumption after a specified idle time interval. As part
of power management, system software checks for idle devices. The Power
Management framework exports interfaces that enable communication
between the system software and the device driver.</p>
</div>
<div class="paragraph">
<p>The illumos Power Management framework provides the following features
for device power management:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A device-independent model for power-manageable devices.</p>
</li>
<li>
<p><code>dtpower(8)</code>, a tool for configuring workstation power management.
Power management can also be implemented through the <code>power.conf(5)</code> and
<code>/etc/default/power</code> files.</p>
</li>
<li>
<p>A set of DDI interfaces for notifying the framework about power
management compatibility and idleness state.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="system-power-management"><a class="anchor" href="#system-power-management"></a>2.50.2. System Power Management</h4>
<div class="paragraph">
<p>System power management involves saving the state of the
system prior to powering the system down. Thus, the system can be
returned to the same state immediately when the system is turned back
on.</p>
</div>
<div class="paragraph">
<p>To shut down an entire system with return to the state prior to the
shutdown, take the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stop kernel threads and user processes. Restart these threads and
processes later.</p>
</li>
<li>
<p>Save the hardware state of all devices on the system to disk. Restore
the state later.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
System power management is currently implemented only on some SPARC
systems supported by illumos. See the <code>power.conf(5)</code> man page for more
information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The System Power Management framework in illumos provides the following
features for system power management:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A platform-independent model of system idleness.</p>
</li>
<li>
<p><code>pmconfig(8)</code>, a tool for configuring workstation power management.
Power management can also be implemented through the <code>power.conf(5)</code> and
<code>/etc/default/power</code> files.</p>
</li>
<li>
<p>A set of interfaces for the device driver to override the method for
determining which drivers have hardware state.</p>
</li>
<li>
<p>A set of interfaces to enable the framework to call into the driver to
save and restore the device state.</p>
</li>
<li>
<p>A mechanism for notifying processes that a resume operation has
occurred.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-power-management-model"><a class="anchor" href="#device-power-management-model"></a>2.51. Device Power Management Model</h3>
<div class="paragraph">
<p>The following sections describe the details of the
device power management model. This model includes the following
elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Components</p>
</li>
<li>
<p>Idleness</p>
</li>
<li>
<p>Power levels</p>
</li>
<li>
<p>Dependency</p>
</li>
<li>
<p>Policy</p>
</li>
<li>
<p>Device power management interfaces</p>
</li>
<li>
<p>Power management entry points</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="power-management-components"><a class="anchor" href="#power-management-components"></a>2.51.1. Power Management Components</h4>
<div class="paragraph">
<p>A device is power manageable if the power consumption of
the device can be reduced when the device is idle. Conceptually, a
power-manageable device consists of a number of power-manageable
hardware units that are called <em>components</em>.</p>
</div>
<div class="paragraph">
<p>The device driver notifies the system about device components and their
associated power levels. Accordingly, the driver creates a
<code>pm-components(9P)</code> property in the driver&#8217;s <code>attach(9E)</code> entry point as
part of driver initialization.</p>
</div>
<div class="paragraph">
<p>Most devices that are power manageable implement only a single
component. An example of a single-component, power-manageable device is
a disk whose spindle motor can be stopped to save power when the disk is
idle.</p>
</div>
<div class="paragraph">
<p>If a device has multiple power-manageable units that are separately
controllable, the device should implement multiple components.</p>
</div>
<div class="paragraph">
<p>An example of a two-component, power-manageable device is a frame buffer
card with a monitor. Frame buffer electronics is the first component
[component 0]. The frame buffer&#8217;s power consumption can be
reduced when not in use. The monitor is the second component
[component 1]. The monitor can also enter a lower power mode
when the monitor is not in use. The frame buffer electronics and monitor
are considered by the system as one device with two components.</p>
</div>
<div class="sect4">
<h5 id="multiple-power-management-components"><a class="anchor" href="#multiple-power-management-components"></a>Multiple Power Management Components</h5>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_raise_power</p>
</div>
<div class="paragraph">
<p>To the power management framework, all components are considered equal
and completely independent of each other. If the component states are
not completely compatible, the device driver must ensure that
undesirable state combinations do not occur. For example, a frame
buffer/monitor card has the following possible states: <code>D0</code>, <code>D1</code>, <code>D2</code>,
and <code>D3</code>. The monitor attached to the card has the following potential
states: <code>On</code>, <code>Standby</code>, <code>Suspend</code>, and <code>Off</code>. These states are not
necessarily compatible with each other. For example, if the monitor is
<code>On</code>, then the frame buffer must be at <code>D0</code>, that is, full on. If the
frame buffer driver gets a request to power up the monitor to <code>On</code> while
the frame buffer is at <code>D3</code>, the driver must call
<code>pm_raise_power(9F)</code> to bring the frame buffer up before setting
the monitor <code>On</code>. System requests to lower the power of the frame buffer
while the monitor is <code>On</code> must be refused by the driver.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="power-management-states"><a class="anchor" href="#power-management-states"></a>2.51.2. Power Management States</h4>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_busy_component</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_idle_component</p>
</div>
<div class="paragraph">
<p>Each component of a device can be in one of two states: <em>busy</em> or
<em>idle</em>. The device driver notifies the framework of changes in the
device state by calling <code>pm_busy_component(9F)</code> and
<code>pm_idle_component(9F)</code>. When components are initially created,
the components are considered idle.</p>
</div>
</div>
<div class="sect3">
<h4 id="power-levels"><a class="anchor" href="#power-levels"></a>2.51.3. Power Levels</h4>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>power levels</p>
</div>
<div class="paragraph">
<p>From the <code>pm-components</code> property exported by the device, the Device
Power Management framework knows what power levels the device supports.
Power-level values must be positive integers. The interpretation of
power levels is determined by the device driver writer. Power levels
must be listed in monotonically increasing order in the <code>pm-components</code>
property. A power level of 0 is interpreted by the framework to mean
off. When the framework must power up a device due to a dependency, the
framework sets each component at its highest power level.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>pm-components</code> entry from the <code>.conf</code>
file of a driver that implements a single power-managed component
consisting of a disk spindle motor. The disk spindle motor is component
0. The spindle motor supports two power levels. These levels represent
“stopped” and “spinning at full speed.”</p>
</div>
<div id="powermgt-ex-117" class="paragraph">
<p>Sample <code>pm-component</code> Entry</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pm-components="NAME=Spindle Motor", "0=Stopped", "1=Full Speed";</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how <a href="#powermgt-ex-117">example_title</a>
could be implemented in the <code>attach</code> routine of the driver.</p>
</div>
<div id="powermgt-ex-118" class="paragraph">
<p><code>attach(9E)</code> Routine With <code>pm-components</code> Property</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static char *pmcomps[] = {
    "NAME=Spindle Motor",
    "0=Stopped",
    "1=Full Speed"
};
/* ... */
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    /* ... */
    if (ddi_prop_update_string_array(DDI_DEV_T_NONE, dip,
        "pm-components", &amp;pmcomp[0],
        sizeof (pmcomps) / sizeof (char *)) != DDI_PROP_SUCCESS)
        goto failed;
    /* ... */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a frame buffer that implements two
components. Component 0 is the frame buffer electronics that support
four different power levels. Component 1 represents the state of power
management of the attached monitor.</p>
</div>
<div id="powermgt-ex-119" class="paragraph">
<p>Multiple Component <code>pm-components</code> Entry</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pm-components="NAME=Frame Buffer", "0=Off", "1=Suspend", \
    "2=Standby", "3=On",
    "NAME=Monitor", "0=Off", "1=Suspend", "2=Standby", "3=On";</pre>
</div>
</div>
<div class="paragraph">
<p>When a device driver is first attached,
the framework does not know the power level of the device. A power
transition can occur when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The driver calls <code>pm_raise_power(9F)</code> or
<code>pm_lower_power(9F)</code>.</p>
</li>
<li>
<p>The framework has lowered the power level of a component because a
time threshold has been exceeded.</p>
</li>
<li>
<p>Another device has changed power and a dependency exists between the
two devices. See <a href="#power-management-dependencies">Power Management Dependencies</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After a power transition, the framework begins tracking the power level
of each component of the device. Tracking also occurs if the driver has
informed the framework of the power level. The driver informs the
framework of a power level change by calling
<code>pm_power_has_changed(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The system calculates a default threshold for each potential power
transition. These thresholds are based on the system idleness threshold.
The default thresholds can be overridden using <code>pmconfig</code> or
<code>power.conf(5)</code>. Another default threshold based on the system idleness
threshold is used when the component power level is unknown.</p>
</div>
</div>
<div class="sect3">
<h4 id="power-management-dependencies"><a class="anchor" href="#power-management-dependencies"></a>2.51.4. Power Management Dependencies</h4>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>Some devices should be powered down only when other devices are also
powered down. For example, if a CD-ROM drive is allowed to power down,
necessary functions, such as the ability to eject a CD, might be lost.</p>
</div>
<div class="paragraph">
<p>To prevent a device from powering down independently, you can make that
device dependent on another device that is likely to remain powered on.
Typically, a device is made dependent upon a frame buffer, because a
monitor is generally on whenever a user is utilizing a system.</p>
</div>
<div class="paragraph">
<p>The <code>power.conf(5)`file specifies the
dependencies among devices. (A parent node in the device tree implicitly
depends upon its children. This dependency is handled automatically by
the power management framework.) You can specify a particular dependency
with a `power.conf(5)</code> entry of this form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>device-dependency dependent-phys-path phys-path</pre>
</div>
</div>
<div class="paragraph">
<p>Where &lt;dependent-phys-path&gt; is the device that
is kept powered up, such as the CD-ROM drive. &lt;phys-path&gt;
represents the device whose power state is to be depended on, such as
the frame buffer.</p>
</div>
<div class="paragraph">
<p>Adding an entry to <code>power.conf</code> for every new device
that is plugged into the system would be burdensome. The following
syntax enables you to indicate dependency in a more general fashion:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>device-dependency-property property phys-path</pre>
</div>
</div>
<div class="paragraph">
<p>Such an entry mandates that any device
that exports the property &lt;property&gt; must be dependent upon the
device named by &lt;phys-path&gt;. Because this dependency applies
especially to removable-media devices, <code>/etc/power.conf</code> includes the
following line by default:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>device_dependent-property  removable-media  /dev/fb</pre>
</div>
</div>
<div class="paragraph">
<p>With this syntax, no device that exports the removable-media property
can be powered down unless the console frame buffer is also powered
down.</p>
</div>
<div class="paragraph">
<p>For more information, see the <code>power.conf(5)</code> and <code>removable-media(9P)</code>
man pages.</p>
</div>
</div>
<div class="sect3">
<h4 id="automatic-power-management-for-devices"><a class="anchor" href="#automatic-power-management-for-devices"></a>2.51.5. Automatic Power Management for Devices</h4>
<div class="paragraph">
<p>If automatic power management is enabled by <code>pmconfig</code> or
<code>power.conf(5)</code>, then all devices with a <code>pm-components(9P)</code> property
automatically will use power management. After a component has been idle
for a default period, the component is automatically lowered to the next
lowest power level. The default period is calculated by the power
management framework to set the entire device to its lowest power state
within the system idleness threshold.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, automatic power management is enabled on all SPARC desktop
systems first shipped after July 1, 1999. This feature is disabled by
default for all other systems. To determine whether automatic power
management is enabled on your machine, refer to the <code>power.conf(5)</code> man
page for instructions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>power.conf(5)</code> can be used to override the defaults calculated by the
framework.</p>
</div>
</div>
<div class="sect3">
<h4 id="device-power-management-interfaces"><a class="anchor" href="#device-power-management-interfaces"></a>2.51.6. Device Power Management Interfaces</h4>
<div class="paragraph">
<p>A device driver that supports a device with
power-manageable components must create a <code>pm-components(9P)</code> property.
This property indicates to the system that the device has
power-manageable components. <code>pm-components</code> also tells the system which
power levels are available. The driver typically informs the system by
calling <code>ddi_prop_update_string_array(9F)</code> from the
driver&#8217;s <code>attach(9E)</code> entry point. An alternative means of informing the
system is from a <code>driver.conf(5)</code> file. See the <code>pm-components(9P)</code> man
page for details.</p>
</div>
<div class="sect4">
<h5 id="busy-idle-state-transitions"><a class="anchor" href="#busy-idle-state-transitions"></a>Busy-Idle State Transitions</h5>
<div class="paragraph">
<p>The driver must keep the framework informed of device
state transitions from idle to busy or busy to idle. Where these
transitions happen is entirely device-specific. The transitions between
the busy and idle states depend on the nature of the device and the
abstraction represented by the specific component. For example, SCSI
disk target drivers typically export a single component, which
represents whether the SCSI target disk drive is spun up or not. The
component is marked busy whenever an outstanding request to the drive
exists. The component is marked idle when the last queued request
finishes. Some components are created and never marked busy. For
example, components created by <code>pm-components(9P)</code> are created in an
idle state.</p>
</div>
<div class="paragraph">
<p>The <code>pm_busy_component(9F)</code> and <code>pm_idle_component(9F)</code>
interfaces notify the power management framework of busy-idle state
transitions. The <code>pm_busy_component(9F)</code> call has the following
syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int pm_busy_component(dev_info_t *dip, int component);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pm_busy_component(9F)</code> marks &lt;component&gt; as busy. While
the component is busy, that component should not be powered off. If the
component is already powered off, then marking that component busy does
not change the power level. The driver needs to call
<code>pm_raise_power(9F)</code> for this purpose. Calls to
<code>pm_busy_component(9F)</code> are cumulative and require a
corresponding number of calls to <code>pm_idle_component(9F)</code> to idle
the component.</p>
</div>
<div class="paragraph">
<p>The <code>pm_idle_component(9F)</code> routine has the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int pm_idle_component(dev_info_t *dip, int component);</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> `pm++_++idle++_++component(9F)` marks ++&lt;++component++&gt;++
as idle. An idle component is subject to being powered off.
`pm++_++idle++_++component(9F)` must be called once for each call to
`pm++_++busy++_++component(9F)` in order to idle the component.</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="device-power-state-transitions"><a class="anchor" href="#device-power-state-transitions"></a>Device Power State Transitions</h5>
<div class="literalblock">
<div class="content">
<pre>   A device driver can call
`pm++_++raise++_++power(9F)` to request that a component be set to at
least a given power level. Setting the power level in this manner is
necessary before using a component that has been powered off. For
example, the `read(9E)` routine of a SCSI disk target driver might need
to spin up the disk, if the disk has been powered off. The
`pm++_++raise++_++power(9F)` function requests the power management
framework to initiate a device power state transition to a higher power
level. Normally, reductions in component power levels are initiated by
the framework. However, a device driver should call
`pm++_++lower++_++power(9F)` when detaching, in order to reduce the
power consumption of unused devices as much as possible.</pre>
</div>
</div>
<div class="paragraph">
<p>Powering down can pose risks for some devices. For example, some tape
drives damage tapes when power is removed. Similarly, some disk drives
have a limited tolerance for power cycles, because each cycle results in
a head landing. Use the <code>no-involuntary-power-cycles(9P)</code> property to
notify the system that the device driver should control all power cycles
for the device. This approach prevents power from being removed from a
device while the device driver is detached unless the device was powered
off by a driver&#8217;s call to <code>pm_lower_power(9F)</code> from its
<code>detach(9E)</code> entry point.</p>
</div>
<div class="paragraph">
<p>The <code>pm_raise_power(9F)</code> function is called when the driver
discovers that a component needed for some operation is at an
insufficient power level. This interface causes the driver to raise the
current power level of the component to the needed level. All the
devices that depend on this device are also brought back to full power
by this call.</p>
</div>
<div class="paragraph">
<p>Call the <code>pm_lower_power(9F)</code> function when the device is
detaching once access to the device is no longer needed. Call
<code>pm_lower_power(9F)</code> to set each component at the lowest power
so that the device uses as little power as possible while not in use.
The <code>pm_lower_power</code> function must be called from the <code>detach</code>
entry point. The <code>pm_lower_power</code> function has no effect if it
is called from any other part of the driver.</p>
</div>
<div class="paragraph">
<p>The <code>pm_power_has_changed(9F)</code> function is called to notify
the framework about a power transition. The transition might be due to
the device changing its own power level. The transition might also be
due to an operation such as suspend-resume. The syntax for
<code>pm_power_has_changed(9F)</code> is the same as the syntax for
<code>pm_raise_power(9F)</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="power-entry-point"><a class="anchor" href="#power-entry-point"></a>2.51.7. <code>power</code> Entry Point</h4>
<div class="literalblock">
<div class="content">
<pre>   The power management
framework uses the `power(9E)` entry point.</pre>
</div>
</div>
<div class="paragraph">
<p><code>power</code> uses the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int power(dev_info_t *dip, int component, int level);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a component&#8217;s power level needs to be changed, the system calls the
<code>power(9E)</code> entry point. The action taken by this entry point is device
driver-specific. In the example of the SCSI target disk driver mentioned
previously, setting the power level to 0 results in sending a SCSI
command to spin down the disk, while setting the power level to the full
power level results in sending a SCSI command to spin up the disk.</p>
</div>
<div class="paragraph">
<p>If a power transition can cause the device to lose state, the driver
must save any necessary state in memory for later restoration. If a
power transition requires the saved state to be restored before the
device can be used again, then the driver must restore that state. The
framework makes no assumptions about what power transactions cause the
loss of state or require the restoration of state for automatically
power-managed devices. The following example shows a sample <code>power</code>
routine.</p>
</div>
<div id="powermgt-ex-131" class="paragraph">
<p>Using the <code>power</code> Routine for a Single-Component Device</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">xxpower(dev_info_t *dip, int component, int level)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Make sure the request is valid
     */
    if (!xx_valid_power_level(component, level))
        return (DDI_FAILURE);
    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * If the device is busy, don't lower its power level
     */
    if (xsp-&gt;xx_busy[component] &amp;&amp;
        xsp-&gt;xx_power_level[component] &gt; level) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_FAILURE);
    }

    if (xsp-&gt;xx_power_level[component] != level) {
        /*
         * device- and component-specific setting of power level
         * goes here
         */
        xsp-&gt;xx_power_level[component] = level;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_SUCCESS);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example is a <code>power</code> routine for a device with two
components, where component 0 must be on when component 1 is on.</p>
</div>
<div id="powermgt-ex-132" class="paragraph">
<p><code>power(9E)</code> Routine for Multiple-Component Device</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">xxpower(dev_info_t *dip, int component, int level)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Make sure the request is valid
     */
    if (!xx_valid_power_level(component, level))
        return (DDI_FAILURE);
    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * If the device is busy, don't lower its power level
     */
    if (xsp-&gt;xx_busy[component] &amp;&amp;
        xsp-&gt;xx_power_level[component] &gt; level) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_FAILURE);
    }
    /*
     * This code implements inter-component dependencies:
     * If we are bringing up component 1 and component 0
     * is off, we must bring component 0 up first, and if
     * we are asked to shut down component 0 while component
     * 1 is up we must refuse
     */
    if (component == 1 &amp;&amp; level &gt; 0 &amp;&amp; xsp-&gt;xx_power_level[0] == 0) {
        xsp-&gt;xx_busy[0]++;
        if (pm_busy_component(dip, 0) != DDI_SUCCESS) {
            /*
             * This can only happen if the args to
             * pm_busy_component()
             * are wrong, or pm-components property was not
             * exported by the driver.
             */
            xsp-&gt;xx_busy[0]--;
            mutex_exit(&amp;xsp-&gt;mu);
            cmn_err(CE_WARN, "xxpower pm_busy_component()
                failed");
            return (DDI_FAILURE);
        }
        mutex_exit(&amp;xsp-&gt;mu);
        if (pm_raise_power(dip, 0, XX_FULL_POWER_0) != DDI_SUCCESS)
            return (DDI_FAILURE);
        mutex_enter(&amp;xsp-&gt;mu);
    }
    if (component == 0 &amp;&amp; level == 0 &amp;&amp; xsp-&gt;xx_power_level[1] != 0) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_FAILURE);
    }
    if (xsp-&gt;xx_power_level[component] != level) {
        /*
         * device- and component-specific setting of power level
         * goes here
         */
        xsp-&gt;xx_power_level[component] = level;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_SUCCESS);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="system-power-management-model"><a class="anchor" href="#system-power-management-model"></a>2.52. System Power Management Model</h3>
<div class="paragraph">
<p>This section describes the details of the System Power
Management model. The model includes the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Autoshutdown threshold</p>
</li>
<li>
<p>Busy state</p>
</li>
<li>
<p>Hardware state</p>
</li>
<li>
<p>Policy</p>
</li>
<li>
<p>Power management entry points</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="autoshutdown-threshold"><a class="anchor" href="#autoshutdown-threshold"></a>2.52.1. Autoshutdown Threshold</h4>
<div class="paragraph">
<p>The system can be shut down, that is, powered off,
automatically after a configurable period of idleness. This period is
known as the <em>autoshutdown threshold</em>. This behavior is enabled by
default for SPARC desktop systems first shipped after October 1, 1995
and before July 1, 1999. See the <code>power.conf(5)`man page for more
information. Autoshutdown can be overridden using `dtpower(8)</code> or
<code>power.conf(5)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="busy-state"><a class="anchor" href="#busy-state"></a>2.52.2. Busy State</h4>
<div class="paragraph">
<p>The busy state of the system can be measured in several ways. The
currently supported built-in metric items are keyboard characters, mouse
activity, <code>tty</code> characters, load average, disk reads, and NFS requests.
Any one of these items can make the system busy. In addition to the
built-in metrics, an interface is defined for running a user-specified
process that can indicate that the system is busy.</p>
</div>
</div>
<div class="sect3">
<h4 id="hardware-state"><a class="anchor" href="#hardware-state"></a>2.52.3. Hardware State</h4>
<div class="paragraph">
<p>Devices that export a <code>reg</code> property are
considered to have hardware state that must be saved prior to shutting
down the system. A device without the <code>reg</code> property is considered to be
stateless. However, this consideration can be overridden by the device
driver.</p>
</div>
<div class="paragraph">
<p>A device with hardware state
but no <code>reg</code> property, such as a SCSI driver, must be called to save and
restore the state if the driver exports a <code>pm-hardware-state</code> property
with the value <code>needs-suspend-resume</code>. Otherwise, the lack of a <code>reg</code>
property is taken to mean that the device has no hardware state. For
information on device properties, see <a href="#properties">Properties</a>.</p>
</div>
<div class="paragraph">
<p>A device with a <code>reg</code> property and no hardware state can export a
<code>pm-hardware-state</code> property with the value <code>no-suspend-resume</code>. Using
<code>no-suspend-resume</code> with the <code>pm-hardware-state</code> property keeps the
framework from calling the driver to save and restore that state. For
more information on power management properties, see the
<code>pm-components(9P)</code> man page.</p>
</div>
</div>
<div class="sect3">
<h4 id="automatic-power-management-for-systems"><a class="anchor" href="#automatic-power-management-for-systems"></a>2.52.4. Automatic Power Management for Systems</h4>
<div class="paragraph">
<p>The system is shut down if the following conditions
apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Autoshutdown is enabled by <code>dtpower(8)</code> or <code>power.conf(5)</code>.</p>
</li>
<li>
<p>The system has been idle for <em>autoshutdown threshold</em> minutes.</p>
</li>
<li>
<p>All of the metrics that are specified in <code>power.conf</code> have been
satisfied.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="entry-points-used-by-system-power-management"><a class="anchor" href="#entry-points-used-by-system-power-management"></a>2.52.5. Entry Points Used by System Power Management</h4>
<div class="paragraph">
<p>System power management passes the command
<code>DDI_SUSPEND</code> to the <code>detach(9E)</code> driver entry point to request the
driver to save the device hardware state. System power management passes
the command <code>DDI_RESUME</code> to the <code>attach(9E)</code> driver entry point to
request the driver to restore the device hardware state.</p>
</div>
<div class="sect4">
<h5 id="detach-entry-point-1"><a class="anchor" href="#detach-entry-point-1"></a><code>detach</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>detach(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int detach(dev_info_t *dip, ddi_detach_cmd_t cmd);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A device with a reg property or a pm-hardware-state
property set to <code>needs-suspend-resume</code> must be able to save the hardware
state of the device. The framework calls into the driver&#8217;s <code>detach(9E)</code>
entry point to enable the driver to save the state for restoration after
the system power returns. To process the <code>DDI_SUSPEND</code> command,
<code>detach(9E)</code> must perform the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Block further operations from being initiated until the device is
resumed, except for <code>dump(9E)</code> requests.</p>
</li>
<li>
<p>Wait until outstanding operations have completed. If an outstanding
operation can be restarted, you can abort that operation.</p>
</li>
<li>
<p>Cancel any timeouts and callbacks that are pending.</p>
</li>
<li>
<p>Save any volatile hardware state to memory. The state includes the
contents of device registers, and can also include downloaded firmware.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the driver is unable to suspend the device and save its state to
memory, then the driver must return <code>DDI_FAILURE</code>. The framework
then aborts the system power management operation.</p>
</div>
<div class="paragraph">
<p>In some cases, powering down a device
involves certain risks. For example, if a tape drive is powered off with
a tape inside, the tape can be damaged. In such a case, <code>attach(9E)</code>
should do the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Call <code>ddi_removing_power(9F)</code> to determine whether a
<code>DDI_SUSPEND</code> command can cause power to be removed from the device.</p>
</li>
<li>
<p>Determine whether power removal can cause problems.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If both cases are true, the <code>DDI_SUSPEND</code> request should be
rejected. <a href="#powermgt-ex-140">example_title</a> shows an <code>attach(9E)</code>
routine using <code>ddi_removing_power(9F)</code> to check whether the
<code>DDI_SUSPEND</code> command causes problems.</p>
</div>
<div class="paragraph">
<p>Dump requests must be honored. The framework uses the <code>dump(9E)</code> entry
point to write out the state file that contains the contents of memory.
See the <code>dump(9E)</code> man page for the restrictions that are imposed on the
device driver when using this entry point.</p>
</div>
<div class="paragraph">
<p>Calling the <code>detach(9E)</code> entry point of a power-manageable component
with the <code>DDI_SUSPEND</code> command should save the state when the device
is powered off. The driver should cancel pending timeouts. The driver
should also suppress any calls to <code>pm_raise_power(9F)</code> except
for <code>dump(9E)</code> requests. When the device is resumed by a call to
<code>attach(9E)</code> with a command of <code>DDI_RESUME</code>, timeouts and calls to
<code>pm_raise_power</code> can be resumed. The driver must keep sufficient
track of its state to be able to deal appropriately with this
possibility. The following example shows a <code>detach(9E)</code> routine with the
<code>DDI_SUSPEND</code> command implemented.</p>
</div>
<div id="powermgt-ex-140" class="paragraph">
<p><code>detach(9E)</code> Routine Implementing <code>DDI_SUSPEND</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    struct xxstate *xsp;
    int instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);

    switch (cmd) {
    case DDI_DETACH:
        /* ... */
    case DDI_SUSPEND:
        /*
         * We do not allow DDI_SUSPEND if power will be removed and
         * we have a device that damages tape when power is removed
         * We do support DDI_SUSPEND for Device Reconfiguration.
         */
        if (ddi_removing_power(dip) &amp;&amp; xxdamages_tape(dip))
            return (DDI_FAILURE);
        mutex_enter(&amp;xsp-&gt;mu);
        xsp-&gt;xx_suspended = 1;  /* stop new operations */
        /*
         * Sleep waiting for all the commands to be completed
         *
         * If a callback is outstanding which cannot be cancelled
         * then either wait for the callback to complete or fail the
         * suspend request
         *
         * This section is only needed if the driver maintains a
         * running timeout
         */
        if (xsp-&gt;xx_timeout_id) {
            timeout_id_t temp_timeout_id = xsp-&gt;xx_timeout_id;
            xsp-&gt;xx_timeout_id = 0;
            mutex_exit(&amp;xsp-&gt;mu);
            untimeout(temp_timeout_id);
            mutex_enter(&amp;xsp-&gt;mu);
        }
        if (!xsp-&gt;xx_state_saved) {
            /*
             * Save device register contents into
             * xsp-&gt;xx_device_state
             */
        }
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_SUCCESS);
    default:
        return (DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="attach-entry-point-1"><a class="anchor" href="#attach-entry-point-1"></a><code>attach</code> Entry Point</h5>
<div class="paragraph">
<p>The syntax for <code>attach(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int attach(dev_info_t *dip, ddi_attach_cmd_t cmd);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When power is restored to the system, each device with a
<code>reg</code> property or with a <code>pm-hardware-state</code> property of value
<code>needs-suspend-resume</code> has its <code>attach(9E)</code> entry point called with a
command value of <code>DDI_RESUME</code>. If the system shutdown is aborted,
each suspended driver is called to resume even though the power has not
been shut off. Consequently, the resume code in <code>attach(9E)</code> must make
no assumptions about whether the system actually lost power.</p>
</div>
<div class="paragraph">
<p>The power management framework considers the power level of the
components to be unknown at <code>DDI_RESUME</code> time. Depending on the
nature of the device, the driver writer has two choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the driver can determine the actual power level of the components
of the device without powering the components up, such as by reading a
register, then the driver should notify the framework of the power level
of each component by calling <code>pm_power_has_changed(9F)</code>.</p>
</li>
<li>
<p>If the driver cannot determine the power levels of the components,
then the driver should mark each component internally as unknown and
call <code>pm_raise_power(9F)</code> before the first access to each
component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows an <code>attach(9E)</code> routine with the
<code>DDI_RESUME</code> command.</p>
</div>
<div id="powermgt-ex-142" class="paragraph">
<p><code>attach(9E)</code> Routine Implementing <code>DDI_RESUME</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">xxattach(devinfo_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate *xsp;
    int    instance;

    instance = ddi_get_instance(dip);
    xsp = ddi_get_soft_state(statep, instance);

    switch (cmd) {
    case DDI_ATTACH:
    /* ... */
    case DDI_RESUME:
        mutex_enter(&amp;xsp-&gt;mu);
        if (xsp-&gt;xx_pm_state_saved) {
            /*
             * Restore device register contents from
             * xsp-&gt;xx_device_state
             */
        }
        /*
         * This section is optional and only needed if the
         * driver maintains a running timeout
         */
        xsp-&gt;xx_timeout_id = timeout( /* ... */ );

        xsp-&gt;xx_suspended = 0;        /* allow new operations */
        cv_broadcast(&amp;xsp-&gt;xx_suspend_cv);
        /* If it is possible to determine in a device-specific
         * way what the power levels of components are without
         * powering the components up,
         * then the following code is recommended
         */
        for (i = 0; i &lt; num_components; i++) {
            xsp-&gt;xx_power_level[i] = xx_get_power_level(dip, i);
            if (xsp-&gt;xx_power_level[i] != XX_LEVEL_UNKNOWN)
                (void) pm_power_has_changed(dip, i,
                    xsp-&gt;xx_power_level[i]);
        }
        mutex_exit(&amp;xsp-&gt;mu);
        return(DDI_SUCCESS);
    default:
        return(DDI_FAILURE);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>detach(9E)</code> and <code>attach(9E)</code> interfaces can also be used to resume
a system that has been quiesced.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="power-management-device-access-example"><a class="anchor" href="#power-management-device-access-example"></a>2.53. Power Management Device Access Example</h3>
<div class="paragraph">
<p>If power management is supported, and <code>detach(9E)</code> and <code>attach(9E)</code> are
used as in <a href="#powermgt-ex-140">example_title</a> and
<a href="#powermgt-ex-142">example_title</a>, then access to the device can
be made from user context, for example, from <code>read(2)</code>, <code>write(2)</code>, and
<code>ioctl(2)</code>.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates this approach. The example assumes
that the operation about to be performed requires a component
<code>component</code> that is operating at power level <code>level</code>.</p>
</div>
<div id="powermgt-ex-143" class="paragraph">
<p>Device Access</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">mutex_enter(&amp;xsp-&gt;mu);
/*
 * Block command while device is suspended by DDI_SUSPEND
 */
while (xsp-&gt;xx_suspended)
    cv_wait(&amp;xsp-&gt;xx_suspend_cv, &amp;xsp-&gt;mu);
/*
 * Mark component busy so xx_power() will reject attempt to lower power
 */
xsp-&gt;xx_busy[component]++;
if (pm_busy_component(dip, component) != DDI_SUCCESS) {
    xsp-&gt;xx_busy[component]--;
    /*
     * Log error and abort
     */
}
if (xsp-&gt;xx_power_level[component] &lt; level) {
    mutex_exit(&amp;xsp-&gt;mu);
    if (pm_raise_power(dip, component, level) != DDI_SUCCESS) {
        /*
         * Log error and abort
         */
    }
    mutex_enter(&amp;xsp-&gt;mu);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code fragment in the following example can be used when device
operation completes, for example, in the device&#8217;s interrupt handler.</p>
</div>
<div id="powermgt-ex-147" class="paragraph">
<p>Device Operation Completion</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * For each command completion, decrement the busy count and unstack
 * the pm_busy_component() call by calling pm_idle_component(). This
 * will allow device power to be lowered when all commands complete
 * (all pm_busy_component() counts are unstacked)
 */
xsp-&gt;xx_busy[component]--;
if (pm_idle_component(dip, component) != DDI_SUCCESS) {
    xsp-&gt;xx_busy[component]++;
    /*
     * Log error and abort
     */
}
/*
 * If no more outstanding commands, wake up anyone (like DDI_SUSPEND)
 * waiting for all commands to  be completed
 */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="power-management-flow-of-control"><a class="anchor" href="#power-management-flow-of-control"></a>2.54. Power Management Flow of Control</h3>
<div class="literalblock">
<div class="content">
<pre>  link:#powermgt-fig-145[Power Management
Conceptual State Diagram] illustrates the flow of control in the power
management framework.</pre>
</div>
</div>
<div class="paragraph">
<p>When a component&#8217;s activity is complete, a driver can call
<code>pm_idle_component(9F)</code> to mark the component as idle. When the
component has been idle for its threshold time, the framework can lower
the power of the component to its next lower level. The framework calls
the <code>power(9E)</code> function to set the component&#8217;s power to the next lower
supported power level, if a lower level exists. The driver&#8217;s <code>power(9E)</code>
function should reject any attempt to lower the power level of a
component when that component is busy. The <code>power(9E)</code> function should
save any state that could be lost in a transition to a lower level prior
to making that transition.</p>
</div>
<div class="paragraph">
<p>When the component is needed at a higher level, the driver calls
<code>pm_busy_component(9F)</code>. This call keeps the framework from
lowering the power still further and then calls
<code>pm_raise_power(9F)</code> on the component. The framework next calls
<code>power(9E)</code> to raise the power of the component before the call to
<code>pm_raise_power(9F)</code> returns. The driver&#8217;s <code>power(9E)</code> code must
restore any state that was lost in the lower level but that is needed in
the higher level.</p>
</div>
<div class="paragraph">
<p>When a driver is detaching, the driver should call
<code>pm_lower_power(9F)</code> for each component to lower its power to
its lowest level. The framework can then call the driver&#8217;s <code>power(9E)</code>
routine to lower the power of the component before the call to
<code>pm_lower_power(9F)</code> returns.</p>
</div>
<div id="powermgt-fig-145" class="imageblock">
<div class="content">
<img src="figures/powermgt-concept.png" alt="Diagram shows the flow of control through power management routines.">
</div>
<div class="title">Figure 11. Power Management Conceptual State Diagram</div>
</div>
</div>
<div class="sect2">
<h3 id="changes-to-power-management-interfaces"><a class="anchor" href="#changes-to-power-management-interfaces"></a>2.55. Changes to Power Management Interfaces</h3>
<div class="paragraph">
<p>Prior to the Solaris 8 release, power management of devices was not
automatic. Developers had to add an entry to <code>/etc/power.conf</code> for each
device that was to be power-managed. The framework assumed that all
devices supported only two power levels: 0 and standard power.</p>
</div>
<div class="paragraph">
<p>Power assumed an implied dependency of all other components on component
0. When component 0 changed to level 0, a call was made into the
driver&#8217;s <code>detach</code>(9E) with the <code>DDI_PM_SUSPEND</code> command to save
the hardware state. When component 0 changed from level 0, a call was
made to the <code>attach</code>(9E) routine with the command
<code>DDI_PM_RESUME</code> to restore hardware state.</p>
</div>
<div class="paragraph">
<p>The following interfaces and commands are obsolete, although they are
still supported for binary purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ddi_dev_is_needed(9F)</code></p>
</li>
<li>
<p><code>pm_create_components(9F)</code></p>
</li>
<li>
<p><code>pm_destroy_components(9F)</code></p>
</li>
<li>
<p><code>pm_get_normal_power(9F)</code></p>
</li>
<li>
<p><code>pm_set_normal_power(9F)</code></p>
</li>
<li>
<p><code>DDI_PM_SUSPEND</code></p>
</li>
<li>
<p><code>DDI_PM_RESUME</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since the Solaris 8 release, devices that export the <code>pm-components</code>
property automatically use power management if <code>autopm</code> is enabled.</p>
</div>
<div class="paragraph">
<p>The framework now knows from the <code>pm-components</code> property which power
levels are supported by each device.</p>
</div>
<div class="paragraph">
<p>The framework makes no assumptions about dependencies among the
different components of a device. The device driver is responsible for
saving and restoring hardware state as needed when changing power
levels.</p>
</div>
<div class="paragraph">
<p>These changes enable the power management framework to deal with
emerging device technology. Power management now results in greater
power savings. The framework can detect automatically which devices can
save power. The framework can use intermediate power states of the
devices. A system can now meet energy consumption goals without powering
down the entire system and without any functions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Power Management Interfaces</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Removed Interfaces</th>
<th class="tableblock halign-left valign-top">Equivalent Interfaces</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_create_components</code>(9F)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm-components(9P)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_set_normal_power</code>(9F)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm-components(9P)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_destroy_components</code>(9F)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_get_normal_power</code>(9F)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dev_is_needed</code>(9F)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_raise_power(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_lower_power(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_power_has_changed(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDI_PM_SUSPEND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDI_PM_RESUME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="hardening-illumos-drivers"><a class="anchor" href="#hardening-illumos-drivers"></a>2.56. Hardening illumos Drivers</h3>
<div class="paragraph">
<p>Management Architecture (FMA) I/O Fault Services enable driver
developers to integrate fault management capabilities into I/O device
drivers. The illumos I/O fault services framework defines a set of
interfaces that enable all drivers to coordinate and perform basic error
handling tasks and activities. The illumos FMA as a whole provides for
error handling and fault diagnosis, in addition to response and
recovery. FMA is a component of illumos&#8217;s Predictive Self-Healing
strategy.</p>
</div>
<div class="paragraph">
<p>A driver is considered hardened when it uses the defensive programming
practices described in this document in addition to the I/O fault
services framework for error handling and diagnosis. The driver
hardening test harness tests that the I/O fault services and defensive
programming requirements have been correctly fulfilled.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#illumos-fault-management-architecture-io-fault-services">illumos Fault Management Architecture I/O Fault
Services</a> provides a reference for driver developers who want to
integrate fault management capabilities into I/O device drivers.</p>
</li>
<li>
<p><a href="#defensive-programming-techniques-for-illumos-device-drivers">Defensive Programming Techniques for
illumos Device Drivers</a> provides general information about how to
defensively write an illumos device driver.</p>
</li>
<li>
<p><a href="#driver-hardening-test-harness">Driver Hardening Test Harness</a> is a driver development
tool that injects simulated hardware faults when the driver under
development accesses its hardware.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="illumos-fault-management-architecture-io-fault-services"><a class="anchor" href="#illumos-fault-management-architecture-io-fault-services"></a>2.57. illumos Fault Management Architecture I/O Fault Services</h3>
<div class="paragraph">
<p>This section explains how to integrate fault management error reporting,
error handling, and diagnosis for I/O device drivers. This section
provides an in-depth examination of the I/O fault services framework and
how to utilize the I/O fault service APIs within a device driver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#what-is-predictive-self-healing">What Is Predictive Self-Healing?</a> provides background and
an overview of the illumos Fault Management Architecture.</p>
</li>
<li>
<p><a href="#illumos-fault-manager">illumos Fault Manager</a> describes additional background
with a focus on a high-level overview of the illumos Fault Manager,
<code>fmd(8)</code>.</p>
</li>
<li>
<p><a href="#error-handling">Error Handling</a> is the primary section for driver
developers. This section highlights the best practice coding techniques
for high-availability and the use of I/O fault services in driver code
to interact with the FMA.</p>
</li>
<li>
<p><a href="#diagnosing-faults">Diagnosing Faults</a> describes how faults are diagnosed from
the errors detected by drivers.</p>
</li>
<li>
<p><a href="#event-registry">Event Registry</a> provides information on illumos&#8217;s Event
Registry.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="what-is-predictive-self-healing"><a class="anchor" href="#what-is-predictive-self-healing"></a>2.57.1. What Is Predictive Self-Healing?</h4>
<div class="paragraph">
<p>Predictive Self-Healing</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ereport event</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ereport events</p>
</div>
<div class="paragraph">
<p>diagnosis engine</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>diagnosis engine</p>
</div>
<div class="paragraph">
<p>fault event</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault event</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>Traditionally, systems have exported hardware and software error
information directly to human administrators and to management software
in the form of syslog messages. Often, error detection, diagnosis,
reporting, and handling was embedded in the code of each driver.</p>
</div>
<div class="paragraph">
<p>A system like the illumos OS predictive self-healing system is first and
foremost self-diagnosing. Self-diagnosing means the system provides
technology to automatically diagnose problems from observed symptoms,
and the results of the diagnosis can then be used to trigger automated
response and recovery. A <em>fault</em> in hardware or a defect in software can
be associated with a set of possible observed symptoms called <em>errors</em>.
The data generated by the system as the result of observing an error is
called an error report or <em>ereport</em>.</p>
</div>
<div class="paragraph">
<p>In a system capable of self-healing, ereports are captured by the system
and are encoded as a set of name-value pairs described by an extensible
event protocol to form an <em>ereport event</em>. Ereport events and other data
are gathered to facilitate self-healing, and are dispatched to software
components called diagnosis engines designed to diagnose the underlying
problems corresponding to the error symptoms observed by the system. A
<em>diagnosis engine</em> runs in the background and silently consumes error
telemetry until it can produce a diagnosis or predict a fault.</p>
</div>
<div class="paragraph">
<p>After processing sufficient telemetry to reach a conclusion, a diagnosis
engine produces another event called a <em>fault event</em>. The fault event is
then broadcast to all agents that are interested in the specific fault
event. An <em>agent</em> is a software component that initiates recovery and
responds to specific fault events. A software component known as the
illumos Fault Manager, <code>fmd(8)</code>, manages the multiplexing of events
between ereport generators, diagnosis engines, and agent software.</p>
</div>
</div>
<div class="sect3">
<h4 id="illumos-fault-manager"><a class="anchor" href="#illumos-fault-manager"></a>2.57.2. illumos Fault Manager</h4>
<div class="paragraph">
<p>fault manager daemon</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault manager daemon</p>
</div>
<div class="paragraph">
<p>The illumos Fault Manager, <code>fmd(8)</code>, is responsible for dispatching
in-bound error telemetry events to the appropriate diagnosis engines.
The diagnosis engine is responsible for identifying the underlying
hardware faults or software defects that are producing the error
symptoms. The <code>fmd</code>(1M) daemon is the illumos implementation of a fault
manager. It starts at boot time and loads all of the diagnosis engines
and agents available on the system. The illumos Fault Manager also
provides interfaces for system administrators and service personnel to
observe fault management activity.</p>
</div>
<div class="sect4">
<h5 id="diagnosis-suspect-lists-and-fault-events"><a class="anchor" href="#diagnosis-suspect-lists-and-fault-events"></a>Diagnosis, Suspect Lists, and Fault Events</h5>
<div class="paragraph">
<p>list suspect</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>list suspect</p>
</div>
<div class="paragraph">
<p>suspect list</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>suspect list</p>
</div>
<div class="paragraph">
<p>Once a diagnosis has been made, the diagnosis is output in the form of a
<em>list.suspect</em> event. A list.suspect event is an event comprised of one
or more possible fault or defect events. Sometimes the diagnosis cannot
narrow the cause of errors to a single fault or defect. For example, the
underlying problem might be a broken wire connecting controllers to the
main system bus. The problem might be with a component on the bus or
with the bus itself. In this specific case, the list.suspect event will
contain multiple fault events: one for each controller attached to the
bus, and one for the bus itself.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>resource</em> is the component that was diagnosed as faulty. The
<code>fmdump(8)</code> command shows this payload member as “Problem in.”</p>
</li>
<li>
<p>The <em>Automated System Recovery Unit</em> (ASRU) is the hardware or
software component that must be disabled to prevent further error
symptoms from occurring. The <code>fmdump</code>(1M) command shows this payload
member as “Affects.”</p>
</li>
<li>
<p>The <em>Field Replaceable Unit</em> (FRU) is the component that must be
replaced or repaired to fix the underlying problem.</p>
</li>
<li>
<p>The <em>Label</em> payload is a string that gives the location of the FRU in
the same form as it is printed on the chassis or motherboard, for
example next to a DIMM slot or PCI card slot. The <code>fmdump</code> command shows
this payload member as “Location.”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, after receiving a certain number of ECC correctable errors
in a given amount of time for a particular memory location, the CPU and
memory diagnosis engine issues a diagnosis (list.suspect event) for a
faulty DIMM.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fmdump -v -u 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c
TIME                 UUID                                 SUNW-MSG-ID
Oct 31 13:40:18.1864 38bd6f1b-a4de-4c21-db4e-ccd26fa8573c AMD-8000-8L
100%  fault.cpu.amd.icachetag

Problem in: hc:///motherboard=0/chip=0/cpu=0
Affects: cpu:///cpuid=0
FRU: hc:///motherboard=0/chip=0
Location: SLOT 2</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>fmd(8)</code> has identified a problem in a resource,
specifically a CPU (<code>hc:///motherboard=0/chip=0/cpu=0</code>). To suppress
further error symptoms and to prevent an uncorrectable error from
occurring, an ASRU, (<code>cpu:///cpuid=0</code>), is identified for retirement.
The component that needs to be replaced is the FRU
(<code>hc:///motherboard=0/chip=0</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="response-agents"><a class="anchor" href="#response-agents"></a>Response Agents</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>response agent</p>
</div>
<div class="paragraph">
<p>retire agent</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>retire agent</p>
</div>
<div class="paragraph">
<p>An agent is a software component that takes action in response to a
diagnosis or repair. For example, the CPU and memory retire agent is
designed to act on list.suspects that contain a fault.cpu.* event.
The <code>cpumem-retire</code> agent will attempt to off-line a CPU or retire a
physical memory page from service. If the agent is successful, an entry
in the fault manager&#8217;s ASRU cache is added for the page or CPU that was
successfully retired. The <code>fmadm(8)</code> utility, as shown in the example
below, shows an entry for a memory rank that has been diagnosed as
having a fault. ASRUs that the system does not have the ability to
off-line, retire, or disable, will also have an entry in the ASRU cache,
but they will be seen as degraded. Degraded means the resource
associated with the ASRU is faulty, but the ASRU is unable to be removed
from service. Currently illumos agent software cannot act upon I/O ASRUs
(device instances). All faulty I/O resource entries in the cache are in
the degraded state.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># fmadm faulty
   STATE RESOURCE / UUID
-------- ----------------------------------------------------------------------
degraded mem:///motherboard=0/chip=1/memory-controller=0/dimm=3/rank=0
         ccae89df-2217-4f5c-add4-d920f78b4faf
-------- ----------------------------------------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>The primary purpose of a <em>retire agent</em> is to isolate (safely remove
from service) the piece of hardware or software that has been diagnosed
as faulty.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Send alerts via SNMP traps. This can translate a diagnosis into an
alert for SNMP that plugs into existing software mechanisms.</p>
</li>
<li>
<p>Post a syslog message. Message specific diagnoses (for example, syslog
message agent) can take the result of a diagnosis and translate it into
a syslog message that administrators can use to take a specific action.</p>
</li>
<li>
<p>Other agent actions such as update the FRUID. Response agents can be
platform-specific.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="message-ids-and-dictionary-files"><a class="anchor" href="#message-ids-and-dictionary-files"></a>Message IDs and Dictionary Files</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault messages</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>list suspect</p>
</div>
<div class="paragraph">
<p>The syslog message agent takes the output of the diagnosis (the
list.suspect event) and writes specific messages to the console or
<code>/var/adm/messages</code>. Often console messages can be difficult to
understand. FMA remedies this problem by providing a defined fault
message structure that is generated every time a list.suspect event is
delivered to a syslog message.</p>
</div>
<div class="paragraph">
<p>syslog agent generates a message identifier (MSG ID). The event registry
generates dictionary files (<code>.dict</code> files) that map a list.suspect event
to a structured message identifier that should be used to identify and
view the associated knowledge article. Message files, (<code>.po</code> files) map
the message ID to localized messages for every possible list of
suspected faults that the diagnosis engine can generate. The following
is an example of a fault message emitted on a test system.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SUNW-MSG-ID: AMD-8000-7U, TYPE: Fault, VER: 1, SEVERITY: Major
EVENT-TIME: Fri Jul 28 04:26:51 PDT 2006
PLATFORM: Sun Fire V40z, CSN: XG051535088, HOSTNAME: parity
SOURCE: eft, REV: 1.16
EVENT-ID: add96f65-5473-69e6-dbe1-8b3d00d5c47b
DESC: The number of errors associated with this CPU has exceeded
acceptable levels. Refer to http://sun.com/msg/AMD-8000-7U for
more information.
AUTO-RESPONSE: An attempt will be made to remove this CPU from service.
IMPACT: Performance of this system may be affected.
REC-ACTION: Schedule a repair procedure to replace the affected CPU.
Use fmdump -v -u &lt;EVENT_ID&gt; to identify the module.</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="system-topology"><a class="anchor" href="#system-topology"></a>System Topology</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>topology of system</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault event</p>
</div>
<div class="paragraph">
<p>To identify where a fault might have occurred, diagnosis engines need to
have the topology for a given software or hardware system represented.
The <code>fmd(8)</code> daemon provides diagnosis engines with a handle to a
topology snapshot that can be used during diagnosis. Topology
information is used to represent the resource, ASRU, and FRU found in
each fault event. The topology can also be used to store the platform
label, FRUID, and serial number identification.</p>
</div>
<div class="paragraph">
<p>The resource payload member in the fault event is always represented by
the physical path location from the platform chassis outward. For
example, a PCI controller function that is bridged from the main system
bus to a PCI local bus is represented by its <code>hc</code> scheme path name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>hc:///motherboard=0/hostbridge=1/pcibus=0/pcidev=13/pcifn=0</pre>
</div>
</div>
<div class="paragraph">
<p>The ASRU payload member in the fault event is typically represented by
the illumos device tree instance name that is bound to a hardware
controller, device, or function. FMA uses the <code>dev</code> scheme to represent
the ASRU in its native format for actions that might be taken by a
future implementation of a retire agent specifically designed for I/O
devices:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dev:////pci@1e,600000/ide@d</pre>
</div>
</div>
<div class="paragraph">
<p>The FRU payload representation in the fault event varies depending on
the closest replaceable component to the I/O resource that has been
diagnosed as faulty. For example, a fault event for a broken embedded
PCI controller might name the motherboard of the system as the FRU that
needs to be replaced:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>hc:///motherboard=0</pre>
</div>
</div>
<div class="paragraph">
<p>The label payload is a string that gives the location of the FRU in the
same form as it is printed on the chassis or motherboard, for example
next to a DIMM slot or PCI card slot:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Label: SLOT 2</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="error-handling"><a class="anchor" href="#error-handling"></a>2.57.3. Error Handling</h4>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>error handling</p>
</div>
<div class="paragraph">
<p>This section describes how to use I/O fault services APIs to handle
errors within a driver. This section discusses how drivers should
indicate and initialize their fault management capabilities, generate
error reports, and register the driver&#8217;s error handler routine.</p>
</div>
<div class="paragraph">
<p>Excerpts are provided from source code examples that
demonstrate the use of the I/O fault services API from the Broadcom 1Gb
NIC driver, <code>bge</code>. Follow these examples as a model for how to integrate
fault management capability into your own drivers. Take the following
steps to study the complete <code>bge</code> driver code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Go to the <a href="http://src.illumos.org/">illumos source browser</a>.</p>
</li>
<li>
<p>Enter <code>bge</code> in the File Path field.</p>
</li>
<li>
<p>Select illumos-gate in the project(s) listing.</p>
</li>
<li>
<p>Click the Search button.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Drivers that have been instrumented to provide FMA error report
telemetry detect errors and determine the impact of those errors on the
services provided by the driver. Following the detection of an error,
the driver should determine when its services have been impacted and to
what degree.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Attempt recovery</p>
</li>
<li>
<p>Retry an I/O transaction</p>
</li>
<li>
<p>Attempt fail-over techniques</p>
</li>
<li>
<p>Report the error to the calling application/stack</p>
</li>
<li>
<p>If the error cannot be constrained any other way, then panic</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Errors detected by the driver are communicated to the
fault management daemon as an <em>ereport</em>. An ereport is a structured
event defined by the FMA event protocol. The event protocol is a
specification for a set of common data fields that must be used to
describe all possible error and fault events, in addition to the list of
suspected faults. Ereports are gathered into a flow of error telemetry
and dispatched to the diagnosis engine.</p>
</div>
<div class="sect4">
<h5 id="declaring-fault-management-capabilities"><a class="anchor" href="#declaring-fault-management-capabilities"></a>Declaring Fault Management Capabilities</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault management capabilities, declaring</p>
</div>
<div class="paragraph">
<p>ddi_fm_init</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_init</p>
</div>
<div class="paragraph">
<p>A hardened device driver must declare its fault management capabilities
to the I/O Fault Management framework. Use the ddi_fm_init(9F)
function to declare the fault management capabilities of your driver.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_init(dev_info_t *dip, int *fmcap, ddi_iblock_cookie_t *ibcp)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ddi_fm_init</code> function can be called from
kernel context in a driver <code>attach(9E)</code> or <code>detach(9E)</code> entry point. The
<code>ddi_fm_init</code> function usually is called from the <code>attach</code> entry
point. The <code>ddi_fm_init</code> function allocates and initializes
resources according to &lt;fmcap&gt;. The &lt;fmcap&gt; parameter
must be set to the bitwise-inclusive-OR of the following fault
management capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DDI_FM_EREPORT_CAPABLE</code> - Driver is responsible for and
capable of generating FMA protocol error events (ereports) upon
detection of an error condition.</p>
</li>
<li>
<p><code>DDI_FM_ACCCHK_CAPABLE</code> - Driver is responsible for and
capable of checking for errors upon completion of one or more access I/O
transactions.</p>
</li>
<li>
<p><code>DDI_FM_DMACHK_CAPABLE</code> - Driver is responsible for and
capable of checking for errors upon completion of one or more DMA I/O
transactions.</p>
</li>
<li>
<p><code>DDI_FM_ERRCB_CAPABLE</code> - Driver has an error callback
function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A hardened leaf driver generally sets all these
capabilities. However, if its parent nexus is not capable of supporting
any one of the requested capabilities, the associated bit is cleared and
returned as such to the driver. Before returning from
ddi_fm_init(9F), the I/O fault services framework creates a set
of fault management capability properties: fm-ereport-capable,
fm-accchk-capable, fm-dmachk-capable and fm-errcb-capable. The currently
supported fault management capability level is observable by using the
<code>prtconf(8)</code> command.</p>
</div>
<div class="paragraph">
<p>To make your driver support administrative selection of fault management
capabilities, export and set the fault management capability level
properties to the values described above in the <code>driver.conf(5)</code> file.
The fm-capable properties must be set and read prior to calling
<code>ddi_fm_init</code> with the desired capability list.</p>
</div>
<div class="paragraph">
<p>The following example from the <code>bge</code>
driver shows the <code>bge_fm_init</code> function, which calls the
ddi_fm_init(9F) function. The <code>bge_fm_init</code> function is
called in the <code>bge_attach</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
bge_fm_init(bge_t *bgep)
{
        ddi_iblock_cookie_t iblk;

        /* Only register with IO Fault Services if we have some capability */
        if (bgep-&gt;fm_capabilities) {
                bge_reg_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_FLAGERR_ACC;
                dma_attr.dma_attr_flags = DDI_DMA_FLAGERR;
                /*
                 * Register capabilities with IO Fault Services
                 */
                ddi_fm_init(bgep-&gt;devinfo, &amp;bgep-&gt;fm_capabilities, &amp;iblk);
                /*
                 * Initialize pci ereport capabilities if ereport capable
                 */
                if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        pci_ereport_setup(bgep-&gt;devinfo);
                /*
                 * Register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        ddi_fm_handler_register(bgep-&gt;devinfo,
                        bge_fm_error_cb, (void*) bgep);
        } else {
                /*
                 * These fields have to be cleared of FMA if there are no
                 * FMA capabilities at runtime.
                 */
                bge_reg_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                bge_desc_accattr.devacc_attr_access = DDI_DEFAULT_ACC;
                dma_attr.dma_attr_flags = 0;
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cleaning-up-fault-management-resources"><a class="anchor" href="#cleaning-up-fault-management-resources"></a>Cleaning Up Fault Management Resources</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault management resources, cleaning up</p>
</div>
<div class="paragraph">
<p>ddi_fm_fini</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_fini</p>
</div>
<div class="paragraph">
<p>The ddi_fm_fini(9F) function cleans up resources allocated to
support fault management for &lt;dip&gt;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_fini(dev_info_t *dip)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ddi_fm_fini</code> function can be called from kernel context in
a driver <code>attach(9E)</code> or <code>detach(9E)</code> entry point.</p>
</div>
<div class="paragraph">
<p>The following example from the <code>bge</code>
driver shows the <code>bge_fm_fini</code> function, which calls the
ddi_fm_fini(9F) function. The <code>bge_fm_fini</code> function is
called in the <code>bge_unattach</code> function, which is called in both the
<code>bge_attach</code> and <code>bge_detach</code> functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
bge_fm_fini(bge_t *bgep)
{
        /* Only unregister FMA capabilities if we registered some */
        if (bgep-&gt;fm_capabilities) {
                /*
                 * Release any resources allocated by pci_ereport_setup()
                 */
                if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities) ||
                    DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        pci_ereport_teardown(bgep-&gt;devinfo);
                /*
                 * Un-register error callback if error callback capable
                 */
                if (DDI_FM_ERRCB_CAP(bgep-&gt;fm_capabilities))
                        ddi_fm_handler_unregister(bgep-&gt;devinfo);
                /*
                 * Unregister from IO Fault Services
                 */
                ddi_fm_fini(bgep-&gt;devinfo);
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="getting-the-fault-management-capability-bit-mask"><a class="anchor" href="#getting-the-fault-management-capability-bit-mask"></a>Getting the Fault Management Capability Bit Mask</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault management capability bit mask</p>
</div>
<div class="paragraph">
<p>ddi_fm_capable</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_capable</p>
</div>
<div class="paragraph">
<p>The ddi_fm_capable(9F) function returns the capability bit mask
currently set for &lt;dip&gt;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_capable(dev_info_t *dip)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reporting-errors"><a class="anchor" href="#reporting-errors"></a>Reporting Errors</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#gemfu">Queueing an Error Event</a> discusses how to queue error
events.</p>
</li>
<li>
<p><a href="#gemfk">Detecting and Reporting PCI-Related Errors</a> describes how
to report PCI-related errors.</p>
</li>
<li>
<p><a href="#gemha">Reporting Standard I/O Controller Errors</a> describes how to
report standard I/O controller errors.</p>
</li>
<li>
<p><a href="#gemgp">Service Impact Function</a> discusses how to report whether
an error has impacted the services provided by a device.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="gemfu"><a class="anchor" href="#gemfu"></a>Queueing an Error Event</h6>
<div class="paragraph">
<p>ddi_fm_ereport_post</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_ereport_post</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ereport events</p>
</div>
<div class="paragraph">
<p>ENA (Error Numeric Association)</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ENA (Error Numeric Association)</p>
</div>
<div class="paragraph">
<p>The ddi_fm_ereport_post(9F) function causes an ereport event
to be queued for delivery to the fault manager daemon, <code>fmd(8)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_ereport_post(dev_info_t *dip,
                         const char *error_class,
                         uint64_t ena,
                         int sflag, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;sflag&gt; parameter indicates whether the caller is willing to
wait for system memory and event channel resources to become available.</p>
</div>
<div class="paragraph">
<p>The ENA indicates the <em>Error Numeric Association</em> (ENA) for this error
report. The ENA might have been initialized and obtained from another
error detecting software module such as a bus nexus driver. If the ENA
is set to 0, it will be initialized by
<code>ddi_fm_ereport_post</code>.</p>
</div>
<div class="paragraph">
<p>The name-value pair (&lt;nvpair&gt;) variable argument list contains
one or more name, type, value pointer &lt;nvpair&gt; tuples for
non-array <code>data_type_t</code> types or one or more name, type, number
of element, value pointer tuples for <code>data_type_t</code> array types.
The &lt;nvpair&gt; tuples make up the ereport event payload required
for diagnosis. The end of the argument list is specified by <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p>The ereport
class names and payloads described in <a href="#gemha">Reporting Standard I/O
Controller Errors</a> for I/O controllers are used as appropriate for
&lt;error_class&gt;. Other ereport class names and payloads can be
defined, but they must be registered in the illumos <em>event registry</em> and
accompanied by driver specific diagnosis engine software, or the
Eversholt fault tree (eft) rules. For more information about the illumos
event registry and about Eversholt fault tree rules, see the
<a href="http://www.opensolaris.org/os/community/fm/">Fault Management community</a>
on <a href="http://www.opensolaris.org/os/">OpenSolaris</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">bge_fm_ereport(bge_t *bgep, char *detail)
{
        uint64_t ena;
        char buf[FM_MAX_CLASS];
        (void) snprintf(buf, FM_MAX_CLASS, "%s.%s", DDI_FM_DEVICE, detail);
        ena = fm_ena_generate(0, FM_ENA_FMT1);
        if (DDI_FM_EREPORT_CAP(bgep-&gt;fm_capabilities)) {
                ddi_fm_ereport_post(bgep-&gt;devinfo, buf, ena, DDI_NOSLEEP,
                    FM_VERSION, DATA_TYPE_UINT8, FM_EREPORT_VERS0, NULL);
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="gemfk"><a class="anchor" href="#gemfk"></a>Detecting and Reporting PCI-Related Errors</h6>
<div class="paragraph">
<p>pci_ereport_post</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>pci_ereport_post</p>
</div>
<div class="paragraph">
<p>pci_ereport_setup</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>pci_ereport_seetup</p>
</div>
<div class="paragraph">
<p>pci_ereport_teardown</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>pci_ereport_teardown</p>
</div>
<div class="paragraph">
<p>PCI-related errors, including PCI, PCI-X, and PCI-E, are automatically
detected and reported when you use pci_ereport_post(9F).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void pci_ereport_post(dev_info_t *dip, ddi_fm_error_t *derr, uint16_t *xx_status)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Drivers do not need to generate driver-specific ereports for errors that
occur in the PCI Local Bus configuration status registers. The
<code>pci_ereport_post</code> function can report data parity errors,
master aborts, target aborts, signaled system errors, and much more.</p>
</div>
<div class="paragraph">
<p>If <code>pci_ereport_post</code> is to be used by a driver, then
pci_ereport_setup(9F) must have been previously called during
the driver&#8217;s attach(9E) routine, and pci_ereport_teardown(9F)
must subsequently be called during the driver&#8217;s detach(9E) routine.</p>
</div>
<div class="paragraph">
<p>The <code>bge</code> code samples below show the <code>bge</code> driver invoking the
<code>pci_ereport_post</code> function from the driver&#8217;s error handler. See
also <a href="#registering-an-error-handler">Registering an Error Handler</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error
      * in any dma or access handle, we can just return
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err-&gt;fme_status);
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="gemha"><a class="anchor" href="#gemha"></a>Reporting Standard I/O Controller Errors</h6>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>eft diagnosis engine</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>event registry</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DDI_FM_* I/O controller errors</p>
</div>
<div class="paragraph">
<p>A standard set of device ereports is defined for commonly seen errors
for I/O controllers. These ereports should be generated whenever one of
the error symptoms described in this section is detected.</p>
</div>
<div class="paragraph">
<p>The ereports described in this section are dispatched for diagnosis to
the eft diagnosis engine, which uses a common set of standard rules to
diagnose them. Any other errors detected by device drivers must be
defined as ereport events in the illumos event registry and must be
accompanied by device specific diagnosis software or eft rules.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_FM_DEVICE_INVAL_STATE</dt>
<dd>
<p>The driver has detected that the device is in an invalid state.
+
A driver should post an error when it detects that the data it
transmits or receives appear to be invalid. For example, in the <code>bge</code>
code, the <code>bge_chip_reset</code> and <code>bge_receive_ring</code>
routines generate the <code>ereport.io.device.inval_state</code> error when
these routines detect invalid data.
+</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * The SEND INDEX registers should be reset to zero by the
 * global chip reset; if they're not, there'll be trouble
 * later on.
 */
sx0 = bge_reg_get32(bgep, NIC_DIAG_SEND_INDEX_REG(0));
if (sx0 != 0) {
    BGE_REPORT((bgep, "SEND INDEX - device didn't RESET"));
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (DDI_FAILURE);
}
/* ... */
/*
 * Sync (all) the receive ring descriptors
 * before accepting the packets they describe
 */
DMA_SYNC(rrp-&gt;desc, DDI_DMA_SYNC_FORKERNEL);
if (*rrp-&gt;prod_index_p &gt;= rrp-&gt;desc.nslots) {
    bgep-&gt;bge_chip_state = BGE_CHIP_ERROR;
    bge_fm_ereport(bgep, DDI_FM_DEVICE_INVAL_STATE);
    return (NULL);
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_FM_DEVICE_INTERN_CORR</dt>
<dd>
<p>The device has reported a self-corrected internal error. For example,
a correctable ECC error has been detected by the hardware in an
internal buffer within the device.
+
This error flag is not used in the <code>bge</code> driver. See the
<code>nxge_fm.c</code> file on the illumos source browser for examples that
use this error. Take the following steps to study the <code>nxge</code> driver
code:
+</p>
<div class="ulist">
<ul>
<li>
<p>Go to <a href="http://src.illumos.org">illumos source browser</a>.</p>
</li>
<li>
<p>Enter <code>nxge</code> in the File Path field.</p>
</li>
<li>
<p>Select illumos-gate in the project(s) listing.</p>
</li>
<li>
<p>Click the Search button.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">DDI_FM_DEVICE_INTERN_UNCORR</dt>
<dd>
<p>The device has reported an uncorrectable internal error. For example,
an uncorrectable ECC error has been detected by the hardware in an
internal buffer within the device.
+
This error flag is not used in the <code>bge</code> driver. See the
<code>nxge_fm.c</code> file on the illumos source browser for examples that
use this error.</p>
</dd>
<dt class="hdlist1">DDI_FM_DEVICE_STALL</dt>
<dd>
<p>The driver has detected that data transfer has stalled unexpectedly.
+
The <code>bge_factotum_stall_check</code> routine provides an example
of stall detection.
+</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">dogval = bge_atomic_shl32(&amp;bgep-&gt;watchdog, 1);
if (dogval &lt; bge_watchdog_count)
    return (B_FALSE);

BGE_REPORT((bgep, "Tx stall detected,
watchdog code 0x%x", dogval));
bge_fm_ereport(bgep, DDI_FM_DEVICE_STALL);
return (B_TRUE);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_FM_DEVICE_NO_RESPONSE</dt>
<dd>
<p>The device is not responding to a driver command.
+</p>
</dd>
</dl>
</div>
<div class="literalblock">
<div class="content">
<pre>bge_chip_poll_engine(bge_t *bgep, bge_regno_t regno,
        uint32_t mask, uint32_t val)
{
        uint32_t regval;
        uint32_t n;

        for (n = 200; n; --n) {
                regval = bge_reg_get32(bgep, regno);
                if ((regval &amp; mask) == val)
                        return (B_TRUE);
                drv_usecwait(100);
        }
        bge_fm_ereport(bgep, DDI_FM_DEVICE_NO_RESPONSE);
        return (B_FALSE);
}</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_FM_DEVICE_BADINT_LIMIT</dt>
<dd>
<p>The device has raised too many consecutive invalid interrupts.
+
  The <code>bge_intr</code> routine within
the <code>bge</code> driver provides an example of stuck interrupt detection. The
<code>bge_fm_ereport</code> function is a wrapper for the
ddi_fm_ereport_post(9F) function. See the
<code>bge_fm_ereport</code> example in <a href="#gemfu">Queueing an Error
Event</a>
+</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (bgep-&gt;missed_dmas &gt;= bge_dma_miss_limit) {
    /*
     * If this happens multiple times in a row,
     * it means DMA is just not working.  Maybe
     * the chip has failed, or maybe there's a
     * problem on the PCI bus or in the host-PCI
     * bridge (Tomatillo).
     *
     * At all events, we want to stop further
     * interrupts and let the recovery code take
     * over to see whether anything can be done
     * about it ...
     */
    bge_fm_ereport(bgep,
        DDI_FM_DEVICE_BADINT_LIMIT);
    goto chip_stop;
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="gemgp"><a class="anchor" href="#gemgp"></a>Service Impact Function</h6>
<div class="paragraph">
<p>ddi_fm_service_impact</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_service_impact</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>access or DMA handle error</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DDI_SERVICE_* service impact values</p>
</div>
<div class="paragraph">
<p>A fault management capable driver must indicate whether or not an error
has impacted the services provided by a device. Following detection of
an error and, if necessary, a shutdown of services, the driver should
invoke the ddi_fm_service_impact(9F) routine to reflect the
current service state of the device instance. The service state can be
used by diagnosis and recovery software to help identify or react to the
problem.</p>
</div>
<div class="paragraph">
<p>The <code>ddi_fm_service_impact</code> routine should be called both
when an error has been detected by the driver itself, and when the
framework has detected an error and marked an access or DMA handle as
faulty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_service_impact(dev_info_t *dip, int svc_impact)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following service impact values (&lt;svc_impact&gt;) are
accepted by <code>ddi_fm_service_impact</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_SERVICE_LOST</dt>
<dd>
<p>The service provided by the device is unavailable due to a device
fault or software defect.</p>
</dd>
<dt class="hdlist1">DDI_SERVICE_DEGRADED</dt>
<dd>
<p>The driver is unable to provide normal service, but the driver can
provide a partial or degraded level of service. For example, the
driver might have to make repeated attempts to perform an operation
before it succeeds, or it might be running at less that its configured
speed.</p>
</dd>
<dt class="hdlist1">DDI_SERVICE_UNAFFECTED</dt>
<dd>
<p>The driver has detected an error, but the services provided by the
device instance are unaffected.</p>
</dd>
<dt class="hdlist1">DDI_SERVICE_RESTORED</dt>
<dd>
<p>All of the device&#8217;s services have been restored.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The call to <code>ddi_fm_service_impact</code> generates the following
ereports on behalf of the driver, based on the service impact argument
to the service impact routine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ereport.io.service.lost</code></p>
</li>
<li>
<p><code>ereport.io.service.degraded</code></p>
</li>
<li>
<p><code>ereport.io.service.unaffected</code></p>
</li>
<li>
<p><code>ereport.io.service.restored</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the following <code>bge</code> code, the driver determines that it is unable to
successfully restart transmitting or receiving packets as the result of
an error. The service state of the device transitions to
DDI_SERVICE_LOST.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * All OK, reinitialize hardware and kick off GLD scheduling
 */
mutex_enter(bgep-&gt;genlock);
if (bge_restart(bgep, B_TRUE) != DDI_SUCCESS) {
    (void) bge_check_acc_handle(bgep, bgep-&gt;cfg_handle);
    (void) bge_check_acc_handle(bgep, bgep-&gt;io_handle);
    ddi_fm_service_impact(bgep-&gt;devinfo, DDI_SERVICE_LOST);
    mutex_exit(bgep-&gt;genlock);
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ddi_fm_service_impact</code> function should not be called
from the registered callback routine.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="access-attributes-structure"><a class="anchor" href="#access-attributes-structure"></a>Access Attributes Structure</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>access attributes</p>
</div>
<div class="paragraph">
<p>programmed I/O access errors</p>
</div>
<div class="paragraph">
<p>ddi_device_acc_attr</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_device_acc_attr</p>
</div>
<div class="paragraph">
<p>A <code>DDI_FM_ACCCHK_CAPABLE</code> device driver must set its access
attributes to indicate that it is capable of handling programmed I/O
(PIO) access errors that occur during a register read or write. The
<code>devacc_attr_access</code> field in the
<code>ddi_device_acc_attr(9S)</code> structure should be set as an
indicator to the system that the driver is capable of checking for and
handling data path errors. The <code>ddi_device_acc_attr</code>
structure contains the following members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ushort_t devacc_attr_version;
uchar_t devacc_attr_endian_flags;
uchar_t devacc_attr_dataorder;
uchar_t devacc_attr_access;             /* access error protection */</code></pre>
</div>
</div>
<div class="paragraph">
<p>Errors detected in the data path to or from a device can be processed by
one or more of the device driver&#8217;s nexus parents.</p>
</div>
<div class="paragraph">
<p>The <code>devacc_attr_access</code> field can be set to the following
values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DDI_DEFAULT_ACC</dt>
<dd>
<p>This flag indicates the system will take the default action (panic if
appropriate) when an error occurs. This attribute cannot be used by
DDI_FM_ACCCHK_CAPABLE drivers.</p>
</dd>
<dt class="hdlist1">DDI_FLAGERR_ACC</dt>
<dd>
<p>  This flag indicates that the system will
attempt to handle and recover from an error associated with the access
handle. The driver should use the techniques described in
<a href="#defensive-programming-techniques-for-illumos-device-drivers">Defensive Programming Techniques for
illumos Device Drivers</a> and should use
ddi_fm_acc_err_get(9F) to regularly check for errors
before the driver allows data to be passed back to the calling
application.</p>
<div class="ulist">
<ul>
<li>
<p>Error notification via the driver callback</p>
</li>
<li>
<p>An error condition observable via
ddi_fm_acc_err_get(9F)</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">DDI_CAUTIOUS_ACC</dt>
<dd>
<p> The DDI_CAUTIOUS_ACC flag provides a high level
of protection for each Programmed I/O access made by the driver.
The DDI_CAUTIOUS_ACC flag signifies that an error is
anticipated by the accessing driver. The system attempts to handle and
recover from an error associated with this handle as gracefully as
possible. No error reports are generated as a result, but the handle&#8217;s
<code>fme_status</code> flag is set to DDI_FM_NONFATAL. This flag is
functionally equivalent to <code>ddi_peek(9F)</code> and <code>ddi_poke(9F)</code>.
The use of
the DDI_CAUTIOUS_ACC provides:
+</p>
<div class="ulist">
<ul>
<li>
<p>Exclusive access to the bus</p>
</li>
<li>
<p>On trap protection - (<code>ddi_peek</code> and <code>ddi_poke</code>)</p>
</li>
<li>
<p>Error notification through the driver callback registered with
ddi_fm_handler_register(9F)</p>
</li>
<li>
<p>An error condition observable through
ddi_fm_acc_err_get(9F)</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Use of this flag will cause a significant impact on the performance of the driver.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Generally, drivers should check for data path errors at appropriate
junctures in the code path to guarantee consistent data and to ensure
that proper error status is presented in the I/O software stack.</p>
</div>
<div class="paragraph">
<p>DDI_FM_ACCCHK_CAPABLE device drivers must set their
<code>devacc_attr_access</code> field to DDI_FLAGERR_ACC or
DDI_CAUTIOUS_ACC.</p>
</div>
</div>
<div class="sect4">
<h5 id="dma-attributes-structure"><a class="anchor" href="#dma-attributes-structure"></a>DMA Attributes Structure</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DMA errors</p>
</div>
<div class="paragraph">
<p>ddi_dma_attr</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_dma_attr</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DDI_DMA_FLAGERR</p>
</div>
<div class="paragraph">
<p>As with access handle setup, a DDI_FM_DMACHK_CAPABLE device
driver must set the <code>dma_attr_flag</code> field of its
<code>ddi_dma_attr(9S)</code> structure to the DDI_DMA_FLAGERR
flag. The system attempts to recover from an error associated with a
handle that has DDI_DMA_FLAGERR set. The <code>ddi_dma_attr</code>
structure contains the following members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint_t          dma_attr_version;       /* version number */
uint64_t        dma_attr_addr_lo;       /* low DMA address range */
uint64_t        dma_attr_addr_hi;       /* high DMA address range */
uint64_t        dma_attr_count_max;     /* DMA counter register */
uint64_t        dma_attr_align;         /* DMA address alignment */
uint_t          dma_attr_burstsizes;    /* DMA burstsizes */
uint32_t        dma_attr_minxfer;       /* min effective DMA size */
uint64_t        dma_attr_maxxfer;       /* max DMA xfer size */
uint64_t        dma_attr_seg;           /* segment boundary */
int             dma_attr_sgllen;        /* s/g length */
uint32_t        dma_attr_granular;      /* granularity of device */
uint_t          dma_attr_flags;         /* Bus specific DMA flags */</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  Drivers that set the
DDI++_++DMA++_++FLAGERR flag should use the techniques described in
link:#defensive-programming-techniques-for-illumos-device-drivers[Defensive Programming Techniques for illumos
Device Drivers] and should use ddi++_++fm++_++dma++_++err++_++get(9F) to
check for data path errors whenever DMA transactions are completed or at
significant points within the code path. This ensures consistent data
and proper error status presented to the I/O software stack.</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Error notification via the driver callback registered with
<code>ddi_fm_handler_register</code></p>
</li>
<li>
<p>An error condition observable by calling
<code>ddi_fm_dma_err_get</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="getting-error-status"><a class="anchor" href="#getting-error-status"></a>Getting Error Status</h5>
<div class="paragraph">
<p>If a fault has occurred that affects the resource mapped by the handle,
the error status structure is updated to reflect error information
captured during error handling by a bus or other device driver in the
I/O data path.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_dma_err_get(ddi_dma_handle_t handle, ddi_fm_error_t *de, int version)

void ddi_fm_acc_err_get(ddi_acc_handle_t handle, ddi_fm_error_t *de, int version)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ddi_fm_acc_err_get(9F) and
ddi_fm_dma_err_get(9F) functions return the error status
for a DMA or access handle respectively. The version field should be set
to DDI_FME_VERSION.</p>
</div>
<div class="paragraph">
<p>An error for an access handle means that
an error has been detected that has affected PIO transactions to or from
the device using that access handle. Any data received by the driver,
for example via a recent <code>ddi_get8(9F)</code> call, should be considered
potentially corrupt. Any data sent to the device, for example via a
recent <code>ddi_put32(9F)</code> call might also have been corrupted or might
not have been received at all. The underlying fault might, however, be
transient, and the driver can therefore attempt to recover by calling
ddi_fm_acc_err_clear(9F), resetting the device to get it
back into a known state, and retrying any potentially failed
transactions.</p>
</div>
<div class="paragraph">
<p>If an error is indicated for a DMA handle, it implies that an error has
been detected that has (or will) affect DMA transactions between the
device and the memory currently bound to the handle (or most recently
bound, if the handle is currently unbound). Possible causes include the
failure of a component in the DMA data path, or an attempt by the device
to make an invalid DMA access. The driver might be able to continue by
retrying and reallocating memory. The contents of the memory currently
(or previously) bound to the handle should be regarded as indeterminate
and should be released back to the system. The fault indication
associated with the current transaction is lost once the handle is bound
or re-bound, but because the fault might persist, future DMA operations
might not succeed.</p>
</div>
</div>
<div class="sect4">
<h5 id="clearing-errors"><a class="anchor" href="#clearing-errors"></a>Clearing Errors</h5>
<div class="paragraph">
<p>These routines should be called when the driver wants to retry a request
after an error was detected by the handle without needing to free and
reallocate the handle first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_acc_err_clear(ddi_acc_handle_t handle, int version)

void ddi_fm_dma_err_clear(ddi_dma_handle_t handle, int version)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="registering-an-error-handler"><a class="anchor" href="#registering-an-error-handler"></a>Registering an Error Handler</h5>
<div class="paragraph">
<p>Error handling activity might begin at the time that the error is
detected by the operating system via a trap or error interrupt. If the
software responsible for handling the error (the error handler) cannot
immediately isolate the device that was involved in the failed I/O
operation, it must attempt to find a software module within the device
tree that can perform the error isolation. The illumos device tree
provides a structural means to propagate nexus driver error handling
activities to children who might have a more detailed understanding of
the error and can capture error state and isolate the problem device.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    A driver can
register an error handler callback with the I/O Fault Services
Framework. The error handler should be specific to the type of error and
subsystem where error detection has occurred. When the driver's error
handler routine is invoked, the driver must check for any outstanding
errors associated with device transactions and generate ereport events.
The driver must also return error handler status in its
`ddi++_++fm++_++error` structure. For example, if it has been determined
that the system's integrity has been compromised, the most appropriate
action might be for the error handler to panic the system.</pre>
</div>
</div>
<div class="paragraph">
<p>The callback is invoked by a parent nexus driver when an error might be
associated with a particular device instance. Device drivers that
register error handlers must be DDI_FM_ERRCB_CAPABLE.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void ddi_fm_handler_register(dev_info_t *dip, ddi_err_func_t handler, void *impl_data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>ddi_fm_handler_register(9F) routine registers an error
handler callback with the I/O fault services framework. The
<code>ddi_fm_handler_register</code> function should be called in the
driver&#8217;s <code>attach(9E)</code> entry point for callback registration following
driver fault management initialization (<code>ddi_fm_init</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check for any outstanding hardware errors associated with device
transactions, and generate ereport events for diagnosis. For a PCI,
PCI-x, or PCI express device this can generally be done using
<code>pci_ereport_post</code> as described in <a href="#gemfk">Detecting and
Reporting PCI-Related Errors</a>.</p>
</li>
<li>
<p>Return error handler status in its
<code>ddi_fm_error</code> structure:</p>
<div class="ulist">
<ul>
<li>
<p>DDI_FM_OK</p>
</li>
<li>
<p>DDI_FM_FATAL</p>
</li>
<li>
<p>DDI_FM_NONFATAL</p>
</li>
<li>
<p>DDI_FM_UNKNOWN</p>
</li>
</ul>
</div>
</li>
<li>
<p>A pointer to a device instance (&lt;dip&gt;) under the driver&#8217;s
control</p>
</li>
<li>
<p>A data structure (<code>ddi_fm_error</code>) that contains common fault
management data and status for error handling</p>
</li>
<li>
<p>A pointer to any implementation specific data
(&lt;impl_data&gt;) specified at the time of the handler&#8217;s</p>
</li>
<li>
<p>Must not hold locks</p>
</li>
<li>
<p>Must not sleep waiting for resources</p>
</li>
<li>
<p>Isolating the device instance that might have caused errors</p>
</li>
<li>
<p>Recovering transactions associated with errors</p>
</li>
<li>
<p>Reporting the service impact of errors</p>
</li>
<li>
<p>Scheduling device shutdown for errors considered fatal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These actions can be carried out within the error handler function.
However, because of the restrictions on locking and because the error
handler function does not always know the context of what the driver was
doing at the point where the fault occurred, it is more usual for these
actions to be carried out following inline calls to
ddi_fm_acc_err_get(9F) and
ddi_fm_dma_err_get(9F) within the normal paths of the
driver as described previously.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*
 * The I/O fault service error handling callback function
 */
/*ARGSUSED*/
static int
bge_fm_error_cb(dev_info_t *dip, ddi_fm_error_t *err, const void *impl_data)
{
     /*
      * as the driver can always deal with an error
      * in any dma or access handle, we can just return
      * the fme_status value.
      */
     pci_ereport_post(dip, err, NULL);
     return (err-&gt;fme_status);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="fault-management-data-and-status-structure"><a class="anchor" href="#fault-management-data-and-status-structure"></a>Fault Management Data and Status Structure</h5>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ENA (Error Numeric Association)</p>
</div>
<div class="paragraph">
<p>ddi_fm_error</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>ddi_fm_error</p>
</div>
<div class="paragraph">
<p>Driver error handling callbacks are passed a pointer to a data structure
that contains common fault management data and status for error
handling.</p>
</div>
<div class="paragraph">
<p>The data structure <code>ddi_fm_error</code> contains an FMA protocol ENA
for the current error, the status of the error handler callback, an
error expectation flag, and any potential access or DMA handles
associated with an error detected by the parent nexus.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fme_ena</code></dt>
<dd>
<p>This field is initialized by the calling parent nexus and might have
been incremented along the error handling propagation chain before
reaching the driver&#8217;s registered callback routine. If the driver
detects a related error of its own, it should increment this ENA prior
to calling <code>ddi_fm_ereport_post</code>.</p>
</dd>
<dt class="hdlist1"><code>fme_acc_handle</code>, <code>fme_dma_handle</code></dt>
<dd>
<p>These fields contain a valid access or DMA handle if the parent was
able to associate an error detected at its level to a handle mapped or
bound by the device driver.</p>
</dd>
<dt class="hdlist1"><code>fme_flag</code></dt>
<dd>
<p>The <code>fme_flag</code> is set to DDI_FM_ERR_EXPECTED if the
calling parent determines the error was the result of a
DDI_CAUTIOUS_ACC protected operation. In this case, the
<code>fme_acc_handle</code> is valid and the driver should check for and
report only errors not associated with the DDI_CAUTIOUS_ACC
protected operation. Otherwise, <code>fme_flag</code> is set to
DDI_FM_ERR_UNEXPECTED and the driver must perform the full
range of error handling tasks.</p>
</dd>
<dt class="hdlist1"><code>fme_status</code></dt>
<dd>
<p>Upon return from its error handler callback, the driver must set
<code>fme_status</code> to one of the following values:
+</p>
<div class="ulist">
<ul>
<li>
<p>DDI_FM_OK – No errors were detected and the operational
state of this device instance remains the same.</p>
</li>
<li>
<p>DDI_FM_FATAL – An error has
occurred and the driver considers it to be fatal to the system. For
example, a call to pci_ereport_post(9F) might have detected a
system fatal error. In this case, the driver should report any
additional error information it might have in the context of the
driver.</p>
</li>
<li>
<p>DDI_FM_NONFATAL – An error has been detected by the driver
but is not considered fatal to the system. The driver has identified
the error and has either isolated the error or is committing that it
will isolate the error.</p>
</li>
<li>
<p>DDI_FM_UNKNOWN – An error has been detected, but the driver
is unable to isolate the device or determine the impact of the error
on the operational state of the system.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="diagnosing-faults"><a class="anchor" href="#diagnosing-faults"></a>2.57.4. Diagnosing Faults</h4>
<div class="paragraph">
<p>fault manager daemon</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>fault manager daemon</p>
</div>
<div class="paragraph">
<p>DE (diagnosis engine)</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DE (diagnosis engine)</p>
</div>
<div class="paragraph">
<p>Eversholt fault tree (eft) rules</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>Eversholt fault tree (eft) rules</p>
</div>
<div class="paragraph">
<p>eft diagnosis rules</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>eft diagnosis rules</p>
</div>
<div class="paragraph">
<p>The fault management daemon, <code>fmd(8)</code>, provides a programming interface
for the development of diagnosis engine (DE) plug-in modules. A DE can
be written to consume and diagnose any error telemetry or specific error
telemetries. The eft DE was designed to diagnose any number of ereport
classes based on diagnosis rules specified in the Eversholt language.</p>
</div>
<div class="sect4">
<h5 id="standard-leaf-device-diagnosis"><a class="anchor" href="#standard-leaf-device-diagnosis"></a>Standard Leaf Device Diagnosis</h5>
<div class="paragraph">
<p>Most I/O subsystems use the eft DE and rules sets to diagnose device and
device driver related problems. A standard set of ereports, listed in
<a href="#gemha">Reporting Standard I/O Controller Errors</a>, has been
specified for PCI leaf devices. Accompanying these ereports are eft
diagnosis rules that take the telemetry and identify the associated
device fault. Drivers that generate these ereports do not need to
deliver any additional diagnosis software or eft rules.</p>
</div>
<div class="paragraph">
<p>The detection and generation of these ereports produces the following
fault events:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fault.io.pci.bus-linkerr</code></dt>
<dd>
<p>A hardware fault on the PCI bus</p>
</dd>
<dt class="hdlist1"><code>fault.io.pci.device-interr</code></dt>
<dd>
<p>A hardware fault within the device</p>
</dd>
<dt class="hdlist1"><code>fault.io.pci.device-invreq</code></dt>
<dd>
<p>A hardware fault in the device or a defect in the driver that causes
the device to send an invalid request</p>
</dd>
<dt class="hdlist1"><code>fault.io.pci.device-noresp</code></dt>
<dd>
<p>A hardware fault in the device that causes the driver not to respond
to a valid request</p>
</dd>
<dt class="hdlist1"><code>fault.io.pciex.bus-linkerr</code></dt>
<dd>
<p>A hardware fault on the link</p>
</dd>
<dt class="hdlist1"><code>fault.io.pciex.bus-noresp</code></dt>
<dd>
<p>The link going down so that a device cannot respond to a valid request</p>
</dd>
<dt class="hdlist1"><code>fault.io.pciex.device-interr</code></dt>
<dd>
<p>A hardware fault within the device</p>
</dd>
<dt class="hdlist1"><code>fault.io.pciex.device-invreq</code></dt>
<dd>
<p>A hardware fault in the device or a defect in the driver that causes
the device to send an invalid request</p>
</dd>
<dt class="hdlist1"><code>fault.io.pciex.device-noresp</code></dt>
<dd>
<p>A hardware fault in the device causing it not to respond to a valid</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="specialized-device-diagnosis"><a class="anchor" href="#specialized-device-diagnosis"></a>Specialized Device Diagnosis</h5>
<div class="paragraph">
<p>Driver developers who want to generate additional ereports or provide
more specialized diagnosis software or eft rules can do so by writing a
C-based DE or an eft diagnosis rules set. See the
<a href="http://www.opensolaris.org/os/community/fm/">Fault Management community</a>
on <a href="http://www.opensolaris.org/os/">OpenSolaris</a> for information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="event-registry"><a class="anchor" href="#event-registry"></a>2.57.5. Event Registry</h4>
<div class="paragraph">
<p>event registry</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>event registry</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>DE (diagnosis engine)</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>eft diagnosis rules</p>
</div>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>suspect list</p>
</div>
<div class="paragraph">
<p>The illumos event registry is the central repository of all class names,
ereports, faults, defects, upsets and suspect lists (list.suspect)
events. The event registry also contains the current definitions of all
event member payloads, as well as important non-payload information like
internal documentation, suspect lists, dictionaries, and knowledge
articles. For example, <code>ereport.io</code> and <code>fault.io</code> are two of the base
class names that are of particular importance to I/O driver developers.</p>
</div>
<div class="paragraph">
<p>The FMA event protocol defines a base set of payload members that is
supplied with each of the registered events. Developers can also define
additional events that help diagnosis engines (or eft rules) to narrow a
suspect list down to a specific fault.</p>
</div>
</div>
<div class="sect3">
<h4 id="glossary"><a class="anchor" href="#glossary"></a>2.57.6. Glossary</h4>
<div class="paragraph">
<p>This section uses the following terms:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Agent</dt>
<dd>
<p>A generic term used to describe fault manager modules that subscribe
to fault.* or list.* events. Agents are used to retire faulty
resources, communicate diagnosis results to Administrators, and bridge
to higher-level management frameworks.</p>
</dd>
<dt class="hdlist1">ASRU (Automated System Reconfiguration Unit)</dt>
<dd>
<p>The ASRU is a resource that can be disabled by software or hardware in
order to isolate a problem in the system and suppress further error
reports.</p>
</dd>
<dt class="hdlist1">DE (Diagnosis Engine)</dt>
<dd>
<p>A fault management module whose purpose is to diagnose problems by
subscribing to one or more classes of incoming error events and using
these events to solve cases associated with each problem on the
system.</p>
</dd>
<dt class="hdlist1">ENA (Error Numeric Association)</dt>
<dd>
<p>An Error Numeric Association (ENA) is an encoded integer that uniquely
identifies an error report within a given fault region and time
period. The ENA also indicates the relationship of the error to
previous errors as a secondary effect.</p>
</dd>
<dt class="hdlist1">Error</dt>
<dd>
<p>An unexpected condition, result, signal, or datum. An error is the
symptom of a problem on the system. Each problem typically produces
many different kinds of errors.</p>
</dd>
<dt class="hdlist1">ereport (Error Report)</dt>
<dd>
<p>The data captured with a particular error. Error report formats are
defined in advance by creating a class naming the error report and
defining a schema using the illumos event registry.</p>
</dd>
<dt class="hdlist1">ereport event (Error Event)</dt>
<dd>
<p>The data structure that represents an instance of an error report.
Error events are represented as name-value pair lists.</p>
</dd>
<dt class="hdlist1">Fault</dt>
<dd>
<p>Malfunctioning behavior of a hardware component.</p>
</dd>
<dt class="hdlist1">Fault Boundary</dt>
<dd>
<p>Logical partition of hardware or software elements for which a
specific set of faults can be enumerated.</p>
</dd>
<dt class="hdlist1">Fault Event</dt>
<dd>
<p>An instance of a fault diagnosis encoded in the protocol.</p>
</dd>
<dt class="hdlist1">Fault Manager</dt>
<dd>
<p>Software component responsible for fault diagnosis via one or more
diagnosis engines and state management.</p>
</dd>
<dt class="hdlist1">FMRI (Fault Managed Resource Identifier)</dt>
<dd>
<p>An FMRI is a URL-like identifier that acts as the canonical name for a
particular resource in the fault management system. Each FMRI includes
a scheme that identifies the type of resource, and one or more values
that are specific to the scheme. An FMRI can be represented as
URL-like string or as a name-value pair list data structure.</p>
</dd>
<dt class="hdlist1">FRU (Field Replaceable Unit)</dt>
<dd>
<p>The FRU is a resource that can be replaced in the field by a customer
or service provider. FRUs can be defined for hardware (for example
system boards) or for software (for example software packages or
patches).</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="resources"><a class="anchor" href="#resources"></a>2.57.7. Resources</h4>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.opensolaris.org/os/community/fm/">Fault Management
OpenSolaris community</a></p>
</li>
<li>
<p><a href="http://www.illumos.org/msg/">FMA Messaging web site</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defensive-programming-techniques-for-illumos-device-drivers"><a class="anchor" href="#defensive-programming-techniques-for-illumos-device-drivers"></a>2.58. Defensive Programming Techniques for illumos Device Drivers</h3>
<div class="paragraph">
<p>This section offers techniques for device drivers to avoid system panics
and hangs, wasting system resources, and spreading data corruption. A
driver is considered hardened when it uses these defensive programming
practices in addition to the I/O fault services framework for error
handling and diagnosis.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each piece of hardware should be controlled by a separate instance of
the device driver. See <a href="#device-configuration-concepts">Device Configuration
Concepts</a>.</p>
</li>
<li>
<p>Programmed I/O (PIO) must be performed <em>only</em> through the DDI access
functions, using the appropriate data access handle. See
<a href="#device-access-programmed-io">Device Access: Programmed I/O</a>.</p>
</li>
<li>
<p>The device driver must assume that data that is received from the
device might be corrupted. The driver must check the integrity of the
data before the data is used.</p>
</li>
<li>
<p>The driver must avoid releasing bad data to the rest of the system.</p>
</li>
<li>
<p>Use only documented DDI functions and interfaces in your driver.</p>
</li>
<li>
<p>The driver must ensure that the device writes only into pages of
memory in the DMA buffers (<code>DDI_DMA_READ</code>) that are controlled
entirely by the driver. This technique prevents a DMA fault from
corrupting an arbitrary part of the system&#8217;s main memory.</p>
</li>
<li>
<p>The device driver must not be an unlimited drain on system resources
if the device locks up. The driver should time out if a device claims to
be continuously busy. The driver should also detect a pathological
(stuck) interrupt request and take appropriate action.</p>
</li>
<li>
<p>The device driver must support hotplugging in illumos.</p>
</li>
<li>
<p>The device driver must use callbacks instead of waiting on resources.</p>
</li>
<li>
<p>The driver must free up resources after a fault. For example, the
system must be able to close all minor devices and detach driver
instances even after the hardware fails.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="using-separate-device-driver-instances"><a class="anchor" href="#using-separate-device-driver-instances"></a>2.58.1. Using Separate Device Driver Instances</h4>
<div class="paragraph">
<p>driver instances</p>
</div>
<div class="paragraph">
<p>The illumos kernel allows multiple instances of a driver. Each instance
has its own data space but shares the text and some global data with
other instances. The device is managed on a per-instance basis. Drivers
should use a separate instance for each piece of hardware unless the
driver is designed to handle any failover internally. Multiple instances
of a driver per slot can occur, for example, with multifunction cards.</p>
</div>
</div>
<div class="sect3">
<h4 id="exclusive-use-of-ddi-access-handles"><a class="anchor" href="#exclusive-use-of-ddi-access-handles"></a>2.58.2. Exclusive Use of DDI Access Handles</h4>
<div class="paragraph">
<p>access handles</p>
</div>
<div class="paragraph">
<p>programmed I/O</p>
</div>
<div class="paragraph">
<p>use with DDI access routines</p>
</div>
<div class="paragraph">
<p>ddi_get</p>
</div>
<div class="paragraph">
<p>ddi_put</p>
</div>
<div class="paragraph">
<p>ddi_rep_get</p>
</div>
<div class="paragraph">
<p>ddi_rep_put</p>
</div>
<div class="paragraph">
<p>All PIO access by a driver must use illumos DDI access functions from
the following families of routines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ddi_get</code>&lt;X&gt;</p>
</li>
<li>
<p><code>ddi_put</code>&lt;X&gt;</p>
</li>
<li>
<p><code>ddi_rep_get</code>&lt;X&gt;</p>
</li>
<li>
<p><code>ddi_rep_put</code>&lt;X&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The driver should not directly access the mapped
registers by the address that is returned from
<code>ddi_regs_map_setup(9F)</code>. Avoid the <code>ddi_peek(9F)</code> and
<code>ddi_poke(9F)</code> routines because these routines do not use access
handles.</p>
</div>
<div class="paragraph">
<p>The DDI access mechanism is important because DDI access provides an
opportunity to control how data is read into the kernel.</p>
</div>
</div>
<div class="sect3">
<h4 id="_detecting_corrupted_data"><a class="anchor" href="#_detecting_corrupted_data"></a>2.58.3. Detecting Corrupted Data</h4>
<div class="paragraph">
<p>data corruption</p>
</div>
<div class="paragraph">
<p>The following sections describe where data corruption can occur and how
to detect corruption.</p>
</div>
<div class="sect4">
<h5 id="corruption-of-device-management-and-control-data"><a class="anchor" href="#corruption-of-device-management-and-control-data"></a>Corruption of Device Management and Control Data</h5>
<div class="paragraph">
<p>data corruption</p>
</div>
<div class="paragraph">
<p>device management data</p>
</div>
<div class="paragraph">
<p>data corruption</p>
</div>
<div class="paragraph">
<p>control data</p>
</div>
<div class="paragraph">
<p>The driver should assume that any data obtained from the
device, whether by PIO or DMA, could have been corrupted. In particular,
extreme care should be taken with pointers, memory offsets, and array
indexes that are based on data from the device. Such values can be
<em>malignant</em>, in that these values can cause a kernel panic if
dereferenced. All such values should be checked for range and alignment
(if required) before use.</p>
</div>
<div class="paragraph">
<p>Even a pointer that is not malignant can still be
misleading. For example, a pointer can point to a valid but not correct
instance of an object. Where possible, the driver should cross-check the
pointer with the object to which it is pointing, or otherwise validate
the data obtained through that pointer.</p>
</div>
<div class="paragraph">
<p>Other types of data can also be misleading, such as packet lengths,
status words, or channel IDs. These data types should be checked to the
extent possible. A packet length can be range-checked to ensure that the
length is neither negative nor larger than the containing buffer. A
status word can be checked for “impossible” bits. A channel ID can be
matched against a list of valid IDs.</p>
</div>
<div class="paragraph">
<p>Where a value is used to identify a stream, the driver must ensure that
the stream still exists. The asynchronous nature of processing STREAMS
means that a stream can be dismantled while device interrupts are still
outstanding.</p>
</div>
<div class="paragraph">
<p>The driver should not reread data from the device. The data should be
read once, validated, and stored in the driver&#8217;s local state. This
technique avoids the hazard of data that is correct when initially read,
but is incorrect when reread later.</p>
</div>
<div class="paragraph">
<p>The driver should also ensure that all loops are bounded. For example, a
device that returns a continuous <code>BUSY</code> status should not be able to
lock up the entire system.</p>
</div>
</div>
<div class="sect4">
<h5 id="corruption-of-received-data"><a class="anchor" href="#corruption-of-received-data"></a>Corruption of Received Data</h5>
<div class="paragraph">
<p>data corruption</p>
</div>
<div class="paragraph">
<p>of received data</p>
</div>
<div class="paragraph">
<p>Device errors can result in corrupted data being placed in receive
buffers. Such corruption is indistinguishable from corruption that
occurs beyond the domain of the device, for example, within a network.
Typically, existing software is already in place to handle such
corruption. One example is the integrity checks at the transport layer
of a protocol stack. Another example is integrity checks within the
application that uses the device.</p>
</div>
<div class="paragraph">
<p>If the received data is not to be checked for integrity at a higher
layer, the data can be integrity-checked within the driver itself.
Methods of detecting corruption in received data are typically
device-specific. Checksums and CRC are examples of the kinds of checks
that can be done.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dma_isolation"><a class="anchor" href="#_dma_isolation"></a>2.58.4. DMA Isolation</h4>
<div class="paragraph">
<p>A defective device might initiate an improper DMA transfer over the bus.
This data transfer could corrupt good data that was previously
delivered. A device that fails might generate a corrupt address that can
contaminate memory that does not even belong to its own driver.</p>
</div>
<div class="paragraph">
<p>In systems with an IOMMU, a device can write only to pages mapped as
writable for DMA. Therefore, such pages should be owned solely by one
driver instance. These pages should not be shared with any other kernel
structure. While the page in question is mapped as writable for DMA, the
driver should be suspicious of data in that page. The page must be
unmapped from the IOMMU before the page is passed beyond the driver, and
before any validation of the data.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   You can use
`ddi++_++umem++_++alloc(9F)` to guarantee that a whole aligned page is
allocated, or allocate multiple pages and ignore the memory below the
first page boundary. You can find the size of an IOMMU page by using
`ddi++_++ptob(9F)`.</pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the driver can choose to copy the data into a safe part
of memory before processing it. If this is done, the data must first be
synchronized using <code>ddi_dma_sync(9F)</code>.</p>
</div>
<div class="paragraph">
<p>Calls to <code>ddi_dma_sync</code> should specify <code>SYNC_FOR_DEV</code>
before using DMA to transfer data to a device, and
<code>SYNC_FOR_CPU</code> after using DMA to transfer data from the device
to memory.</p>
</div>
<div class="paragraph">
<p>On some PCI-based systems with an IOMMU,
devices can use PCI dual address cycles (64-bit addresses) to bypass the
IOMMU. This capability gives the device the potential to corrupt any
region of main memory. Device drivers must not attempt to use such a
mode and should disable it.</p>
</div>
</div>
<div class="sect3">
<h4 id="handling-stuck-interrupts"><a class="anchor" href="#handling-stuck-interrupts"></a>2.58.5. Handling Stuck Interrupts</h4>
<div class="paragraph">
<p>The driver must identify stuck interrupts because a persistently
asserted interrupt severely affects system performance, almost certainly
stalling a single-processor machine.</p>
</div>
<div class="paragraph">
<p>Sometimes the driver might have difficulty identifying a particular
interrupt as invalid. For network drivers, if a receive interrupt is
indicated but no new buffers have been made available, no work was
needed. When this situation is an isolated occurrence, it is not a
problem, since the actual work might already have been completed by
another routine such as a read service.</p>
</div>
<div class="paragraph">
<p>On the other hand, continuous interrupts with no work for the driver to
process can indicate a stuck interrupt line. For this reason, platforms
allow a number of apparently invalid interrupts to occur before taking
defensive action.</p>
</div>
<div class="paragraph">
<p>While appearing to have work to do, a hung device might be failing to
update its buffer descriptors. The driver should defend against such
repetitive requests.</p>
</div>
<div class="paragraph">
<p>In some cases, platform-specific bus drivers might be capable of
identifying a persistently unclaimed interrupt and can disable the
offending device. However, this relies on the driver&#8217;s ability to
identify the valid interrupts and return the appropriate value. The
driver should return a <code>DDI_INTR_UNCLAIMED</code> result unless the
driver detects that the device legitimately asserted an interrupt. The
interrupt is legitimate only if the device actually requires the driver
to do some useful work.</p>
</div>
<div class="paragraph">
<p>The legitimacy of other, more incidental, interrupts is much harder to
certify. An interrupt-expected flag is a useful tool for evaluating
whether an interrupt is valid. Consider an interrupt such as <em>descriptor
free</em>, which can be generated if all the device&#8217;s descriptors had been
previously allocated. If the driver detects that it has taken the last
descriptor from the card, it can set an interrupt-expected flag. If this
flag is not set when the associated interrupt is delivered, the
interrupt is suspicious.</p>
</div>
<div class="paragraph">
<p>Some informative interrupts might not be predictable, such as one that
indicates that a medium has become disconnected or frame sync has been
lost. The easiest method of detecting whether such an interrupt is stuck
is to mask this particular source on first occurrence until the next
polling cycle.</p>
</div>
<div class="paragraph">
<p>If the interrupt occurs again while disabled, the interrupt should be
considered false. Some devices have interrupt status bits that can be
read even if the mask register has disabled the associated source and
might not be causing the interrupt. You can devise a more appropriate
algorithm specific to your devices.</p>
</div>
<div class="paragraph">
<p>Avoid looping on interrupt status bits indefinitely. Break such loops if
none of the status bits set at the start of a pass requires any real
work.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-programming-considerations"><a class="anchor" href="#additional-programming-considerations"></a>2.58.6. Additional Programming Considerations</h4>
<div class="ulist">
<ul>
<li>
<p>Thread interaction</p>
</li>
<li>
<p>Threats from top-down requests</p>
</li>
<li>
<p>Adaptive strategies</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_thread_interaction"><a class="anchor" href="#_thread_interaction"></a>Thread Interaction</h5>
<div class="paragraph">
<p>Kernel panics in a device driver
are often caused by unexpected interaction of kernel threads after a
device failure. When a device fails, threads can interact in ways that
you did not anticipate.</p>
</div>
<div class="paragraph">
<p>If processing routines terminate early, the condition variable waiters
are blocked because an expected signal is never given. Attempting to
inform other modules of the failure or handling unanticipated callbacks
can result in undesirable thread interactions. Consider the sequence of
mutex acquisition and relinquishing that can occur during device
failures.</p>
</div>
<div class="paragraph">
<p>that originate in an upstream STREAMS module can become involved in
unfortunate paradoxes if those threads are used to return to that module
unexpectedly. Consider using alternative threads to handle exception
messages. For instance, a procedure might use a read-side service
routine to communicate an <code>M_ERROR</code>, rather than handling the error
directly with a read-side <code>putnext(9F)</code>.</p>
</div>
<div class="paragraph">
<p>A failing STREAMS device that
cannot be quiesced during close because of a fault can generate an
interrupt after the stream has been dismantled. The interrupt handler
must not attempt to use a stale stream pointer to try to process the
message.</p>
</div>
</div>
<div class="sect4">
<h5 id="threats-from-top-down-requests"><a class="anchor" href="#threats-from-top-down-requests"></a>Threats From Top-Down Requests</h5>
<div class="paragraph">
<p>requests from user applications</p>
</div>
<div class="paragraph">
<p>user applications</p>
</div>
<div class="paragraph">
<p>requests from</p>
</div>
<div class="paragraph">
<p>While protecting the system from defective hardware, you also need to
protect against driver misuse. Although the driver can assume that the
kernel infrastructure is always correct (a trusted core), user requests
passed to it can be potentially destructive.</p>
</div>
<div class="paragraph">
<p>For example, a user can request an action to be performed upon a
user-supplied data block (<code>M_IOCTL</code>) that is smaller than the block
size that is indicated in the control part of the message. The driver
should never trust a user application.</p>
</div>
<div class="paragraph">
<p>Consider the construction of each type of <code>ioctl</code> that your driver can
receive and the potential harm that the <code>ioctl</code> could cause. The driver
should perform checks to ensure that it does not process a malformed
<code>ioctl</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_adaptive_strategies"><a class="anchor" href="#_adaptive_strategies"></a>Adaptive Strategies</h5>
<div class="paragraph">
<p>A driver can continue to provide service using faulty hardware. The
driver can attempt to work around the identified problem by using an
alternative strategy for accessing the device. Given that broken
hardware is unpredictable and given the risk associated with additional
design complexity, adaptive strategies are not always wise. At most,
these strategies should be limited to periodic interrupt polling and
retry attempts. Periodically retrying the device tells the driver when a
device has recovered. Periodic polling can control the interrupt
mechanism after a driver has been forced to disable interrupts.</p>
</div>
<div class="paragraph">
<p>Ideally, a system always has an alternative device to provide a vital
system service. Service multiplexors in kernel or user space offer the
best method of maintaining system services when a device fails. Such
practices are beyond the scope of this section.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="driver-hardening-test-harness"><a class="anchor" href="#driver-hardening-test-harness"></a>2.59. Driver Hardening Test Harness</h3>
<div class="paragraph">
<p>driver hardening test harness</p>
</div>
<div class="paragraph">
<p>injecting hardware faults</p>
</div>
<div class="paragraph">
<p>hardware faults</p>
</div>
<div class="paragraph">
<p>The driver hardening test harness tests that the I/O fault services and
defensive programming requirements have been correctly fulfilled.
Hardened device drivers are resilient to potential hardware faults. You
must test the resilience of device drivers as part of the driver
development process. This type of testing requires that the driver
handle a wide range of typical hardware faults in a controlled and
repeatable way. The driver hardening test harness enables you to
simulate such hardware faults in software.</p>
</div>
<div class="paragraph">
<p>The driver hardening test harness is an illumos device
driver development tool. The test harness injects a wide range of
simulated hardware faults when the driver under development accesses its
hardware. This section describes how to configure the test harness,
create error-injection specifications (referred to as <em>errdefs</em>), and
execute the tests on your device driver.</p>
</div>
<div class="paragraph">
<p>The test harness intercepts calls from the driver to various DDI
routines, then corrupts the result of the calls as if the hardware had
caused the corruption. In addition, the harness allows for corruption of
accesses to specific registers as well as definition of more random
types of corruption.</p>
</div>
<div class="paragraph">
<p>The test harness can generate test scripts automatically by tracing all
register accesses as well as direct memory access (DMA) and interrupt
usage during the running of a specified workload. A script is generated
that reruns that workload while injecting a set of faults into each
access.</p>
</div>
<div class="paragraph">
<p>The driver tester should remove duplicate test cases from the generated
scripts.</p>
</div>
<div class="paragraph">
<p>The test harness is
implemented as a device driver called <code>bofi</code>, which stands for
bus_ops fault injection, and two user-level utilities,
<code>th_define(8)</code> and <code>th_manage(8)</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Validates compliant use of illumos DDI services</p>
</li>
<li>
<p>Facilitates controlled corruption of programmed I/O (PIO) and DMA
requests and interference with interrupts, thus simulating faults that
occur in the hardware managed by the driver</p>
</li>
<li>
<p>Facilitates simulation of failures in the data path between the CPU
and the device, which are reported from parent nexus drivers</p>
</li>
<li>
<p>Monitors a driver&#8217;s access during a specified workload and generates
fault-injection scripts</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_fault_injection"><a class="anchor" href="#_fault_injection"></a>2.59.1. Fault Injection</h4>
<div class="paragraph">
<p>fault injection</p>
</div>
<div class="paragraph">
<p>The driver hardening test harness intercepts and, when requested,
corrupts each access a driver makes to its hardware. This section
provides information you should understand to create faults to test the
resilience of your driver.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  illumos devices are managed inside a
tree-like structure called the device tree (devinfo tree). Each node of
the devinfo tree stores information that relates to a particular
instance of a device in the system. Each leaf node corresponds to a
device driver, while all other nodes are called _nexus nodes_.
Typically, a nexus represents a bus. A bus node isolates leaf drivers
from bus dependencies, which enables architecturally independent drivers
to be produced.</pre>
</div>
</div>
<div class="paragraph">
<p>Many of the DDI functions, particularly the data access functions,
result in upcalls to the bus nexus drivers. When a leaf driver accesses
its hardware, it passes a handle to an access routine. The bus nexus
understands how to manipulate the handle and fulfill the request. A
DDI-compliant driver only accesses hardware through use of these DDI
access routines. The test harness intercepts these upcalls before they
reach the specified bus nexus. If the data access matches the criteria
specified by the driver tester, the access is corrupted. If the data
access does not match the criteria, it is given to the bus nexus to
handle in the usual way.</p>
</div>
<div class="paragraph">
<p>A driver obtains an access handle by using the
<code>ddi_regs_map_setup(9F)</code> function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ddi_regs_map_setup(dip, rset, ma, offset, size, handle)</pre>
</div>
</div>
<div class="paragraph">
<p>The arguments specify which “offboard” memory is to be mapped. The
driver must use the returned handle when it references the mapped I/O
addresses, since handles are meant to isolate drivers from the details
of bus hierarchies. Therefore, do not directly use the returned mapped
address, &lt;ma&gt;. Direct use of the mapped address destroys the
current and future uses of the data access function mechanism.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I/O to Host:</p>
<div class="literalblock">
<div class="content">
<pre>ddi_getX(handle, ma)
ddi_rep_getX(handle, buf, ma, repcnt, flag)</pre>
</div>
</div>
</li>
<li>
<p>Host to I/O:</p>
<div class="literalblock">
<div class="content">
<pre>ddi_putX(handle, ma, value)</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;X&gt; and &lt;repcnt&gt; are the number of bytes to be
transferred. &lt;X&gt; is the bus transfer size of 8, 16, 32, or 64
bytes.</p>
</div>
<div class="paragraph">
<p>DMA has a similar, yet richer, set of data access functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="setting-up-the-test-harness"><a class="anchor" href="#setting-up-the-test-harness"></a>2.59.2. Setting Up the Test Harness</h4>
<div class="paragraph">
<p>The driver hardening test harness is part of the Solaris Developer
Cluster. If you have not installed this Solaris cluster, you must
manually install the test harness packages appropriate for your
platform.</p>
</div>
<div class="sect4">
<h5 id="installing-the-test-harness"><a class="anchor" href="#installing-the-test-harness"></a>Installing the Test Harness</h5>
<div class="paragraph">
<p>To install the test harness packages (SUNWftduu and SUNWftdur), use the
<code>pkgadd(8)</code> command.</p>
</div>
<div class="paragraph">
<p>As superuser, go to the directory in which the packages are located and
type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># pkgadd -d . SUNWftduu SUNWftdur</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-the-test-harness"><a class="anchor" href="#configuring-the-test-harness"></a>Configuring the Test Harness</h5>
<div class="paragraph">
<p>bofi.conf</p>
</div>
<div class="paragraph">
<p>After the test harness is installed, set the properties in the
<code>/kernel/drv/bofi.conf</code> file to configure the harness to interact with
your driver. When the harness configuration is complete, reboot the
system to load the harness driver.</p>
</div>
<div class="paragraph">
<p>The test harness behavior is controlled by boot-time properties that are
set in the <code>/kernel/drv/bofi.conf</code> configuration file.</p>
</div>
<div class="paragraph">
<p>When the harness is first installed, enable the harness to intercept the
DDI accesses to your driver by setting these properties:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">bofi-nexus</dt>
<dd>
<p>Bus nexus type, such as the PCI bus</p>
</dd>
<dt class="hdlist1">bofi-to-test</dt>
<dd>
<p>Name of the driver under test</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, to test a PCI bus network driver called <code>xyznetdrv</code>, set
the following property values:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>bofi-nexus="pci"
bofi-to-test="xyznetdrv"</pre>
</div>
</div>
<div class="paragraph">
<p>Other properties relate to the use and harness checking of the illumos
DDI data access mechanisms for reading and writing from peripherals that
use PIO and transferring data to and from peripherals that use DMA.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">bofi-range-check</dt>
<dd>
<p>When this property is set, the test harness checks the consistency of
the arguments that are passed to PIO data access functions.</p>
</dd>
<dt class="hdlist1">bofi-ddi-check</dt>
<dd>
<p>When this property is set, the test harness verifies
that the mapped address that is returned by
ddi_map_regs_setup(9F) is not used outside of the context
of the data access functions.</p>
</dd>
<dt class="hdlist1">bofi-sync-check</dt>
<dd>
<p>When this property is set, the test harness verifies
correct usage of DMA functions and ensures that the driver makes
compliant use of <code>ddi_dma_sync(9F)</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testing-the-driver"><a class="anchor" href="#testing-the-driver"></a>2.59.3. Testing the Driver</h4>
<div class="paragraph">
<p>injecting hardware faults</p>
</div>
<div class="paragraph">
<p>hardware faults</p>
</div>
<div class="paragraph">
<p>th_define</p>
</div>
<div class="paragraph">
<p>th_manage</p>
</div>
<div class="paragraph">
<p>This section describes how to create and inject faults by using the
<code>th_define(8)</code> and <code>th_manage(8)</code> commands.</p>
</div>
<div class="sect4">
<h5 id="creating-faults"><a class="anchor" href="#creating-faults"></a>Creating Faults</h5>
<div class="paragraph">
<p>The <code>th_define</code> utility provides an interface to the <code>bofi</code> device
driver for defining errdefs. An <em>errdef</em> corresponds to a specification
for how to corrupt a device driver&#8217;s accesses to its hardware. The
<code>th_define</code> command-line arguments determine the precise nature of
the fault to be injected. If the supplied arguments define a consistent
errdef, the <code>th_define</code> process stores the errdef with the <code>bofi</code>
driver. The process suspends itself until the criteria given by the
errdef becomes satisfied. In practice, the suspension ends when the
access counts go to zero (0).</p>
</div>
</div>
<div class="sect4">
<h5 id="injecting-faults"><a class="anchor" href="#injecting-faults"></a>Injecting Faults</h5>
<div class="paragraph">
<p>fault injection</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type of hardware being accessed (driver name)</p>
</li>
<li>
<p>Instance of the hardware being accessed (driver instance)</p>
</li>
<li>
<p>Register set being tested</p>
</li>
<li>
<p>Subset of the register set that is targeted</p>
</li>
<li>
<p>Direction of the transfer (read or write)</p>
</li>
<li>
<p>Type of access (PIO or DMA)</p>
</li>
<li>
<p>The driver instance and register set being tested (<code>n</code> &lt;name&gt;,
<code>i</code> &lt;instance&gt;, and <code>r</code> &lt;reg_number&gt;).</p>
</li>
<li>
<p>The subset of the register set eligible for corruption. This subset is
indicated by providing an offset into the register set and a length from
that offset (<code>l</code> &lt;offset&gt; <code>[</code>&lt;len&gt;<code>]</code>).</p>
</li>
<li>
<p>The kind of access to be intercepted: <code>log</code>, <code>pio</code>, <code>dma</code>,
<code>pio_r</code>, <code>pio_w</code>, <code>dma_r</code>, <code>dma_w</code>, <code>intr</code> (<code>a</code>
&lt;acc_types&gt;).</p>
</li>
<li>
<p>How many accesses should be faulted (<code>c</code> &lt;count&gt;
<code>[</code>&lt;failcount&gt;<code>]</code>).</p>
</li>
<li>
<p>The kind of corruption that should be applied to a qualifying access
(<code>o</code> &lt;operator&gt; <code>[</code>&lt;operand&gt;<code>]</code>).</p>
<div class="ulist">
<ul>
<li>
<p>Replace datum with a fixed value (EQUAL)</p>
</li>
<li>
<p>Perform a bitwise operation on the datum (AND, OR, XOR)</p>
</li>
<li>
<p>Ignore the transfer (for host to I/O accesses NO_TRANSFER)</p>
</li>
<li>
<p>Lose, delay, or inject spurious interrupts (LOSE, DELAY, EXTRA)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the <code>a</code> &lt;acc_chk&gt; option to simulate framework faults in
an errdef.</p>
</div>
</div>
<div class="sect4">
<h5 id="fault-injection-process"><a class="anchor" href="#fault-injection-process"></a>Fault-Injection Process</h5>
<div class="paragraph">
<p>th_define</p>
</div>
<div class="paragraph">
<p>th_manage</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>th_define(8)</code> command to create errdefs.</p>
<div class="paragraph">
<p>Create errdefs by passing test definitions to the <code>bofi</code> driver, which
stores the definitions so they can be accessed by using the
<code>th_manage(8)</code> command.</p>
</div>
</li>
<li>
<p>Create a workload, then use the <code>th_manage</code> command to activate
and manage the errdef.</p>
<div class="paragraph">
<p>The <code>th_manage</code> command is a user interface to the various ioctls
that are recognized by the <code>bofi</code> harness driver. The <code>th_manage</code>
command operates at the level of driver names and instances and includes
these commands: <code>get_handles</code> to list access handles, <code>start</code> to
activate errdefs, and <code>stop</code> to deactivate errdefs.</p>
</div>
<div class="paragraph">
<p>The activation of an errdef results in qualifying data accesses to be
faulted. The <code>th_manage</code> utility supports these commands:
<code>broadcast</code> to provide the current state of the errdef and
<code>clear_errors</code> to clear the errdef.</p>
</div>
<div class="paragraph">
<p>See the <code>th_define</code>(1M) and <code>th_manage</code>(1M) man pages for more
information.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="test-harness-warnings"><a class="anchor" href="#test-harness-warnings"></a>Test Harness Warnings</h5>
<div class="ulist">
<ul>
<li>
<p>Write warning messages to the console</p>
</li>
<li>
<p>Write warning messages to the console and then panic the system</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the second method to help pinpoint the root cause of a problem.</p>
</div>
<div class="paragraph">
<p>When the bofi-range-check property value is set to <code>warn</code>, the harness
prints the following messages (or panics if set to panic) when it
detects a range violation of a DDI function by your driver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ddi_getX() out of range addr %x not in %x
ddi_putX() out of range addr %x not in %x
ddi_rep_getX() out of range addr %x not in %x
ddi_rep_putX() out of range addr %x not in %x</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;X&gt; is 8, 16, 32, or 64.</p>
</div>
<div class="paragraph">
<p>When the harness has been requested to insert over 1000 extra
interrupts, the following message is printed if the driver does not
detect interrupt jabber:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>undetected interrupt jabber - %s %d</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-scripts-to-automate-the-test-process"><a class="anchor" href="#using-scripts-to-automate-the-test-process"></a>2.59.4. Using Scripts to Automate the Test Process</h4>
<div class="paragraph">
<p>th_define</p>
</div>
<div class="paragraph">
<p>You can create fault-injection test scripts by using the logging access
type of the <code>th_define(8)</code> utility:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># th_define -n name -i instance -a log [-e fixup_script]</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>th_define</code> command takes the instance offline and brings it
back online. Then <code>th_define</code> runs the workload that is described by
the &lt;fixup_script&gt; and logs I/O accesses that are made by
the driver instance.</p>
</div>
<div class="paragraph">
<p>The &lt;fixup_script&gt; is called twice with the set of optional
arguments. The script is called once just before the instance is taken
offline, and it is called again after the instance has been brought
online.</p>
</div>
<div class="paragraph">
<p>The following variables are passed into the environment of the called
executable:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DRIVER_PATH</dt>
<dd>
<p>Device path of the instance</p>
</dd>
<dt class="hdlist1">DRIVER_INSTANCE</dt>
<dd>
<p>Instance number of the driver</p>
</dd>
<dt class="hdlist1">DRIVER_UNCONFIGURE</dt>
<dd>
<p>Set to 1 when the instance is about to be taken offline</p>
</dd>
<dt class="hdlist1">DRIVER_CONFIGURE</dt>
<dd>
<p>Set to 1 when the instance has just been brought online</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Typically, the &lt;fixup_script&gt; ensures that the device under
test is in a suitable state to be taken offline (unconfigured) or in a
suitable state for error injection (for example, configured, error free,
and servicing a workload). The following script is a minimal script for
a network driver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/ksh
driver=xyznetdrv
ifnum=$driver$DRIVER_INSTANCE

if [[ $DRIVER_CONFIGURE = 1 ]]; then
   ifconfig $ifnum plumb
   ifconfig $ifnum ...
   ifworkload start $ifnum
elif [[ $DRIVER_UNCONFIGURE = 1 ]]; then
   ifworkload stop $ifnum
   ifconfig $ifnum down
   ifconfig $ifnum unplumb
exit $?</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ifworkload</code> command should initiate the workload as a background
task. The fault injection occurs after the &lt;fixup_script&gt;
configures the driver under test and brings it online
(DRIVER_CONFIGURE is set to 1).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the <code>e</code> &lt;fixup_script&gt; option is present, it must be the
last option on the command line. If the <code>e</code> option is not present, a
default script is used. The default script repeatedly attempts to bring
the device under test offline and online. Thus the workload consists of
the driver&#8217;s <code>attach</code> and <code>detach</code> paths.</p>
</div>
<div class="paragraph">
<p>The resulting log is converted into a set of executable scripts that are
suitable for running unassisted fault-injection tests. These scripts are
created in a subdirectory of the current directory with the name
<code>driver.test.id</code>. The scripts inject faults, one at a time, into the
driver while running the workload that is described by the
&lt;fixup_script&gt;.</p>
</div>
<div class="paragraph">
<p>The driver tester has substantial control over the
errdefs that are produced by the test automation process. See the
<code>th_define(8)</code> man page.</p>
</div>
<div class="paragraph">
<p>If the tester chooses a suitable range of workloads for the test
scripts, the harness gives good coverage of the hardening aspects of the
driver. However, to achieve full coverage, the tester might need to
create additional test cases manually. Add these cases to the test
scripts. To ensure that testing completes in a timely manner, you might
need to manually delete duplicate test cases.</p>
</div>
<div class="sect4">
<h5 id="automated-test-process"><a class="anchor" href="#automated-test-process"></a>Automated Test Process</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Identify the aspects of the driver to be tested.</p>
<div class="ulist">
<ul>
<li>
<p>Attach and detach</p>
</li>
<li>
<p>Plumb and unplumb under a stack</p>
</li>
<li>
<p>Normal data transfer</p>
</li>
<li>
<p>Documented debug modes</p>
<div class="paragraph">
<p>A separate workload script (&lt;fixup_script&gt;) must be
generated for each mode of use.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>For each mode of use, prepare an executable
program(&lt;fixup_script&gt;) that configures and unconfigures the
device, and creates and terminates a workload.</p>
</li>
<li>
<p>Run the <code>th_define</code>(1M) command with the errdefs, together with an
access type of <code>a</code> &lt;log&gt;.</p>
</li>
<li>
<p>Wait for the logs to fill.</p>
<div class="paragraph">
<p>The logs contain a dump of the <code>bofi</code> driver&#8217;s internal buffers. This
data is included at the front of the script.</p>
</div>
<div class="paragraph">
<p>Because it can take from a few seconds to several minutes to create the
logs, use the <code>th_manage broadcast</code> command to check the progress.</p>
</div>
</li>
<li>
<p>Change to the created test directory and run the master test script.</p>
<div class="paragraph">
<p>The master script runs each generated test script in sequence. Separate
test scripts are generated per register set.</p>
</div>
</li>
<li>
<p>Store the results for analysis.</p>
<div class="paragraph">
<p>Successful test results, such as <code>success (corruption reported)</code> and
<code>success (corruption undetected)</code>, show that the driver under test is
behaving properly. The results are reported as
<code>failure (no service impact reported)</code> if the harness detects that the
driver has failed to report the service impact after reporting a fault,
or if the driver fails to detect that an access or DMA handle has been
marked as faulted.</p>
</div>
<div class="paragraph">
<p>It is fine for a few <code>test not triggered</code> failures to appear in the
output. However, several such failures indicate that the test is not
working properly. These failures can appear when the driver does not
access the same registers as when the test scripts were generated.</p>
</div>
</li>
<li>
<p>Run the test on multiple instances of the driver concurrently to test
the multithreading of error paths.</p>
<div class="paragraph">
<p>For example, each <code>th_define</code> command creates a separate directory
that contains test scripts and a master script:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># th_define -n xyznetdrv -i 0 -a log -e script
# th_define -n xyznetdrv -i 1 -a log -e script</pre>
</div>
</div>
<div class="paragraph">
<p>Once created, run the master scripts in parallel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The generated scripts produce only simulated fault injections that are
based on what was logged during the time the logging errdef was active.
When you define a workload, ensure that the required results are logged.
Also analyze the resulting logs and fault-injection specifications.
Verify that the hardware access coverage that the resulting test scripts
created is what is required.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="layered-driver-interface-ldi"><a class="anchor" href="#layered-driver-interface-ldi"></a>2.60. Layered Driver Interface (LDI)</h3>
<div class="paragraph">
<p>Layered Driver Interface</p>
</div>
<div class="paragraph">
<p>DDI/DKI</p>
</div>
<div class="paragraph">
<p>The LDI is a set of DDI/DKI that enables a
kernel module to access other devices in the system. The LDI also
enables you to determine which devices are currently being used by
kernel modules.</p>
</div>
<div class="paragraph">
<p>This chapter covers the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#kernel-interfaces">Kernel Interfaces</a></p>
</li>
<li>
<p><a href="#user-interfaces">User Interfaces</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ldi-overview"><a class="anchor" href="#ldi-overview"></a>2.61. LDI Overview</h3>
<div class="paragraph">
<p>The LDI includes two categories of interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kernel interfaces</strong>. User applications use system calls to open, read,
and write to devices that are managed by a device driver within the
kernel. Kernel modules can use the LDI kernel interfaces to open, read,
and write to devices that are managed by another device driver within
the kernel. For example, a user application might use <code>read(2)</code> and a
kernel module might use <code>ldi_read(9F)</code> to read the same device. See
<a href="#kernel-interfaces">Kernel Interfaces</a>.</p>
</li>
<li>
<p><strong>User interfaces</strong>. The LDI user interfaces can provide information to
user processes regarding which devices are currently being used by other
devices in the kernel. See <a href="#user-interfaces">User Interfaces</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following
terms are commonly used in discussing the LDI:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Target Device</strong>. A target device is a device within the kernel that is
managed by a device driver and is being accessed by a device consumer.</p>
</li>
<li>
<p><strong>Device Consumer</strong>. A device consumer is a user process or kernel
module that opens and accesses a target device. A device consumer
normally performs operations such as <code>open</code>, <code>read</code>, <code>write</code>, or <code>ioctl</code>
on a target device.</p>
</li>
<li>
<p><strong>Kernel Device Consumer</strong>. A kernel device consumer is a particular
kind of device consumer. A kernel device consumer is a kernel module
that accesses a target device. The kernel device consumer usually is not
the device driver that manages the target device that is being accessed.
Instead, the kernel device consumer accesses the target device
indirectly through the device driver that manages the target device.</p>
</li>
<li>
<p><strong>Layered Driver</strong>. A layered driver is a particular kind of kernel
device consumer. A layered driver is a kernel driver that does not
directly manage any piece of hardware. Instead, a layered driver
accesses one of more target devices indirectly through the device
drivers that manage those target devices. Volume managers and STREAMS
multiplexers are good examples of layered drivers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="kernel-interfaces"><a class="anchor" href="#kernel-interfaces"></a>2.62. Kernel Interfaces</h3>
<div class="paragraph">
<p>Some LDI kernel interfaces enable the LDI
to track and report kernel device usage information. See
<a href="#layered-identifiers-kernel-device-consumers">Layered Identifiers – Kernel Device Consumers</a>.</p>
</div>
<div class="paragraph">
<p>Other LDI kernel interfaces enable kernel
modules to perform access operations such as <code>open</code>, <code>read</code>, and <code>write</code>
a target device. These LDI kernel interfaces also enable a kernel device
consumer to query property and event information about target devices.
See <a href="#layered-driver-handles-target-devices">Layered Driver Handles – Target Devices</a>.</p>
</div>
<div class="paragraph">
<p><a href="#ldi-kernel-interfaces-example">LDI Kernel Interfaces Example</a> shows an example driver that
uses many of these LDI interfaces.</p>
</div>
<div class="sect3">
<h4 id="layered-identifiers-kernel-device-consumers"><a class="anchor" href="#layered-identifiers-kernel-device-consumers"></a>2.62.1. Layered Identifiers – Kernel Device Consumers</h4>
<div class="paragraph">
<p>layered identifier</p>
</div>
<div class="paragraph">
<p>layered identifier</p>
</div>
<div class="paragraph">
<p>LDI types</p>
</div>
<div class="paragraph">
<p>ldi_ident_t</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_ident_from_dev</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_ident_from_dip</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_ident_from_stream</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_ident_release</p>
</div>
<div class="paragraph">
<p>Layered identifiers enable the LDI to track and report kernel device
usage information. A layered identifier (<code>ldi_ident_t</code>)
identifies a kernel device consumer. Kernel device consumers must obtain
a layered identifier prior to opening a target device using the LDI.</p>
</div>
<div class="paragraph">
<p>Layered drivers are the only supported types of kernel device consumers.
Therefore, a layered driver must obtain a layered identifier that is
associated with the device number, the device information node, or the
stream of the layered driver. The layered identifier is associated with
the layered driver. The layered identifier is not associated with the
target device.</p>
</div>
<div class="paragraph">
<p>You can retrieve the kernel device usage information that is collected
by the LDI by using the <code>libdevinfo(3LIB)</code> interfaces, the <code>fuser(8)</code>
command, or the <code>prtconf(8)</code> command. For example, the <code>prtconf(8)</code>
command can show which target devices a layered driver is accessing or
which layered drivers are accessing a particular target device. See
<a href="#user-interfaces">User Interfaces</a> to learn more about how to retrieve device
usage information.</p>
</div>
<div class="paragraph">
<p>The following describes the LDI layered identifier interfaces:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_ident_t</code></dt>
<dd>
<p>Layered identifier. An opaque type.</p>
</dd>
<dt class="hdlist1"><code>ldi_ident_from_dev(9F)</code></dt>
<dd>
<p>Allocate and retrieve a layered identifier that is associated with a
<code>dev_t</code> device number.</p>
</dd>
<dt class="hdlist1"><code>ldi_ident_from_dip(9F)</code></dt>
<dd>
<p>Allocate and retrieve a layered identifier that is associated with a
<code>dev_info_t</code> device information node.</p>
</dd>
<dt class="hdlist1"><code>ldi_ident_from_stream(9F)</code></dt>
<dd>
<p>Allocate and retrieve a layered identifier that is associated with a
stream.</p>
</dd>
<dt class="hdlist1"><code>ldi_ident_release(9F)</code></dt>
<dd>
<p>Release a layered identifier that was allocated with
<code>ldi_ident_from_dev(9F)</code>,
<code>ldi_ident_from_dip(9F)</code>, or
<code>ldi_ident_from_stream(9F)</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="layered-driver-handles-target-devices"><a class="anchor" href="#layered-driver-handles-target-devices"></a>2.62.2. Layered Driver Handles – Target Devices</h4>
<div class="paragraph">
<p>layered driver handle</p>
</div>
<div class="paragraph">
<p>layered driver handle</p>
</div>
<div class="paragraph">
<p>LDI types</p>
</div>
<div class="paragraph">
<p>ldi_handle_t</p>
</div>
<div class="paragraph">
<p>target device</p>
</div>
<div class="paragraph">
<p>Kernel device consumers must use a layered driver handle
(<code>ldi_handle_t</code>) to access a target device through LDI
interfaces. The <code>ldi_handle_t</code> type is valid only with LDI
interfaces. The LDI allocates and returns this handle when the LDI
successfully opens a device. A kernel device consumer can then use this
handle to access the target device through the LDI interfaces. The LDI
deallocates the handle when the LDI closes the device. See
<a href="#ldi-kernel-interfaces-example">LDI Kernel Interfaces Example</a> for an example.</p>
</div>
<div class="paragraph">
<p>This section discusses how kernel device consumers can access target
devices and retrieve different types of information. See
<a href="#opening-and-closing-target-devices">Opening and Closing Target Devices</a> to learn how kernel
device consumers can open and close target devices. See
<a href="#accessing-target-devices">Accessing Target Devices</a> to learn how kernel device
consumers can perform operations such as <code>read</code>, <code>write</code>, <code>strategy</code>,
and <code>ioctl</code> on target devices. <a href="#retrieving-target-device-information">Retrieving Target Device
Information</a> describes interfaces that retrieve target device
information such as device open type and device minor name.
<a href="#retrieving-target-device-property-values">Retrieving Target Device Property Values</a> describes
interfaces that retrieve values and address of target device properties.
See <a href="#receiving-asynchronous-device-event-notification">Receiving Asynchronous Device Event Notification</a> to
learn how kernel device consumers can receive event notification from
target devices.</p>
</div>
<div class="sect4">
<h5 id="opening-and-closing-target-devices"><a class="anchor" href="#opening-and-closing-target-devices"></a>Opening and Closing Target Devices</h5>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_open_by_dev</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_open_by_devid</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_open_by_name</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_close</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>This section describes the LDI kernel interfaces for opening and closing
target devices. The open interfaces take a pointer to a layered driver
handle. The open interfaces attempt to open the target device specified
by the device number, device ID, or path name. If the open operation is
successful, the open interfaces allocate and return a layered driver
handle that can be used to access the target device. The close interface
closes the target device associated with the specified layered driver
handle and then frees the layered driver handle.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_handle_t</code></dt>
<dd>
<p>Layered driver handle for target device access. An opaque data
structure that is returned when a device is successfully opened.</p>
</dd>
<dt class="hdlist1"><code>ldi_open_by_dev(9F)</code></dt>
<dd>
<p>Open the device specified by the <code>dev_t</code> device number parameter.</p>
</dd>
<dt class="hdlist1"><code>ldi_open_by_devid(9F)</code></dt>
<dd>
<p>Open the device specified by the <code>ddi_devid_t</code> device ID
parameter. You also must specify the minor node name to open.</p>
</dd>
<dt class="hdlist1"><code>ldi_open_by_name(9F)</code></dt>
<dd>
<p>Open a device by path name. The path name is a null-terminated string
in the kernel address space. The path name must be an absolute path,
beginning with a forward slash character (<code>/</code>).</p>
</dd>
<dt class="hdlist1"><code>ldi_close(9F)</code></dt>
<dd>
<p>Close a device that was opened with <code>ldi_open_by_dev(9F)</code>,
<code>ldi_open_by_devid(9F)</code>, or
<code>ldi_open_by_name(9F)</code>. After <code>ldi_close(9F)</code> returns,
the layered driver handle of the device that was closed is no longer
valid.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="accessing-target-devices"><a class="anchor" href="#accessing-target-devices"></a>Accessing Target Devices</h5>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_read</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_aread</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_write</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_awrite</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_strategy</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_dump</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_poll</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_ioctl</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_devmap</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_getmsg</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_putmsg</p>
</div>
<div class="paragraph">
<p>This section describes the LDI kernel interfaces for accessing target
devices. These interfaces enable a kernel device consumer to perform
operations on the target device specified by the layered driver handle.
Kernel device consumers can perform operations such as <code>read</code>, <code>write</code>,
<code>strategy</code>, and <code>ioctl</code> on the target device.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_handle_t</code></dt>
<dd>
<p>Layered driver handle for target device access. An opaque data
structure.</p>
</dd>
<dt class="hdlist1"><code>ldi_read(9F)</code></dt>
<dd>
<p>Pass a read request to the device entry point for the target device.
This operation is supported for block, character, and STREAMS devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_aread(9F)</code></dt>
<dd>
<p>Pass an asynchronous read request to the device entry point for the
target device. This operation is supported for block and character
devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_write(9F)</code></dt>
<dd>
<p>Pass a write request to the device entry point for the target device.
This operation is supported for block, character, and STREAMS devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_awrite(9F)</code></dt>
<dd>
<p>Pass an asynchronous write request to the device entry point for the
target device. This operation is supported for block and character
devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_strategy(9F)</code></dt>
<dd>
<p>Pass a strategy request to the device entry point for the target
device. This operation is supported for block and character devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_dump(9F)</code></dt>
<dd>
<p>Pass a dump request to the device entry point for the target device.
This operation is supported for block and character devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_poll(9F)</code></dt>
<dd>
<p>Pass a poll request to the device entry point for the target device.
This operation is supported for block, character, and STREAMS devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_ioctl(9F)</code></dt>
<dd>
<p>Pass an <code>ioctl</code> request to the device entry point for the target
device. This operation is supported for block, character, and STREAMS
devices. The LDI supports STREAMS linking and STREAMS <code>ioctl</code>
commands. See the “STREAM IOCTLS” section of the <code>ldi_ioctl(9F)</code>
man page. See also the <code>ioctl</code> commands in the <code>streamio(4I)</code> man
page.</p>
</dd>
<dt class="hdlist1"><code>ldi_devmap(9F)</code></dt>
<dd>
<p>Pass a <code>devmap</code> request to the device entry point for the target
device. This operation is supported for block and character devices.</p>
</dd>
<dt class="hdlist1"><code>ldi_getmsg(9F)</code></dt>
<dd>
<p>Get a message block from a stream.</p>
</dd>
<dt class="hdlist1"><code>ldi_putmsg(9F)</code></dt>
<dd>
<p>Put a message block on a stream.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="retrieving-target-device-information"><a class="anchor" href="#retrieving-target-device-information"></a>Retrieving Target Device Information</h5>
<div class="paragraph">
<p>device information</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_dev</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_otyp</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_devid</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_minor_name</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_size</p>
</div>
<div class="paragraph">
<p>ddi_devid_free</p>
</div>
<div class="paragraph">
<p>kmem_free</p>
</div>
<div class="paragraph">
<p>This section describes LDI interfaces that kernel device consumers can
use to retrieve device information about a specified target device. A
target device is specified by a layered driver handle. A kernel device
consumer can receive information such as device number, device open
type, device ID, device minor name, and device size.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_get_dev(9F)</code></dt>
<dd>
<p>Get the <code>dev_t</code> device number for the target device specified by
the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_get_otyp(9F)</code></dt>
<dd>
<p>Get the open flag that was used to open the target device specified by
the layered driver handle. This flag tells you whether the target
device is a character device or a block device.</p>
</dd>
<dt class="hdlist1"><code>ldi_get_devid(9F)</code></dt>
<dd>
<p>Get the <code>ddi_devid_t</code> device ID for the target device
specified by the layered driver handle. Use
<code>ddi_devid_free(9F)</code> to free the <code>ddi_devid_t</code> when
you are finished using the device ID.</p>
</dd>
<dt class="hdlist1"><code>ldi_get_minor_name(9F)</code></dt>
<dd>
<p>Retrieve a buffer that contains the name of the minor node that was
opened for the target device. Use <code>kmem_free(9F)</code> to release the
buffer when you are finished using the minor node name.</p>
</dd>
<dt class="hdlist1"><code>ldi_get_size(9F)</code></dt>
<dd>
<p>Retrieve the partition size of the target device specified by the
layered driver handle.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="retrieving-target-device-property-values"><a class="anchor" href="#retrieving-target-device-property-values"></a>Retrieving Target Device Property Values</h5>
<div class="paragraph">
<p>device information</p>
</div>
<div class="paragraph">
<p>property values</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_exists</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_get_int</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_get_int64</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_lookup_int_array</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_lookup_int64_array</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_lookup_string</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_lookup_string_array</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_prop_lookup_byte_array</p>
</div>
<div class="paragraph">
<p>This section describes LDI interfaces that kernel device consumers can
use to retrieve property information about a specified target device. A
target device is specified by a layered driver handle. A kernel device
consumer can receive values and addresses of properties and determine
whether a property exists.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_prop_exists(9F)</code></dt>
<dd>
<p>Return <code>1</code> if the property exists for the target device specified by
the layered driver handle. Return <code>0</code> if the property does not exist
for the specified target device.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_get_int(9F)</code></dt>
<dd>
<p>Search for an <code>int</code> integer property that is associated with the
target device specified by the layered driver handle. If the integer
property is found, return the property value.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_get_int64(9F)</code></dt>
<dd>
<p>Search for an <code>int64_t</code> integer property that is associated with
the target device specified by the layered driver handle. If the
integer property is found, return the property value.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_lookup_int_array(9F)</code></dt>
<dd>
<p>Retrieve the address of an <code>int</code> integer array property value for the
target device specified by the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_lookup_int64_array(9F)</code></dt>
<dd>
<p>Retrieve the address of an <code>int64_t</code> integer array property value
for the target device specified by the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_lookup_string(9F)</code></dt>
<dd>
<p>Retrieve the address of a null-terminated string property value for
the target device specified by the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_lookup_string_array(9F)</code></dt>
<dd>
<p>Retrieve the address of an array of strings. The string array is an
array of pointers to null-terminated strings of property values for
the target device specified by the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_prop_lookup_byte_array(9F)</code></dt>
<dd>
<p>Retrieve the address of an array of bytes. The byte array is a
property value of the target device specified by the layered driver
handle.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="receiving-asynchronous-device-event-notification"><a class="anchor" href="#receiving-asynchronous-device-event-notification"></a>Receiving Asynchronous Device Event Notification</h5>
<div class="paragraph">
<p>asynchronous notification</p>
</div>
<div class="paragraph">
<p>event notification interfaces</p>
</div>
<div class="paragraph">
<p>ddi_eventcookie_t</p>
</div>
<div class="paragraph">
<p>LDI types</p>
</div>
<div class="paragraph">
<p>ldi_callback_id_t</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_get_eventcookie</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_add_event_handler</p>
</div>
<div class="paragraph">
<p>LDI functions</p>
</div>
<div class="paragraph">
<p>ldi_remove_event_handler</p>
</div>
<div class="paragraph">
<p>The LDI enables kernel device consumers to register for event
notification and to receive event notification from target devices. A
kernel device consumer can register an event handler that will be called
when the event occurs. The kernel device consumer must open a device and
receive a layered driver handle before the kernel device consumer can
register for event notification with the LDI event notification
interfaces.</p>
</div>
<div class="paragraph">
<p>The LDI event notification interfaces enable a kernel device consumer to
specify an event name and to retrieve an associated kernel event cookie.
The kernel device consumer can then pass the layered driver handle
(<code>ldi_handle_t</code>), the cookie (<code>ddi_eventcookie_t</code>), and
the event handler to <code>ldi_add_event_handler(9F)</code> to register
for event notification. When registration completes successfully, the
kernel device consumer receives a unique LDI event handler identifier
(<code>ldi_callback_id_t</code>). The LDI event handler identifier is
an opaque type that can be used only with the LDI event notification
interfaces.</p>
</div>
<div class="paragraph">
<p>The LDI provides a framework to register for events generated by other
devices. The LDI itself does not define any event types or provide
interfaces for generating events.</p>
</div>
<div class="paragraph">
<p>The following describes the LDI asynchronous event notification
interfaces:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ldi_callback_id_t</code></dt>
<dd>
<p>Event handler identifier. An opaque type.</p>
</dd>
<dt class="hdlist1"><code>ldi_get_eventcookie(9F)</code></dt>
<dd>
<p>Retrieve an event service cookie for the target device specified by
the layered driver handle.</p>
</dd>
<dt class="hdlist1"><code>ldi_add_event_handler(9F)</code></dt>
<dd>
<p>Add the callback handler specified by the
<code>ldi_callback_id_t</code> registration identifier. The callback
handler is invoked when the event specified by the
<code>ddi_eventcookie_t</code> cookie occurs.</p>
</dd>
<dt class="hdlist1"><code>ldi_remove_event_handler(9F)</code></dt>
<dd>
<p>Remove the callback handler specified by the
<code>ldi_callback_id_t</code> registration identifier.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ldi-kernel-interfaces-example"><a class="anchor" href="#ldi-kernel-interfaces-example"></a>2.62.3. LDI Kernel Interfaces Example</h4>
<div class="paragraph">
<p>This section shows an example kernel device consumer that uses some of
the LDI calls discussed in the preceding sections in this chapter. This
section discusses the following aspects of this example module:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#device-configuration-file">Device Configuration File</a></p>
</li>
<li>
<p><a href="#driver-source-file">Driver Source File</a></p>
</li>
<li>
<p><a href="#test-the-layered-driver">Test the Layered Driver</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This example kernel device consumer is named <code>lyr</code>. The <code>lyr</code> module is
a layered driver that uses LDI calls to send data to a target device. In
its <code>open(9E)</code> entry point, the <code>lyr</code> driver opens the device that is
specified by the <code>lyr_targ</code> property in the <code>lyr.conf</code> configuration
file. In its <code>write(9E)</code> entry point, the <code>lyr</code> driver writes all of its
incoming data to the device specified by the <code>lyr_targ</code> property.</p>
</div>
<div class="sect4">
<h5 id="device-configuration-file"><a class="anchor" href="#device-configuration-file"></a>Device Configuration File</h5>
<div class="paragraph">
<p>In the configuration file shown below, the target device that the <code>lyr</code>
driver is writing to is the console.</p>
</div>
<div id="euayx" class="paragraph">
<p>Configuration File</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident   "%Z%%M% %I% %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="driver-source-file"><a class="anchor" href="#driver-source-file"></a>Driver Source File</h5>
<div class="paragraph">
<p>state structure</p>
</div>
<div class="paragraph">
<p>soft state information</p>
</div>
<div class="paragraph">
<p>layered driver handle</p>
</div>
<div class="paragraph">
<p>layered identifier</p>
</div>
<div class="paragraph">
<p>In the driver source file shown below, the <code>lyr_state_t</code>
structure holds the soft state for the <code>lyr</code> driver. The soft state
includes the layered driver handle (<code>lh</code>) for the <code>lyr_targ</code> device
and the layered identifier (<code>li</code>) for the <code>lyr</code> device. For more
information on soft state, see <a href="#retrieving-driver-soft-state-information">Retrieving Driver Soft State
Information</a>.</p>
</div>
<div class="paragraph">
<p>In the <code>lyr_open</code> entry
point, <code>ddi_prop_lookup_string(9F)</code> retrieves from the
<code>lyr_targ</code> property the name of the target device for the <code>lyr</code>
device to open. The <code>ldi_ident_from_dev(9F)</code> function gets
an LDI layered identifier for the <code>lyr</code> device. The
<code>ldi_open_by_name(9F)</code> function opens the <code>lyr_targ</code>
device and gets a layered driver handle for the <code>lyr_targ</code> device.</p>
</div>
<div class="paragraph">
<p>Note that if any failure
occurs in <code>lyr_open</code>, the <code>ldi_close(9F)</code>,
<code>ldi_ident_release(9F)</code>, and <code>ddi_prop_free(9F)</code> calls
undo everything that was done. The <code>ldi_close(9F)</code> function closes
the <code>lyr_targ</code> device. The <code>ldi_ident_release(9F)</code> function
releases the <code>lyr</code> layered identifier. The <code>ddi_prop_free(9F)</code>
function frees resources allocated when the <code>lyr_targ</code> device name
was retrieved. If no failure occurs, the <code>ldi_close(9F)</code> and
<code>ldi_ident_release(9F)</code> functions are called in the
<code>lyr_close</code> entry point.</p>
</div>
<div class="paragraph">
<p>In the last line of the driver module, the
<code>ldi_write(9F)</code> function is called. The <code>ldi_write(9F)</code> function
takes the data written to the <code>lyr</code> device in the <code>lyr_write</code> entry
point and writes that data to the <code>lyr_targ</code> device. The
<code>ldi_write(9F)</code> function uses the layered driver handle for the
<code>lyr_targ</code> device to write the data to the <code>lyr_targ</code> device.</p>
</div>
<div id="euayy" class="paragraph">
<p>Driver Source File</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;sys/types.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/open.h&gt;
#include &lt;sys/cred.h&gt;
#include &lt;sys/cmn_err.h&gt;
#include &lt;sys/modctl.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;
#include &lt;sys/sunldi.h&gt;

typedef struct lyr_state {
    ldi_handle_t    lh;
    ldi_ident_t     li;
    dev_info_t      *dip;
    minor_t     minor;
    int         flags;
    kmutex_t    lock;
} lyr_state_t;

#define LYR_OPENED      0x1     /* lh is valid */
#define LYR_IDENTED     0x2     /* li is valid */

static int lyr_info(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int lyr_attach(dev_info_t *, ddi_attach_cmd_t);
static int lyr_detach(dev_info_t *, ddi_detach_cmd_t);
static int lyr_open(dev_t *, int, int, cred_t *);
static int lyr_close(dev_t, int, int, cred_t *);
static int lyr_write(dev_t, struct uio *, cred_t *);

static void *lyr_statep;

static struct cb_ops lyr_cb_ops = {
    lyr_open,       /* open */
    lyr_close,      /* close */
    nodev,      /* strategy */
    nodev,      /* print */
    nodev,      /* dump */
    nodev,      /* read */
    lyr_write,      /* write */
    nodev,      /* ioctl */
    nodev,      /* devmap */
    nodev,      /* mmap */
    nodev,      /* segmap */
    nochpoll,       /* poll */
    ddi_prop_op,    /* prop_op */
    NULL,       /* streamtab  */
    D_NEW | D_MP,   /* cb_flag */
    CB_REV,     /* cb_rev */
    nodev,      /* aread */
    nodev       /* awrite */
};

static struct dev_ops lyr_dev_ops = {
    DEVO_REV,       /* devo_rev, */
    0,          /* refcnt  */
    lyr_info,       /* getinfo */
    nulldev,    /* identify */
    nulldev,    /* probe */
    lyr_attach,     /* attach */
    lyr_detach,     /* detach */
    nodev,      /* reset */
    &amp;lyr_cb_ops,    /* cb_ops */
    NULL,       /* bus_ops */
    NULL        /* power */
};

static struct modldrv modldrv = {
    &amp;mod_driverops,
    "LDI example driver",
    &amp;lyr_dev_ops
};

static struct modlinkage modlinkage = {
    MODREV_1,
    &amp;modldrv,
};

_init(void)
{
    int rv;

    if ((rv = ddi_soft_state_init(&amp;lyr_statep, sizeof (lyr_state_t),
        0)) != 0) {
        cmn_err(CE_WARN, "lyr _init: soft state init failed\n");
        return (rv);
    }
    if ((rv = mod_install(&amp;modlinkage)) != 0) {
        cmn_err(CE_WARN, "lyr _init: mod_install failed\n");
        goto FAIL;
    }
    return (rv);
    /*NOTEREACHED*/
FAIL:
    ddi_soft_state_fini(&amp;lyr_statep);
    return (rv);
}

_info(struct modinfo *modinfop)
{
    return (mod_info(&amp;modlinkage, modinfop));
}

_fini(void)
{
    int rv;

    if ((rv = mod_remove(&amp;modlinkage)) != 0) {
        return(rv);
    }
    ddi_soft_state_fini(&amp;lyr_statep);
    return (rv);
}
/*
 * 1:1 mapping between minor number and instance
 */
static int
lyr_info(dev_info_t *dip, ddi_info_cmd_t infocmd, void *arg, void **result)
{
    int inst;
    minor_t minor;
    lyr_state_t *statep;
    char *myname = "lyr_info";

    minor = getminor((dev_t)arg);
    inst = minor;
    switch (infocmd) {
    case DDI_INFO_DEVT2DEVINFO:
        statep = ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: get soft state "
                "failed on inst %d\n", myname, inst);
            return (DDI_FAILURE);
        }
        *result = (void *)statep-&gt;dip;
        break;
    case DDI_INFO_DEVT2INSTANCE:
        *result = (void *)inst;
        break;
    default:
        break;
    }

    return (DDI_SUCCESS);
}

static int
lyr_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_attach";

    switch (cmd) {
    case DDI_ATTACH:
        inst = ddi_get_instance(dip);

        if (ddi_soft_state_zalloc(lyr_statep, inst) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_soft_state_zallac failed "
                "on inst %d\n", myname, inst);
            goto FAIL;
        }
        statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
        if (statep == NULL) {
            cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        statep-&gt;dip = dip;
        statep-&gt;minor = inst;
        if (ddi_create_minor_node(dip, "node", S_IFCHR, statep-&gt;minor,
            DDI_PSEUDO, 0) != DDI_SUCCESS) {
            cmn_err(CE_WARN, "%s: ddi_create_minor_node failed on "
                "inst %d\n", myname, inst);
            goto FAIL;
        }
        mutex_init(&amp;statep-&gt;lock, NULL, MUTEX_DRIVER, NULL);
        return (DDI_SUCCESS);
    case DDI_RESUME:
    case DDI_PM_RESUME:
    default:
        break;
    }
    return (DDI_FAILURE);
    /*NOTREACHED*/
FAIL:
    ddi_soft_state_free(lyr_statep, inst);
    ddi_remove_minor_node(dip, NULL);
    return (DDI_FAILURE);
}

static int
lyr_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    int inst;
    lyr_state_t *statep;
    char *myname = "lyr_detach";

    inst = ddi_get_instance(dip);
    statep = ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: get soft state failed on "
            "inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    if (statep-&gt;dip != dip) {
        cmn_err(CE_WARN, "%s: soft state does not match devinfo "
            "on inst %d\n", myname, inst);
        return (DDI_FAILURE);
    }
    switch (cmd) {
    case DDI_DETACH:
        mutex_destroy(&amp;statep-&gt;lock);
        ddi_soft_state_free(lyr_statep, inst);
        ddi_remove_minor_node(dip, NULL);
        return (DDI_SUCCESS);
    case DDI_SUSPEND:
    case DDI_PM_SUSPEND:
    default:
        break;
    }
    return (DDI_FAILURE);
}
/*
 * on this driver's open, we open the target specified by a property and store
 * the layered handle and ident in our soft state.  a good target would be
 * "/dev/console" or more interestingly, a pseudo terminal as specified by the
 * tty command
 */
/*ARGSUSED*/
static int
lyr_open(dev_t *devtp, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(*devtp);
    lyr_state_t *statep;
    char *myname = "lyr_open";
    dev_info_t *dip;
    char *lyr_targ = NULL;

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    dip = statep-&gt;dip;
    /*
     * our target device to open should be specified by the "lyr_targ"
     * string property, which should be set in this driver's .conf file
     */
    if (ddi_prop_lookup_string(DDI_DEV_T_ANY, dip, DDI_PROP_NOTPROM,
        "lyr_targ", &amp;lyr_targ) != DDI_PROP_SUCCESS) {
        cmn_err(CE_WARN, "%s: ddi_prop_lookup_string failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    /*
     * since we only have one pair of lh's and li's available, we don't
     * allow multiple on the same instance
     */
    mutex_enter(&amp;statep-&gt;lock);
    if (statep-&gt;flags &amp; (LYR_OPENED | LYR_IDENTED)) {
        cmn_err(CE_WARN, "%s: multiple layered opens or idents "
            "from inst %d not allowed\n", myname, inst);
        mutex_exit(&amp;statep-&gt;lock);
        ddi_prop_free(lyr_targ);
        return (EIO);
    }
    rv = ldi_ident_from_dev(*devtp, &amp;statep-&gt;li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_ident_from_dev failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep-&gt;flags |= LYR_IDENTED;
    rv = ldi_open_by_name(lyr_targ, FREAD | FWRITE, credp, &amp;statep-&gt;lh,
        statep-&gt;li);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_open_by_name failed on inst %d\n",
            myname, inst);
        goto FAIL;
    }
    statep-&gt;flags |= LYR_OPENED;
    cmn_err(CE_CONT, "\n%s: opened target '%s' successfully on inst %d\n",
        myname, lyr_targ, inst);
    rv = 0;

FAIL:
    /* cleanup on error */
    if (rv != 0) {
        if (statep-&gt;flags &amp; LYR_OPENED)
            (void)ldi_close(statep-&gt;lh, FREAD | FWRITE, credp);
        if (statep-&gt;flags &amp; LYR_IDENTED)
            ldi_ident_release(statep-&gt;li);
        statep-&gt;flags &amp;= ~(LYR_OPENED | LYR_IDENTED);
    }
    mutex_exit(&amp;statep-&gt;lock);
    if (lyr_targ != NULL)
        ddi_prop_free(lyr_targ);
    return (rv);
}
/*
 * on this driver's close, we close the target indicated by the lh member
 * in our soft state and release the ident, li as well.  in fact, we MUST do
 * both of these at all times even if close yields an error because the
 * device framework effectively closes the device, releasing all data
 * associated with it and simply returning whatever value the target's
 * close(9E) returned.  therefore, we must as well.
 */
/*ARGSUSED*/
static int
lyr_close(dev_t devt, int oflag, int otyp, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_close";
    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    mutex_enter(&amp;statep-&gt;lock);
    rv = ldi_close(statep-&gt;lh, FREAD | FWRITE, credp);
    if (rv != 0) {
        cmn_err(CE_WARN, "%s: ldi_close failed on inst %d, but will ",
            "continue to release ident\n", myname, inst);
    }
    ldi_ident_release(statep-&gt;li);
    if (rv == 0) {
        cmn_err(CE_CONT, "\n%s: closed target successfully on "
            "inst %d\n", myname, inst);
    }
    statep-&gt;flags &amp;= ~(LYR_OPENED | LYR_IDENTED);
    mutex_exit(&amp;statep-&gt;lock);
    return (rv);
}
/*
 * echo the data we receive to the target
 */
/*ARGSUSED*/
static int
lyr_write(dev_t devt, struct uio *uiop, cred_t *credp)
{
    int rv, inst = getminor(devt);
    lyr_state_t *statep;
    char *myname = "lyr_write";

    statep = (lyr_state_t *)ddi_get_soft_state(lyr_statep, inst);
    if (statep == NULL) {
        cmn_err(CE_WARN, "%s: ddi_get_soft_state failed on "
            "inst %d\n", myname, inst);
        return (EIO);
    }
    return (ldi_write(statep-&gt;lh, uiop, credp));
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compile the driver.</p>
<div class="paragraph">
<p>Use the <code>D_KERNEL</code> option to indicate that this is a kernel module.
* If you are compiling for a SPARC architecture, use the <code>xarch=v9</code>
option:</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -c -D_KERNEL -xarch=v9 lyr.c</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If you are compiling for a 32-bit x86 architecture, use the following
command:</p>
<div class="literalblock">
<div class="content">
<pre>% cc -c -D_KERNEL lyr.c</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Link the driver.</p>
<div class="literalblock">
<div class="content">
<pre>% ld -r -o lyr lyr.o</pre>
</div>
</div>
</li>
<li>
<p>Install the configuration file.</p>
<div class="paragraph">
<p>As user <code>root</code>, copy the configuration file to the kernel driver area of
the machine:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cp lyr.conf /usr/kernel/drv</pre>
</div>
</div>
</li>
<li>
<p>Install the driver binary.</p>
<div class="ulist">
<ul>
<li>
<p>As user <code>root</code>, copy the driver binary to the <code>sparcv9</code> driver area on
a SPARC architecture:</p>
<div class="literalblock">
<div class="content">
<pre># cp lyr /usr/kernel/drv/sparcv9</pre>
</div>
</div>
</li>
<li>
<p>As user <code>root</code>, copy the driver binary to the <code>drv</code> driver area on a
32-bit x86 architecture:</p>
<div class="literalblock">
<div class="content">
<pre># cp lyr /usr/kernel/drv</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Load the driver.</p>
<div class="paragraph">
<p>As user <code>root</code>, use the <code>add_drv(8)</code> command to load the driver.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># add_drv lyr</pre>
</div>
</div>
<div class="paragraph">
<p>List the pseudo devices to confirm that the <code>lyr</code> device now exists:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># ls /devices/pseudo | grep lyr
lyr@1
lyr@1:node</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="test-the-layered-driver"><a class="anchor" href="#test-the-layered-driver"></a>Test the Layered Driver</h5>
<div class="paragraph">
<p>To test the <code>lyr</code> driver, write a message to the <code>lyr</code> device and verify
that the message displays on the <code>lyr_targ</code> device.</p>
</div>
<div id="exegr" class="paragraph">
<p>Write a Short Message to the Layered Device</p>
</div>
<div class="paragraph">
<p>In this example, the <code>lyr_targ</code> device is the console of the system
where the <code>lyr</code> device is installed.</p>
</div>
<div class="paragraph">
<p>If the display you are viewing is also the display for the console
device of the system where the <code>lyr</code> device is installed, note that
writing to the console will corrupt your display. The console messages
will appear outside your window system. You will need to redraw or
refresh your display after testing the <code>lyr</code> driver.</p>
</div>
<div class="paragraph">
<p>If the display you are viewing is not the display for the console device
of the system where the <code>lyr</code> device is installed, log into or otherwise
gain a view of the display of the target console device.</p>
</div>
<div class="paragraph">
<p>The following command writes a very brief message to the <code>lyr</code> device:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># echo "\n\n\t===&gt; Hello World!! &lt;===\n" &gt; /devices/pseudo/lyr@1:node</pre>
</div>
</div>
<div class="paragraph">
<p>You should see the following messages displayed on the target console:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>console login:

    ===&gt; Hello World!! &lt;===

lyr:
lyr_open: opened target '/dev/console' successfully on inst 1
lyr:
lyr_close: closed target successfully on inst 1</pre>
</div>
</div>
<div class="paragraph">
<p>The messages from <code>lyr_open</code> and <code>lyr_close</code>
come from the <code>cmn_err(9F)</code> calls in the <code>lyr_open</code> and
<code>lyr_close</code> entry points.</p>
</div>
<div id="exegt" class="paragraph">
<p>Write a Longer Message to the Layered Device</p>
</div>
<div class="paragraph">
<p>The following command writes a longer message to the <code>lyr</code> device:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># cat lyr.conf &gt; /devices/pseudo/lyr@1:node</pre>
</div>
</div>
<div class="paragraph">
<p>You should see the following messages displayed on the target console:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>lyr:
lyr_open: opened target '/dev/console' successfully on inst 1
#
# Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#pragma ident   "%Z%%M% %I%     %E% SMI"

name="lyr" parent="pseudo" instance=1;
lyr_targ="/dev/console";
lyr:
lyr_close: closed target successfully on inst 1</pre>
</div>
</div>
<div id="exegu" class="paragraph">
<p>Change the Target Device</p>
</div>
<div class="paragraph">
<p>To change the target device, edit
<code>/usr/kernel/drv/lyr.conf</code> and change the value of the <code>lyr_targ</code>
property to be a path to a different target device. For example, the
target device could be the output of a <code>tty</code> command in a local
terminal. An example of such a device path is <code>/dev/pts/4</code>.</p>
</div>
<div class="paragraph">
<p>Make sure the <code>lyr</code> device is not in use before you update the driver to
use the new target device.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># modinfo -c | grep lyr
174          3 lyr                              UNLOADED/UNINSTALLED</pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>update_drv(8)</code> command to reload the <code>lyr.conf</code>
configuration file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># update_drv lyr</pre>
</div>
</div>
<div class="paragraph">
<p>Write a message to the <code>lyr</code> device again and verify that the message
displays on the new <code>lyr_targ</code> device.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="user-interfaces"><a class="anchor" href="#user-interfaces"></a>2.63. User Interfaces</h3>
<div class="paragraph">
<p>device layering</p>
</div>
<div class="paragraph">
<p>device layering</p>
</div>
<div class="paragraph">
<p>device usage</p>
</div>
<div class="paragraph">
<p>device information library</p>
</div>
<div class="paragraph">
<p>The LDI includes user-level library and command interfaces to report
device layering and usage information. <a href="#device-information-library-interfaces">Device Information
Library Interfaces</a> discusses the <code>libdevinfo(3LIB)</code> interfaces for
reporting device layering information. <a href="#print-system-configuration-command-interfaces">Print System
Configuration Command Interfaces</a> discusses the <code>prtconf(8)</code> interfaces
for reporting kernel device usage information. <a href="#device-user-command-interfaces">Device User
Command Interfaces</a> discusses the <code>fuser(8)</code> interfaces for reporting
device consumer information.</p>
</div>
<div class="sect3">
<h4 id="device-information-library-interfaces"><a class="anchor" href="#device-information-library-interfaces"></a>2.63.1. Device Information Library Interfaces</h4>
<div class="paragraph">
<p>device information</p>
</div>
<div class="paragraph">
<p>The LDI includes <code>libdevinfo(3LIB)</code> interfaces that report a snapshot of
device layering information. Device layering occurs when one device in
the system is a consumer of another device in the system. Device
layering information is reported only if both the consumer and the
target are bound to a device node that is contained within the snapshot.</p>
</div>
<div class="paragraph">
<p>Device layering information is reported by the <code>libdevinfo(3LIB)</code>
interfaces as a directed graph. An <em>lnode</em> is an abstraction that
represents a vertex in the graph and is bound to a device node. You can
use <code>libdevinfo(3LIB)</code> interfaces to access properties of an lnode, such
as the name and device number of the node.</p>
</div>
<div class="paragraph">
<p>The edges in the graph are represented by a link. A link has a source
lnode that represents the device consumer. A link also has a target
lnode that represents the target device.</p>
</div>
<div class="paragraph">
<p>following describes the <code>libdevinfo(3LIB)</code> device layering information
interfaces:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>DINFOLYR</code></dt>
<dd>
<p>Snapshot flag that enables you to capture device layering information.</p>
</dd>
<dt class="hdlist1"><code>di_link_t</code></dt>
<dd>
<p>A directed link between two endpoints. Each endpoint is a
<code>di_lnode_t</code>. An opaque structure.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_t</code></dt>
<dd>
<p>The endpoint of a link. An opaque structure. A <code>di_lnode_t</code> is
bound to a <code>di_node_t</code>.</p>
</dd>
<dt class="hdlist1"><code>di_node_t</code></dt>
<dd>
<p>Represents a device node. An opaque structure. A <code>di_node_t</code>
is not necessarily bound to a <code>di_lnode_t</code>.</p>
</dd>
<dt class="hdlist1"><code>di_walk_link(3DEVINFO)</code></dt>
<dd>
<p>Walk all links in the snapshot.</p>
</dd>
<dt class="hdlist1"><code>di_walk_lnode(3DEVINFO)</code></dt>
<dd>
<p>Walk all lnodes in the snapshot.</p>
</dd>
<dt class="hdlist1"><code>di_link_next_by_node(3DEVINFO)</code></dt>
<dd>
<p>Get a handle to the next link where the specified <code>di_node_t</code>
node is either the source or the target.</p>
</dd>
<dt class="hdlist1"><code>di_link_next_by_lnode(3DEVINFO)</code></dt>
<dd>
<p>Get a handle to the next link where the specified <code>di_lnode_t</code>
lnode is either the source or the target.</p>
</dd>
<dt class="hdlist1"><code>di_link_to_lnode(3DEVINFO)</code></dt>
<dd>
<p>Get the lnode that corresponds to the specified endpoint of a
<code>di_link_t</code> link.</p>
</dd>
<dt class="hdlist1"><code>di_link_spectype(3DEVINFO)</code></dt>
<dd>
<p>Get the link spectype. The spectype indicates how the target device is
being accessed. The target device is represented by the target lnode.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_next(3DEVINFO)</code></dt>
<dd>
<p>Get a handle to the next occurrence of the specified
<code>di_lnode_t</code> lnode associated with the specified
<code>di_node_t</code> device node.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_name(3DEVINFO)</code></dt>
<dd>
<p>Get the name that is associated with the specified lnode.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_devinfo(3DEVINFO)</code></dt>
<dd>
<p>Get a handle to the device node that is associated with the specified
lnode.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_devt(3DEVINFO)</code></dt>
<dd>
<p>Get the device number of the device node that is associated with the
specified lnode.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The device layering information returned by the LDI can be quite
complex. Therefore, the LDI provides interfaces to help you traverse the
device tree and the device usage graph. These interfaces enable the
consumer of a device tree snapshot to associate custom data pointers
with different structures within the snapshot. For example, as an
application traverses lnodes, the application can update the custom
pointer associated with each lnode to mark which lnodes already have
been seen.</p>
</div>
<div class="paragraph">
<p>The following
describes the <code>libdevinfo(3LIB)</code> node and link marking interfaces:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>di_lnode_private_set(3DEVINFO)</code></dt>
<dd>
<p>Associate the specified data with the specified lnode. This
association enables you to traverse lnodes in the snapshot.</p>
</dd>
<dt class="hdlist1"><code>di_lnode_private_get(3DEVINFO)</code></dt>
<dd>
<p>Retrieve a pointer to data that was associated with an lnode through a
call to <code>di_lnode_private_set(3DEVINFO)</code>.</p>
</dd>
<dt class="hdlist1"><code>di_link_private_set(3DEVINFO)</code></dt>
<dd>
<p>Associate the specified data with the specified link. This association
enables you to traverse links in the snapshot.</p>
</dd>
<dt class="hdlist1"><code>di_link_private_get(3DEVINFO)</code></dt>
<dd>
<p>Retrieve a pointer to data that was associated with a link through a
call to <code>di_link_private_set(3DEVINFO)</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="print-system-configuration-command-interfaces"><a class="anchor" href="#print-system-configuration-command-interfaces"></a>2.63.2. Print System Configuration Command Interfaces</h4>
<div class="paragraph">
<p>displaying kernel device usage information</p>
</div>
<div class="paragraph">
<p>device usage</p>
</div>
<div class="paragraph">
<p>The <code>prtconf(8)</code> command is enhanced to display kernel device usage
information. The default <code>prtconf(8)</code> output is not changed. Device
usage information is displayed when you specify the verbose option (<code>v</code>)
with the <code>prtconf(8)</code> command. Usage information about a particular
device is displayed when you specify a path to that device on the
<code>prtconf(8)</code> command line.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>prtconf -v</code></dt>
<dd>
<p>Display device minor node and device usage information. Show kernel
consumers and the minor nodes each kernel consumer currently has open.</p>
</dd>
<dt class="hdlist1"><code>prtconf</code> &lt;path&gt;</dt>
<dd>
<p>Display device usage information for the device specified by
&lt;path&gt;.</p>
</dd>
<dt class="hdlist1"><code>prtconf -a</code> &lt;path&gt;</dt>
<dd>
<p>Display device usage information for the device specified by
&lt;path&gt; and all device nodes that are ancestors of
&lt;path&gt;.</p>
</dd>
<dt class="hdlist1"><code>prtconf -c</code> &lt;path&gt;</dt>
<dd>
<p>Display device usage information for the device specified by
&lt;path&gt; and all device nodes that are children of
&lt;path&gt;.</p>
</dd>
</dl>
</div>
<div id="exegp" class="paragraph">
<p>Device Usage Information</p>
</div>
<div class="paragraph">
<p>When you want usage information about a particular device, the value of
the &lt;path&gt; parameter can be any valid device path.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf /dev/cfg/c0
SUNW,isptwo, instance #0</pre>
</div>
</div>
<div id="exegs" class="paragraph">
<p>Ancestor Node Usage Information</p>
</div>
<div class="paragraph">
<p>To display usage information about a particular device and all device
nodes that are ancestors of that particular device, specify the <code>a</code> flag
with the <code>prtconf(8)</code> command. Ancestors include all nodes up to the
root of the device tree. If you specify the <code>a</code> flag with the
<code>prtconf(8)</code> command, then you must also specify a device &lt;path&gt;
name.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf -a /dev/cfg/c0
SUNW,Sun-Fire
    ssm, instance #0
        pci, instance #0
            pci, instance #0
                SUNW,isptwo, instance #0</pre>
</div>
</div>
<div id="exegw" class="paragraph">
<p>Child Node Usage Information</p>
</div>
<div class="paragraph">
<p>To display usage information about a particular device and all device
nodes that are children of that particular device, specify the <code>c</code> flag
with the <code>prtconf(8)</code> command. If you specify the <code>c</code> flag with the
<code>prtconf(8)</code> command, then you must also specify a device &lt;path&gt;
name.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf -c /dev/cfg/c0
SUNW,isptwo, instance #0
    sd (driver not attached)
    st (driver not attached)
    sd, instance #1
    sd, instance #0
    sd, instance #6
    st, instance #1 (driver not attached)
    st, instance #0 (driver not attached)
    st, instance #2 (driver not attached)
    st, instance #3 (driver not attached)
    st, instance #4 (driver not attached)
    st, instance #5 (driver not attached)
    st, instance #6 (driver not attached)
    ses, instance #0 (driver not attached)
    ...</pre>
</div>
</div>
<div id="exego" class="paragraph">
<p>Layering and Device Minor Node Information – Keyboard</p>
</div>
<div class="paragraph">
<p>To display device layering and device minor node information about a
particular device, specify the <code>v</code> flag with the <code>prtconf(8)</code> command.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf -v /dev/kbd
conskbd, instance #0
    System properties:
        ...
    Device Layered Over:
        mod=kb8042 dev=(101,0)
            dev_path=/isa/i8042@1,60/keyboard@0
    Device Minor Nodes:
        dev=(103,0)
            dev_path=/pseudo/conskbd@0:kbd
                spectype=chr type=minor
                dev_link=/dev/kbd
        dev=(103,1)
            dev_path=/pseudo/conskbd@0:conskbd
                spectype=chr type=internal
            Device Minor Layered Under:
                mod=wc accesstype=chr
                    dev_path=/pseudo/wc@0</pre>
</div>
</div>
<div class="paragraph">
<p>This example shows that the <code>/dev/kbd</code> device is layered on top of the
hardware keyboard device (<code>/isa/i8042@1,60/keyboard@0</code>). This example
also shows that the <code>/dev/kbd</code> device has two device minor nodes. The
first minor node has a <code>/dev</code> link that can be used to access the node.
The second minor node is an internal node that is not accessible through
the file system. The second minor node has been opened by the <code>wc</code>
driver, which is the workstation console. Compare the output from this
example to the output from <a href="#exegq">example_title</a>.</p>
</div>
<div id="exegn" class="paragraph">
<p>Layering and Device Minor Node Information – Network Device</p>
</div>
<div class="paragraph">
<p>This example shows which devices are using the currently plumbed network
device.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% prtconf -v /dev/iprb0
pci1028,145, instance #0
    Hardware properties:
        ...
    Interrupt Specifications:
        ...
    Device Minor Nodes:
        dev=(27,1)
            dev_path=/pci@0,0/pci8086,244e@1e/pci1028,145@c:iprb0
                spectype=chr type=minor
                alias=/dev/iprb0
        dev=(27,4098)
            dev_path=&lt;clone&gt;
            Device Minor Layered Under:
                mod=udp6 accesstype=chr
                    dev_path=/pseudo/udp6@0
        dev=(27,4097)
            dev_path=&lt;clone&gt;
            Device Minor Layered Under:
                mod=udp accesstype=chr
                    dev_path=/pseudo/udp@0
        dev=(27,4096)
            dev_path=&lt;clone&gt;
            Device Minor Layered Under:
                mod=udp accesstype=chr
                    dev_path=/pseudo/udp@0</pre>
</div>
</div>
<div class="paragraph">
<p>This example shows that the <code>iprb0</code> device has been linked under <code>udp</code>
and <code>udp6</code>. Notice that no paths are shown to the minor nodes that <code>udp</code>
and <code>udp6</code> are using. No paths are shown in this case because the minor
nodes were created through <code>clone</code> opens of the <code>iprb</code> driver, and
therefore there are no file system paths by which these nodes can be
accessed. Compare the output from this example to the output from
<a href="#exegv">example_title</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="device-user-command-interfaces"><a class="anchor" href="#device-user-command-interfaces"></a>2.63.3. Device User Command Interfaces</h4>
<div class="paragraph">
<p>display device usage information</p>
</div>
<div class="paragraph">
<p>device usage</p>
</div>
<div class="paragraph">
<p>The <code>fuser(8)</code> command is enhanced to display device usage information.
The <code>fuser(8)</code> command displays device usage information only if
&lt;path&gt; represents a device minor node. The <code>d</code> flag is valid for
the <code>fuser(8)</code> command only if you specify a &lt;path&gt; that
represents a device minor node.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fuser</code> &lt;path&gt;</dt>
<dd>
<p>Display information about application device consumers and kernel
device consumers if &lt;path&gt; represents a device minor node.</p>
</dd>
<dt class="hdlist1"><code>fuser -d</code> &lt;path&gt;</dt>
<dd>
<p>Display all users of the underlying device that is associated with the
device minor node represented by &lt;path&gt;.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Kernel device consumers are reported in one of the following four
formats. Kernel device consumers always are surrounded by square
brackets (<code>[]</code>).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        [kernel_module_name]
        [kernel_module_name,dev_path=path]
        [kernel_module_name,dev=(major,minor)]
        [kernel_module_name,dev=(major,minor),dev_path=path]</pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>fuser(8)</code> command displays file or device users, the output
consists of a process ID on <code>stdout</code> followed by a character on
<code>stderr</code>. The character on <code>stderr</code> describes how the file or device is
being used. All kernel consumer information is displayed to <code>stderr</code>. No
kernel consumer information is displayed to <code>stdout</code>.</p>
</div>
<div class="paragraph">
<p>If you do not use the <code>d</code> flag, then the <code>fuser(8)</code> command reports
consumers of only the device minor node that is specified by
&lt;path&gt;. If you use the <code>d</code> flag, then the <code>fuser(8)</code> command
reports consumers of the device node that underlies the minor node
specified by &lt;path&gt;. The following example illustrates the
difference in report output in these two cases.</p>
</div>
<div id="exegv" class="paragraph">
<p>Consumers of Underlying Device Nodes</p>
</div>
<div class="paragraph">
<p>Most network devices clone their minor node when the device is opened.
If you request device usage information for the clone minor node, the
usage information might show that no process is using the device. If
instead you request device usage information for the underlying device
node, the usage information might show that a process is using the
device. In this example, no device consumers are reported when only a
device &lt;path&gt; is passed to the <code>fuser(8)</code> command. When the <code>d</code>
flag is used, the output shows that the device is being accessed by
<code>udp</code> and <code>udp6</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% fuser /dev/iprb0
/dev/iprb0:
% fuser -d /dev/iprb0
/dev/iprb0:  [udp,dev_path=/pseudo/udp@0] [udp6,dev_path=/pseudo/udp6@0]</pre>
</div>
</div>
<div class="paragraph">
<p>Compare the output from this example to the output from
<a href="#exegn">example_title</a>.</p>
</div>
<div id="exegq" class="paragraph">
<p>Consumer of the Keyboard Device</p>
</div>
<div class="paragraph">
<p>In this example, a kernel consumer is accessing <code>/dev/kbd</code>. The kernel
consumer that is accessing the <code>/dev/kbd</code> device is the workstation
console driver.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% fuser -d /dev/kbd
/dev/kbd:  [genunix] [wc,dev_path=/pseudo/wc@0]</pre>
</div>
</div>
<div class="paragraph">
<p>Compare the output from this example to the output from
<a href="#exego">example_title</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_designing_specific_kinds_of_device_drivers"><a class="anchor" href="#_designing_specific_kinds_of_device_drivers"></a>3. Designing Specific Kinds of Device Drivers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The second part of the book provides design information that is specific
to the type of driver:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#drivers-for-character-devices">Drivers for Character Devices</a> describes drivers
for character-oriented devices.</p>
</li>
<li>
<p><a href="#drivers-for-block-devices">Drivers for Block Devices</a> describes drivers for a
block-oriented devices.</p>
</li>
<li>
<p><a href="#scsi-target-drivers">SCSI Target Drivers</a> outlines the Sun Common SCSI
Architecture (SCSA) and the requirements for SCSI target drivers.</p>
</li>
<li>
<p><a href="#scsi-host-bus-adapter-drivers">SCSI Host Bus Adapter Drivers</a> explains how to
apply SCSA to SCSI Host Bus Adapter (HBA) drivers.</p>
</li>
<li>
<p><a href="#drivers-for-network-devices">Drivers for Network Devices</a> describes the Generic LAN
driver (GLD), a illumos network driver that uses STREAMS technology and
the Data Link Provider Interface (DLPI).</p>
</li>
<li>
<p><a href="#usb-drivers">USB Drivers</a> describes how to write a client USB device
driver using the USBA 2.0 framework.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="drivers-for-character-devices"><a class="anchor" href="#drivers-for-character-devices"></a>3.1. Drivers for Character Devices</h3>
<div class="paragraph">
<p>A <em>character device</em> does not have physically addressable storage media,
such as tape drives or serial ports, where I/O is normally performed in
a byte stream. This chapter describes the structure of a character
device driver, focusing in particular on entry points for character
drivers. In addition, this chapter describes the use of <code>physio(9F)</code> and
<code>aphysio(9F)</code> in the context of synchronous and asynchronous I/O
transfers.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#overview-of-the-character-driver-structure">Overview of the Character Driver Structure</a></p>
</li>
<li>
<p><a href="#character-device-autoconfiguration">Character Device Autoconfiguration</a></p>
</li>
<li>
<p><a href="#device-access-character-drivers">Device Access (Character Drivers)</a></p>
</li>
<li>
<p><a href="#io-request-handling">I/O Request Handling</a></p>
</li>
<li>
<p><a href="#mapping-device-memory">Mapping Device Memory</a></p>
</li>
<li>
<p><a href="#multiplexing-io-on-file-descriptors">Multiplexing I/O on File Descriptors</a></p>
</li>
<li>
<p><a href="#miscellaneous-io-control">Miscellaneous I/O Control</a></p>
</li>
<li>
<p><a href="#32-bit-and-64-bit-data-structure-macros">32-bit and 64-bit Data Structure Macros</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-of-the-character-driver-structure"><a class="anchor" href="#overview-of-the-character-driver-structure"></a>3.2. Overview of the Character Driver Structure</h3>
<div class="paragraph">
<p><a href="#character-fig-3">Character Driver Roadmap</a> shows data structures
and routines that define the structure of a character device driver.
Device drivers typically include the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Device-loadable driver section</p>
</li>
<li>
<p>Device configuration section</p>
</li>
<li>
<p>Character driver entry points</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The shaded device access section in the following figure illustrates
character driver entry points.</p>
</div>
<div id="character-fig-3" class="imageblock">
<div class="content">
<img src="figures/character-view.png" alt="Diagram shows structures and entry points for character device drivers.">
</div>
<div class="title">Figure 12. Character Driver Roadmap</div>
</div>
<div class="paragraph">
<p>Associated with each device driver is a <code>dev_ops(9S)</code> structure,
which in turn refers to a <code>cb_ops(9S)</code> structure. These structures
contain pointers to the driver entry points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>open(9E)</code></p>
</li>
<li>
<p><code>close(9E)</code></p>
</li>
<li>
<p><code>read(9E)</code></p>
</li>
<li>
<p><code>write(9E)</code></p>
</li>
<li>
<p><code>ioctl(9E)</code></p>
</li>
<li>
<p><code>chpoll(9E)</code></p>
</li>
<li>
<p><code>aread(9E)</code></p>
</li>
<li>
<p><code>awrite(9E)</code></p>
</li>
<li>
<p><code>mmap(9E)</code></p>
</li>
<li>
<p><code>devmap(9E)</code></p>
</li>
<li>
<p><code>segmap(9E)</code></p>
</li>
<li>
<p><code>prop_op(9E)</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some
of these entry points can be replaced with <code>nodev(9F)</code> or <code>nulldev(9F)</code>
as appropriate.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="character-device-autoconfiguration"><a class="anchor" href="#character-device-autoconfiguration"></a>3.3. Character Device Autoconfiguration</h3>
<div class="paragraph">
<p><code>attach(9E)</code> routine should perform the common initialization tasks that
all devices require, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocating per-instance state structures</p>
</li>
<li>
<p>Registering device interrupts</p>
</li>
<li>
<p>Mapping the device&#8217;s registers</p>
</li>
<li>
<p>Initializing mutex variables and condition variables</p>
</li>
<li>
<p>Creating power-manageable components</p>
</li>
<li>
<p>Creating minor nodes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#attach-entry-point"> Entry Point</a> for code examples of these tasks.</p>
</div>
<div class="paragraph">
<p>Character device drivers create minor
nodes of type <code>S_IFCHR</code>. A minor node of <code>S_IFCHR</code> causes a
character special file that represents the node to eventually appear in
the <code>/devices</code> hierarchy.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical <code>attach(9E)</code> routine for character
drivers. Properties that are associated with the device are commonly
declared in an <code>attach</code> routine. This example uses a predefined <code>Size</code>
property. <code>Size</code> is the equivalent of the <code>Nblocks</code> property for getting
the size of partition in a block device. If, for example, you are doing
character I/O on a disk device, you might use <code>Size</code> to get the size of
a partition. Since <code>Size</code> is a 64-bit property, you must use a 64-bit
property interface. In this case, you use
<code>ddi_prop_update_int64(9F)</code>. See <a href="#device-properties">Device
Properties</a> for more information about properties.</p>
</div>
<div id="character-40982" class="paragraph">
<p>Character Driver <code>attach</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
  int instance = ddi_get_instance(dip);
  switch (cmd) {
  case DDI_ATTACH:
      /*
       * Allocate a state structure and initialize it.
       * Map the device's registers.
       * Add the device driver's interrupt handler(s).
       * Initialize any mutexes and condition variables.
       * Create power manageable components.
       *
       * Create the device's minor node. Note that the node_type
       * argument is set to DDI_NT_TAPE.
       */
       if (ddi_create_minor_node(dip, minor_name, S_IFCHR,
           instance, DDI_NT_TAPE, 0) == DDI_FAILURE)
{
           /* Free resources allocated so far. */
           /* Remove any previously allocated minor nodes. */
           ddi_remove_minor_node(dip, NULL);
           return (DDI_FAILURE);
       }
      /*
       * Create driver properties like "Size." Use "Size"
       * instead of "size" to ensure the property works
       * for large bytecounts.
       */
       xsp-&gt;Size = size_of_device_in_bytes;
       maj_number = ddi_driver_major(dip);
       if (ddi_prop_update_int64(makedevice(maj_number, instance),
           dip, "Size", xsp-&gt;Size) != DDI_PROP_SUCCESS) {
           cmn_err(CE_CONT, "%s: cannot create Size property\n",
               ddi_get_name(dip));
               /* Free resources allocated so far. */
           return (DDI_FAILURE);
       }
      /* ... */
      return (DDI_SUCCESS);
case DDI_RESUME:
      /* See the "Power Management" chapter in this book. */
default:
      return (DDI_FAILURE);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-access-character-drivers"><a class="anchor" href="#device-access-character-drivers"></a>3.4. Device Access (Character Drivers)</h3>
<div class="paragraph">
<p>Access to a device by one or more
application programs is controlled through the <code>open(9E)</code> and
<code>close(9E)</code> entry points. An <code>open(2)</code> system call to a special file
representing a character device always causes a call to the <code>open(9E)</code>
routine for the driver. For a particular minor device, <code>open(9E)</code> can be
called many times. The <code>close(9E)</code> routine is called only when the final
reference to a device is removed. If the device is accessed through file
descriptors, the final call to <code>close(9E)</code> can occur as a result of a
<code>close(2)</code> or <code>exit(2)</code> system call. If the device is accessed through
memory mapping, the final call to <code>close(9E)</code> can occur as a result of a
<code>munmap(2)</code> system call.</p>
</div>
<div class="sect3">
<h4 id="open-entry-point-character-drivers"><a class="anchor" href="#open-entry-point-character-drivers"></a>3.4.1. <code>open</code> Entry Point (Character Drivers)</h4>
<div class="paragraph">
<p>device access functions</p>
</div>
<div class="paragraph">
<p>character drivers</p>
</div>
<div class="paragraph">
<p>character device driver</p>
</div>
<div class="paragraph">
<p>The primary function of <code>open</code> is to verify that the open request is
allowed. The syntax for <code>open(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxopen(dev_t *devp, int flag, int otyp, cred_t *credp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;devp&gt;</dt>
<dd>
<p>Pointer to a device number. The <code>open</code> routine is passed a pointer so
that the driver can change the minor number. With this pointer,
drivers can dynamically create minor instances of the device. An
example would be a pseudo terminal driver that creates a new
pseudo-terminal whenever the driver is opened. A driver that
dynamically chooses the minor number normally creates only one minor
device node in <code>attach(9E)</code> with
<code>ddi_create_minor_node(9F)</code>, then changes the minor number
component of <code>*devp</code> using <code>makedevice(9F)</code> and <code>getmajor(9F)</code>:
+</p>
</dd>
</dl>
</div>
<div class="literalblock">
<div class="content">
<pre>*devp = makedevice(getmajor(*devp), new_minor);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  +
  You do not have to call `ddi++_++create++_++minor++_++node(9F)` for
  the new minor. A driver must not change the major number of
  `++*++devp`. The driver must keep track of available minor numbers
  internally.
++&lt;++flag++&gt;++::
  Flag with bits to indicate whether the device is opened for reading
  (`FREAD`), writing (`FWRITE`), or both. User threads issuing the
  `open(2)` system call can also request exclusive access to the device
  (`FEXCL`) or specify that the open should not block for any reason
  (`FNDELAY`), but the driver must enforce both cases. A driver for a
  write-only device such as a printer might consider an `open(9E)` for
  reading invalid.
++&lt;++otyp++&gt;++::
  Integer that indicates how `open` was called. The driver must check
  that the value of ++&lt;++otyp++&gt;++ is appropriate for the device. For
  character drivers, ++&lt;++otyp++&gt;++ should be `OTYP++_++CHR` (see the
  `open(9E)` man page).
++&lt;++credp++&gt;++::
  Pointer to a credential structure containing information about the
  caller, such as the user ID and group IDs. Drivers should not examine
  the structure directly, but should instead use `drv++_++priv(9F)` to
  check for the common case of root privileges. In this example, only
  `root` or a user with the PRIV++_++SYS++_++DEVICES privilege is
  allowed to open the device for writing.</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a character driver <code>open(9E)</code> routine.</p>
</div>
<div id="character-27851" class="paragraph">
<p>Character Driver <code>open(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxopen(dev_t *devp, int flag, int otyp, cred_t *credp)
{
    minor_t        instance;

    if (getminor(*devp)         /* if device pointer is invalid */
        return (EINVAL);
    instance = getminor(*devp); /* one-to-one example mapping */
    /* Is the instance attached? */
    if (ddi_get_soft_state(statep, instance) == NULL)
        return (ENXIO);
    /* verify that otyp is appropriate */
    if (otyp != OTYP_CHR)
        return (EINVAL);
    if ((flag &amp; FWRITE) &amp;&amp; drv_priv(credp) == EPERM)
        return (EPERM);
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="close-entry-point-character-drivers"><a class="anchor" href="#close-entry-point-character-drivers"></a>3.4.2. <code>close</code> Entry Point (Character Drivers)</h4>
<div class="paragraph">
<p>The syntax for <code>close(9E)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxclose(dev_t dev, int flag, int otyp, cred_t *credp);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>close</code>
should perform any cleanup necessary to finish using the minor device,
and prepare the device (and driver) to be opened again. For example, the
open routine might have been invoked with the exclusive access (<code>FEXCL</code>)
flag. A call to <code>close(9E)</code> would allow additional open routines to
continue. Other functions that <code>close(9E)</code> might perform are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Waiting for I/O to drain from output buffers before returning</p>
</li>
<li>
<p>Rewinding a tape (tape device)</p>
</li>
<li>
<p>Hanging up the phone line (modem device)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A driver that waits for I/O to drain could wait forever if draining
stalls due to external conditions such as flow control. See
<a href="#threads-unable-to-receive-signals">Threads Unable to Receive Signals</a> for information about how
to avoid this problem.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="io-request-handling"><a class="anchor" href="#io-request-handling"></a>3.5. I/O Request Handling</h3>
<div class="paragraph">
<p>section discusses I/O request processing in detail.</p>
</div>
<div class="sect3">
<h4 id="user-addresses"><a class="anchor" href="#user-addresses"></a>3.5.1. User Addresses</h4>
<div class="paragraph">
<p>When a user thread issues a <code>write(2)</code>
system call, the thread passes the address of a buffer in user space:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>char buffer[] = "python";
count = write(fd, buffer, strlen(buffer) + 1);</pre>
</div>
</div>
<div class="paragraph">
<p>The system builds a <code>uio(9S)</code> structure to describe this transfer by
allocating an <code>iovec(9S)</code> structure and setting the <code>iov_base</code> field
to the address passed to <code>write(2)</code>, in this case, <code>buffer</code>. The
<code>uio(9S)</code> structure is passed to the driver <code>write(9E)</code> routine. See
<a href="#vectored-io">Vectored I/O</a> for more information about the
<code>uio(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>The address in the <code>iovec(9S)</code> is in user space, not kernel space. Thus,
the address is neither guaranteed to be currently in memory nor to be a
valid address. In either case, accessing a user address directly from
the device driver or from the kernel could crash the system. Thus,
device drivers should never access user addresses directly. Instead, a
data transfer routine in the illumos DDI/DKI should be used to transfer
data into or out of the kernel. These routines can handle page faults.
The DDI/DKI routines can bring in the proper user page to continue the
copy transparently. Alternatively, the routines can return an error on
an invalid access.</p>
</div>
<div class="paragraph">
<p><code>copyout(9F)</code>
can be used to copy data from kernel space to user space. <code>copyin(9F)</code>
can copy data from user space to kernel space. <code>ddi_copyout(9F)</code> and
<code>ddi_copyin(9F)</code> operate similarly but are to be used in the
<code>ioctl(9E)</code> routine. <code>copyin(9F)</code> and <code>copyout(9F)</code> can be used on the
buffer described by each <code>iovec(9S)</code> structure, or <code>uiomove(9F)</code> can
perform the entire transfer to or from a contiguous area of driver or
device memory.</p>
</div>
</div>
<div class="sect3">
<h4 id="vectored-io"><a class="anchor" href="#vectored-io"></a>3.5.2. Vectored I/O</h4>
<div class="paragraph">
<p>In character drivers, transfers are described by a <code>uio(9S)</code> structure.
The <code>uio(9S)</code> structure contains information about the direction and
size of the transfer, plus an array of buffers for one end of the
transfer. The other end is the device.</p>
</div>
<div class="paragraph">
<p>The <code>uio(9S)</code> structure contains the following members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">iovec_t       *uio_iov;       /* base address of the iovec */
                              /* buffer description array */
int           uio_iovcnt;     /* the number of iovec structures */
off_t         uio_offset;     /* 32-bit offset into file where */
                              /* data is transferred from or to */
offset_t      uio_loffset;    /* 64-bit offset into file where */
                              /* data is transferred from or to */
uio_seg_t     uio_segflg;     /* identifies the type of I/O transfer */
                              /* UIO_SYSSPACE:  kernel &lt;-&gt; kernel */
                              /* UIO_USERSPACE: kernel &lt;-&gt; user */
short         uio_fmode;      /* file mode flags (not driver setTable) */
daddr_t       uio_limit;      /* 32-bit ulimit for file (maximum */
                              /* block offset). not driver settable. */
diskaddr_t    uio_llimit;     /* 64-bit ulimit for file (maximum block */
                              /* block offset). not driver settable. */
int           uio_resid;      /* amount (in bytes) not */
                              /* transferred on completion */</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>uio(9S)</code> structure is passed to the driver <code>read(9E)</code> and <code>write(9E)</code>
entry points. This structure is generalized to support what is called
<em>gather-write</em> and <em>scatter-read</em>. When writing to a device, the data
buffers to be written do not have to be contiguous in application
memory. Similarly, data that is transferred from a device into memory
comes off in a contiguous stream but can go into noncontiguous areas of
application memory. See the <code>readv(2)</code>, <code>writev(2)</code>, <code>pread(2)</code>, and
<code>pwrite(2)</code> man pages for more information on scatter-gather I/O.</p>
</div>
<div class="paragraph">
<p>Each buffer is described by an
<code>iovec(9S)</code> structure. This structure contains a pointer to the data
area and the number of bytes to be transferred.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">caddr_t    iov_base;    /* address of buffer */
int        iov_len;     /* amount to transfer */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>uio</code> structure contains a pointer to an array of <code>iovec(9S)</code>
structures. The base address of this array is held in <code>uio_iov</code>, and
the number of elements is stored in <code>uio_iovcnt</code>.</p>
</div>
<div class="paragraph">
<p>The <code>uio_offset</code> field contains the 32-bit offset into the device at
which the application needs to begin the transfer. <code>uio_loffset</code> is
used for 64-bit file offsets. If the device does not support the notion
of an offset, these fields can be safely ignored. The driver should
interpret either <code>uio_offset</code> or <code>uio_loffset</code>, but not both. If
the driver has set the <code>D_64BIT</code> flag in the <code>cb_ops(9S)</code>
structure, that driver should use <code>uio_loffset</code>.</p>
</div>
<div class="paragraph">
<p>The <code>uio_resid</code> field starts out as the number of bytes to be
transferred, that is, the sum of all the <code>iov_len</code> fields in
<code>uio_iov</code>. This field <em>must</em> be set by the driver to the number of
bytes that were <em>not</em> transferred before returning. The <code>read(2)</code> and
<code>write(2)</code> system calls use the return value from the <code>read(9E)</code> and
<code>write(9E)</code> entry points to determine failed transfers. If a failure
occurs, these routines return -1. If the return value indicates success,
the system calls return the number of bytes requested minus
<code>uio_resid</code>. If <code>uio_resid</code> is not changed by the driver, the
<code>read(2)</code> and <code>write(2)</code> calls return 0. A return value of 0 indicates
end-of-file, even though all the data has been transferred.</p>
</div>
<div class="paragraph">
<p>The support routines <code>uiomove(9F)</code>, <code>physio(9F)</code>, and <code>aphysio(9F)</code>
update the <code>uio(9S)</code> structure directly. These support routines update
the device offset to account for the data transfer. Neither the
<code>uio_offset</code> or <code>uio_loffset</code> fields need to be adjusted when
the driver is used with a seekable device that uses the concept of
position. I/O performed to a device in this manner is constrained by the
maximum possible value of <code>uio_offset</code> or <code>uio_loffset</code>. An
example of such a usage is raw I/O on a disk.</p>
</div>
<div class="paragraph">
<p>If the device has no concept of position, the driver can take the
following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save <code>uio_offset</code> or <code>uio_loffset</code>.</p>
</li>
<li>
<p>Perform the I/O operation.</p>
</li>
<li>
<p>Restore <code>uio_offset</code> or <code>uio_loffset</code> to the field&#8217;s initial
value.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>I/O that is performed to a device in this manner is not constrained by
the maximum possible value of <code>uio_offset</code> or <code>uio_loffset</code>. An
example of this type of usage is I/O on a serial line.</p>
</div>
<div class="paragraph">
<p>The following example shows one way to preserve <code>uio_loffset</code> in the
<code>read(9E)</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxread(dev_t dev, struct uio *uio_p, cred_t *cred_p)
{
    offset_t off;
    /* ... */
    off = uio_p-&gt;uio_loffset;  /* save the offset */
    /* do the transfer */
    uio_p-&gt;uio_loffset = off;  /* restore it */
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="differences-between-synchronous-and-asynchronous-io"><a class="anchor" href="#differences-between-synchronous-and-asynchronous-io"></a>3.5.3. Differences Between Synchronous and Asynchronous I/O</h4>
<div class="paragraph">
<p>Data transfers can be <em>synchronous</em> or
<em>asynchronous</em>. The determining factor is whether the entry point that
schedules the transfer returns immediately or waits until the I/O has
been completed.</p>
</div>
<div class="paragraph">
<p><code>read(9E)</code> and <code>write(9E)</code> entry points are synchronous entry points.
The transfer must not return until the I/O is complete. Upon return from
the routines, the process knows whether the transfer has succeeded.</p>
</div>
<div class="paragraph">
<p><code>aread(9E)</code> and <code>awrite(9E)</code> entry points are asynchronous entry points.
Asynchronous entry points schedule the I/O and return immediately. Upon
return, the process that issues the request knows that the I/O is
scheduled and that the status of the I/O must be determined later. In
the meantime, the process can perform other operations.</p>
</div>
<div class="paragraph">
<p>With an asynchronous I/O request to the
kernel, the process is not required to wait while the I/O is in process.
A process can perform multiple I/O requests and allow the kernel to
handle the data transfer details. Asynchronous I/O requests enable
applications such as transaction processing to use concurrent
programming methods to increase performance or response time. Any
performance boost for applications that use asynchronous I/O, however,
comes at the expense of greater programming complexity.</p>
</div>
</div>
<div class="sect3">
<h4 id="data-transfer-methods"><a class="anchor" href="#data-transfer-methods"></a>3.5.4. Data Transfer Methods</h4>
<div class="paragraph">
<p>Data can be transferred using either programmed I/O or DMA. These data
transfer methods can be used either by synchronous or by asynchronous
entry points, depending on the capabilities of the device.</p>
</div>
<div class="sect4">
<h5 id="programmed-io-transfers"><a class="anchor" href="#programmed-io-transfers"></a>Programmed I/O Transfers</h5>
<div class="paragraph">
<p>I/O devices rely on the CPU to perform the data transfer. Programmed I/O
data transfers are identical to other read and write operations for
device registers. Various data access routines are used to read or store
values to device memory.</p>
</div>
<div class="paragraph">
<p><code>uiomove(9F)</code> can be used
to transfer data to some programmed I/O devices. <code>uiomove(9F)</code> transfers
data between the user space, as defined by the <code>uio(9S)</code> structure, and
the kernel. <code>uiomove</code> can handle page faults, so the memory to which
data is transferred need not be locked down. <code>uiomove</code> also updates the
<code>uio_resid</code> field in the <code>uio(9S)</code> structure. The following example
shows one way to write a ramdisk <code>read(9E)</code> routine. It uses synchronous
I/O and relies on the presence of the following fields in the ramdisk
state structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">caddr_t    ram;        /* base address of ramdisk */
int        ramsize;    /* size of the ramdisk */</code></pre>
</div>
</div>
<div id="character-31915" class="paragraph">
<p>Ramdisk <code>read(9E)</code> Routine Using <code>uiomove(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
rd_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
     rd_devstate_t     *rsp;

     rsp = ddi_get_soft_state(rd_statep, getminor(dev));
     if (rsp == NULL)
       return (ENXIO);
     if (uiop-&gt;uio_offset &gt;= rsp-&gt;ramsize)
       return (EINVAL);
     /*
      * uiomove takes the offset into the kernel buffer,
      * the data transfer count (minimum of the requested and
      * the remaining data), the UIO_READ flag, and a pointer
      * to the uio structure.
      */
     return (uiomove(rsp-&gt;ram + uiop-&gt;uio_offset,
         min(uiop-&gt;uio_resid, rsp-&gt;ramsize - uiop-&gt;uio_offset),
         UIO_READ, uiop));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example of programmed I/O would be a driver that writes data one
byte at a time directly to the device&#8217;s memory. Each byte is retrieved
from the <code>uio(9S)</code> structure by using <code>uwritec(9F)</code>. The byte is then
sent to the device. <code>read(9E)</code> can use <code>ureadc(9F)</code> to transfer a byte
from the device to the area described by the <code>uio(9S)</code> structure.</p>
</div>
<div id="character-ex-15" class="paragraph">
<p>Programmed I/O <code>write(9E)</code> Routine Using <code>uwritec(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{
    int    value;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL)
        return (ENXIO);
    /* if the device implements a power manageable component, do this: */
    pm_busy_component(xsp-&gt;dip, 0);
    if (xsp-&gt;pm_suspended)
        pm_raise_power(xsp-&gt;dip, normal power);

    while (uiop-&gt;uio_resid &gt; 0) {
        /*
         * do the programmed I/O access
         */
        value = uwritec(uiop);
        if (value == -1)
               return (EFAULT);
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;data,
            (uint8_t)value);
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
            START_TRANSFER);
        /*
         * this device requires a ten microsecond delay
         * between writes
         */
        drv_usecwait(10);
    }
    pm_idle_component(xsp-&gt;dip, 0);
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="dma-transfers-synchronous"><a class="anchor" href="#dma-transfers-synchronous"></a>DMA Transfers (Synchronous)</h5>
<div class="paragraph">
<p>drivers generally use <code>physio(9F)</code> to do the setup work for DMA
transfers in <code>read(9E)</code> and <code>write(9E)</code>, as is shown in
<a href="#character-36010">example_title</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int physio(int (*strat)(struct buf *), struct buf *bp,
     dev_t dev, int rw, void (*mincnt)(struct buf *),
     struct uio *uio);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>physio(9F)</code> requires the driver to provide the address of a
<code>strategy(9E)</code> routine. <code>physio(9F)</code> ensures that memory space is locked
down, that is, memory cannot be paged out, for the duration of the data
transfer. This lock-down is necessary for DMA transfers because DMA
transfers cannot handle page faults. <code>physio(9F)</code> also provides an
automated way of breaking a larger transfer into a series of smaller,
more manageable ones. See <a href="#minphys-entry-point"> Entry Point</a> for more
information.</p>
</div>
<div id="character-36010" class="paragraph">
<p><code>read(9E)</code> and <code>write(9E)</code> Routines Using <code>physio(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxread(dev_t dev, struct uio *uiop, cred_t *credp)
{
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_READ, xxminphys, uiop);
     return (ret);
}

static int
xxwrite(dev_t dev, struct uio *uiop, cred_t *credp)
{
     struct xxstate *xsp;
     int ret;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     ret = physio(xxstrategy, NULL, dev, B_WRITE, xxminphys, uiop);
     return (ret);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the call to <code>physio(9F)</code>, <code>xxstrategy</code> is a pointer to the driver
<code>strategy</code> routine. Passing <code>NULL</code> as the <code>buf(9S)</code> structure pointer
tells <code>physio(9F)</code> to allocate a <code>buf(9S)</code> structure. If the driver must
provide <code>physio(9F)</code> with a <code>buf(9S)</code> structure, <code>getrbuf(9F)</code> should be
used to allocate the structure. <code>physio(9F)</code> returns zero if the
transfer completes successfully, or an error number on failure. After
calling <code>strategy(9E)</code>, <code>physio(9F)</code> calls <code>biowait(9F)</code> to block until
the transfer either completes or fails. The return value of <code>physio(9F)</code>
is determined by the error field in the <code>buf(9S)</code> structure set by
<code>bioerror(9F)</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="dma-transfers-asynchronous"><a class="anchor" href="#dma-transfers-asynchronous"></a>DMA Transfers (Asynchronous)</h5>
<div class="paragraph">
<p>drivers that support <code>aread(9E)</code> and <code>awrite(9E)</code> use <code>aphysio(9F)</code>
instead of <code>physio(9F)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int aphysio(int (*strat)(struct buf *), int (*cancel)(struct buf *),
     dev_t dev, int rw, void (*mincnt)(struct buf *),
     struct aio_req *aio_reqp);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The address of <code>anocancel(9F)</code> is the only value that can currently be
passed as the second argument to <code>aphysio(9F)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>aphysio(9F)</code> requires the driver to pass the address of a
<code>strategy(9E)</code> routine. <code>aphysio(9F)</code> ensures that memory space is
locked down, that is, cannot be paged out, for the duration of the data
transfer. This lock-down is necessary for DMA transfers because DMA
transfers cannot handle page faults. <code>aphysio(9F)</code> also provides an
automated way of breaking a larger transfer into a series of smaller,
more manageable ones. See <a href="#minphys-entry-point"> Entry Point</a> for more
information.</p>
</div>
<div class="paragraph">
<p><a href="#character-36010">example_title</a> and
<a href="#character-29697">example_title</a> demonstrate that the
<code>aread(9E)</code> and <code>awrite(9E)</code> entry points differ only slightly from the
<code>read(9E)</code> and <code>write(9E)</code> entry points. The difference is primarily in
their use of <code>aphysio(9F)</code> instead of <code>physio(9F)</code>.</p>
</div>
<div id="character-29697" class="paragraph">
<p><code>aread(9E)</code> and <code>awrite(9E)</code> Routines Using <code>aphysio(9F)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxaread(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_READ,
     xxminphys, aiop));
}

static int
xxawrite(dev_t dev, struct aio_req *aiop, cred_t *cred_p)
{
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
        return (ENXIO);
     return (aphysio(xxstrategy, anocancel, dev, B_WRITE,
     xxminphys,aiop));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the call to <code>aphysio(9F)</code>, <code>xxstrategy</code> is a pointer to the driver
strategy routine. &lt;aiop&gt; is a pointer to the <code>aio_req(9S)</code>
structure. &lt;aiop&gt; is passed to <code>aread(9E)</code> and <code>awrite(9E)</code>.
<code>aio_req(9S)</code> describes where the data is to be stored in user
space. <code>aphysio(9F)</code> returns zero if the I/O request is scheduled
successfully or an error number on failure. After calling
<code>strategy(9E)</code>, <code>aphysio(9F)</code> returns without waiting for the I/O to
complete or fail.</p>
</div>
</div>
<div class="sect4">
<h5 id="minphys-entry-point"><a class="anchor" href="#minphys-entry-point"></a><code>minphys</code> Entry Point</h5>
<div class="paragraph">
<p><code>minphys</code> entry point is a pointer to a function to be called by
<code>physio(9F)</code> or <code>aphysio(9F)</code>. The purpose of &lt;xxminphys&gt; is to
ensure that the size of the requested transfer does not exceed a
driver-imposed limit. If the user requests a larger transfer,
<code>strategy(9E)</code> is called repeatedly, requesting no more than the imposed
limit at a time. This approach is important because DMA resources are
limited. Drivers for slow devices, such as printers, should be careful
not to tie up resources for a long time.</p>
</div>
<div class="paragraph">
<p>Usually, a driver passes the address of the kernel function
<code>minphys(9F)</code>, but the driver can define its own <code>xxminphys</code> routine
instead. The job of <code>xxminphys</code> is to keep the <code>b_bcount</code> field of
the <code>buf(9S)</code> structure under a driver&#8217;s limit. The driver should adhere
to other system limits as well. For example, the driver&#8217;s <code>xxminphys</code>
routine should call the system <code>minphys(9F)</code> routine after setting the
<code>b_bcount</code> field and before returning.</p>
</div>
<div id="character-ex-17" class="paragraph">
<p><code>minphys(9F)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define XXMINVAL (512 &lt;&lt; 10)    /* 512 KB */
static void
xxminphys(struct buf *bp)
{
    if (bp-&gt;b_bcount &gt; XXMINVAL)
        bp-&gt;b_bcount = XXMINVAL
    minphys(bp);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="strategy-entry-point"><a class="anchor" href="#strategy-entry-point"></a><code>strategy</code> Entry Point</h5>
<div class="paragraph">
<p><code>strategy(9E)</code> routine originated in block drivers. The strategy
function got its name from implementing a strategy for efficient queuing
of I/O requests to a block device. A driver for a character-oriented
device can also use a <code>strategy(9E)</code> routine. In the character I/O model
presented here, <code>strategy(9E)</code> does not maintain a queue of requests,
but rather services one request at a time.</p>
</div>
<div class="paragraph">
<p>In the following example, the <code>strategy(9E)</code> routine for a
character-oriented DMA device allocates DMA resources for synchronous
data transfer. <code>strategy</code> starts the command by programming the device
register. See <a href="#direct-memory-access-dma">Direct Memory Access (DMA)</a> for a detailed
description.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>strategy(9E)</code> does not receive a device number (<code>dev_t</code>) as a
parameter. Instead, the device number is retrieved from the <code>b_edev</code>
field of the <code>buf(9S)</code> structure passed to <code>strategy(9E)</code>.
</td>
</tr>
</table>
</div>
<div id="character-35679" class="paragraph">
<p><code>strategy(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstrategy(struct buf *bp)
{
     minor_t            instance;
     struct xxstate     *xsp;
     ddi_dma_cookie_t   cookie;

     instance = getminor(bp-&gt;b_edev);
     xsp = ddi_get_soft_state(statep, instance);
     /* ... */
      * If the device has power manageable components,
      * mark the device busy with pm_busy_components(9F),
      * and then ensure that the device is
      * powered up by calling pm_raise_power(9F).
      */
     /* Set up DMA resources with ddi_dma_alloc_handle(9F) and
      * ddi_dma_buf_bind_handle(9F).
      */
     xsp-&gt;bp = bp; /* remember bp */
     /* Program DMA engine and start command */
     return (0);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although <code>strategy</code> is declared to return an <code>int</code>, <code>strategy</code> must
always return zero.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On completion of the DMA transfer, the device generates an interrupt,
causing the interrupt routine to be called. In the following example,
<code>xxintr</code> receives a pointer to the state structure for the device that
might have generated the interrupt.</p>
</div>
<div id="character-28538" class="paragraph">
<p>Interrupt Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     if ( /* device did not interrupt */ ) {
        return (DDI_INTR_UNCLAIMED);
     }
     if ( /* error */ ) {
        /* error handling */
     }
     /* Release any resources used in the transfer, such as DMA resources.
      * ddi_dma_unbind_handle(9F) and ddi_dma_free_handle(9F)
      * Notify threads that the transfer is complete.
      */
     biodone(xsp-&gt;bp);
     return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The driver indicates an error by calling <code>bioerror(9F)</code>. The driver must
call <code>biodone(9F)</code> when the transfer is complete or after indicating an
error with <code>bioerror(9F)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-device-memory-1"><a class="anchor" href="#mapping-device-memory-1"></a>3.6. Mapping Device Memory</h3>
<div class="paragraph">
<p>Some devices, such as frame
buffers, have memory that is directly accessible to user threads by way
of memory mapping. Drivers for these devices typically do not support
the <code>read(9E)</code> and <code>write(9E)</code> interfaces. Instead, these drivers
support memory mapping with the <code>devmap(9E)</code> entry point. For example, a
frame buffer driver might implement the <code>devmap(9E)</code> entry point to
enable the frame buffer to be mapped in a user thread.</p>
</div>
<div class="paragraph">
<p>The <code>devmap(9E)</code> entry point is called to export device memory or kernel
memory to user applications. The <code>devmap</code> function is called from
<code>devmap_setup(9F)</code> inside <code>segmap(9E)</code> or on behalf of
<code>ddi_devmap_segmap(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>segmap(9E)</code> entry point is
responsible for setting up a memory mapping requested by an <code>mmap(2)</code>
system call. Drivers for many memory-mapped devices use
<code>ddi_devmap_segmap(9F)</code> as the entry point rather than defining
their own <code>segmap(9E)</code> routine.</p>
</div>
<div class="paragraph">
<p>See <a href="#mapping-device-and-kernel-memory">Mapping Device and Kernel Memory</a> and
<a href="#device-context-management">Device Context Management</a> for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="multiplexing-io-on-file-descriptors"><a class="anchor" href="#multiplexing-io-on-file-descriptors"></a>3.7. Multiplexing I/O on File Descriptors</h3>
<div class="paragraph">
<p>A thread sometimes needs
to handle I/O on more than one file descriptor. One example is an
application program that needs to read the temperature from a
temperature-sensing device and then report the temperature to an
interactive display. A program that makes a read request with no data
available should not block while waiting for the temperature before
interacting with the user again.</p>
</div>
<div class="paragraph">
<p>The <code>poll(2)</code> system call provides
users with a mechanism for multiplexing I/O over a set of file
descriptors that reference open files. <code>poll(2)</code> identifies those file
descriptors on which a program can send or receive data without
blocking, or on which certain events have occurred.</p>
</div>
<div class="paragraph">
<p>enable a program to poll a character driver, the driver must implement
the <code>chpoll(9E)</code> entry point. The system calls <code>chpoll(9E)</code> when a user
process issues a <code>poll(2)</code> system call on a file descriptor associated
with the device. The <code>chpoll(9E)</code> entry point routine is used by
non-STREAMS character device drivers that need to support polling.</p>
</div>
<div class="paragraph">
<p>The <code>chpoll(9E)</code> function uses the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxchpoll(dev_t dev, short events, int anyyet, short *reventsp,
    struct pollhead **phpp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>chpoll(9E)</code> entry point, the driver must follow these rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement the following algorithm when the <code>chpoll(9E)</code> entry point is
called:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if ( /* events are satisfied now */ ) {
    *reventsp = mask_of_satisfied_events
} else {
    *reventsp = 0;
    if (!anyyet)
        *phpp = &amp;local_pollhead_structure;
}
return (0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <code>chpoll(9E)</code> man page for a discussion of events to check. The
<code>chpoll(9E)</code> entry point should then return the mask of satisfied events
by setting the return events in &lt;*reventsp&gt;.</p>
</div>
<div class="paragraph">
<p>If no events have occurred, the return field for the events is cleared.
If the &lt;anyyet&gt; field is not set, the driver must return an
instance of the <code>pollhead</code> structure. The <code>pollhead</code> structure is
usually allocated in a state structure. The <code>pollhead</code> structure should
be treated as opaque by the driver. None of the <code>pollhead</code> fields should
be referenced.</p>
</div>
</li>
<li>
<p>Call <code>pollwakeup(9F)</code> whenever a device condition of type <code>events</code>,
listed in <a href="#character-25342">example_title</a>, occurs. This
function should be called only with one event at a time. You can call
<code>pollwakeup(9F)</code> in the interrupt routine when the condition has
occurred.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#character-25342">example_title</a> and
<a href="#character-38661">example_title</a> show how to implement the
polling discipline and how to use <code>pollwakeup(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to handle the <code>POLLIN</code> and <code>POLLERR</code>
events. The driver first reads the status register to determine the
current state of the device. The parameter <code>events</code> specifies which
conditions the driver should check. If an appropriate condition has
occurred, the driver sets that bit in &lt;*reventsp&gt;. If none of
the conditions has occurred and if &lt;anyyet&gt; is not set, the
address of the <code>pollhead</code> structure is returned in &lt;*phpp&gt;.</p>
</div>
<div id="character-25342" class="paragraph">
<p><code>chpoll(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxchpoll(dev_t dev, short events, int anyyet,
    short *reventsp, struct pollhead **phpp)
{
     uint8_t status;
     short revent;
     struct xxstate *xsp;

     xsp = ddi_get_soft_state(statep, getminor(dev));
     if (xsp == NULL)
         return (ENXIO);
     revent = 0;
     /*
      * Valid events are:
      * POLLIN | POLLOUT | POLLPRI | POLLHUP | POLLERR
      * This example checks only for POLLIN and POLLERR.
      */
     status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
     if ((events &amp; POLLIN) &amp;&amp; data available to read) {
        revent |= POLLIN;
     }
     if (status &amp; DEVICE_ERROR) {
        revent |= POLLERR;
     }
     /* if nothing has occurred */
     if (revent == 0) {
        if (!anyyet) {
        *phpp = &amp;xsp-&gt;pollhead;
        }
     }
       *reventsp = revent;
     return (0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>pollwakeup(9F)</code> function.
The <code>pollwakeup(9F)</code> function usually is called in the interrupt routine
when a supported condition has occurred. The interrupt routine reads the
status from the status register and checks for the conditions. The
routine then calls <code>pollwakeup(9F)</code> for each event to possibly notify
polling threads that they should check again. Note that <code>pollwakeup(9F)</code>
should not be called with any locks held, since deadlock could result if
another routine tried to enter <code>chpoll(9E)</code> and grab the same lock.</p>
</div>
<div id="character-38661" class="paragraph">
<p>Interrupt Routine Supporting <code>chpoll(9E)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static u_int
xxintr(caddr_t arg)
{
     struct xxstate *xsp = (struct xxstate *)arg;
     uint8_t    status;
     /* normal interrupt processing */
     /* ... */
     status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
     if (status &amp; DEVICE_ERROR) {
        pollwakeup(&amp;xsp-&gt;pollhead, POLLERR);
     }
     if ( /* just completed a read */ ) {
        pollwakeup(&amp;xsp-&gt;pollhead, POLLIN);
     }
     /* ... */
     return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="miscellaneous-io-control"><a class="anchor" href="#miscellaneous-io-control"></a>3.8. Miscellaneous I/O Control</h3>
<div class="paragraph">
<p>I/O</p>
</div>
<div class="paragraph">
<p>miscellaneous control of</p>
</div>
<div class="paragraph">
<p><code>ioctl(9E)</code> routine is called when a user thread issues an <code>ioctl(2)</code>
system call on a file descriptor associated with the device. The I/O
control mechanism is a catchall for getting and setting device-specific
parameters. This mechanism is frequently used to set a device-specific
mode, either by setting internal driver software flags or by writing
commands to the device. The control mechanism can also be used to return
information to the user about the current device state. In short, the
control mechanism can do whatever the application and driver need to
have done.</p>
</div>
<div class="sect3">
<h4 id="ioctl-entry-point-character-drivers"><a class="anchor" href="#ioctl-entry-point-character-drivers"></a>3.8.1. <code>ioctl</code> Entry Point (Character Drivers)</h4>
<div class="paragraph">
<p>character drivers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
     cred_t *credp, int *rvalp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;cmd&gt; parameter indicates which command <code>ioctl(9E)</code> should
perform. By convention, the driver with which an I/O control command is
associated is indicated in bits 8-15 of the command. Typically, the
ASCII code of a character represents the driver. The driver-specific
command in bits 0-7. The creation of some I/O commands is illustrated in
the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define XXIOC            (`x' &lt;&lt; 8)   /* `x' is a character that represents device xx */
#define XX_GET_STATUS    (XXIOC | 1)  /* get status register */
#define XX_SET_CMD       (XXIOC | 2)  /* send command */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interpretation of &lt;arg&gt; depends on the command. I/O control
commands should be documented in the driver documentation or a man page.
The command should also be defined in a public header file, so that
applications can determine the name of the command, what the command
does, and what the command accepts or returns as &lt;arg&gt;. Any data
transfer of &lt;arg&gt; into or out of the driver must be performed by
the driver.</p>
</div>
<div class="paragraph">
<p>Certain classes of devices such as frame buffers or disks must support
standard sets of I/O control requests. These standard I/O control
interfaces are documented in the illumos Reference Manual Collection.
For example, <code>fbio(4I)</code> documents the I/O controls that frame buffers
must support, and <code>dkio(4I)</code> documents standard disk I/O controls. See
<a href="#miscellaneous-io-control">Miscellaneous I/O Control</a> for more information on
I/O controls.</p>
</div>
<div class="paragraph">
<p>Drivers must use <code>ddi_copyin(9F)</code> to transfer &lt;arg&gt; data
from the user-level application to the kernel level. Drivers must use
<code>ddi_copyout(9F)</code> to transfer data from the kernel to the user
level. Failure to use <code>ddi_copyin(9F)</code> or <code>ddi_copyout(9F)</code> can
result in panics under two conditions. A panic occurs if the
architecture separates the kernel and user address spaces, or if the
user address has been swapped out.</p>
</div>
<div class="paragraph">
<p><code>ioctl(9E)</code> is usually a switch statement with a case for each supported
<code>ioctl(9E)</code> request.</p>
</div>
<div id="character-15130" class="paragraph">
<p><code>ioctl(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    uint8_t        csr;
    struct xxstate     *xsp;

    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_GET_STATUS:
        csr = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
        if (ddi_copyout(&amp;csr, (void *)arg, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        break;
    case XX_SET_CMD:
        if (ddi_copyin((void *)arg, &amp;csr, sizeof (uint8_t), mode) != 0) {
            return (EFAULT);
        }
        ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr, csr);
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;cmd&gt; variable identifies a specific device control
operation. A problem can occur if &lt;arg&gt; contains a user virtual
address. <code>ioctl(9E)</code> must call <code>ddi_copyin(9F)</code> or
<code>ddi_copyout(9F)</code> to transfer data between the data structure in the
application program pointed to by &lt;arg&gt; and the driver. In
<a href="#character-15130">example_title</a>, for the case of an
<code>XX_GET_STATUS</code> request, the contents of
&lt;xsp-&gt;regp-&gt;csr&gt; are copied to the address in
&lt;arg&gt;. <code>ioctl(9E)</code> can store in &lt;*rvalp&gt; any integer
value as the return value to the <code>ioctl(2)</code> system call that makes a
successful request. Negative return values, such as -1, should be
avoided. Many application programs assume that negative values indicate
failure.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates an application that uses the I/O
controls discussed in the previous paragraph.</p>
</div>
<div id="character-20506" class="paragraph">
<p>Using <code>ioctl(9E)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;sys/types.h&gt;
#include "xxio.h"     /* contains device's ioctl cmds and args */
main(void)
{
     uint8_t    status;
     /* ... */
     /*
      * read the device status
      */
     if (ioctl(fd, XX_GET_STATUS, &amp;status) == -1) {
         /* error handling */
     }
     printf("device status %x\n", status);
     exit(0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="io-control-support-for-64-bit-capable-device-drivers"><a class="anchor" href="#io-control-support-for-64-bit-capable-device-drivers"></a>3.8.2. I/O Control Support for 64-Bit Capable Device Drivers</h4>
<div class="paragraph">
<p>The illumos kernel runs
in 64-bit mode on suitable hardware, supporting both 32-bit applications
and 64-bit applications. A 64-bit device driver is required to support
I/O control commands from programs of both sizes. The difference between
a 32-bit program and a 64-bit program is the C language type model. A
32-bit program is ILP32, and a 64-bit program is LP64. See
<a href="#making-a-device-driver-64-bit-ready">appendix_title</a> for information on C data type
models.</p>
</div>
<div class="paragraph">
<p>If data that flows between programs and the kernel is not identical in
format, the driver must be able to handle the model mismatch. Handling a
model mismatch requires making appropriate adjustments to the data.</p>
</div>
<div class="paragraph">
<p>To determine whether a model mismatch exists, the <code>ioctl(9E)</code> mode
parameter passes the data model bits to the driver. As
<a href="#character-38299">example_title</a> shows, the mode parameter is
then passed to <code>ddi_model_convert_from(9F)</code> to determine
whether any model conversion is necessary.</p>
</div>
<div class="paragraph">
<p>A flag subfield of the mode argument is used to pass the data model to
the <code>ioctl(9E)</code> routine. The flag is set to one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DATAMODEL_ILP32</code></p>
</li>
<li>
<p><code>DATAMODEL_LP64</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>FNATIVE</code> is conditionally defined to match the data model of the kernel
implementation. The <code>FMODELS</code> mask should be used to extract the flag
from the <code>mode</code> argument. The driver can then examine the data model
explicitly to determine how to copy the application data structure.</p>
</div>
<div class="paragraph">
<p>The DDI function <code>ddi_model_convert_from(9F)</code> is a
convenience routine that can assist some drivers with their <code>ioctl</code>
calls. The function takes the data type model of the user application as
an argument and returns one of the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DDI_MODEL_ILP32</code> – Convert from ILP32 application</p>
</li>
<li>
<p><code>DDI_MODEL_NONE</code> – No conversion needed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DDI_MODEL_NONE</code> is returned if no data conversion is necessary,
as occurs when the application and driver have the same data model.
<code>DDI_MODEL_ILP32</code> is returned to a driver that is compiled to
the LP64 model and that communicates with a 32-bit application.</p>
</div>
<div class="paragraph">
<p>In the following example, the driver copies a data structure that
contains a user address. The data structure changes size from ILP32 to
LP64. Accordingly, the 64-bit driver uses a 32-bit version of the
structure when communicating with a 32-bit application.</p>
</div>
<div id="character-38299" class="paragraph">
<p><code>ioctl(9E)</code> Routine to Support 32-bit Applications and 64-bit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct args32 {
    uint32_t    addr;    /* 32-bit address in LP64 */
    int     len;
}
struct args {
    caddr_t     addr;    /* 64-bit address in LP64 */
    int     len;
}

static int
xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
    cred_t *credp, int *rvalp)
{
    struct  xxstate  *xsp;
    struct  args     a;
    xsp = ddi_get_soft_state(statep, getminor(dev));
    if (xsp == NULL) {
        return (ENXIO);
    }
    switch (cmd) {
    case XX_COPYIN_DATA:
        switch(ddi_model_convert_from(mode)) {
        case DDI_MODEL_ILP32:
        {
            struct args32 a32;

            /* copy 32-bit args data shape */
            if (ddi_copyin((void *)arg, &amp;a32,
                sizeof (struct args32), mode) != 0) {
                return (EFAULT);
            }
            /* convert 32-bit to 64-bit args data shape */
            a.addr = a32.addr;
            a.len = a32.len;
            break;
        }
        case DDI_MODEL_NONE:
            /* application and driver have same data model. */
            if (ddi_copyin((void *)arg, &amp;a, sizeof (struct args),
                mode) != 0) {
                return (EFAULT);
            }
        }
        /* continue using data shape in native driver data model. */
        break;

    case XX_COPYOUT_DATA:
        /* copyout handling */
        break;
    default:
        /* generic "ioctl unknown" error */
        return (ENOTTY);
    }
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handling-copyout-overflow"><a class="anchor" href="#handling-copyout-overflow"></a>3.8.3. Handling <code>copyout</code> Overflow</h4>
<div class="paragraph">
<p>Sometimes a driver needs to copy out a native quantity that no longer
fits in the 32-bit sized structure. In this case, the driver should
return EOVERFLOW to the caller. EOVERFLOW serves as an indication that
the data type in the interface is too small to hold the value to be
returned, as shown in the following example.</p>
</div>
<div id="character-ex-6" class="paragraph">
<p>Handling <code>copyout(9F)</code> Overflow</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
 cred_t *cr, int *rval_p)
{
    struct resdata res;
    /* body of driver */
    switch (ddi_model_convert_from(mode &amp; FMODELS)) {
    case DDI_MODEL_ILP32: {
        struct resdata32 res32;

        if (res.size &gt; UINT_MAX)
                return (EOVERFLOW);
        res32.size = (size32_t)res.size;
        res32.flag = res.flag;
        if (ddi_copyout(&amp;res32,
            (void *)arg, sizeof (res32), mode))
                return (EFAULT);
    }
    break;

    case DDI_MODEL_NONE:
        if (ddi_copyout(&amp;res, (void *)arg, sizeof (res), mode))
                return (EFAULT);
        break;
    }
    return (0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>[[32-bit-and-64-bit-data-structure-macros]]
=== 32-bit and 64-bit Data Structure Macros</p>
</div>
<div class="paragraph">
<p>The method in <a href="#character-ex-6">example_title</a> works well for
many drivers. An alternate scheme is to use the data structure macros
that are provided in `&lt;sys/model.h&gt;`to move data between the
application and the kernel. These macros make the code less cluttered
and behave identically, from a functional perspective.</p>
</div>
<div id="character-ex-8" class="paragraph">
<p>Using Data Structure Macros to Move Data</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    xxioctl(dev_t dev, int cmd, intptr_t arg, int mode,
        cred_t *cr, int *rval_p)
    {
        STRUCT_DECL(opdata, op);

        if (cmd != OPONE)
            return (ENOTTY);

        STRUCT_INIT(op, mode);

        if (copyin((void *)arg,
            STRUCT_BUF(op), STRUCT_SIZE(op)))
                return (EFAULT);

        if (STRUCT_FGET(op, flag) != XXACTIVE ||
            STRUCT_FGET(op, size) &gt; XXSIZE)
                return (EINVAL);
        xxdowork(device_state, STRUCT_FGET(op, size));
        return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-do-the-structure-macros-work"><a class="anchor" href="#how-do-the-structure-macros-work"></a>3.8.4. How Do the Structure Macros Work?</h4>
<div class="paragraph">
<p>In a 64-bit device driver, structure macros enable the use of the same
piece of kernel memory by data structures of both sizes. The memory
buffer holds the contents of the native form of the data structure, that
is, the LP64 form, and the ILP32 form. Each structure access is
implemented by a conditional expression. When compiled as a 32-bit
driver, only one data model, the native form, is supported. No
conditional expression is used.</p>
</div>
<div class="paragraph">
<p>The 64-bit versions of the macros depend on the definition of a shadow
version of the data structure. The shadow version describes the 32-bit
interface with fixed-width types. The name of the shadow data structure
is formed by appending “32” to the name of the native data structure.
For convenience, place the definition of the shadow structure in the
same file as the native structure to ease future maintenance costs.</p>
</div>
<div class="paragraph">
<p>The macros can take the following arguments:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;structname&gt;</dt>
<dd>
<p>The structure name of the native form of the data structure as entered
after the <code>struct</code> keyword.</p>
</dd>
<dt class="hdlist1">&lt;umodel&gt;</dt>
<dd>
<p>A flag word that contains the user data model, such as <code>FILP32</code> or
<code>FLP64</code>, extracted from the mode parameter of <code>ioctl(9E)</code>.</p>
</dd>
<dt class="hdlist1">&lt;handle&gt;</dt>
<dd>
<p>The name used to refer to a particular instance of a structure that is
manipulated by these macros.</p>
</dd>
<dt class="hdlist1">&lt;fieldname&gt;</dt>
<dd>
<p>The name of the field within the structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="when-to-use-structure-macros"><a class="anchor" href="#when-to-use-structure-macros"></a>3.8.5. When to Use Structure Macros</h4>
<div class="paragraph">
<p>Macros enable you to make in-place references only to the fields of a
data item. Macros do not provide a way to take separate code paths that
are based on the data model. Macros should be avoided if the number of
fields in the data structure is large. Macros should also be avoided if
the frequency of references to these fields is high.</p>
</div>
<div class="paragraph">
<p>Macros hide many of the differences between data models in the
implementation of the macros. As a result, code written with this
interface is generally easier to read. When compiled as a 32-bit driver,
the resulting code is compact without needing clumsy <code>#ifdefs</code>, but
still preserves type checking.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring-and-initializing-structure-handles"><a class="anchor" href="#declaring-and-initializing-structure-handles"></a>3.8.6. Declaring and Initializing Structure Handles</h4>
<div class="paragraph">
<p><code>STRUCT_DECL(9F)</code> and <code>STRUCT_INIT(9F)</code> can be used to declare
and initialize a handle and space for decoding an <code>ioctl</code> on the stack.
<code>STRUCT_HANDLE(9F)</code> and <code>STRUCT_SET_HANDLE(9F)</code> declare and
initialize a handle without allocating space on the stack. The latter
macros can be useful if the structure is very large, or is contained in
some other data structure.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the <code>STRUCT_DECL(9F)</code> and <code>STRUCT_HANDLE(9F)</code> macros
expand to data structure declarations, these macros should be grouped
with such declarations in C code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The macros for declaring and initializing structures are as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>STRUCT_DECL(</code>&lt;structname&gt;<code>,</code> &lt;handle&gt;<code>)</code></dt>
<dd>
<p>Declares a <em>structure handle</em>that is called <code>handle</code> for a
&lt;structname&gt; data structure. <code>STRUCT_DECL</code> allocates space
for its native form on the stack. The native form is assumed to be
larger than or equal to the ILP32 form of the structure.</p>
</dd>
<dt class="hdlist1"><code>STRUCT_INIT(</code>&lt;handle&gt;<code>,</code> &lt;umodel&gt;<code>)</code></dt>
<dd>
<p>Initializes the data model for &lt;handle&gt; to <code>umodel</code>. This
macro must be invoked before any access is made to a structure handle
declared with <code>STRUCT_DECL(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>STRUCT_HANDLE(</code>&lt;structname&gt;<code>,</code> &lt;handle&gt;<code>)</code></dt>
<dd>
<p>  Declares a <em>structure handle</em> that is called <code>handle</code>. Contrast with
  <code>STRUCT_DECL(9F)</code>.
<code>STRUCT_SET_HANDLE(</code>&lt;handle&gt;<code>,</code> &lt;umodel&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;addr&gt;<code>)</code></dt>
<dd>
<p>Initializes the data model for &lt;handle&gt; to &lt;umodel&gt;,
and sets &lt;addr&gt; as the buffer used for subsequent
manipulation. Invoke this macro before accessing a structure handle
declared with <code>STRUCT_DECL(9F)</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="operations-on-structure-handles"><a class="anchor" href="#operations-on-structure-handles"></a>3.8.7. Operations on Structure Handles</h4>
<div class="paragraph">
<p>The macros for performing operations on structures are as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>size_t STRUCT_SIZE(</code>&lt;handle&gt;<code>)</code></dt>
<dd>
<p>  Returns the size of the structure referred to by &lt;handle&gt;,
  according to its embedded data model.
<code>typeof</code> &lt;fieldname&gt; <code>STRUCT_FGET(</code>&lt;handle&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;fieldname&gt;<code>)</code></dt>
<dd>
<p>  Returns the indicated field in the data structure referred to by
  &lt;handle&gt;. This field is a non-pointer type.
<code>typeof</code> &lt;fieldname&gt; <code>STRUCT_FGETP(</code>&lt;handle&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;fieldname&gt;<code>)</code></dt>
<dd>
<p>  Returns the indicated field in the data structure referred to by
  &lt;handle&gt;. This field is a pointer type.
<code>STRUCT_FSET(</code>&lt;handle&gt;<code>,</code> &lt;fieldname&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;val&gt;<code>)</code></dt>
<dd>
<p>  Sets the indicated field in the data structure referred to by
  &lt;handle&gt; to value &lt;val&gt;. The type of &lt;val&gt;
  should match the type of &lt;fieldname&gt;. The field is a
  non-pointer type.
<code>STRUCT_FSETP(</code>&lt;handle&gt;<code>,</code> &lt;fieldname&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;val&gt;<code>)</code></dt>
<dd>
<p>  Sets the indicated field in the data structure referred to by
  &lt;handle&gt; to value &lt;val&gt;. The field is a pointer type.
<code>typeof</code> &lt;fieldname&gt; <code>*STRUCT_FADDR(</code>&lt;handle&gt;<code>,</code></p>
</dd>
<dt class="hdlist1">&lt;fieldname&gt;<code>)</code></dt>
<dd>
<p>Returns the address of the indicated field in the data structure
referred to by &lt;handle&gt;.</p>
</dd>
<dt class="hdlist1"><code>struct structname *STRUCT_BUF(</code>&lt;handle&gt;<code>)</code></dt>
<dd>
<p>Returns a pointer to the native structure described by
&lt;handle&gt;.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="other-operations"><a class="anchor" href="#other-operations"></a>3.8.8. Other Operations</h4>
<div class="paragraph">
<p>Some miscellaneous structure macros follow:</p>
</div>
<div class="paragraph">
<p><code>size_t SIZEOF_STRUCT(</code>&lt;struct_name&gt;<code>,</code>
&lt;datamodel&gt;<code>)</code>::
  Returns the size of &lt;struct_name&gt;, which is based on the
  given data model.
<code>size_t SIZEOF_PTR(</code>&lt;datamodel&gt;<code>)</code>::
  Returns the size of a pointer based on the given data model.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="drivers-for-block-devices"><a class="anchor" href="#drivers-for-block-devices"></a>3.9. Drivers for Block Devices</h3>
<div class="paragraph">
<p>This chapter describes the structure of block device drivers. The kernel
views a block device as a set of randomly accessible logical blocks. The
file system uses a list of <code>buf(9S)</code> structures to buffer the data
blocks between a block device and the user space. Only block devices can
support a file system.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#block-driver-structure-overview">Block Driver Structure Overview</a></p>
</li>
<li>
<p><a href="#file-io">File I/O</a></p>
</li>
<li>
<p><a href="#block-device-autoconfiguration">Block Device Autoconfiguration</a></p>
</li>
<li>
<p><a href="#controlling-device-access">Controlling Device Access</a></p>
</li>
<li>
<p><a href="#synchronous-data-transfers-block-drivers">Synchronous Data Transfers (Block Drivers)</a></p>
</li>
<li>
<p><a href="#asynchronous-data-transfers-block-drivers">Asynchronous Data Transfers (Block Drivers)</a></p>
</li>
<li>
<p><a href="#dump-and-print-entry-points"> and Entry Points</a></p>
</li>
<li>
<p><a href="#disk-device-drivers">Disk Device Drivers</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="block-driver-structure-overview"><a class="anchor" href="#block-driver-structure-overview"></a>3.10. Block Driver Structure Overview</h3>
<div class="paragraph">
<p><a href="#block-fig-3">Block Driver Roadmap</a> shows data structures and
routines that define the structure of a block device driver. Device
drivers typically include the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Device-loadable driver section</p>
</li>
<li>
<p>Device configuration section</p>
</li>
<li>
<p>Device access section</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The shaded device access section in the following figure illustrates
entry points for block drivers.</p>
</div>
<div id="block-fig-3" class="imageblock">
<div class="content">
<img src="figures/block-view.png" alt="Diagram shows structures and entry points for block device drivers.">
</div>
<div class="title">Figure 13. Block Driver Roadmap</div>
</div>
<div class="paragraph">
<p>with each device driver is a <code>dev_ops(9S)</code> structure, which in turn
refers to a <code>cb_ops(9S)</code> structure. See <a href="#driver-autoconfiguration">Driver
Autoconfiguration</a> for details on driver data structures.</p>
</div>
<div class="paragraph">
<p>Block device drivers provide these entry points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>open(9E)</code></p>
</li>
<li>
<p><code>close(9E)</code></p>
</li>
<li>
<p><code>strategy(9E)</code></p>
</li>
<li>
<p><code>print(9E)</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some of the entry points can be replaced by <code>nodev(9F)</code> or <code>nulldev(9F)</code>
as appropriate.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="file-io"><a class="anchor" href="#file-io"></a>3.11. File I/O</h3>
<div class="paragraph">
<p>file system I/O</p>
</div>
<div class="paragraph">
<p>I/O</p>
</div>
<div class="paragraph">
<p>file system structure</p>
</div>
<div class="paragraph">
<p>A file system is a tree-structured hierarchy of directories and files.
Some file systems, such as the UNIX File System (UFS), reside on
block-oriented devices. File systems are created by <code>format(8)</code> and
<code>newfs(8)</code>.</p>
</div>
<div class="paragraph">
<p>When an application issues a <code>read(2)</code> or <code>write(2)</code> system call to an
ordinary file on the UFS file system, the file system can call the
device driver <code>strategy(9E)</code> entry point for the block device on which
the file system resides. The file system code can call <code>strategy(9E)</code>
several times for a single <code>read(2)</code> or <code>write(2)</code> system call.</p>
</div>
<div class="paragraph">
<p>The file system code determines the logical device address, or <em>logical
block number</em>, for each ordinary file block. A block I/O request is then
built in the form of a <code>buf(9S)</code> structure directed at the block device.
The driver <code>strategy(9E)</code> entry point then interprets the <code>buf(9S)</code>
structure and completes the request.</p>
</div>
</div>
<div class="sect2">
<h3 id="block-device-autoconfiguration"><a class="anchor" href="#block-device-autoconfiguration"></a>3.12. Block Device Autoconfiguration</h3>
<div class="paragraph">
<p>of block devices</p>
</div>
<div class="paragraph">
<p><code>attach(9E)</code> should perform the common initialization tasks for each
instance of a device:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocating per-instance state structures</p>
</li>
<li>
<p>Mapping the device&#8217;s registers</p>
</li>
<li>
<p>Registering device interrupts</p>
</li>
<li>
<p>Initializing mutex and condition variables</p>
</li>
<li>
<p>Creating power manageable components</p>
</li>
<li>
<p>Creating minor nodes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Block device drivers create minor nodes of type <code>S_IFBLK</code>. As a
result, a block special file that represents the node appears in the
<code>/devices</code> hierarchy.</p>
</div>
<div class="paragraph">
<p>device names for block devices appear in the <code>/dev/dsk</code> directory, and
consist of a controller number, bus-address number, disk number, and
slice number. These names are created by the <code>devfsadm(8)</code> program if
the node type is set to <code>DDI_NT_BLOCK</code> or
<code>DDI_NT_BLOCK_CHAN</code>. <code>DDI_NT_BLOCK_CHAN</code> should
be specified if the device communicates on a channel, that is, a bus
with an additional level of addressability. SCSI disks are a good
example. <code>DDI_NT_BLOCK_CHAN</code> causes a bus-address field
(t<em>N</em>) to appear in the logical name. <code>DDI_NT_BLOCK</code> should be
used for most other devices.</p>
</div>
<div class="paragraph">
<p>A minor device
refers to a partition on the disk. For each minor device, the driver
must create an <code>nblocks</code> or <code>Nblocks</code> property. This integer property
gives the number of blocks supported by the minor device expressed in
units of <code>DEV_BSIZE</code>, that is, 512 bytes. The file system uses the
<code>nblocks</code> and <code>Nblocks</code> properties to determine device limits. <code>Nblocks</code>
is the 64-bit version of <code>nblocks</code>. <code>Nblocks</code> should be used with
storage devices that can hold over 1 Tbyte of storage per disk. See
<a href="#device-properties">Device Properties</a> for more information.</p>
</div>
<div class="paragraph">
<p><a href="#block-29600">example_title</a> shows a typical <code>attach(9E)</code> entry
point with emphasis on creating the device&#8217;s minor node and the
<code>Nblocks</code> property. Note that because this example uses <code>Nblocks</code> and
not <code>nblocks</code>, <code>ddi_prop_update_int64(9F)</code> is called instead
of <code>ddi_prop_update_int(9F)</code>.</p>
</div>
<div class="paragraph">
<p>a side note, this example shows the use of <code>makedevice(9F)</code> to create a
device number for <code>ddi_prop_update_int64</code>. The <code>makedevice</code>
function makes use of <code>ddi_driver_major(9F)</code>, which generates a
major number from a pointer to a <code>dev_info_t</code> structure. Using
<code>ddi_driver_major</code> is similar to using <code>getmajor(9F)</code>, which
gets a <code>dev_t</code> structure pointer.</p>
</div>
<div id="block-29600" class="paragraph">
<p>Block Driver <code>attach</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    int instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
      /*
       * allocate a state structure and initialize it
       * map the devices registers
       * add the device driver's interrupt handler(s)
       * initialize any mutexes and condition variables
       * read label information if the device is a disk
       * create power manageable components
       *
       * Create the device minor node. Note that the node_type
       * argument is set to DDI_NT_BLOCK.
       */
      if (ddi_create_minor_node(dip, "minor_name", S_IFBLK,
          instance, DDI_NT_BLOCK, 0) == DDI_FAILURE) {
          /* free resources allocated so far */
          /* Remove any previously allocated minor nodes */
          ddi_remove_minor_node(dip, NULL);
          return (DDI_FAILURE);
      }
      /*
       * Create driver properties like "Nblocks". If the device
       * is a disk, the Nblocks property is usually calculated from
       * information in the disk label.  Use "Nblocks" instead of
       * "nblocks" to ensure the property works for large disks.
       */
      xsp-&gt;Nblocks = size;
      /* size is the size of the device in 512 byte blocks */
      maj_number = ddi_driver_major(dip);
      if (ddi_prop_update_int64(makedevice(maj_number, instance), dip,
          "Nblocks", xsp-&gt;Nblocks) != DDI_PROP_SUCCESS) {
          cmn_err(CE_CONT, "%s: cannot create Nblocks property\n",
              ddi_get_name(dip));
          /* free resources allocated so far */
          return (DDI_FAILURE);
      }
      xsp-&gt;open = 0;
      xsp-&gt;nlayered = 0;
      /* ... */
      return (DDI_SUCCESS);

      case DDI_RESUME:
          /* For information, see Chapter 12, "Power Management," in this book. */
      default:
          return (DDI_FAILURE);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controlling-device-access"><a class="anchor" href="#controlling-device-access"></a>3.13. Controlling Device Access</h3>
<div class="paragraph">
<p>This section describes the entry points for <code>open</code> and <code>close</code> functions
in block device drivers. See <a href="#drivers-for-character-devices">Drivers for Character
Devices</a> for more information on <code>open(9E)</code> and <code>close(9E)</code>.</p>
</div>
<div class="sect3">
<h4 id="open-entry-point-block-drivers"><a class="anchor" href="#open-entry-point-block-drivers"></a>3.13.1. <code>open</code> Entry Point (Block Drivers)</h4>
<div class="paragraph">
<p><code>open(9E)</code> entry point is used to gain access to a given device. The
<code>open(9E)</code> routine of a block driver is called when a user thread issues
an <code>open(2)</code> or <code>mount(2)</code> system call on a block special file
associated with the minor device, or when a layered driver calls
<code>open(9E)</code>. See <a href="#file-io">File I/O</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>open</code> entry point should check for the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The device can be opened, that is, the device is online and ready.</p>
</li>
<li>
<p>The device can be opened as requested. The device supports the
operation. The device&#8217;s current state does not conflict with the
request.</p>
</li>
<li>
<p>The caller has permission to open the device.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example demonstrates a block driver <code>open(9E)</code> entry
point.</p>
</div>
<div id="block-40232" class="paragraph">
<p>Block Driver <code>open(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxopen(dev_t *devp, int flags, int otyp, cred_t *credp)
{
    minor_t         instance;
    struct xxstate        *xsp;

    instance = getminor(*devp);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * only honor FEXCL. If a regular open or a layered open
     * is still outstanding on the device, the exclusive open
     * must fail.
     */
    if ((flags &amp; FEXCL) &amp;&amp; (xsp-&gt;open || xsp-&gt;nlayered)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (EAGAIN);
    }
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered++;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 1;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
          return (EINVAL);
    }
    mutex_exit(&amp;xsp-&gt;mu);
    return (0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>otyp</code> argument is used to specify the type of open on the device.
<code>OTYP_BLK</code> is the typical open type for a block device. A device can
be opened several times with <code>otyp</code> set to <code>OTYP_BLK</code>. <code>close(9E)</code>
is called only once when the final close of type <code>OTYP_BLK</code> has
occurred for the device. <code>otyp</code> is set to <code>OTYP_LYR</code> if the device
is being used as a layered device. For every open of type
<code>OTYP_LYR</code>, the layering driver issues a corresponding close of type
<code>OTYP_LYR</code>. The example keeps track of each type of open so the
driver can determine when the device is not being used in <code>close(9E)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="close-entry-point-block-drivers"><a class="anchor" href="#close-entry-point-block-drivers"></a>3.13.2. <code>close</code> Entry Point (Block Drivers)</h4>
<div class="paragraph">
<p>The <code>close(9E)</code>
entry point uses the same arguments as <code>open(9E)</code> with one exception.
<code>dev</code> is the device number rather than a pointer to the device number.</p>
</div>
<div class="paragraph">
<p>The <code>close</code> routine should verify <code>otyp</code> in the same way as was
described for the <code>open(9E)</code> entry point. In the following example,
<code>close</code> must determine when the device can really be closed. Closing is
affected by the number of block opens and layered opens.</p>
</div>
<div id="block-15508" class="paragraph">
<p>Block Device <code>close(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxclose(dev_t dev, int flag, int otyp, cred_t *credp)
{
    minor_t instance;
    struct xxstate *xsp;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (ENXIO);
    mutex_enter(&amp;xsp-&gt;mu);
    switch (otyp) {
      case OTYP_LYR:
          xsp-&gt;nlayered--;
          break;
      case OTYP_BLK:
          xsp-&gt;open = 0;
          break;
      default:
          mutex_exit(&amp;xsp-&gt;mu);
         return (EINVAL);
    }

    if (xsp-&gt;open || xsp-&gt;nlayered) {
        /* not done yet */
        mutex_exit(&amp;xsp-&gt;mu);
        return (0);
    }
    /* cleanup (rewind tape, free memory, etc.) */
    /* wait for I/O to drain */
    mutex_exit(&amp;xsp-&gt;mu);

    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="strategy-entry-point-1"><a class="anchor" href="#strategy-entry-point-1"></a>3.13.3. <code>strategy</code> Entry Point</h4>
<div class="paragraph">
<p>The <code>strategy(9E)</code> entry point is used to read and write
data buffers to and from a block device. The name <em>strategy</em> refers to
the fact that this entry point might implement some optimal strategy for
ordering requests to the device.</p>
</div>
<div class="paragraph">
<p><code>strategy(9E)</code> can be written to process one request at a
time, that is, a synchronous transfer. <code>strategy</code> can also be written to
queue multiple requests to the device, as in an asynchronous transfer.
When choosing a method, the abilities and limitations of the device
should be taken into account.</p>
</div>
<div class="paragraph">
<p>The <code>strategy(9E)</code> routine is passed a pointer to a <code>buf(9S)</code> structure.
This structure describes the transfer request, and contains status
information on return. <code>buf(9S)</code> and <code>strategy(9E)</code> are the focus of
block device operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="buf-structure"><a class="anchor" href="#buf-structure"></a>3.13.4. <code>buf</code> Structure</h4>
<div class="paragraph">
<p>The following <code>buf</code> structure members are
important to block drivers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int           b_flags;       /* Buffer Status */
struct buf    *av_forw;      /* Driver work list link */
struct buf    *av_back;      /* Driver work list link */
size_t        b_bcount;      /* # of bytes to transfer */
union {
    caddr_t   b_addr;        /* Buffer's virtual address */
} b_un;
daddr_t       b_blkno;       /* Block number on device */
diskaddr_t    b_lblkno;      /* Expanded block number on device */
size_t        b_resid;       /* # of bytes not transferred after error */
int           b_error;       /* Expanded error field */
void          *b_private;    /* “opaque” driver private area */
dev_t         b_edev;        /* expanded dev field */</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>av_forw</code> and <code>av_back</code></dt>
<dd>
<p>Pointers that the driver can use to manage a list of buffers by the
driver. See <a href="#asynchronous-data-transfers-block-drivers">Asynchronous Data Transfers (Block
Drivers)</a> for a discussion of the <code>av_forw</code> and <code>av_back</code>
pointers.</p>
</dd>
<dt class="hdlist1"><code>b_bcount</code></dt>
<dd>
<p>Specifies the number of bytes to be transferred by the device.</p>
</dd>
<dt class="hdlist1"><code>b_un.b_addr</code></dt>
<dd>
<p>The kernel virtual address of the data buffer. Only valid after
<code>bp_mapin(9F)</code> call.</p>
</dd>
<dt class="hdlist1"><code>b_blkno</code></dt>
<dd>
<p>The starting 32-bit logical block number on the device for the data
transfer, which is expressed in 512-byte <code>DEV_BSIZE</code> units. The
driver should use either <code>b_blkno</code> or <code>b_lblkno</code> but not both.</p>
</dd>
<dt class="hdlist1"><code>b_lblkno</code></dt>
<dd>
<p>The starting 64-bit logical block number on the device for the data
transfer, which is expressed in 512-byte <code>DEV_BSIZE</code> units. The
driver should use either <code>b_blkno</code> or <code>b_lblkno</code> but not both.</p>
</dd>
<dt class="hdlist1"><code>b_resid</code></dt>
<dd>
<p>Set by the driver to indicate the number of bytes that were not
transferred because of an error. See
<a href="#block-33565">example_title</a> for an example of setting
<code>b_resid</code>. The <code>b_resid</code> member is overloaded. <code>b_resid</code>
is also used by <code>disksort(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>b_error</code></dt>
<dd>
<p>Set to an error number by the driver when a transfer error occurs.
<code>b_error</code> is set in conjunction with the <code>b_flags</code>
<code>B_ERROR</code> bit. See the <code>Intro(9E)</code> man page for details about
error values. Drivers should use <code>bioerror(9F)</code> rather than setting
<code>b_error</code> directly.</p>
</dd>
<dt class="hdlist1"><code>b_flags</code></dt>
<dd>
<p>Flags with status and transfer attributes of the <code>buf</code> structure. If
<code>B_READ</code> is set, the <code>buf</code> structure indicates a transfer from the
device to memory. Otherwise, this structure indicates a transfer from
memory to the device. If the driver encounters an error during data
transfer, the driver should set the <code>B_ERROR</code> field in the
<code>b_flags</code> member. In addition, the driver should provide a more
specific error value in <code>b_error</code>. Drivers should use
<code>bioerror(9F)</code> rather than setting <code>B_ERROR</code>.
+
[CAUTION]
====
Drivers should never clear <code>b_flags</code>.
====</p>
</dd>
<dt class="hdlist1"><code>b_private</code></dt>
<dd>
<p>For exclusive use by the driver to store driver-private data.</p>
</dd>
<dt class="hdlist1"><code>b_edev</code></dt>
<dd>
<p>Contains the device number of the device that was used in the
transfer.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="bp_mapin-structure"><a class="anchor" href="#bp_mapin-structure"></a><code>bp_mapin</code> Structure</h5>
<div class="paragraph">
<p>A <code>buf</code> structure pointer can be passed into the device driver&#8217;s
<code>strategy(9E)</code> routine. However, the data buffer referred to by
<code>b_un.b_addr</code> is not necessarily mapped in the kernel&#8217;s address
space. Therefore, the driver cannot directly access the data. Most
block-oriented devices have DMA capability and therefore do not need to
access the data buffer directly. Instead, these devices use the DMA
mapping routines to enable the device&#8217;s DMA engine to do the data
transfer. For details about using DMA, see <a href="#direct-memory-access-dma">Direct Memory
Access (DMA)</a>.</p>
</div>
<div class="paragraph">
<p>If a driver needs to access the data buffer directly, that driver must
first map the buffer into the kernel&#8217;s address space by using
<code>bp_mapin(9F)</code>. <code>bp_mapout(9F)</code> should be used when the driver
no longer needs to access the data directly.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<code>bp_mapout(9F)</code> should only be called on buffers that have been
allocated and are owned by the device driver. <code>bp_mapout</code> must not
be called on buffers that are passed to the driver through the
<code>strategy(9E)</code> entry point, such as a file system. <code>bp_mapin(9F)</code>
does not keep a reference count. <code>bp_mapout(9F)</code> removes any kernel
mapping on which a layer over the device driver might rely.
===
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="synchronous-data-transfers-block-drivers"><a class="anchor" href="#synchronous-data-transfers-block-drivers"></a>3.14. Synchronous Data Transfers (Block Drivers)</h3>
<div class="paragraph">
<p>This section presents a
simple method for performing synchronous I/O transfers. This method
assumes that the hardware is a simple disk device that can transfer only
one data buffer at a time by using DMA. Another assumption is that the
disk can be spun up and spun down by software command. The device
driver&#8217;s <code>strategy(9E)</code> routine waits for the current request to be
completed before accepting a new request. The device interrupts when the
transfer is complete. The device also interrupts if an error occurs.</p>
</div>
<div class="paragraph">
<p>The steps for performing a synchronous data transfer for a block driver
are as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check for invalid <code>buf(9S)</code> requests.</p>
<div class="paragraph">
<p>Check the <code>buf(9S)</code> structure that is passed to <code>strategy(9E)</code> for
validity. All drivers should check the following conditions:
* The request begins at a valid block. The driver converts the
<code>b_blkno</code> field to the correct device offset and then determines
whether the offset is valid for the device.
* The request does not go beyond the last block on the device.
* Device-specific requirements are met.</p>
</div>
<div class="paragraph">
<p>+
If an error is encountered, the driver
should indicate the appropriate error with <code>bioerror(9F)</code>. The driver
should then complete the request by calling <code>biodone(9F)</code>. <code>biodone</code>
notifies the caller of <code>strategy(9E)</code> that the transfer is complete. In
this case, the transfer has stopped because of an error.</p>
</div>
</li>
<li>
<p>Check whether the device is busy.</p>
<div class="paragraph">
<p>Synchronous data transfers allow single-threaded access to the device.
The device driver enforces this access in two ways:
* The driver maintains a busy flag that is guarded by a mutex.
* The driver waits on a condition variable with <code>cv_wait(9F)</code>, when
the device is busy.</p>
</div>
<div class="paragraph">
<p>+
If the device is busy, the thread waits until the interrupt handler
indicates that the device is not longer busy. The available status can
be indicated by either the <code>cv_broadcast(9F)</code> or the
<code>cv_signal(9F)</code> function. See <a href="#multithreading">Multithreading</a> for
details on condition variables.</p>
</div>
<div class="paragraph">
<p>+
When the device is no longer busy, the <code>strategy(9E)</code> routine marks the
device as available. <code>strategy</code> then prepares the buffer and the device
for the transfer.</p>
</div>
</li>
<li>
<p>Set up the buffer for DMA.</p>
<div class="paragraph">
<p>Prepare the data buffer for a DMA transfer by using
<code>ddi_dma_alloc_handle(9F)</code> to allocate a DMA handle. Use
<code>ddi_dma_buf_bind_handle(9F)</code> to bind the data buffer to
the handle. For information on setting up DMA resources and related data
structures, see <a href="#direct-memory-access-dma">Direct Memory Access (DMA)</a>.</p>
</div>
</li>
<li>
<p>Begin the transfer.</p>
<div class="paragraph">
<p>At this point, a pointer to the <code>buf(9S)</code> structure is saved in the
state structure of the device. The interrupt routine can then complete
the transfer by calling <code>biodone(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The device driver then accesses device registers to initiate a data
transfer. In most cases, the driver should protect the device registers
from other threads by using mutexes. In this case, because
<code>strategy(9E)</code> is single-threaded, guarding the device registers is not
necessary. See <a href="#multithreading">Multithreading</a> for details about data
locks.</p>
</div>
<div class="paragraph">
<p>When the executing thread has started the device&#8217;s DMA engine, the
driver can return execution control to the calling routine, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    struct device_reg *regp;
    minor_t instance;
    ddi_dma_cookie_t cookie;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL) {
        bioerror(bp, ENXIO);
        biodone(bp);
        return (0);
    }
    /* validate the transfer request */
    if ((bp-&gt;b_blkno &gt;= xsp-&gt;Nblocks) || (bp-&gt;b_blkno &lt; 0)) {
        bioerror(bp, EINVAL);
        biodone(bp);
        return (0);
    }
    /*
     * Hold off all threads until the device is not busy.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    while (xsp-&gt;busy) {
        cv_wait(&amp;xsp-&gt;cv, &amp;xsp-&gt;mu);
    }
    xsp-&gt;busy = 1;
    mutex_exit(&amp;xsp-&gt;mu);
    /*
     * If the device has power manageable components,
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    regp = xsp-&gt;regp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</code></pre>
</div>
</div>
</li>
<li>
<p>Handle the interrupting device.</p>
<div class="paragraph">
<p>When the device finishes the data transfer, the driver generates an
interrupt, which eventually results in the driver&#8217;s interrupt routine
being called. Most drivers specify the state structure of the device as
the argument to the interrupt routine when registering interrupts. See
the <code>ddi_add_intr(9F)</code> man page and
<a href="#registering-interrupts">Registering Interrupts</a>. The interrupt routine can
then access the <code>buf(9S)</code> structure being transferred, plus any other
information that is available from the state structure.</p>
</div>
<div class="paragraph">
<p>The interrupt handler should check the device&#8217;s status register to
determine whether the transfer completed without error. If an error
occurred, the handler should indicate the appropriate error with
<code>bioerror(9F)</code>. The handler should also clear the pending interrupt for
the device and then complete the transfer by calling <code>biodone(9F)</code>.</p>
</div>
<div class="paragraph">
<p>As the final task, the handler clears the busy flag. The handler then
calls <code>cv_signal(9F)</code> or <code>cv_broadcast(9F)</code> on the condition
variable, signaling that the device is no longer busy. This notification
enables other threads waiting for the device in <code>strategy(9E)</code> to
proceed with the next data transfer.</p>
</div>
<div class="paragraph">
<p>The following example shows a synchronous interrupt routine.</p>
</div>
</li>
</ol>
</div>
<div id="block-ex-19" class="paragraph">
<p>Synchronous Interrupt Routine for Block Drivers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    cv_signal(&amp;xsp-&gt;cv);
    mutex_exit(&amp;xsp-&gt;mu);
    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-data-transfers-block-drivers"><a class="anchor" href="#asynchronous-data-transfers-block-drivers"></a>3.15. Asynchronous Data Transfers (Block Drivers)</h3>
<div class="paragraph">
<p>This section presents a
method for performing asynchronous I/O transfers. The driver queues the
I/O requests and then returns control to the caller. Again, the
assumption is that the hardware is a simple disk device that allows one
transfer at a time. The device interrupts when a data transfer has
completed. An interrupt also takes place if an error occurs. The basic
steps for performing asynchronous data transfers are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Check for invalid <code>buf(9S)</code> requests.</p>
</li>
<li>
<p>Enqueue the request.</p>
</li>
<li>
<p>Start the first transfer.</p>
</li>
<li>
<p>Handle the interrupting device.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="checking-for-invalid-buf-requests"><a class="anchor" href="#checking-for-invalid-buf-requests"></a>3.15.1. Checking for Invalid <code>buf</code> Requests</h4>
<div class="paragraph">
<p>As in the synchronous case, the device driver should check the <code>buf(9S)</code>
structure passed to <code>strategy(9E)</code> for validity. See
<a href="#synchronous-data-transfers-block-drivers">Synchronous Data Transfers (Block Drivers)</a> for more
details.</p>
</div>
</div>
<div class="sect3">
<h4 id="enqueuing-the-request"><a class="anchor" href="#enqueuing-the-request"></a>3.15.2. Enqueuing the Request</h4>
<div class="paragraph">
<p>Unlike synchronous data transfers, a driver does not wait for an
asynchronous request to complete. Instead, the driver adds the request
to a queue. The head of the queue can be the current transfer. The head
of the queue can also be a separate field in the state structure for
holding the active request, as in <a href="#fblfb">example_title</a>.</p>
</div>
<div class="paragraph">
<p>If the queue is initially empty, then the hardware is not busy and
<code>strategy(9E)</code> starts the transfer before returning. Otherwise, if a
transfer completes with a non-empty queue, the interrupt routine begins
a new transfer. <a href="#fblfb">example_title</a> places the decision of
whether to start a new transfer into a separate routine for convenience.</p>
</div>
<div class="paragraph">
<p>The driver can use the <code>av_forw</code> and the <code>av_back</code> members of
the <code>buf(9S)</code> structure to manage a list of transfer requests. A single
pointer can be used to manage a singly linked list, or both pointers can
be used together to build a doubly linked list. The device hardware
specification specifies which type of list management, such as insertion
policies, is used to optimize the performance of the device. The
transfer list is a per-device list, so the head and tail of the list are
stored in the state structure.</p>
</div>
<div class="paragraph">
<p>The following example provides multiple threads with access to the
driver shared data, such as the transfer list. You must identify the
shared data and must protect the data with a mutex. See
<a href="#multithreading">Multithreading</a> for more details about mutex locks.</p>
</div>
<div id="fblfb" class="paragraph">
<p>Enqueuing Data Transfer Requests for Block Drivers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstrategy(struct buf *bp)
{
    struct xxstate *xsp;
    minor_t instance;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /* ... */
    /* validate transfer request */
    /* ... */
    /*
     * Add the request to the end of the queue. Depending on the device, a sorting
     * algorithm, such as disksort(9F) can be used if it improves the
     * performance of the device.
     */
    mutex_enter(&amp;xsp-&gt;mu);
    bp-&gt;av_forw = NULL;
    if (xsp-&gt;list_head) {
        /* Non-empty transfer list */
        xsp-&gt;list_tail-&gt;av_forw = bp;
        xsp-&gt;list_tail = bp;
    } else {
        /* Empty Transfer list */
        xsp-&gt;list_head = bp;
        xsp-&gt;list_tail = bp;
    }
    mutex_exit(&amp;xsp-&gt;mu);
    /* Start the transfer if possible */
    (void) xxstart((caddr_t)xsp);
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="starting-the-first-transfer"><a class="anchor" href="#starting-the-first-transfer"></a>3.15.3. Starting the First Transfer</h4>
<div class="paragraph">
<p>Device drivers that implement queuing usually have a <code>start</code> routine.
<code>start</code> dequeues the next request and starts the data transfer to or
from the device. In this example, <code>start</code> processes all requests
regardless of the state of the device, whether busy or free.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>start</code> must be written to be called from any context. <code>start</code> can be
called by both the strategy routine in kernel context and the interrupt
routine in interrupt context.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>start</code> is called by <code>strategy(9E)</code> every time <code>strategy</code> queues a
request so that an idle device can be started. If the device is busy,
<code>start</code> returns immediately.</p>
</div>
<div class="paragraph">
<p><code>start</code> is also called by the interrupt handler before the handler
returns from a claimed interrupt so that a nonempty queue can be
serviced. If the queue is empty, <code>start</code> returns immediately.</p>
</div>
<div class="paragraph">
<p>Because <code>start</code> is a private driver routine, <code>start</code> can take any
arguments and can return any type. The following code sample is written
to be used as a DMA callback, although that portion is not shown.
Accordingly, the example must take a <code>caddr_t</code> as an argument and
return an <code>int</code>. See <a href="#handling-resource-allocation-failures">Handling Resource Allocation
Failures</a> for more information about DMA callback routines.</p>
</div>
<div id="fblfa" class="paragraph">
<p>Starting the First Data Request for a Block Driver</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxstart(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;

    mutex_enter(&amp;xsp-&gt;mu);
    /*
     * If there is nothing more to do, or the device is
     * busy, return.
     */
    if (xsp-&gt;list_head == NULL || xsp-&gt;busy) {
       mutex_exit(&amp;xsp-&gt;mu);
       return (0);
    }
    xsp-&gt;busy = 1;
    /* Get the first buffer off the transfer list */
    bp = xsp-&gt;list_head;
    /* Update the head and tail pointer */
    xsp-&gt;list_head = xsp-&gt;list_head-&gt;av_forw;
    if (xsp-&gt;list_head == NULL)
       xsp-&gt;list_tail = NULL;
    bp-&gt;av_forw = NULL;
    mutex_exit(&amp;xsp-&gt;mu);
    /*
     * If the device has power manageable components,
     * mark the device busy with pm_busy_components(9F),
     * and then ensure that the device
     * is powered up by calling pm_raise_power(9F).
     *
     * Set up DMA resources with ddi_dma_alloc_handle(9F) and
     * ddi_dma_buf_bind_handle(9F).
     */
    xsp-&gt;bp = bp;
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_addr,
        cookie.dmac_address);
    ddi_put32(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;dma_size,
        (uint32_t)cookie.dmac_size);
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        ENABLE_INTERRUPTS | START_TRANSFER);
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handling-the-interrupting-device"><a class="anchor" href="#handling-the-interrupting-device"></a>3.15.4. Handling the Interrupting Device</h4>
<div class="paragraph">
<p>The interrupt routine is similar to the asynchronous version, with the
addition of the call to <code>start</code> and the removal of the call to
<code>cv_signal(9F)</code>.</p>
</div>
<div id="block-33565" class="paragraph">
<p>Block Driver Routine for Asynchronous Interrupts</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static u_int
xxintr(caddr_t arg)
{
    struct xxstate *xsp = (struct xxstate *)arg;
    struct buf *bp;
    uint8_t status;
    mutex_enter(&amp;xsp-&gt;mu);
    status = ddi_get8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr);
    if (!(status &amp; INTERRUPTING)) {
        mutex_exit(&amp;xsp-&gt;mu);
        return (DDI_INTR_UNCLAIMED);
    }
    /* Get the buf responsible for this interrupt */
    bp = xsp-&gt;bp;
    xsp-&gt;bp = NULL;
    /*
     * This example is for a simple device which either
     * succeeds or fails the data transfer, indicated in the
     * command/status register.
     */
    if (status &amp; DEVICE_ERROR) {
        /* failure */
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
    } else {
        /* success */
        bp-&gt;b_resid = 0;
    }
    ddi_put8(xsp-&gt;data_access_handle, &amp;xsp-&gt;regp-&gt;csr,
        CLEAR_INTERRUPT);
    /* The transfer has finished, successfully or not */
    biodone(bp);
    /*
     * If the device has power manageable components that were
     * marked busy in strategy(9F), mark them idle now with
     * pm_idle_component(9F)
     * Release any resources used in the transfer, such as DMA
     * resources (ddi_dma_unbind_handle(9F) and
     * ddi_dma_free_handle(9F)).
     *
     * Let the next I/O thread have access to the device.
     */
    xsp-&gt;busy = 0;
    mutex_exit(&amp;xsp-&gt;mu);
    (void) xxstart((caddr_t)xsp);
    return (DDI_INTR_CLAIMED);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dump-and-print-entry-points"><a class="anchor" href="#dump-and-print-entry-points"></a>3.16. <code>dump</code> and <code>print</code> Entry Points</h3>
<div class="paragraph">
<p>This section discusses the <code>dump(9E)</code> and <code>print(9E)</code> entry points.</p>
</div>
<div class="sect3">
<h4 id="dump-entry-point-block-drivers"><a class="anchor" href="#dump-entry-point-block-drivers"></a>3.16.1. <code>dump</code> Entry Point (Block Drivers)</h4>
<div class="paragraph">
<p>The <code>dump(9E)</code> entry point is used to copy
a portion of virtual address space directly to the specified device in
the case of a system failure. <code>dump</code> is also used to copy the state of
the kernel out to disk during a checkpoint operation. See the <code>cpr(4)</code>
and <code>dump(9E)</code> man pages for more information. The entry point must be
capable of performing this operation without the use of interrupts,
because interrupts are disabled during the checkpoint operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int dump(dev_t dev, caddr_t addr, daddr_t blkno, int nblk)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;dev&gt;</dt>
<dd>
<p>Device number of the device to receive the dump.</p>
</dd>
<dt class="hdlist1">&lt;addr&gt;</dt>
<dd>
<p>Base kernel virtual address at which to start the dump.</p>
</dd>
<dt class="hdlist1">&lt;blkno&gt;</dt>
<dd>
<p>Block at which the dump is to start.</p>
</dd>
<dt class="hdlist1">&lt;nblk&gt;</dt>
<dd>
<p>Number of blocks to dump.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The dump depends upon the existing driver working properly.</p>
</div>
</div>
<div class="sect3">
<h4 id="print-entry-point-block-drivers"><a class="anchor" href="#print-entry-point-block-drivers"></a>3.16.2. <code>print</code> Entry Point (Block Drivers)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int print(dev_t dev, char *str)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>print(9E)</code> entry point is called by the system to display a message
about an exception that has been detected. <code>print(9E)</code> should call
<code>cmn_err(9F)</code> to post the message to the console on behalf of the
system. The following example demonstrates a typical <code>print</code> entry
point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxprint(dev_t dev, char *str)
{
    cmn_err(CE_CONT, “xx: %s\n”, str);
    return (0);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disk-device-drivers"><a class="anchor" href="#disk-device-drivers"></a>3.17. Disk Device Drivers</h3>
<div class="paragraph">
<p>Disk devices represent an important class of block device drivers.</p>
</div>
<div class="sect3">
<h4 id="disk-ioctls"><a class="anchor" href="#disk-ioctls"></a>3.17.1. Disk `ioctl`s</h4>
<div class="paragraph">
<p>illumos disk drivers need to
support a minimum set of <code>ioctl</code> commands specific to illumos disk
drivers. These I/O controls are specified in the <code>dkio(4I)</code> manual page.
Disk I/O controls transfer disk information to or from the device
driver. An illumos disk device is supported by disk utility commands
such as <code>format(8)</code> and <code>newfs(8)</code>. The mandatory illumos disk I/O
controls are as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">DKIOCINFO</dt>
<dd>
<p>Returns information that describes the disk controller</p>
</dd>
<dt class="hdlist1">DKIOCGAPART</dt>
<dd>
<p>Returns a disk&#8217;s partition map</p>
</dd>
<dt class="hdlist1">DKIOCSAPART</dt>
<dd>
<p>Sets a disk&#8217;s partition map</p>
</dd>
<dt class="hdlist1">DKIOCGGEOM</dt>
<dd>
<p>Returns a disk&#8217;s geometry</p>
</dd>
<dt class="hdlist1">DKIOCSGEOM</dt>
<dd>
<p>Sets a disk&#8217;s geometry</p>
</dd>
<dt class="hdlist1">DKIOCGVTOC</dt>
<dd>
<p>Returns a disk&#8217;s Volume Table of Contents</p>
</dd>
<dt class="hdlist1">DKIOCSVTOC</dt>
<dd>
<p>Sets a disk&#8217;s Volume Table of Contents</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="disk-performance"><a class="anchor" href="#disk-performance"></a>3.17.2. Disk Performance</h4>
<div class="paragraph">
<p>illumos DDI/DKI provides facilities to optimize I/O transfers for
improved file system performance. A mechanism manages the list of I/O
requests so as to optimize disk access for a file system. See
<a href="#asynchronous-data-transfers-block-drivers">Asynchronous Data Transfers (Block Drivers)</a> for a
description of enqueuing an I/O request.</p>
</div>
<div class="paragraph">
<p>The <code>diskhd</code> structure is used to manage a linked list of I/O requests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct diskhd {
    long     b_flags;         /* not used, needed for consistency*/
    struct   buf *b_forw,     *b_back;     /* queue of unit queues */
    struct   buf *av_forw,    *av_back;    /* queue of bufs for this unit */
    long     b_bcount;        /* active flag */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>diskhd</code> data structure has two <code>buf</code> pointers that the driver can
manipulate. The <code>av_forw</code> pointer points to the first active I/O
request. The second pointer, <code>av_back</code>, points to the last active
request on the list.</p>
</div>
<div class="paragraph">
<p>A pointer to this structure is passed as an argument to <code>disksort(9F)</code>,
along with a pointer to the current <code>buf</code> structure being processed. The
<code>disksort</code> routine sorts the <code>buf</code> requests to optimize disk seek. The
routine then inserts the <code>buf</code> pointer into the <code>diskhd</code> list. The
<code>disksort</code> program uses the value that is in <code>b_resid</code> of the <code>buf</code>
structure as a sort key. The driver is responsible for setting this
value. Most illumos disk drivers use the cylinder group as the sort key.
This approach optimizes the file system read-ahead accesses.</p>
</div>
<div class="paragraph">
<p>When data has been added to the <code>diskhd</code> list, the device needs to
transfer the data. If the device is not busy processing a request, the
<code>xxstart</code> routine pulls the first <code>buf</code> structure off the <code>diskhd</code> list
and starts a transfer.</p>
</div>
<div class="paragraph">
<p>If the device is busy, the driver should return from the <code>xxstrategy</code>
entry point. When the hardware is done with the data transfer, an
interrupt is generated. The driver&#8217;s interrupt routine is then called to
service the device. After servicing the interrupt, the driver can then
call the <code>start</code> routine to process the next <code>buf</code> structure in the
<code>diskhd</code> list.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scsi-target-drivers"><a class="anchor" href="#scsi-target-drivers"></a>3.18. SCSI Target Drivers</h3>
<div class="paragraph">
<p>The illumos DDI/DKI divides the software interface to SCSI devices into
two major parts: <em>target</em> drivers and <em>host bus adapter (HBA)</em> drivers.
<em>Target</em> refers to a driver for a device on a SCSI bus, such as a disk
or a tape drive. <em>Host bus adapter</em> refers to the driver for the SCSI
controller on the host machine. SCSA defines the interface between these
two components. This chapter discusses target drivers only. See
<a href="#scsi-host-bus-adapter-drivers">SCSI Host Bus Adapter Drivers</a> for information on
host bus adapter drivers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The terms “host bus adapter” and “HBA” are equivalent to “host adapter,”
which is defined in SCSI specifications.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#introduction-to-target-drivers">Introduction to Target Drivers</a></p>
</li>
<li>
<p><a href="#sun-common-scsi-architecture-overview">Sun Common SCSI Architecture Overview</a></p>
</li>
<li>
<p><a href="#hardware-configuration-file">Hardware Configuration File</a></p>
</li>
<li>
<p><a href="#declarations-and-data-structures">Declarations and Data Structures</a></p>
</li>
<li>
<p><a href="#autoconfiguration-for-scsi-target-drivers">Autoconfiguration for SCSI Target Drivers</a></p>
</li>
<li>
<p><a href="#resource-allocation">Resource Allocation</a></p>
</li>
<li>
<p><a href="#building-and-transporting-a-command">Building and Transporting a Command</a></p>
</li>
<li>
<p><a href="#scsi-options">SCSI Options</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="introduction-to-target-drivers"><a class="anchor" href="#introduction-to-target-drivers"></a>3.19. Introduction to Target Drivers</h3>
<div class="paragraph">
<p>Target drivers can be either character or
block device drivers, depending on the device. Drivers for tape drives
are usually character device drivers, while disks are handled by block
device drivers. This chapter describes how to write a SCSI target
driver. The chapter discusses the additional requirements that SCSA
places on block and character drivers for SCSI target devices.</p>
</div>
<div class="paragraph">
<p>The following reference documents provide supplemental information
needed by the designers of target drivers and host bus adapter drivers.</p>
</div>
<div class="paragraph">
<p>Small Computer System Interface 2 (SCSI-2), ANSI/NCITS X3.131-1994,
Global Engineering Documents, 1998. ISBN 1199002488.</p>
</div>
<div class="paragraph">
<p><em>The Basics of SCSI</em>, Fourth Edition, ANCOT Corporation, 1998. ISBN
0963743988.</p>
</div>
<div class="paragraph">
<p>Refer also to the SCSI command specification
for the target device, provided by the hardware vendor.</p>
</div>
</div>
<div class="sect2">
<h3 id="sun-common-scsi-architecture-overview"><a class="anchor" href="#sun-common-scsi-architecture-overview"></a>3.20. Sun Common SCSI Architecture Overview</h3>
<div class="paragraph">
<p>The Sun Common SCSI Architecture (SCSA) is
the illumos DDI/DKI programming interface for the transmission of SCSI
commands from a target driver to a host bus adapter driver. This
interface is independent of the type of host bus adapter hardware, the
platform, the processor architecture, and the SCSI command being
transported across the interface.</p>
</div>
<div class="paragraph">
<p>Conforming to the SCSA enables the target driver to pass SCSI commands
to target devices without knowledge of the hardware implementation of
the host bus adapter.</p>
</div>
<div class="paragraph">
<p>The SCSA conceptually separates building the SCSI command from
transporting the command with data across the SCSI bus. The architecture
defines the software interface between high-level and low-level software
components. The higher level software component consists of one or more
SCSI target drivers, which translate I/O requests into SCSI commands
appropriate for the peripheral device. The following example illustrates
the SCSI architecture.</p>
</div>
<div id="scsi-fig-4" class="imageblock">
<div class="content">
<img src="figures/scsi-scsadiagram.png" alt="Diagram shows the role of the Sun Common SCSI Architecture in relation to SCSI drivers in the operating system.">
</div>
<div class="title">Figure 14. SCSA Block Diagram</div>
</div>
<div class="paragraph">
<p>The lower-level software component consists of a SCSA interface layer
and one or more host bus adapter drivers. The target driver is
responsible for the generation of the proper SCSI commands required to
execute the desired function and for processing the results.</p>
</div>
<div class="sect3">
<h4 id="general-flow-of-control"><a class="anchor" href="#general-flow-of-control"></a>3.20.1. General Flow of Control</h4>
<div class="paragraph">
<p>Assuming no transport errors occur, the following steps describe the
general flow of control for a read or write request.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The target driver&#8217;s <code>read(9E)</code> or <code>write(9E)</code> entry point is invoked.
<code>physio(9F)</code> is used to lock down memory, prepare a <code>buf</code> structure, and
call the strategy routine.</p>
</li>
<li>
<p>The target driver&#8217;s <code>strategy(9E)</code> routine checks the request.
<code>strategy</code> then allocates a <code>scsi_pkt(9S)</code> by using
<code>scsi_init_pkt(9F)</code>. The target driver initializes the packet
and sets the SCSI command descriptor block (CDB) using the
<code>scsi_setup_cdb(9F)</code> function. The target driver also specifies
a timeout. Then, the driver provides a pointer to a callback function.
The callback function is called by the host bus adapter driver on
completion of the command. The <code>buf(9S)</code> pointer should be saved in the
SCSI packet&#8217;s target-private space.</p>
</li>
<li>
<p>The target driver submits the packet to the host bus adapter driver by
using <code>scsi_transport(9F)</code>. The target driver is then free to accept
other requests. The target driver should not access the packet while the
packet is in transport. If either the host bus adapter driver or the
target supports queueing, new requests can be submitted while the packet
is in transport.</p>
</li>
<li>
<p>As soon as the SCSI bus is free and the target not busy, the host bus
adapter driver selects the target and passes the CDB. The target driver
executes the command. The target then performs the requested data
transfers.</p>
</li>
<li>
<p>After the target sends completion status and the command completes,
the host bus adapter driver notifies the target driver. To perform the
notification, the host calls the completion function that was specified
in the SCSI packet. At this time the host bus adapter driver is no
longer responsible for the packet, and the target driver has regained
ownership of the packet.</p>
</li>
<li>
<p>The SCSI packet&#8217;s completion routine analyzes the returned
information. The completion routine then determines whether the SCSI
operation was successful. If a failure has occurred, the target driver
retries the command by calling <code>scsi_transport(9F)</code> again. If the
host bus adapter driver does not support auto request sense, the target
driver must submit a request sense packet to retrieve the sense data in
the event of a check condition.</p>
</li>
<li>
<p>After successful completion or if the command cannot be retried, the
target driver calls <code>scsi_destroy_pkt(9F)</code>.
<code>scsi_destroy_pkt</code> synchronizes the data.
<code>scsi_destroy_pkt</code> then frees the packet. If the target driver
needs to access the data before freeing the packet,
<code>scsi_sync_pkt(9F)</code> is called.</p>
</li>
<li>
<p>Finally, the target driver notifies the requesting application that
the read or write transaction is complete. This notification is made by
returning from the <code>read(9E)</code> entry point in the driver for character
devices. Otherwise, notification is made indirectly through
<code>biodone(9F)</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>SCSA allows the execution of many of such operations, both overlapped
and queued, at various points in the process. The model places the
management of system resources on the host bus adapter driver. The
software interface enables the execution of target driver functions on
host bus adapter drivers by using SCSI bus adapters of varying degrees
of sophistication.</p>
</div>
</div>
<div class="sect3">
<h4 id="scsa-functions"><a class="anchor" href="#scsa-functions"></a>3.20.2. SCSA Functions</h4>
<div class="paragraph">
<p>SCSA defines functions to
manage the allocation and freeing of resources, the sensing and setting
of control states, and the transport of SCSI commands. These functions
are listed in the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. Standard SCSA Functions</caption>
<colgroup>
<col style="width: 56%;">
<col style="width: 44%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Name</th>
<th class="tableblock halign-left valign-top">Category</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_abort(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error handling</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_alloc_consistent_buf(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_destroy_pkt(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_dmafree(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_free_consistent_buf(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_ifgetcap(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transport information and control</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_ifsetcap(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_init_pkt(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource management</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_poll(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Polled I/O</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_probe(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Probe functions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_reset(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_setup_cdb(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CDB initialization function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_sync_pkt(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_transport(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command transport</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_unprobe(9F)</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If your driver needs to work with a SCSI-1 device, use the
<code>makecom(9F)</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hardware-configuration-file"><a class="anchor" href="#hardware-configuration-file"></a>3.21. Hardware Configuration File</h3>
<div class="paragraph">
<p>Because SCSI devices are not
self-identifying, a hardware configuration file is required for a target
driver. See the <code>driver.conf(5)</code> and
<code>scsi_free_consistent_buf(9F)</code> man pages for details. The
following is a typical configuration file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>name="xx" class="scsi" target=2 lun=0;</pre>
</div>
</div>
<div class="paragraph">
<p>The system reads
the file during autoconfiguration. The system uses the &lt;class&gt;
property to identify the driver&#8217;s possible parent. Then, the system
attempts to attach the driver to any parent driver that is of class
<em>scsi</em>. All host bus adapter drivers are of this class. Using the
&lt;class&gt; property rather than the &lt;parent&gt; property is
preferred. This approach enables any host bus adapter driver that finds
the expected device at the specified &lt;target&gt; and &lt;lun&gt;
IDs to attach to the target. The target driver is responsible for
verifying the class in its <code>probe(9E)</code> routine.</p>
</div>
</div>
<div class="sect2">
<h3 id="declarations-and-data-structures"><a class="anchor" href="#declarations-and-data-structures"></a>3.22. Declarations and Data Structures</h3>
<div class="paragraph">
<p>Target drivers must include the header file
<code>&lt;sys/scsi/scsi.h&gt;</code>.</p>
</div>
<div class="paragraph">
<p>SCSI target drivers must use the following command to generate a binary
module:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ld -r xx xx.o -N"misc/scsi"</pre>
</div>
</div>
<div class="sect3">
<h4 id="scsi_device-structure"><a class="anchor" href="#scsi_device-structure"></a>3.22.1. <code>scsi_device</code> Structure</h4>
<div class="paragraph">
<p>The host bus adapter driver
allocates and initializes a <code>scsi_device(9S)</code> structure for the
target driver before either the <code>probe(9E)</code> or <code>attach(9E)</code> routine is
called. This structure stores information about each SCSI logical unit,
including pointers to information areas that contain both generic and
device-specific information. One <code>scsi_device(9S)</code> structure exists
for each logical unit that is attached to the system. The target driver
can retrieve a pointer to this structure by calling
<code>ddi_get_driver_private(9F)</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Because the host bus adapter driver uses the private
field in the target device&#8217;s <code>dev_info</code> structure, target drivers
must not use <code>ddi_set_driver_private(9F)</code>.
===
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>scsi_device(9S)</code> structure contains the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_device {
    struct scsi_address           sd_address;    /* opaque address */
    dev_info_t                    *sd_dev;       /* device node */
    kmutex_t                      sd_mutex;
    void                          *sd_reserved;
    struct scsi_inquiry           *sd_inq;
    struct scsi_extended_sense    *sd_sense;
    caddr_t                       sd_private;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>sd_address</code></dt>
<dd>
<p>Data structure that is passed to the routines for SCSI resource
allocation.</p>
</dd>
<dt class="hdlist1"><code>sd_dev</code></dt>
<dd>
<p>Pointer to the target&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1"><code>sd_mutex</code></dt>
<dd>
<p>Mutex for use by the target driver. This mutex is initialized by the
host bus adapter driver and can be used by the target driver as a
per-device mutex. Do not hold this mutex across a call to
<code>scsi_transport(9F)</code> or <code>scsi_poll(9F)</code>. See
<a href="#multithreading">Multithreading</a> for more information on mutexes.</p>
</dd>
<dt class="hdlist1"><code>sd_inq</code></dt>
<dd>
<p>Pointer for the target device&#8217;s SCSI inquiry data. The
<code>scsi_probe(9F)</code> routine allocates a buffer, fills the buffer in
with inquiry data, and attaches the buffer to this field.</p>
</dd>
<dt class="hdlist1"><code>sd_sense</code></dt>
<dd>
<p>Pointer to a buffer to contain SCSI request sense data from the
device. The target driver must allocate and manage this buffer. See
<a href="#attach-entry-point-scsi-target-drivers"> Entry Point (SCSI Target Drivers)</a>.</p>
</dd>
<dt class="hdlist1"><code>sd_private</code></dt>
<dd>
<p>Pointer field for use by the target driver. This field is commonly
used to store a pointer to a private target driver state structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="scsi_pkt-structure-target-drivers"><a class="anchor" href="#scsi_pkt-structure-target-drivers"></a>3.22.2. <code>scsi_pkt</code> Structure (Target Drivers)</h4>
<div class="paragraph">
<p>The <code>scsi_pkt</code> structure contains the
following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_pkt {
    opaque_t  pkt_ha_private;         /* private data for host adapter */
    struct scsi_address pkt_address;  /* destination packet is for */
    opaque_t  pkt_private;            /* private data for target driver */
    void     (*pkt_comp)(struct scsi_pkt *);  /* completion routine */
    uint_t   pkt_flags;               /* flags */
    int      pkt_time;                /* time allotted to complete command */
    uchar_t  *pkt_scbp;               /* pointer to status block */
    uchar_t  *pkt_cdbp;               /* pointer to command block */
    ssize_t  pkt_resid;               /* data bytes not transferred */
    uint_t   pkt_state;               /* state of command */
    uint_t   pkt_statistics;          /* statistics */
    uchar_t  pkt_reason;              /* reason completion called */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pkt_address</code></dt>
<dd>
<p>Target device&#8217;s address set by <code>scsi_init_pkt(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>pkt_private</code></dt>
<dd>
<p>Place to store private data for the target driver.
&lt;pkt_private&gt; is commonly used to save the <code>buf(9S)</code>
pointer for the command.</p>
</dd>
<dt class="hdlist1"><code>pkt_comp</code></dt>
<dd>
<p>Address of the completion routine. The host bus adapter driver calls
this routine when the driver has transported the command. Transporting
the command does not mean that the command succeeded. The target might
have been busy. Another possibility is that the target might not have
responded before the time out period elapsed. See the description for
<code>pkt_time</code> field. The target driver must supply a valid value in
this field. This value can be <code>NULL</code> if the driver does not want to be
notified.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Two different SCSI callback routines are provided. The <code>pkt_comp</code>
field identifies a <em>completion callback</em> routine, which is called when
the host bus adapter completes its processing. A<em>resource callback</em>
routine is also available, which is called when currently unavailable
resources are likely to be available. See the
<code>scsi_init_pkt(9F)</code> man page.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pkt_flags</code></dt>
<dd>
<p>Provides additional control information, for example, to transport the
command without disconnect privileges (<code>FLAG_NODISCON</code>) or to
disable callbacks (<code>FLAG_NOINTR</code>). See the <code>scsi_pkt(9S)</code> man
page for details.</p>
</dd>
<dt class="hdlist1"><code>pkt_time</code></dt>
<dd>
<p>Time out value in seconds. If the command is not completed within this
time, the host bus adapter calls the completion routine with
<code>pkt_reason</code> set to <code>CMD_TIMEOUT</code>. The target driver should
set this field to longer than the maximum time the command might take.
If the timeout is zero, no timeout is requested. Timeout starts when
the command is transmitted on the SCSI bus.</p>
</dd>
<dt class="hdlist1"><code>pkt_scbp</code></dt>
<dd>
<p>Pointer to the block for SCSI status completion. This field is filled
in by the host bus adapter driver.</p>
</dd>
<dt class="hdlist1"><code>pkt_cdbp</code></dt>
<dd>
<p>Pointer to the SCSI command descriptor block, the actual command to be
sent to the target device. The host bus adapter driver does not
interpret this field. The target driver must fill the field in with a
command that the target device can process.</p>
</dd>
<dt class="hdlist1"><code>pkt_resid</code></dt>
<dd>
<p>Residual of the operation. The <code>pkt_resid</code> field has two different
uses depending on how <code>pkt_resid</code> is used. When <code>pkt_resid</code> is
used to allocate DMA resources for a command
<code>scsi_init_pkt(9F)</code>, <code>pkt_resid</code> indicates the number of
unallocable bytes. DMA resources might <em>not</em> be allocated due to DMA
hardware scatter-gather or other device limitations. After command
transport, <code>pkt_resid</code> indicates the number of non-transferable
data bytes. The field is filled in by the host bus adapter driver
before the completion routine is called.</p>
</dd>
<dt class="hdlist1"><code>pkt_state</code></dt>
<dd>
<p>Indicates the state of the command. The host bus adapter driver fills
in this field as the command progresses. One bit is set in this field
for each of the five following command states:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>STATE_GOT_BUS</code> – Acquired the bus</p>
</li>
<li>
<p><code>STATE_GOT_TARGET</code> – Selected the target</p>
</li>
<li>
<p><code>STATE_SENT_CMD</code> – Sent the command</p>
</li>
<li>
<p><code>STATE_XFERRED_DATA</code> – Transferred data, if appropriate</p>
</li>
<li>
<p><code>STATE_GOT_STATUS</code> – Received status from the device</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>pkt_statistics</code></dt>
<dd>
<p>Contains transport-related statistics set by the host bus adapter
driver.</p>
</dd>
<dt class="hdlist1"><code>pkt_reason</code></dt>
<dd>
<p>Gives the reason the completion routine was called. The completion
routine decodes this field. The routine then takes the appropriate
action. If the command completes, that is, no transport errors occur,
this field is set to <code>CMD_CMPLT</code>. Other values in this field
indicate an error. After a command is completed, the target driver
should examine the <code>pkt_scbp</code> field for a check condition status.
See the <code>scsi_pkt(9S)</code> man page for more information.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="autoconfiguration-for-scsi-target-drivers"><a class="anchor" href="#autoconfiguration-for-scsi-target-drivers"></a>3.23. Autoconfiguration for SCSI Target Drivers</h3>
<div class="literalblock">
<div class="content">
<pre>  SCSI target
drivers must implement the standard autoconfiguration routines
`++_++init(9E)`, `++_++fini(9E)`, and `++_++info(9E)`. See for more
information.</pre>
</div>
</div>
<div class="paragraph">
<p>The following routines are also required, but these routines must
perform specific SCSI and SCSA processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>probe(9E)</code></p>
</li>
<li>
<p><code>attach(9E)</code></p>
</li>
<li>
<p><code>detach(9E)</code></p>
</li>
<li>
<p><code>getinfo(9E)</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="probe-entry-point-scsi-target-drivers"><a class="anchor" href="#probe-entry-point-scsi-target-drivers"></a>3.23.1. <code>probe</code> Entry Point (SCSI Target Drivers)</h4>
<div class="paragraph">
<p>SCSI target devices are not self-identifying,
so target drivers must have a <code>probe(9E)</code> routine. This routine must
determine whether the expected type of device is present and responding.</p>
</div>
<div class="paragraph">
<p>The general structure and the return codes of the <code>probe(9E)</code> routine
are the same as the structure and return codes for other device drivers.
SCSI target drivers must use the <code>scsi_probe(9F)</code> routine in their
<code>probe(9E)</code> entry point. <code>scsi_probe(9F)</code> sends a SCSI inquiry
command to the device and returns a code that indicates the result. If
the SCSI inquiry command is successful, <code>scsi_probe(9F)</code> allocates a
<code>scsi_inquiry(9S)</code> structure and fills the structure in with the
device&#8217;s inquiry data. Upon return from <code>scsi_probe(9F)</code>, the
<code>sd_inq</code> field of the <code>scsi_device(9S)</code> structure points to this
<code>scsi_inquiry(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>Because <code>probe(9E)</code> must be stateless, the target driver must call
<code>scsi_unprobe(9F)</code> before <code>probe(9E)</code> returns, even if
<code>scsi_probe(9F)</code> fails.</p>
</div>
<div class="paragraph">
<p>shows a typical <code>probe(9E)</code> routine. The routine in the example
retrieves the <code>scsi_device(9S)</code> structure from the private field of
its <code>dev_info</code> structure. The routine also retrieves the device&#8217;s
SCSI target and logical unit numbers for printing in messages. The
<code>probe(9E)</code> routine then calls <code>scsi_probe(9F)</code> to verify that the
expected device, a printer in this case, is present.</p>
</div>
<div class="paragraph">
<p>If successful, <code>scsi_probe(9F)</code> attaches the device&#8217;s SCSI inquiry
data in a <code>scsi_inquiry(9S)</code> structure to the <code>sd_inq</code> field of
the <code>scsi_device(9S)</code> structure. The driver can then determine
whether the device type is a printer, which is reported in the
<code>inq_dtype</code> field. If the device is a printer, the type is reported
with <code>scsi_log(9F)</code>, using <code>scsi_dname(9F)</code> to convert the
device type into a string.</p>
</div>
<div id="scsi-14215" class="paragraph">
<p>SCSI Target Driver <code>probe(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxprobe(dev_info_t *dip)
{
    struct scsi_device *sdp;
    int rval, target, lun;
    /*
     * Get a pointer to the scsi_device(9S) structure
     */
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);

    target = sdp-&gt;sd_address.a_target;
    lun = sdp-&gt;sd_address.a_lun;
    /*
     * Call scsi_probe(9F) to send the Inquiry command. It will
     * fill in the sd_inq field of the scsi_device structure.
     */
    switch (scsi_probe(sdp, NULL_FUNC)) {
    case SCSIPROBE_FAILURE:
    case SCSIPROBE_NORESP:
    case SCSIPROBE_NOMEM:
        /*
         * In these cases, device might be powered off,
         * in which case we might be able to successfully
         * probe it at some future time - referred to
         * as `deferred attach'.
         */
        rval = DDI_PROBE_PARTIAL;
        break;
    case SCSIPROBE_NONCCS:
    default:
        /*
         * Device isn't of the type we can deal with,
         * and/or it will never be usable.
         */
        rval = DDI_PROBE_FAILURE;
        break;
    case SCSIPROBE_EXISTS:
        /*
         * There is a device at the target/lun address. Check
         * inq_dtype to make sure that it is the right device
         * type. See scsi_inquiry(9S)for possible device types.
         */
        switch (sdp-&gt;sd_inq-&gt;inq_dtype) {
        case DTYPE_PRINTER:
        scsi_log(sdp, "xx", SCSI_DEBUG,
            "found %s device at target%d, lun%d\n",
            scsi_dname((int)sdp-&gt;sd_inq-&gt;inq_dtype),
            target, lun);
        rval = DDI_PROBE_SUCCESS;
        break;
        case DTYPE_NOTPRESENT:
        default:
        rval = DDI_PROBE_FAILURE;
        break;
        }
    }
    scsi_unprobe(sdp);
    return (rval);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more thorough <code>probe(9E)</code> routine could check <code>scsi_inquiry(9S)</code>
to make sure that the device is of the type expected by a particular
driver.</p>
</div>
</div>
<div class="sect3">
<h4 id="attach-entry-point-scsi-target-drivers"><a class="anchor" href="#attach-entry-point-scsi-target-drivers"></a>3.23.2. <code>attach</code> Entry Point (SCSI Target Drivers)</h4>
<div class="paragraph">
<p>After the <code>probe(9E)</code> routine has verified that the expected device is
present, <code>attach(9E)</code> is called. <code>attach</code> performs these tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocates and initializes any per-instance data.</p>
</li>
<li>
<p>Creates minor device node information.</p>
</li>
<li>
<p>Restores the hardware state of a device after a suspension of the
device or the system. See <a href="#attach-entry-point"> Entry Point</a> for
details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A SCSI target driver needs to call <code>scsi_probe(9F)</code> again to
retrieve the device&#8217;s inquiry data. The driver must also create a SCSI
request sense packet. If the attach is successful, the <code>attach</code> function
should not call <code>scsi_unprobe(9F)</code>.</p>
</div>
<div class="paragraph">
<p>Three routines are used to create the request sense packet:
<code>scsi_alloc_consistent_buf(9F)</code>,
<code>scsi_init_pkt(9F)</code>, and <code>scsi_setup_cdb(9F)</code>.
<code>scsi_alloc_consistent_buf(9F)</code> allocates a buffer that is
suitable for consistent DMA. <code>scsi_alloc_consistent_buf</code>
then returns a pointer to a <code>buf(9S)</code> structure. The advantage of a
consistent buffer is that no explicit synchronization of the data is
required. In other words, the target driver can access the data after
the callback. The <code>sd_sense</code> element of the device&#8217;s
<code>scsi_device(9S)</code> structure must be initialized with the address of
the sense buffer. <code>scsi_init_pkt(9F)</code> creates and partially
initializes a <code>scsi_pkt(9S)</code> structure. <code>scsi_setup_cdb(9F)</code>
creates a SCSI command descriptor block, in this case by creating a SCSI
request sense command.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  Note that a SCSI
device is not self-identifying and does not have a `reg` property. As a
result, the driver must set the `pm-hardware-state` property. Setting
`pm-hardware-state` informs the framework that this device needs to be
suspended and then resumed.</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the SCSI target driver&#8217;s <code>attach</code> routine.</p>
</div>
<div id="scsi-42148" class="paragraph">
<p>SCSI Target Driver <code>attach(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate         *xsp;
    struct scsi_pkt        *rqpkt = NULL;
    struct scsi_device     *sdp;
    struct buf         *bp = NULL;
    int            instance;
    instance = ddi_get_instance(dip);
    switch (cmd) {
      case DDI_ATTACH:
          break;
      case DDI_RESUME:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
    /*
     * Allocate a state structure and initialize it.
     */
    xsp = ddi_get_soft_state(statep, instance);
    sdp = (struct scsi_device *)ddi_get_driver_private(dip);
    /*
     * Cross-link the state and scsi_device(9S) structures.
     */
    sdp-&gt;sd_private = (caddr_t)xsp;
    xsp-&gt;sdp = sdp;
    /*
     * Call scsi_probe(9F) again to get and validate inquiry data.
     * Allocate a request sense buffer. The buf(9S) structure
     * is set to NULL to tell the routine to allocate a new one.
     * The callback function is set to NULL_FUNC to tell the
     * routine to return failure immediately if no
     * resources are available.
     */
    bp = scsi_alloc_consistent_buf(&amp;sdp-&gt;sd_address, NULL,
    SENSE_LENGTH, B_READ, NULL_FUNC, NULL);
    if (bp == NULL)
        goto failed;
    /*
     * Create a Request Sense scsi_pkt(9S) structure.
     */
    rqpkt = scsi_init_pkt(&amp;sdp-&gt;sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, PKT_CONSISTENT, NULL_FUNC, NULL);
    if (rqpkt == NULL)
        goto failed;
    /*
     * scsi_alloc_consistent_buf(9F) returned a buf(9S) structure.
     * The actual buffer address is in b_un.b_addr.
     */
    sdp-&gt;sd_sense = (struct scsi_extended_sense *)bp-&gt;b_un.b_addr;
    /*
     * Create a Group0 CDB for the Request Sense command
     */
    if (scsi_setup_cdb((union scsi_cdb *)rqpkt-&gt;pkt_cdbp,
        SCMD_REQUEST_SENSE, 0, SENSE__LENGTH, 0) == 0)
        goto failed;;
    /*
     * Fill in the rest of the scsi_pkt structure.
     * xxcallback() is the private command completion routine.
     */
    rqpkt-&gt;pkt_comp = xxcallback;
    rqpkt-&gt;pkt_time = 30; /* 30 second command timeout */
    rqpkt-&gt;pkt_flags |= FLAG_SENSING;
    xsp-&gt;rqs = rqpkt;
    xsp-&gt;rqsbuf = bp;
    /*
     * Create minor nodes, report device, and do any other initialization. */
     * Since the device does not have the 'reg' property,
     * cpr will not call its DDI_SUSPEND/DDI_RESUME entries.
     * The following code is to tell cpr that this device
     * needs to be suspended and resumed.
     */
    (void) ddi_prop_update_string(device, dip,
        "pm-hardware-state", "needs-suspend-resume");
    xsp-&gt;open = 0;
    return (DDI_SUCCESS);
failed:
    if (bp)
        scsi_free_consistent_buf(bp);
    if (rqpkt)
        scsi_destroy_pkt(rqpkt);
    sdp-&gt;sd_private = (caddr_t)NULL;
    sdp-&gt;sd_sense = NULL;
    scsi_unprobe(sdp);
    /* Free any other resources, such as the state structure. */
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="detach-entry-point-scsi-target-drivers"><a class="anchor" href="#detach-entry-point-scsi-target-drivers"></a>3.23.3. <code>detach</code> Entry Point (SCSI Target Drivers)</h4>
<div class="paragraph">
<p>The <code>detach(9E)</code> entry point is the inverse of <code>attach(9E)</code>. <code>detach</code>
must free all resources that were allocated in <code>attach</code>. If successful,
the detach should call <code>scsi_unprobe(9F)</code>. The following example
shows a target driver <code>detach</code> routine.</p>
</div>
<div id="scsi-42748" class="paragraph">
<p>SCSI Target Driver <code>detach(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdetach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    struct xxstate *xsp;
    switch (cmd) {
      case DDI_DETACH:
          /*
           * Normal detach(9E) operations, such as getting a
           * pointer to the state structure
           */
          scsi_free_consistent_buf(xsp-&gt;rqsbuf);
          scsi_destroy_pkt(xsp-&gt;rqs);
          xsp-&gt;sdp-&gt;sd_private = (caddr_t)NULL;
          xsp-&gt;sdp-&gt;sd_sense = NULL;
          scsi_unprobe(xsp-&gt;sdp);
          /*
           * Remove minor nodes.
           * Free resources, such as the state structure and properties.
           */
          return (DDI_SUCCESS);
      case DDI_SUSPEND:
          /* For information, see the "Directory Memory Access (DMA)" */
          /* chapter in this book. */
      default:
          return (DDI_FAILURE);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getinfo-entry-point-scsi-target-drivers"><a class="anchor" href="#getinfo-entry-point-scsi-target-drivers"></a>3.23.4. <code>getinfo</code> Entry Point (SCSI Target Drivers)</h4>
<div class="paragraph">
<p>The <code>getinfo(9E)</code> routine for SCSI target drivers is much the same as
for other drivers (see <a href="#getinfo-entry-point"> Entry Point</a> for more
information on <code>DDI_INFO_DEVT2INSTANCE</code> case). However, in the
<code>DDI_INFO_DEVT2DEVINFO</code> case of the <code>getinfo</code> routine, the
target driver must return a pointer to its <code>dev_info</code> node. This
pointer can be saved in the driver state structure or can be retrieved
from the <code>sd_dev</code> field of the <code>scsi_device(9S)</code> structure. The
following example shows an alternative SCSI target driver <code>getinfo</code> code
fragment.</p>
</div>
<div id="scsi-17982" class="paragraph">
<p>Alternative SCSI Target Driver <code>getinfo</code> Code Fragment</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">case DDI_INFO_DEVT2DEVINFO:
    dev = (dev_t)arg;
    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);
    if (xsp == NULL)
        return (DDI_FAILURE);
    *result = (void *)xsp-&gt;sdp-&gt;sd_dev;
    return (DDI_SUCCESS);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resource-allocation"><a class="anchor" href="#resource-allocation"></a>3.24. Resource Allocation</h3>
<div class="paragraph">
<p>To send a SCSI command to the device, the
target driver must create and initialize a <code>scsi_pkt(9S)</code> structure.
This structure must then be passed to the host bus adapter driver.</p>
</div>
<div class="sect3">
<h4 id="scsiinitpkt-function"><a class="anchor" href="#scsiinitpkt-function"></a>3.24.1. <code>scsi_init_pkt</code> Function</h4>
<div class="paragraph">
<p>The <code>scsi_init_pkt(9F)</code> routine
allocates and zeroes a <code>scsi_pkt(9S)</code> structure.
<code>scsi_init_pkt</code> also sets pointers to <code>pkt_private</code>,
<code>*pkt_scbp</code>, and <code>*pkt_cdbp</code>. Additionally,
<code>scsi_init_pkt</code> provides a callback mechanism to handle the case
where resources are not available. This function has the following
syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_pkt *scsi_init_pkt(struct scsi_address *ap,
     struct scsi_pkt *pktp, struct buf *bp, int cmdlen,
     int statuslen, int privatelen, int flags,
     int (*callback)(caddr_t), caddr_t arg)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;ap&gt;</dt>
<dd>
<p>Pointer to a <code>scsi_address</code> structure. <code>ap</code> is the
<code>sd_address</code> field of the device&#8217;s <code>scsi_device(9S)</code>
structure.</p>
</dd>
<dt class="hdlist1">&lt;pktp&gt;</dt>
<dd>
<p>Pointer to the <code>scsi_pkt(9S)</code> structure to be initialized. If this
pointer is set to <code>NULL</code>, a new packet is allocated.</p>
</dd>
<dt class="hdlist1">&lt;bp&gt;</dt>
<dd>
<p>Pointer to a <code>buf(9S)</code> structure. If this pointer is not null and has
a valid byte count, DMA resources are allocated.</p>
</dd>
<dt class="hdlist1">&lt;cmdlen&gt;</dt>
<dd>
<p>Length of the SCSI command descriptor block in bytes.</p>
</dd>
<dt class="hdlist1">&lt;statuslen&gt;</dt>
<dd>
<p>Required length of the SCSI status completion block in bytes.</p>
</dd>
<dt class="hdlist1">&lt;privatelen&gt;</dt>
<dd>
<p>Number of bytes to allocate for the <code>pkt_private</code> field.</p>
</dd>
<dt class="hdlist1">&lt;flags&gt;</dt>
<dd>
<p>Set of flags:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>PKT_CONSISTENT</code> – This bit must be set if the DMA buffer was
allocated using <code>scsi_alloc_consistent_buf(9F)</code>. In this
case, the host bus adapter driver guarantees that the data transfer is
properly synchronized before performing the target driver&#8217;s command
completion callback.</p>
</li>
<li>
<p><code>PKT_DMA_PARTIAL</code> – This bit can be set if the driver
accepts a partial DMA mapping. If set, <code>scsi_init_pkt(9F)</code>
allocates DMA resources with the <code>DDI_DMA_PARTIAL</code> flag set.
The <code>pkt_resid</code> field of the <code>scsi_pkt(9S)</code> structure can be
returned with a nonzero residual. A nonzero value indicates the number
of bytes for which <code>scsi_init_pkt(9F)</code> was unable to allocate
DMA resources.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">&lt;callback&gt;</dt>
<dd>
<p>Specifies the action to take if resources are not available. If set to
<code>NULL_FUNC</code>, <code>scsi_init_pkt(9F)</code> returns the value <code>NULL</code>
immediately. If set to <code>SLEEP_FUNC</code>, <code>scsi_init_pkt</code> does
not return until resources are available. Any other valid kernel
address is interpreted as the address of a function to be called when
resources are likely to be available.</p>
</dd>
<dt class="hdlist1">&lt;arg&gt;</dt>
<dd>
<p>Parameter to pass to the callback function.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>scsi_init_pkt</code> routine synchronizes the data prior to
transport. If the driver needs to access the data after transport, the
driver should call <code>scsi_sync_pkt(9F)</code> to flush any intermediate
caches. The <code>scsi_sync_pkt</code> routine can be used to synchronize
any cached data.</p>
</div>
</div>
<div class="sect3">
<h4 id="scsisyncpkt-function"><a class="anchor" href="#scsisyncpkt-function"></a>3.24.2. <code>scsi_sync_pkt</code> Function</h4>
<div class="paragraph">
<p>If the target driver needs to resubmit the packet after
changing the data, <code>scsi_sync_pkt(9F)</code> must be called before
calling <code>scsi_transport(9F)</code>. However, if the target driver does not
need to access the data, <code>scsi_sync_pkt</code> does not need to be
called after the transport.</p>
</div>
</div>
<div class="sect3">
<h4 id="scsidestroypkt-function"><a class="anchor" href="#scsidestroypkt-function"></a>3.24.3. <code>scsi_destroy_pkt</code> Function</h4>
<div class="paragraph">
<p>The <code>scsi_destroy_pkt(9F)</code> routine synchronizes
any remaining cached data that is associated with the packet, if
necessary. The routine then frees the packet and associated command,
status, and target driver-private data areas. This routine should be
called in the command completion routine.</p>
</div>
</div>
<div class="sect3">
<h4 id="scsiallocconsistent_buf-function"><a class="anchor" href="#scsiallocconsistent_buf-function"></a>3.24.4. <code>scsi_alloc_consistent_buf</code> Function</h4>
<div class="paragraph">
<p>For most I/O requests, the data buffer
passed to the driver entry points is not accessed directly by the
driver. The buffer is just passed on to <code>scsi_init_pkt(9F)</code>. If
a driver sends SCSI commands that operate on buffers that the driver
itself examines, the buffers should be DMA consistent. The SCSI request
sense command is a good example. The
<code>scsi_alloc_consistent_buf(9F)</code> routine allocates a
<code>buf(9S)</code> structure and a data buffer that is suitable for
DMA-consistent operations. The HBA performs any necessary
synchronization of the buffer before performing the command completion
callback.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>scsi_alloc_consistent_buf(9F)</code> uses scarce system
resources. Thus, you should use <code>scsi_alloc_consistent_buf</code>
sparingly.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scsifreeconsistent_buf-function"><a class="anchor" href="#scsifreeconsistent_buf-function"></a>3.24.5. <code>scsi_free_consistent_buf</code> Function</h4>
<div class="paragraph">
<p><code>scsi_free_consistent_buf(9F)</code> releases a
<code>buf(9S)</code> structure and the associated data buffer allocated with
<code>scsi_alloc_consistent_buf(9F)</code>. See <a href="#attach-entry-point-scsi-target-drivers"> Entry
Point (SCSI Target Drivers)</a> and <a href="#detach-entry-point-scsi-target-drivers"> Entry Point (SCSI
Target Drivers)</a> for examples.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="building-and-transporting-a-command"><a class="anchor" href="#building-and-transporting-a-command"></a>3.25. Building and Transporting a Command</h3>
<div class="paragraph">
<p>The host bus adapter driver is responsible for transmitting the command
to the device. Furthermore, the driver is responsible for handling the
low-level SCSI protocol. The <code>scsi_transport(9F)</code> routine hands a
packet to the host bus adapter driver for transmission. The target
driver has the responsibility to create a valid <code>scsi_pkt(9S)</code>
structure.</p>
</div>
<div class="sect3">
<h4 id="building-a-command"><a class="anchor" href="#building-a-command"></a>3.25.1. Building a Command</h4>
<div class="paragraph">
<p>The routine <code>scsi_init_pkt(9F)</code>
allocates space for a SCSI CDB, allocates DMA resources if necessary,
and sets the <code>pkt_flags</code> field, as shown in this example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pkt = scsi_init_pkt(&amp;sdp-&gt;sd_address, NULL, bp,
    CDB_GROUP0, 1, 0, 0, SLEEP_FUNC, NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>This example creates a new packet along with allocating DMA resources as
specified in the passed <code>buf(9S)</code> structure pointer. A SCSI CDB is
allocated for a Group 0 (6-byte) command. The <code>pkt_flags</code> field is
set to zero, but no space is allocated for the <code>pkt_private</code> field.
This call to <code>scsi_init_pkt(9F)</code>, because of the
<code>SLEEP_FUNC</code> parameter, waits indefinitely for resources if no
resources are currently available.</p>
</div>
<div class="paragraph">
<p>The next step is
to initialize the SCSI CDB, using the <code>scsi_setup_cdb(9F)</code>
function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (scsi_setup_cdb((union scsi_cdb *)pkt-&gt;pkt_cdbp,
    SCMD_READ, bp-&gt;b_blkno, bp-&gt;b_bcount &gt;&gt; DEV_BSHIFT, 0) == 0)
    goto failed;</pre>
</div>
</div>
<div class="paragraph">
<p>This example builds a Group 0 command descriptor block. The example
fills in the <code>pkt_cdbp</code> field as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The command itself is in byte 0. The command is set from the parameter
<code>SCMD_READ</code>.</p>
</li>
<li>
<p>The address field is in bits 0-4 of byte 1 and bytes 2 and 3. The
address is set from <code>bp-&gt;b_blkno</code>.</p>
</li>
<li>
<p>The count field is in byte 4. The count is set from the last
parameter. In this case, <code>count</code> is set to <code>bp-&gt;b_bcount</code>
<code>&gt;&gt;</code> <code>DEV_BSHIFT</code>, where <code>DEV_BSHIFT</code> is the byte count of
the transfer converted to the number of blocks.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>scsi_setup_cdb(9F)</code> does not support setting a
target device&#8217;s logical unit number (LUN) in bits 5-7 of byte 1 of the
SCSI command block. This requirement is defined by SCSI-1. For SCSI-1
devices that require the LUN bits set in the command block, use
<code>makecom_g0(9F)</code> or some equivalent rather than
<code>scsi_setup_cdb(9F)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After initializing the SCSI CDB, initialize three other fields in the
packet and store as a pointer to the packet in the state structure.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pkt-&gt;pkt_private = (opaque_t)bp;
pkt-&gt;pkt_comp = xxcallback;
pkt-&gt;pkt_time = 30;
xsp-&gt;pkt = pkt;</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>buf(9S)</code> pointer is saved in the <code>pkt_private</code> field for later
use in the completion routine.</p>
</div>
</div>
<div class="sect3">
<h4 id="setting-target-capabilities"><a class="anchor" href="#setting-target-capabilities"></a>3.25.2. Setting Target Capabilities</h4>
<div class="paragraph">
<p>The target
drivers use <code>scsi_ifsetcap(9F)</code> to set the capabilities of the host
adapter driver. A <em>cap</em> is a name-value pair, consisting of a
null-terminated character string and an integer value. The current value
of a capability can be retrieved using <code>scsi_ifgetcap(9F)</code>.
<code>scsi_ifsetcap(9F)</code> allows capabilities to be set for all targets on
the bus.</p>
</div>
<div class="paragraph">
<p>In general, however, setting capabilities of targets that are not owned
by the target driver is not recommended. This practice is not
universally supported by HBA drivers. Some capabilities, such as
disconnect and synchronous, can be set by default by the HBA driver.
Other capabilities might need to be set explicitly by the target driver.
Wide-xfer and tagged-queueing must be set by the target drive, for
example.</p>
</div>
</div>
<div class="sect3">
<h4 id="transporting-a-command"><a class="anchor" href="#transporting-a-command"></a>3.25.3. Transporting a Command</h4>
<div class="paragraph">
<p>After the <code>scsi_pkt(9S)</code> structure is
filled in, use <code>scsi_transport(9F)</code> to hand the structure to the bus
adapter driver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (scsi_transport(pkt) != TRAN_ACCEPT) {
    bp-&gt;b_resid = bp-&gt;b_bcount;
    bioerror(bp, EIO);
    biodone(bp);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The other return values from
<code>scsi_transport(9F)</code> are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TRAN_BUSY – A command for the specified target is already in
progress.</p>
</li>
<li>
<p>TRAN_BADPKT – The DMA count in the packet was too large, or the
host adapter driver rejected this packet for other reasons.</p>
</li>
<li>
<p>TRAN_FATAL_ERROR – The host adapter driver is unable to accept
this packet.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The mutex <code>sd_mutex</code> in the <code>scsi_device(9S)</code> structure must not
be held across a call to <code>scsi_transport(9F)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>scsi_transport(9F)</code> returns TRAN_ACCEPT, the packet becomes
the responsibility of the host bus adapter driver. The packet should not
be accessed by the target driver until the command completion routine is
called.</p>
</div>
<div class="sect4">
<h5 id="synchronous-scsi_transport-function"><a class="anchor" href="#synchronous-scsi_transport-function"></a>Synchronous <code>scsi_transport</code> Function</h5>
<div class="paragraph">
<p>If <code>FLAG_NOINTR</code> is set in the packet, then <code>scsi_transport(9F)</code>
does not return until the command is complete. No callback is performed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not use <code>FLAG_NOINTR</code> in interrupt context.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-completion"><a class="anchor" href="#command-completion"></a>3.25.4. Command Completion</h4>
<div class="paragraph">
<p>When the host bus adapter driver is through
with the command, the driver invokes the packet&#8217;s completion callback
routine. The driver then passes a pointer to the <code>scsi_pkt(9S)</code>
structure as a parameter. After decoding the packet, the completion
routine takes the appropriate action.</p>
</div>
<div class="paragraph">
<p><a href="#scsi-35252">example_title</a> presents a simple completion
callback routine. This code checks for transport failures. In case of
failure, the routine gives up rather than retrying the command. If the
target is busy, extra code is required to resubmit the command at a
later time.</p>
</div>
<div class="paragraph">
<p>If the command results in a check condition, the target driver needs to
send a request sense command unless auto request sense has been enabled.</p>
</div>
<div class="paragraph">
<p>Otherwise, the command succeeded. At the end of processing for the
command, the command destroys the packet and calls <code>biodone(9F)</code>.</p>
</div>
<div class="paragraph">
<p>In the event of a transport error, such as a bus reset or parity
problem, the target driver can resubmit the packet by using
<code>scsi_transport(9F)</code>. No values in the packet need to be changed
prior to resubmitting.</p>
</div>
<div class="paragraph">
<p>The following example does not attempt to retry incomplete commands.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Normally, the target driver&#8217;s callback function is called in interrupt
context. Consequently, the callback function should never sleep.
</td>
</tr>
</table>
</div>
<div id="scsi-35252" class="paragraph">
<p>Completion Routine for a SCSI Driver</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
xxcallback(struct scsi_pkt *pkt)
{
    struct buf        *bp;
    struct xxstate    *xsp;
    minor_t           instance;
    struct scsi_status *ssp;
    /*
     * Get a pointer to the buf(9S) structure for the command
     * and to the per-instance data structure.
     */
    bp = (struct buf *)pkt-&gt;pkt_private;
    instance = getminor(bp-&gt;b_edev);
    xsp = ddi_get_soft_state(statep, instance);
    /*
     * Figure out why this callback routine was called
     */
    if (pkt-&gt;pkt_reason != CMP_CMPLT) {
        bp-&gt;b_resid = bp-&gt;b_bcount;
        bioerror(bp, EIO);
        scsi_destroy_pkt(pkt);          /* Release resources */
        biodone(bp);                    /* Notify waiting threads */ ;
    } else {
        /*
         * Command completed, check status.
         * See scsi_status(9S)
         */
        ssp = (struct scsi_status *)pkt-&gt;pkt_scbp;
        if (ssp-&gt;sts_busy) {
            /* error, target busy or reserved */
        } else if (ssp-&gt;sts_chk) {
            /* Send a request sense command. */
        } else {
            bp-&gt;b_resid = pkt-&gt;pkt_resid;  /* Packet completed OK */
            scsi_destroy_pkt(pkt);
            biodone(bp);
       }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reuse-of-packets"><a class="anchor" href="#reuse-of-packets"></a>3.25.5. Reuse of Packets</h4>
<div class="paragraph">
<p>A target driver can reuse packets in the
following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resubmit the packet unchanged.</p>
</li>
<li>
<p>Use <code>scsi_sync_pkt(9F)</code> to
synchronize the data. Then, process the data in the driver. Finally,
resubmit the packet.</p>
</li>
<li>
<p>Free DMA resources, using
<code>scsi_dmafree(9F)</code>, and pass the <code>pkt</code> pointer to
<code>scsi_init_pkt(9F)</code> for binding to a new <code>bp</code>. The target driver
is responsible for reinitializing the packet. The CDB has to have the
same length as the previous CDB.</p>
</li>
<li>
<p>If only partial DMA is allocated during the first call to
<code>scsi_init_pkt(9F)</code>, subsequent calls to
<code>scsi_init_pkt(9F)</code> can be made for the same packet. Calls can
be made to <code>bp</code> as well to adjust the DMA resources to the next portion
of the transfer.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="auto-request-sense-mode"><a class="anchor" href="#auto-request-sense-mode"></a>3.25.6. Auto-Request Sense Mode</h4>
<div class="paragraph">
<p>Auto-request sense mode is
most desirable if queuing is used, whether the queuing is tagged or
untagged. A contingent allegiance condition is cleared by any subsequent
command and, consequently, the sense data is lost. Most HBA drivers
start the next command before performing the target driver callback.
Other HBA drivers can use a separate, lower-priority thread to perform
the callbacks. This approach might increase the time needed to notify
the target driver that the packet completed with a check condition. In
this case, the target driver might not be able to submit a request sense
command in time to retrieve the sense data.</p>
</div>
<div class="paragraph">
<p>To avoid this loss of sense data, the HBA driver, or controller, should
issue a request sense command if a check condition has been detected.
This mode is known as auto-request sense mode. Note that not all HBA
drivers are capable of auto-request sense mode, and some drivers can
only operate with auto-request sense mode enabled.</p>
</div>
<div class="paragraph">
<p>A target driver enables auto-request-sense mode by using
<code>scsi_ifsetcap(9F)</code>. The following example shows auto-request sense
enabling.</p>
</div>
<div id="scsi-73381" class="paragraph">
<p>Enabling Auto-Request Sense Mode</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxattach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    struct xxstate *xsp;
    struct scsi_device *sdp = (struct scsi_device *)
    ddi_get_driver_private(dip);
    /*
     * Enable auto-request-sense; an auto-request-sense cmd might
     * fail due to a BUSY condition or transport error. Therefore,
     * it is recommended to allocate a separate request sense
     * packet as well.
     * Note that scsi_ifsetcap(9F) can return -1, 0, or 1
     */
    xsp-&gt;sdp_arq_enabled =
    ((scsi_ifsetcap(ROUTE, “auto-rqsense”, 1, 1) == 1) ? 1 : 0);
    /*
     * If the HBA driver supports auto request sense then the
     * status blocks should be sizeof (struct scsi_arq_status);
     * else
     * One byte is sufficient
     */
    xsp-&gt;sdp_cmd_stat_size =  (xsp-&gt;sdp_arq_enabled ?
    sizeof (struct scsi_arq_status) : 1);
    /* ... */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a packet is allocated using <code>scsi_init_pkt(9F)</code> and
auto-request sense is desired on this packet, additional space is
needed. The target driver must request this space for the status block
to hold the auto-request sense structure. The sense length used in the
request sense command is <code>sizeof</code>, from <code>struct</code>
<code>scsi_extended_sense</code>. Auto-request sense can be disabled per
individual packet by allocating <code>sizeof</code>, from <code>struct</code>
<code>scsi_status</code>, for the status block.</p>
</div>
<div class="paragraph">
<p>The packet is submitted using <code>scsi_transport(9F)</code> as usual. When a
check condition occurs on this packet, the host adapter driver takes the
following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Issues a request sense command if the controller does not have
auto-request sense capability</p>
</li>
<li>
<p>Obtains the sense data</p>
</li>
<li>
<p>Fills in the <code>scsi_arq_status</code> information in the packet&#8217;s
status block</p>
</li>
<li>
<p>Sets <code>STATE_ARQ_DONE</code> in the packet&#8217;s <code>pkt_state</code> field</p>
</li>
<li>
<p>Calls the packet&#8217;s callback handler (<code>pkt_comp</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The target driver&#8217;s callback routine should verify that sense data is
available by checking the <code>STATE_ARQ_DONE</code> bit in
<code>pkt_state</code>. <code>STATE_ARQ_DONE</code> implies that a check condition
has occurred and that a request sense has been performed. If
auto-request sense has been temporarily disabled in a packet, subsequent
retrieval of the sense data cannot be guaranteed.</p>
</div>
<div class="paragraph">
<p>The target driver should then verify whether the auto-request sense
command completed successfully and decode the sense data.</p>
</div>
</div>
<div class="sect3">
<h4 id="dump-handling"><a class="anchor" href="#dump-handling"></a>3.25.7. Dump Handling</h4>
<div class="paragraph">
<p>The <code>dump(9E)</code> entry point copies a portion of virtual address space
directly to the specified device in the case of system failure or
checkpoint operation. See the <code>cpr(4)</code> and <code>dump(9E)</code> man pages. The
<code>dump(9E)</code> entry point must be capable of performing this operation
without the use of interrupts.</p>
</div>
<div class="paragraph">
<p>The arguments for <code>dump</code> are as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;dev&gt;</dt>
<dd>
<p>Device number of the dump device</p>
</dd>
<dt class="hdlist1">&lt;addr&gt;</dt>
<dd>
<p>Kernel virtual address at which to start the dump</p>
</dd>
<dt class="hdlist1">&lt;blkno&gt;</dt>
<dd>
<p>First destination block on the device</p>
</dd>
<dt class="hdlist1">&lt;nblk&gt;</dt>
<dd>
<p>Number of blocks to dump</p>
</dd>
</dl>
</div>
<div id="scsi-ex-3" class="paragraph">
<p><code>dump(9E)</code> Routine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
xxdump(dev_t dev, caddr_t addr, daddr_t blkno, int nblk)
{
    struct xxstate     *xsp;
    struct buf         *bp;
    struct scsi_pkt    *pkt;
    int    rval;
    int    instance;

    instance = getminor(dev);
    xsp = ddi_get_soft_state(statep, instance);

    if (tgt-&gt;suspended) {
        (void) pm_raise_power(DEVINFO(tgt), 0, 1);
    }

    bp = getrbuf(KM_NOSLEEP);
    if (bp == NULL) {
        return (EIO);
    }

/* Calculate block number relative to partition. */
    bp-&gt;b_un.b_addr = addr;
    bp-&gt;b_edev = dev;
    bp-&gt;b_bcount = nblk * DEV_BSIZE;
    bp-&gt;b_flags = B_WRITE | B_BUSY;
    bp-&gt;b_blkno = blkno;

    pkt = scsi_init_pkt(ROUTE(tgt), NULL, bp, CDB_GROUP1,
    sizeof (struct scsi_arq_status),
    sizeof (struct bst_pkt_private), 0, NULL_FUNC, NULL);
    if (pkt == NULL) {
        freerbuf(bp);
        return (EIO);
    }
    (void) scsi_setup_cdb((union scsi_cdb *)pkt-&gt;pkt_cdbp,
        SCMD_WRITE_G1, blkno, nblk, 0);
    /*
     * While dumping in polled mode, other cmds might complete
     * and these should not be resubmitted. we set the
     * dumping flag here which prevents requeueing cmds.
     */
    tgt-&gt;dumping = 1;
    rval = scsi_poll(pkt);
    tgt-&gt;dumping = 0;

    scsi_destroy_pkt(pkt);
    freerbuf(bp);

    if (rval != DDI_SUCCESS) {
        rval = EIO;
    }
    return (rval);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scsi-options"><a class="anchor" href="#scsi-options"></a>3.26. SCSI Options</h3>
<div class="paragraph">
<p>SCSA defines a global variable,
&lt;scsi_options&gt;, for control and debugging. The defined bits
in &lt;scsi_options&gt; can be found in the file
<code>&lt;sys/scsi/conf/autoconf.h&gt;</code>. The &lt;scsi_options&gt;
uses the bits as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>SCSI_OPTIONS_DR</code></dt>
<dd>
<p>Enables global disconnect or reconnect.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST</code></dt>
<dd>
<p>Enables global FAST SCSI support: 10 Mbytes/sec transfers. The HBA
should not operate in FAST SCSI mode unless the
SCSI_OPTIONS_FAST (0x100) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST20</code></dt>
<dd>
<p>Enables global FAST20 SCSI support: 20 Mbytes/sec transfers. The HBA
should not operate in FAST20 SCSI mode unless the
SCSI_OPTIONS_FAST20 (0x400) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST40</code></dt>
<dd>
<p>Enables global FAST40 SCSI support: 40 Mbytes/sec transfers. The HBA
should not operate in FAST40 SCSI mode unless the
SCSI_OPTIONS_FAST40 (0x800) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST80</code></dt>
<dd>
<p>Enables global FAST80 SCSI support: 80 Mbytes/sec transfers. The HBA
should not operate in FAST80 SCSI mode unless the
SCSI_OPTIONS_FAST80 (0x1000) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST160</code></dt>
<dd>
<p>Enables global FAST160 SCSI support: 160 Mbytes/sec transfers. The HBA
should not operate in FAST160 SCSI mode unless the
SCSI_OPTIONS_FAST160 (0x2000) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_FAST320</code></dt>
<dd>
<p>Enables global FAST320 SCSI support: 320 Mbytes/sec transfers. The HBA
should not operate in FAST320 SCSI mode unless the
SCSI_OPTIONS_FAST320 (0x4000) bit is set.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_LINK</code></dt>
<dd>
<p>Enables global link support.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_PARITY</code></dt>
<dd>
<p>Enables global parity support.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_QAS</code></dt>
<dd>
<p>Enables the Quick Arbitration Select feature. QAS is used to decrease
protocol overhead when devices arbitrate for and access the bus. QAS
is only supported on Ultra4 (FAST160) SCSI devices, although not all
such devices support QAS. The HBA should not operate in QAS SCSI mode
unless the SCSI_OPTIONS_QAS (0x100000) bit is set. Consult the
appropriate Sun hardware documentation to determine whether your
machine supports QAS.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_SYNC</code></dt>
<dd>
<p>Enables global synchronous transfer capability.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_TAG</code></dt>
<dd>
<p>Enables global tagged queuing support.</p>
</dd>
<dt class="hdlist1"><code>SCSI_OPTIONS_WIDE</code></dt>
<dd>
<p>Enables global WIDE SCSI.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The setting of &lt;scsi_options&gt; affects <em>all</em> host bus adapter
drivers and all target drivers that are present on the system. Refer to
the <code>scsi_hba_attach(9F)</code> man page for information on
controlling these options for a particular host adapter.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="scsi-host-bus-adapter-drivers"><a class="anchor" href="#scsi-host-bus-adapter-drivers"></a>3.27. SCSI Host Bus Adapter Drivers</h3>
<div class="paragraph">
<p>This chapter contains information on creating SCSI host bus adapter
(HBA) drivers. The chapter provides sample code illustrating the
structure of a typical HBA driver. The sample code shows the use of the
HBA driver interfaces that are provided by the Sun Common SCSI
Architecture (SCSA). This chapter provides information on the following
subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#introduction-to-host-bus-adapter-drivers">Introduction to Host Bus Adapter Drivers</a></p>
</li>
<li>
<p><a href="#scsi-interface">SCSI Interface</a></p>
</li>
<li>
<p><a href="#scsa-hba-interfaces">SCSA HBA Interfaces</a></p>
</li>
<li>
<p><a href="#hba-driver-dependency-and-configuration-issues">HBA Driver Dependency and Configuration Issues</a></p>
</li>
<li>
<p><a href="#entry-points-for-scsa-hba-drivers">Entry Points for SCSA HBA Drivers</a></p>
</li>
<li>
<p><a href="#scsi-hba-driver-specific-issues">SCSI HBA Driver Specific Issues</a></p>
</li>
<li>
<p><a href="#support-for-queuing">Support for Queuing</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="introduction-to-host-bus-adapter-drivers"><a class="anchor" href="#introduction-to-host-bus-adapter-drivers"></a>3.28. Introduction to Host Bus Adapter Drivers</h3>
<div class="paragraph">
<p>As described in <a href="#scsi-target-drivers">SCSI Target Drivers</a>, the DDI/DKI
divides the software interface to SCSI devices into two major parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Target devices and drivers</p>
</li>
<li>
<p>Host bus adapter devices and drivers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Target</em> <em>device</em> refers to a device on a SCSI bus, such as a disk or a
tape drive. <em>Target</em> <em>driver</em> refers to a software component installed
as a device driver. Each target device on a SCSI bus is controlled by
one instance of the target driver.</p>
</div>
<div class="paragraph">
<p><em>Host bus adapter</em> <em>device</em> refers to HBA hardware, such as an SBus or
PCI SCSI adapter card. <em>Host bus adapter</em> <em>driver</em> refers to a software
component that is installed as a device driver. Some examples are the
<code>esp</code> driver on a SPARC machine, the <code>ncrs</code> driver on an x86 machine,
and the <code>isp</code> driver, which works on both architectures. An instance of
the HBA driver controls each of its host bus adapter devices that are
configured in the system.</p>
</div>
<div class="paragraph">
<p>The Sun Common SCSI Architecture (SCSA) defines the interface between
the target and HBA components.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Understanding SCSI target drivers is an essential prerequisite to
writing effective SCSI HBA drivers. For information on SCSI target
drivers, see <a href="#scsi-target-drivers">SCSI Target Drivers</a>. Target driver
developers can also benefit from reading this chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The host bus adapter driver is responsible for performing the following
tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Managing host bus adapter hardware</p>
</li>
<li>
<p>Accepting SCSI commands from the SCSI target driver</p>
</li>
<li>
<p>Transporting the commands to the specified SCSI target device</p>
</li>
<li>
<p>Performing any data transfers that the command requires</p>
</li>
<li>
<p>Collecting status</p>
</li>
<li>
<p>Handling auto-request sense (optional)</p>
</li>
<li>
<p>Informing the target driver of command completion or failure</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="scsi-interface"><a class="anchor" href="#scsi-interface"></a>3.29. SCSI Interface</h3>
<div class="paragraph">
<p>SCSI HBA driver</p>
</div>
<div class="paragraph">
<p>HBA driver</p>
</div>
<div class="paragraph">
<p>SCSI HBA driver</p>
</div>
<div class="paragraph">
<p>SCSA is the DDI/DKI programming interface for the
transmission of SCSI commands from a target driver to a host adapter
driver. By conforming to the SCSA, the target driver can easily pass any
combination of SCSI commands and sequences to a target device. Knowledge
of the hardware implementation of the host adapter is not necessary.
Conceptually, SCSA separates the building of a SCSI command from the
transporting of the command with data to the SCSI bus. SCSA manages the
connections between the target and HBA drivers through an HBA
<em>transport</em>layer, as shown in the following figure.</p>
</div>
<div id="scsihba-fig-11" class="imageblock">
<div class="content">
<img src="figures/scsihba-scsadiagram.png" alt="Diagram shows the host bus adapter transport layer between a target driver and SCSI devices.">
</div>
<div class="title">Figure 15. SCSA Interface</div>
</div>
<div class="literalblock">
<div class="content">
<pre>   The _HBA transport layer_
is a software and hardware layer that is responsible for transporting a
SCSI command to a SCSI target device. The HBA driver provides resource
allocation, DMA management, and transport services in response to
requests made by SCSI target drivers through SCSA. The host adapter
driver also manages the host adapter hardware and the SCSI protocols
necessary to perform the commands. When a command has been completed,
the HBA driver calls the target driver's SCSI `pkt` command completion
routine.</pre>
</div>
</div>
<div class="paragraph">
<p>The following example illustrates this flow, with emphasis on the
transfer of information from target drivers to SCSA to HBA drivers. The
figure also shows typical transport entry points and function calls.</p>
</div>
<div id="scsihba-fig-14" class="imageblock">
<div class="content">
<img src="figures/scsihba-translayerflow.png" alt="Diagram shows how commands flow through the HBA transport layer.">
</div>
<div class="title">Figure 16. Transport Layer Flow</div>
</div>
</div>
<div class="sect2">
<h3 id="scsa-hba-interfaces"><a class="anchor" href="#scsa-hba-interfaces"></a>3.30. SCSA HBA Interfaces</h3>
<div class="paragraph">
<p>SCSA HBA interfaces include HBA entry points, HBA data structures, and
an HBA framework.</p>
</div>
<div class="sect3">
<h4 id="scsa-hba-entry-point-summary"><a class="anchor" href="#scsa-hba-entry-point-summary"></a>3.30.1. SCSA HBA Entry Point Summary</h4>
<div class="paragraph">
<p>SCSA defines a number of HBA
driver entry points. These entry points are listed in the following
table. The entry points are called by the system when a target driver
instance connected to the HBA driver is configured. The entry points are
also called when the target driver makes a SCSA request. See
<a href="#entry-points-for-scsa-hba-drivers">Entry Points for SCSA HBA Drivers</a> for more
information.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. SCSA HBA Entry Point Summary</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Name</th>
<th class="tableblock halign-left valign-top">Called as a Result of</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_abort(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_abort(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_bus_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System resetting bus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_destroy_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling
<code>scsi_destroy_pkt(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_dmafree(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_dmafree(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_getcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_ifgetcap(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_init_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling
<code>scsi_init_pkt(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_quiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System quiescing bus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_reset(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset_notify(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling
<code>scsi_reset_notify(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_setcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_ifsetcap(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_start(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling <code>scsi_transport(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_sync_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling
<code>scsi_sync_pkt(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_free(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System detaching target device instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_init(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System attaching target device instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_probe(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target driver calling
<code>scsi_probe(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_unquiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System resuming activity on bus</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="scsa-hba-data-structures"><a class="anchor" href="#scsa-hba-data-structures"></a>3.30.2. SCSA HBA Data Structures</h4>
<div class="paragraph">
<p>SCSA defines data structures to enable the exchange of
information between the target and HBA drivers. The following data
structures are included:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>scsi_hba_tran(9S)</code></p>
</li>
<li>
<p><code>scsi_address(9S)</code></p>
</li>
<li>
<p><code>scsi_device(9S)</code></p>
</li>
<li>
<p><code>scsi_pkt(9S)</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="scsihbatran-structure"><a class="anchor" href="#scsihbatran-structure"></a><code>scsi_hba_tran</code> Structure</h5>
<div class="paragraph">
<p>Each instance of an HBA driver must allocate a
<code>scsi_hba_tran(9S)</code> structure by using the
<code>scsi_hba_tran_alloc(9F)</code> function in the <code>attach(9E)</code> entry
point. The <code>scsi_hba_tran_alloc</code> function initializes the
<code>scsi_hba_tran</code> structure. The HBA driver must initialize
specific vectors in the transport structure to point to entry points
within the HBA driver. After the <code>scsi_hba_tran</code> structure is
initialized, the HBA driver exports the transport structure to SCSA by
calling the <code>scsi_hba_attach_setup(9F)</code> function.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Because SCSA keeps a pointer to the transport structure in the
driver-private field on the <code>devinfo</code> node, HBA drivers must not use
<code>ddi_set_driver_private(9F)</code>. HBA drivers can, however, use
<code>ddi_get_driver_private(9F)</code> to retrieve the pointer to the
transport structure.
===
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SCSA interfaces require the HBA driver to supply a number of entry
points that are callable through the <code>scsi_hba_tran</code> structure.
See <a href="#entry-points-for-scsa-hba-drivers">Entry Points for SCSA HBA Drivers</a> for more
information.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_hba_tran</code> structure contains the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_hba_tran {
    dev_info_t          *tran_hba_dip;          /* HBAs dev_info pointer */
    void                *tran_hba_private;      /* HBA softstate */
    void                *tran_tgt_private;      /* HBA target private pointer */
    struct scsi_device  *tran_sd;               /* scsi_device */
    int                 (*tran_tgt_init)();     /* Transport target */
                                                /* Initialization */
    int                 (*tran_tgt_probe)();    /* Transport target probe */
    void                (*tran_tgt_free)();     /* Transport target free */
    int                 (*tran_start)();        /* Transport start */
    int                 (*tran_reset)();        /* Transport reset */
    int                 (*tran_abort)();        /* Transport abort */
    int                 (*tran_getcap)();       /* Capability retrieval */
    int                 (*tran_setcap)();       /* Capability establishment */
    struct scsi_pkt     *(*tran_init_pkt)();    /* Packet and DMA allocation */
    void                (*tran_destroy_pkt)();  /* Packet and DMA */
                                                /* Deallocation */
    void                (*tran_dmafree)();      /* DMA deallocation */
    void                (*tran_sync_pkt)();     /* Sync DMA */
    void                (*tran_reset_notify)(); /* Bus reset notification */
    int                 (*tran_bus_reset)();    /* Reset bus only */
    int                 (*tran_quiesce)();      /* Quiesce a bus */
    int                 (*tran_unquiesce)();    /* Unquiesce a bus */
    int                 tran_interconnect_type; /* transport interconnect */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following descriptions give more information about these
<code>scsi_hba_tran</code> structure fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>tran_hba_dip</code></dt>
<dd>
<p>Pointer to the HBA device instance <code>dev_info</code> structure. The
function <code>scsi_hba_attach_setup(9F)</code> sets this field.</p>
</dd>
<dt class="hdlist1"><code>tran_hba_private</code></dt>
<dd>
<p>Pointer to private data maintained by the HBA driver. Usually,
<code>tran_hba_private</code> contains a pointer to the state structure
of the HBA driver.</p>
</dd>
<dt class="hdlist1"><code>tran_tgt_private</code></dt>
<dd>
<p>Pointer to private data maintained by the HBA driver when using
cloning. By specifying <code>SCSI_HBA_TRAN_CLONE</code> when calling
<code>scsi_hba_attach_setup(9F)</code>, the
<code>scsi_hba_tran(9S)</code> structure is cloned once per target. This
approach enables the HBA to initialize this field to point to a
per-target instance data structure in the <code>tran_tgt_init(9E)</code>
entry point. If <code>SCSI_HBA_TRAN_CLONE</code> is not specified,
<code>tran_tgt_private</code> is <code>NULL</code>, and <code>tran_tgt_private</code>
must not be referenced. See <a href="#transport-structure-cloning">Transport Structure
Cloning</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>tran_sd</code></dt>
<dd>
<p>Pointer to a per-target instance <code>scsi_device(9S)</code> structure used
when cloning. If <code>SCSI_HBA_TRAN_CLONE</code> is passed to
<code>scsi_hba_attach_setup(9F)</code>, <code>tran_sd</code> is initialized
to point to the per-target <code>scsi_device</code> structure. This
initialization takes place before any HBA functions are called on
behalf of that target. If <code>SCSI_HBA_TRAN_CLONE</code> is not
specified, <code>tran_sd</code> is <code>NULL</code>, and <code>tran_sd</code> must not be
referenced. See <a href="#transport-structure-cloning">Transport Structure Cloning</a> for more
information.</p>
</dd>
<dt class="hdlist1"><code>tran_tgt_init</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when initializing
a target device instance. If no per-target initialization is required,
the HBA can leave <code>tran_tgt_init</code> set to <code>NULL</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_tgt_probe</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver instance calls <code>scsi_probe(9F)</code>. This routine is called to
probe for the existence of a target device. If no target probing
customization is required for this HBA, the HBA should set
<code>tran_tgt_probe</code> to <code>scsi_hba_probe(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_tgt_free</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
device instance is destroyed. If no per-target deallocation is
necessary, the HBA can leave <code>tran_tgt_free</code> set to <code>NULL</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_start</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_transport(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_reset</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_reset(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_abort</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_abort(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_getcap</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_ifgetcap(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_setcap</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_ifsetcap(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_init_pkt</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_init_pkt(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_destroy_pkt</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_destroy_pkt(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_dmafree</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_dmafree(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_sync_pkt</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>scsi_sync_pkt(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_reset_notify</code></dt>
<dd>
<p>Pointer to the HBA driver entry point that is called when a target
driver calls <code>tran_reset_notify(9E)</code>.</p>
</dd>
<dt class="hdlist1"><code>tran_bus_reset</code></dt>
<dd>
<p>The function entry that resets the SCSI bus without resetting targets.</p>
</dd>
<dt class="hdlist1"><code>tran_quiesce</code></dt>
<dd>
<p>The function entry that waits for all outstanding commands to complete
and blocks (or queues) any I/O requests issued.</p>
</dd>
<dt class="hdlist1"><code>tran_unquiesce</code></dt>
<dd>
<p>The function entry that allows I/O activities to resume on the SCSI
bus.</p>
</dd>
<dt class="hdlist1"><code>tran_interconnect_type</code></dt>
<dd>
<p>Integer value denoting interconnect type of the transport as defined
in the <code>services.h</code> header file.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="scsi_address-structure"><a class="anchor" href="#scsi_address-structure"></a><code>scsi_address</code> Structure</h5>
<div class="paragraph">
<p>The <code>scsi_address(9S)</code> structure provides transport
and addressing information for each SCSI command that is allocated and
transported by a target driver instance.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_address</code> structure contains the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_address {
    struct scsi_hba_tran    *a_hba_tran;    /* Transport vectors */
    ushort_t                a_target;       /* Target identifier */
    uchar_t                 a_lun;          /* LUN on that target */
    uchar_t                 a_sublun;       /* Sub LUN on that LUN */
                                            /* Not used */
};</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>a_hba_tran</code></dt>
<dd>
<p>Pointer to the <code>scsi_hba_tran(9S)</code> structure, as allocated and
initialized by the HBA driver. If <code>SCSI_HBA_TRAN_CLONE</code>
was specified as the flag to <code>scsi_hba_attach_setup(9F)</code>,
<code>a_hba_tran</code> points to a copy of that structure.</p>
</dd>
<dt class="hdlist1"><code>a_target</code></dt>
<dd>
<p>Identifies the SCSI target on the SCSI bus.</p>
</dd>
<dt class="hdlist1"><code>a_lun</code></dt>
<dd>
<p>Identifies the SCSI logical unit on the SCSI target.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="scsi_device-structure-1"><a class="anchor" href="#scsi_device-structure-1"></a><code>scsi_device</code> Structure</h5>
<div class="paragraph">
<p>The HBA framework allocates and initializes a
<code>scsi_device(9S)</code> structure for each instance of a target device.
The allocation and initialization occur before the framework calls the
HBA driver&#8217;s <code>tran_tgt_init(9E)</code> entry point. This structure
stores information about each SCSI logical unit, including pointers to
information areas that contain both generic and device-specific
information. One <code>scsi_device(9S)</code> structure exists for each target
device instance that is attached to the system.</p>
</div>
<div class="paragraph">
<p>If the per-target initialization is successful, the HBA framework sets
the target driver&#8217;s per-instance private data to point to the
<code>scsi_device(9S)</code> structure, using
<code>ddi_set_driver_private(9F)</code>. Note that an initialization is
successful if <code>tran_tgt_init</code> returns success or if the vector
is null.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_device(9S)</code> structure contains the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_device {
    struct scsi_address           sd_address;    /* routing information */
    dev_info_t                    *sd_dev;       /* device dev_info node */
    kmutex_t                      sd_mutex;      /* mutex used by device */
    void                          *sd_reserved;
    struct scsi_inquiry           *sd_inq;
    struct scsi_extended_sense    *sd_sense;
    caddr_t                       sd_private;    /* for driver's use */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>sd_address</code></dt>
<dd>
<p>Data structure that is passed to the routines for SCSI resource
allocation.</p>
</dd>
<dt class="hdlist1"><code>sd_dev</code></dt>
<dd>
<p>Pointer to the target&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1"><code>sd_mutex</code></dt>
<dd>
<p>Mutex for use by the target driver. This mutex is initialized by the
HBA framework. The mutex can be used by the target driver as a
per-device mutex. This mutex should not be held across a call to
<code>scsi_transport(9F)</code> or <code>scsi_poll(9F)</code>. See
<a href="#multithreading">Multithreading</a> for more information on mutexes.</p>
</dd>
<dt class="hdlist1"><code>sd_inq</code></dt>
<dd>
<p>Pointer for the target device&#8217;s SCSI inquiry data. The
<code>scsi_probe(9F)</code> routine allocates a buffer, fills the buffer in,
and attaches the buffer to this field.</p>
</dd>
<dt class="hdlist1"><code>sd_sense</code></dt>
<dd>
<p>Pointer to a buffer to contain request sense data from the device. The
target driver must allocate and manage this buffer itself. See the
target driver&#8217;s <code>attach(9E)</code> routine in <a href="#attach-entry-point"> Entry
Point</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>sd_private</code></dt>
<dd>
<p>Pointer field for use by the target driver. This field is commonly
used to store a pointer to a private target driver state structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="scsi_pkt-structure-hba"><a class="anchor" href="#scsi_pkt-structure-hba"></a><code>scsi_pkt</code> Structure (HBA)</h5>
<div class="paragraph">
<p>To execute SCSI commands, a target driver must first
allocate a <code>scsi_pkt(9S)</code> structure for the command. The target
driver must then specify its own private data area length, the command
status, and the command length. The HBA driver is responsible for
implementing the packet allocation in the <code>tran_init_pkt(9E)</code>
entry point. The HBA driver is also responsible for freeing the packet
in its <code>tran_destroy_pkt(9E)</code> entry point. See <a href="#scsi_pkt-structure-target-drivers">
Structure (Target Drivers)</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_pkt(9S)</code> structure contains these fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct scsi_pkt {
    opaque_t pkt_ha_private;             /* private data for host adapter */
    struct scsi_address pkt_address;     /* destination address */
    opaque_t pkt_private;                /* private data for target driver */
    void (*pkt_comp)(struct scsi_pkt *); /* completion routine */
    uint_t  pkt_flags;                   /* flags */
    int     pkt_time;                    /* time allotted to complete command */
    uchar_t *pkt_scbp;                   /* pointer to status block */
    uchar_t *pkt_cdbp;                   /* pointer to command block */
    ssize_t pkt_resid;                   /* data bytes not transferred */
    uint_t  pkt_state;                   /* state of command */
    uint_t  pkt_statistics;              /* statistics */
    uchar_t pkt_reason;                  /* reason completion called */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pkt_ha_private</code></dt>
<dd>
<p>Pointer to per-command HBA-driver private data.</p>
</dd>
<dt class="hdlist1"><code>pkt_address</code></dt>
<dd>
<p>Pointer to the <code>scsi_address(9S)</code> structure providing address
information for this command.</p>
</dd>
<dt class="hdlist1"><code>pkt_private</code></dt>
<dd>
<p>Pointer to per-packet target-driver private data.</p>
</dd>
<dt class="hdlist1"><code>pkt_comp</code></dt>
<dd>
<p>Pointer to the target-driver completion routine called by the HBA
driver when the transport layer has completed this command.</p>
</dd>
<dt class="hdlist1"><code>pkt_flags</code></dt>
<dd>
<p>Flags for the command.</p>
</dd>
<dt class="hdlist1"><code>pkt_time</code></dt>
<dd>
<p>Specifies the completion timeout in seconds for the command.</p>
</dd>
<dt class="hdlist1"><code>pkt_scbp</code></dt>
<dd>
<p>Pointer to the status completion block for the command.</p>
</dd>
<dt class="hdlist1"><code>pkt_cdbp</code></dt>
<dd>
<p>Pointer to the command descriptor block (CDB) for the command.</p>
</dd>
<dt class="hdlist1"><code>pkt_resid</code></dt>
<dd>
<p>Count of the data bytes that were <em>not</em> transferred when the command
completed. This field can also be used to specify the amount of data
for which resources have not been allocated. The HBA must modify this
field during transport.</p>
</dd>
<dt class="hdlist1"><code>pkt_state</code></dt>
<dd>
<p>State of the command. The HBA must modify this field during transport.</p>
</dd>
<dt class="hdlist1"><code>pkt_statistics</code></dt>
<dd>
<p>Provides a history of the events that the command experienced while in
the transport layer. The HBA must modify this field during transport.</p>
</dd>
<dt class="hdlist1"><code>pkt_reason</code></dt>
<dd>
<p>Reason for command completion. The HBA must modify this field during
transport.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="per-target-instance-data"><a class="anchor" href="#per-target-instance-data"></a>3.30.3. Per-Target Instance Data</h4>
<div class="paragraph">
<p>An HBA driver must allocate a
<code>scsi_hba_tran(9S)</code> structure during <code>attach(9E)</code>. The HBA
driver must then initialize the vectors in this transport structure to
point to the required entry points for the HBA driver. This
<code>scsi_hba_tran</code> structure is then passed into
<code>scsi_hba_attach_setup(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_hba_tran</code> structure contains a
<code>tran_hba_private</code> field, which can be used to refer to the HBA
driver&#8217;s per-instance state.</p>
</div>
<div class="paragraph">
<p>Each <code>scsi_address(9S)</code> structure contains a pointer to the
<code>scsi_hba_tran</code> structure. In addition, the <code>scsi_address</code>
structure provides the target, that is, <code>a_target</code>, and logical unit
(<code>a_lun</code>) addresses for the particular target device. Each entry
point for the HBA driver is passed a pointer to the <code>scsi_address</code>
structure, either directly or indirectly through the
<code>scsi_device(9S)</code> structure. As a result, the HBA driver can
reference its own state. The HBA driver can also identify the target
device that is addressed.</p>
</div>
<div class="paragraph">
<p>The following figure illustrates the HBA data structures for transport
operations.</p>
</div>
<div id="scsihba-fig-25" class="imageblock">
<div class="content">
<img src="figures/scsihba-transportstructs.png" alt="Diagram shows the relationships of structures involved in the HBA transport layer.">
</div>
<div class="title">Figure 17. HBA Transport Structures</div>
</div>
</div>
<div class="sect3">
<h4 id="transport-structure-cloning"><a class="anchor" href="#transport-structure-cloning"></a>3.30.4. Transport Structure Cloning</h4>
<div class="paragraph">
<p>Cloning can be useful if an HBA driver
needs to maintain per-target private data in the
<code>scsi_hba_tran(9S)</code> structure. Cloning can also be used to
maintain a more complex address than is provided in the
<code>scsi_address(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>In the cloning process, the HBA driver must still allocate a
<code>scsi_hba_tran</code> structure at <code>attach(9E)</code> time. The HBA driver
must also initialize the <code>tran_hba_private</code> soft state pointer
and the entry point vectors for the HBA driver. The difference occurs
when the framework begins to connect an instance of a target driver to
the HBA driver. Before calling the HBA driver&#8217;s
<code>tran_tgt_init(9E)</code> entry point, the framework clones the
<code>scsi_hba_tran</code> structure that is associated with that instance
of the HBA. Accordingly, each <code>scsi_address</code> structure that is
allocated and initialized for a particular target device instance points
to a per-target instance <em>copy</em> of the <code>scsi_hba_tran</code>
structure. The <code>scsi_address</code> structures do not point to the
<code>scsi_hba_tran</code> structure that is allocated by the HBA driver at
<code>attach</code> time.</p>
</div>
<div class="paragraph">
<p>An HBA driver can use two important pointers when cloning is specified.
These pointers are contained in the <code>scsi_hba_tran</code> structure.
The first pointer is the <code>tran_tgt_private</code> field, which the
driver can use to point to per-target HBA private data. The
<code>tran_tgt_private</code> pointer is useful, for example, if an HBA
driver needs to maintain a more complex address than <code>a_target</code> and
<code>a_lun</code> provide. The second pointer is the <code>tran_sd</code> field,
which is a pointer to the <code>scsi_device(9S)</code> structure referring to
the particular target device.</p>
</div>
<div class="paragraph">
<p>When specifying cloning, the HBA driver must allocate and initialize the
per-target data. The HBA driver must then initialize the
<code>tran_tgt_private</code> field to point to this data during its
<code>tran_tgt_init(9E)</code> entry point. The HBA driver must free this
per-target data during its <code>tran_tgt_free(9E)</code> entry point.</p>
</div>
<div class="paragraph">
<p>When cloning, the framework initializes the <code>tran_sd</code> field to point
to the <code>scsi_device</code> structure before the HBA driver
<code>tran_tgt_init</code> entry point is called. The driver requests
cloning by passing the <code>SCSI_HBA_TRAN_CLONE</code> flag to
<code>scsi_hba_attach_setup(9F)</code>. The following figure
illustrates the HBA data structures for cloning transport operations.</p>
</div>
<div id="scsihba-fig-28" class="imageblock">
<div class="content">
<img src="figures/scsihba-cloningtransportop.png" alt="Diagram shows an example of cloned HBA structures." width="100">
</div>
<div class="title">Figure 18. Cloning Transport Operation</div>
</div>
</div>
<div class="sect3">
<h4 id="scsa-hba-functions"><a class="anchor" href="#scsa-hba-functions"></a>3.30.5. SCSA HBA Functions</h4>
<div class="paragraph">
<p>SCSA also provides a number of functions. The functions
are listed in the following table, for use by HBA drivers.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. SCSA HBA Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Name</th>
<th class="tableblock halign-left valign-top">Called by Driver Entry Point</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_init(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_init(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_fini(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_fini(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_attach_setup(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attach(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_detach(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>detach(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_tran_alloc(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attach(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_tran_free(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>detach(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_probe(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_probe(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_pkt_alloc(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_init_pkt(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_pkt_free(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_destroy_pkt(9E)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_lookup_capstr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_getcap(9E)</code> and
<code>tran_setcap(9E)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="hba-driver-dependency-and-configuration-issues"><a class="anchor" href="#hba-driver-dependency-and-configuration-issues"></a>3.31. HBA Driver Dependency and Configuration Issues</h3>
<div class="paragraph">
<p>In addition to incorporating SCSA HBA entry points, structures, and
functions into a driver, a developer must deal with driver dependency
and configuration issues. These issues involve configuration properties,
dependency declarations, state structure and per-command structure,
entry points for module initialization, and autoconfiguration entry
points.</p>
</div>
<div class="sect3">
<h4 id="declarations-and-structures"><a class="anchor" href="#declarations-and-structures"></a>3.31.1. Declarations and Structures</h4>
<div class="paragraph">
<p>HBA drivers must include the following header files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;sys/scsi/scsi.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To inform the system that the module depends on SCSA routines, the
driver binary must be generated with the following command. See
<a href="#scsa-hba-interfaces">SCSA HBA Interfaces</a> for more information on SCSA
routines.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% ld -r xx.o -o xx -N "misc/scsi"</pre>
</div>
</div>
<div class="paragraph">
<p>The code samples are derived from a simplified <code>isp</code> driver for the
QLogic Intelligent SCSI Peripheral device. The <code>isp</code> driver supports
WIDE SCSI, with up to 15 target devices and 8 logical units (LUNs) per
target.</p>
</div>
<div class="sect4">
<h5 id="per-command-structure"><a class="anchor" href="#per-command-structure"></a>Per-Command Structure</h5>
<div class="paragraph">
<p>An HBA driver usually needs to define a structure to
maintain state for each command submitted by a target driver. The layout
of this per-command structure is entirely up to the device driver
writer. The layout needs to reflect the capabilities and features of the
hardware and the software algorithms that are used in the driver.</p>
</div>
<div class="paragraph">
<p>The following structure is an example of a per-command structure. The
remaining code fragments of this chapter use this structure to
illustrate the HBA interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct isp_cmd {
     struct isp_request     cmd_isp_request;
     struct isp_response    cmd_isp_response;
     struct scsi_pkt        *cmd_pkt;
     struct isp_cmd         *cmd_forw;
     uint32_t               cmd_dmacount;
     ddi_dma_handle_t       cmd_dmahandle;
     uint_t                 cmd_cookie;
     uint_t                 cmd_ncookies;
     uint_t                 cmd_cookiecnt;
     uint_t                 cmd_nwin;
     uint_t                 cmd_curwin;
     off_t                  cmd_dma_offset;
     uint_t                 cmd_dma_len;
     ddi_dma_cookie_t       cmd_dmacookies[ISP_NDATASEGS];
     u_int                  cmd_flags;
     u_short                cmd_slot;
     u_int                  cmd_cdblen;
     u_int                  cmd_scblen;
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="entry-points-for-module-initialization"><a class="anchor" href="#entry-points-for-module-initialization"></a>3.31.2. Entry Points for Module Initialization</h4>
<div class="paragraph">
<p>This section describes the entry points for operations that are
performed by SCSI HBA drivers.</p>
</div>
<div class="paragraph">
<p>The following code for a SCSI HBA driver illustrates a representative
<code>dev_ops(9S)</code> structure. The driver must initialize the
<code>devo_bus_ops</code> field in this structure to <code>NULL</code>. A SCSI HBA
driver can provide leaf driver interfaces for special purposes, in which
case the <code>devo_cb_ops</code> field might point to a <code>cb_ops(9S)</code>
structure. In this example, no leaf driver interfaces are exported, so
the <code>devo_cb_ops</code> field is initialized to <code>NULL</code>.</p>
</div>
<div class="sect4">
<h5 id="_init-entry-point-scsi-hba-drivers"><a class="anchor" href="#_init-entry-point-scsi-hba-drivers"></a><code>_init</code> Entry Point (SCSI HBA Drivers)</h5>
<div class="paragraph">
<p>The <code>_init(9E)</code> function initializes a loadable module. <code>_init</code>
is called before any other routine in the loadable module.</p>
</div>
<div class="paragraph">
<p>In a SCSI HBA, the <code>_init</code> function must call
<code>scsi_hba_init(9F)</code> to inform the framework of the existence of
the HBA driver before calling <code>mod_install(9F)</code>. If
<code>scsi_hba__init</code> returns a nonzero value, <code>_init</code> should
return this value. Otherwise, <code>_init</code> must return the value returned
by <code>mod_install(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The driver should initialize any required global state before calling
<code>mod_install(9F)</code>.</p>
</div>
<div class="paragraph">
<p>If <code>mod_install</code> fails, the <code>_init</code> function must free any
global resources allocated. <code>_init</code> must call
<code>scsi_hba_fini(9F)</code> before returning.</p>
</div>
<div class="paragraph">
<p>The following example uses a global mutex to show how to allocate data
that is global to all instances of a driver. The code declares global
mutex and soft-state structure information. The global mutex and soft
state are initialized during <code>_init</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_fini-entry-point-scsi-hba-drivers"><a class="anchor" href="#_fini-entry-point-scsi-hba-drivers"></a><code>_fini</code> Entry Point (SCSI HBA Drivers)</h5>
<div class="paragraph">
<p>The <code>_fini(9E)</code> function is called when the system is about to try
to unload the SCSI HBA driver. The <code>_fini</code> function must call
<code>mod_remove(9F)</code> to determine whether the driver can be unloaded. If
<code>mod_remove</code> returns 0, the module can be unloaded. The HBA driver
must deallocate any global resources allocated in <code>_init(9E)</code>. The
HBA driver must also call <code>scsi_hba_fini(9F)</code>.</p>
</div>
<div class="paragraph">
<p><code>_fini</code> must return the value returned by <code>mod_remove</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The HBA driver must not free any resources or call
<code>scsi_hba_fini(9F)</code> unless <code>mod_remove(9F)</code> returns 0.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#scsihba-ex-38">example_title</a> shows module initialization for
SCSI HBA.</p>
</div>
<div id="scsihba-ex-38" class="paragraph">
<p>Module Initialization for SCSI HBA</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct dev_ops isp_dev_ops = {
    DEVO_REV,       /* devo_rev */
    0,              /* refcnt  */
    isp_getinfo,    /* getinfo */
    nulldev,        /* probe */
    isp_attach,     /* attach */
    isp_detach,     /* detach */
    nodev,          /* reset */
    NULL,           /* driver operations */
    NULL,           /* bus operations */
    isp_power,      /* power management */
};

/*
 * Local static data
 */
static kmutex_t      isp_global_mutex;
static void          *isp_state;

_init(void)
{
    int     err;

    if ((err = ddi_soft_state_init(&amp;isp_state,
        sizeof (struct isp), 0)) != 0) {
        return (err);
    }
    if ((err = scsi_hba_init(&amp;modlinkage)) == 0) {
        mutex_init(&amp;isp_global_mutex, "isp global mutex",
        MUTEX_DRIVER, NULL);
        if ((err = mod_install(&amp;modlinkage)) != 0) {
            mutex_destroy(&amp;isp_global_mutex);
            scsi_hba_fini(&amp;modlinkage);
            ddi_soft_state_fini(&amp;isp_state);
        }
    }
    return (err);
}

_fini(void)
{
    int     err;

    if ((err = mod_remove(&amp;modlinkage)) == 0) {
        mutex_destroy(&amp;isp_global_mutex);
        scsi_hba_fini(&amp;modlinkage);
        ddi_soft_state_fini(&amp;isp_state);
    }
    return (err);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="autoconfiguration-entry-points-1"><a class="anchor" href="#autoconfiguration-entry-points-1"></a>3.31.3. Autoconfiguration Entry Points</h4>
<div class="paragraph">
<p>Associated with each device driver is a
<code>dev_ops(9S)</code> structure, which enables the kernel to locate the
autoconfiguration entry points of the driver. A complete description of
these autoconfiguration routines is given in <a href="#driver-autoconfiguration">Driver
Autoconfiguration</a>. This section describes only those entry points
associated with operations performed by SCSI HBA drivers. These entry
points include <code>attach(9E)</code> and <code>detach(9E)</code>.</p>
</div>
<div class="sect4">
<h5 id="attach-entry-point-scsi-hba-drivers"><a class="anchor" href="#attach-entry-point-scsi-hba-drivers"></a><code>attach</code> Entry Point (SCSI HBA Drivers)</h5>
<div class="paragraph">
<p>The <code>attach(9E)</code> entry point for a SCSI HBA driver performs several
tasks when configuring and attaching an instance of the driver for the
device. For a typical driver of real devices, the following operating
system and hardware concerns must be addressed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Soft-state structure</p>
</li>
<li>
<p>DMA</p>
</li>
<li>
<p>Transport structure</p>
</li>
<li>
<p>Attaching an HBA driver</p>
</li>
<li>
<p>Register mapping</p>
</li>
<li>
<p>Interrupt specification</p>
</li>
<li>
<p>Interrupt handling</p>
</li>
<li>
<p>Create power manageable components</p>
</li>
<li>
<p>Report attachment status</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="scsihba-41"><a class="anchor" href="#scsihba-41"></a>Soft-State Structure</h6>
<div class="paragraph">
<p>When allocating the per-device-instance soft-state structure, a driver
must clean up carefully if an error occurs.</p>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-42"><a class="anchor" href="#scsihba-42"></a>DMA</h6>
<div class="paragraph">
<p>The HBA driver must describe the attributes of its DMA engine by
properly initializing the <code>ddi_dma_attr_t</code> structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static ddi_dma_attr_t isp_dma_attr = {
     DMA_ATTR_V0,        /* ddi_dma_attr version */
     0,                  /* low address */
     0xffffffff,         /* high address */
     0x00ffffff,         /* counter upper bound */
     1,                  /* alignment requirements */
     0x3f,               /* burst sizes */
     1,                  /* minimum DMA access */
     0xffffffff,         /* maximum DMA access */
     (1&lt;&lt;24)-1,          /* segment boundary restrictions */
     1,                  /* scatter-gather list length */
     512,                /* device granularity */
     0                   /* DMA flags */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The driver, if providing DMA, should also check that its hardware is
installed in a DMA-capable slot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">if (ddi_slaveonly(dip) == DDI_SUCCESS) {
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-43"><a class="anchor" href="#scsihba-43"></a>Transport Structure</h6>
<div class="paragraph">
<p>The driver should further allocate and initialize a
transport structure for this instance. The <code>tran_hba_private</code>
field is set to point to this instance&#8217;s soft-state structure. The
<code>tran_tgt_probe</code> field can be set to <code>NULL</code> to achieve the
default behavior, if no special probe customization is needed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tran = scsi_hba_tran_alloc(dip, SCSI_HBA_CANSLEEP);

isp-&gt;isp_tran                   = tran;
isp-&gt;isp_dip                    = dip;

tran-&gt;tran_hba_private          = isp;
tran-&gt;tran_tgt_private          = NULL;
tran-&gt;tran_tgt_init             = isp_tran_tgt_init;
tran-&gt;tran_tgt_probe            = scsi_hba_probe;
tran-&gt;tran_tgt_free             = (void (*)())NULL;

tran-&gt;tran_start                = isp_scsi_start;
tran-&gt;tran_abort                = isp_scsi_abort;
tran-&gt;tran_reset                = isp_scsi_reset;
tran-&gt;tran_getcap               = isp_scsi_getcap;
tran-&gt;tran_setcap               = isp_scsi_setcap;
tran-&gt;tran_init_pkt             = isp_scsi_init_pkt;
tran-&gt;tran_destroy_pkt          = isp_scsi_destroy_pkt;
tran-&gt;tran_dmafree              = isp_scsi_dmafree;
tran-&gt;tran_sync_pkt             = isp_scsi_sync_pkt;
tran-&gt;tran_reset_notify         = isp_scsi_reset_notify;
tran-&gt;tran_bus_quiesce          = isp_tran_bus_quiesce
tran-&gt;tran_bus_unquiesce        = isp_tran_bus_unquiesce
tran-&gt;tran_bus_reset            = isp_tran_bus_reset
tran-&gt;tran_interconnect_type    = isp_tran_interconnect_type</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-44"><a class="anchor" href="#scsihba-44"></a>Attaching an HBA Driver</h6>
<div class="paragraph">
<p>The driver should attach this instance of the device, and perform error
cleanup if necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">i = scsi_hba_attach_setup(dip, &amp;isp_dma_attr, tran, 0);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-45"><a class="anchor" href="#scsihba-45"></a>Register Mapping</h6>
<div class="paragraph">
<p>The driver should map in its device&#8217;s registers. The driver need to
specify the following items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Register set index</p>
</li>
<li>
<p>Data access characteristics of the device</p>
</li>
<li>
<p>Size of the register to be mapped</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ddi_device_acc_attr_t    dev_attributes;

     dev_attributes.devacc_attr_version = DDI_DEVICE_ATTR_V0;
     dev_attributes.devacc_attr_dataorder = DDI_STRICTORDER_ACC;
     dev_attributes.devacc_attr_endian_flags = DDI_STRUCTURE_LE_ACC;

     if (ddi_regs_map_setup(dip, 0, (caddr_t *)&amp;isp-&gt;isp_reg,
     0, sizeof (struct ispregs), &amp;dev_attributes,
     &amp;isp-&gt;isp_acc_handle) != DDI_SUCCESS) {
        /* do error recovery */
        return (DDI_FAILURE);
     }</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-46"><a class="anchor" href="#scsihba-46"></a>Adding an Interrupt Handler</h6>
<div class="paragraph">
<p>The driver must first obtain the <em>iblock cookie</em> to initialize any
mutexes that are used in the driver handler. Only after those mutexes
have been initialized can the interrupt handler be added.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">i = ddi_get_iblock_cookie(dip, 0, &amp;isp-&gt;iblock_cookie};
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}

mutex_init(&amp;isp-&gt;mutex, "isp_mutex", MUTEX_DRIVER,
(void *)isp-&gt;iblock_cookie);
i = ddi_add_intr(dip, 0, &amp;isp-&gt;iblock_cookie,
0, isp_intr, (caddr_t)isp);
if (i != DDI_SUCCESS) {
    /* do error recovery */
    return (DDI_FAILURE);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a high-level handler is required, the driver should be coded to
provide such a handler. Otherwise, the driver must be able to fail the
attach. See <a href="#handling-high-level-interrupts">Handling High-Level Interrupts</a> for a
description of high-level interrupt handling.</p>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-104"><a class="anchor" href="#scsihba-104"></a>Create Power Manageable Components</h6>
<div class="paragraph">
<p>With power management, if the host bus adapter only needs to power down
when all target adapters are at power level 0, the HBA driver only needs
to provide a <code>power(9E)</code> entry point. Refer to
<a href="#power-management">Power Management</a>. The HBA driver also needs to
create a <code>pm-components(9P)</code> property that describes the components that
the device implements.</p>
</div>
<div class="paragraph">
<p>Nothing more is necessary, since the components will default to idle,
and the power management framework&#8217;s default dependency processing will
ensure that the host bus adapter will be powered up whenever an target
adapter is powered up. Provided that automatic power management is
enabled automatically, the processing will also power down the host bus
adapter when all target adapters are powered down ().</p>
</div>
</div>
<div class="sect5">
<h6 id="scsihba-47"><a class="anchor" href="#scsihba-47"></a>Report Attachment Status</h6>
<div class="paragraph">
<p>Finally, the driver should report that this instance of the device is
attached and return success.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ddi_report_dev(dip);
return (DDI_SUCCESS);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="detach-entry-point-scsi-hba-drivers"><a class="anchor" href="#detach-entry-point-scsi-hba-drivers"></a><code>detach</code> Entry Point (SCSI HBA Drivers)</h5>
<div class="paragraph">
<p>The driver should perform standard detach operations, including calling
<code>scsi_hba_detach(9F)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entry-points-for-scsa-hba-drivers"><a class="anchor" href="#entry-points-for-scsa-hba-drivers"></a>3.32. Entry Points for SCSA HBA Drivers</h3>
<div class="paragraph">
<p>An HBA driver can work with target drivers through the SCSA interface.
The SCSA interfaces require the HBA driver to supply a number of entry
points that are callable through the <code>scsi_hba_tran(9S)</code>
structure.</p>
</div>
<div class="paragraph">
<p>These entry points fall into five functional groups:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Target driver instance initialization</p>
</li>
<li>
<p>Resource allocation and deallocation</p>
</li>
<li>
<p>Command transport</p>
</li>
<li>
<p>Capability management</p>
</li>
<li>
<p>Abort and reset handling</p>
</li>
<li>
<p>Dynamic reconfiguration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following table lists the entry points for SCSA HBA
by function groups.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 19. SCSA Entry Points</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Groups</th>
<th class="tableblock halign-left valign-top">Entry Points Within Group</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target Driver Instance Initialization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_init(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performs per-target initialization (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_probe(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Probes SCSI bus for existence of a
target (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_tgt_free(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performs per-target deallocation
(optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource Allocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_init_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allocates SCSI packet
and DMA resources</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_destroy_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frees SCSI packet and DMA resources</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_sync_pkt(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Synchronizes memory before and after DMA</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_dmafree(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Frees DMA resources</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command Transport</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_start(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transports a SCSI command</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability Management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_getcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inquires about a
capability&#8217;s value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_setcap(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets a capability&#8217;s value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Abort and Reset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_abort(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aborts outstanding SCSI commands</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resets a target device or the SCSI bus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_bus_reset(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resets the SCSI bus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_reset_notify(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Request to notify target of bus
reset (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dynamic Reconfiguration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_quiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stops activity on the</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tran_unquiesce(9E)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resumes activity on the bus</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="target-driver-instance-initialization"><a class="anchor" href="#target-driver-instance-initialization"></a>3.32.1. Target Driver Instance Initialization</h4>
<div class="paragraph">
<p>The following sections describe target entry points.</p>
</div>
<div class="sect4">
<h5 id="trantgtinit-entry-point"><a class="anchor" href="#trantgtinit-entry-point"></a><code>tran_tgt_init</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_tgt_init(9E)</code> entry
point enables the HBA to allocate and initialize any per-target
resources. <code>tran_tgt_init</code> also enables the HBA to qualify the
device&#8217;s address as valid and supportable for that particular HBA. By
returning <code>DDI_FAILURE</code>, the instance of the target driver for that
device is not probed or attached.</p>
</div>
<div class="paragraph">
<p><code>tran_tgt_init</code> is not required. If <code>tran_tgt_init</code> is
not supplied, the framework attempts to probe and attach all possible
instances of the appropriate target drivers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_tran_tgt_init(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *tran,
    struct scsi_device    *sd)
{
    return ((sd-&gt;sd_address.a_target &lt; N_ISP_TARGETS_WIDE &amp;&amp;
        sd-&gt;sd_address.a_lun &lt; 8) ? DDI_SUCCESS : DDI_FAILURE);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="trantgtprobe-entry-point"><a class="anchor" href="#trantgtprobe-entry-point"></a><code>tran_tgt_probe</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_tgt_probe(9E)</code> entry point enables the
HBA to customize the operation of <code>scsi_probe(9F)</code>, if necessary.
This entry point is called only when the target driver calls
<code>scsi_probe</code>.</p>
</div>
<div class="paragraph">
<p>The HBA driver can retain the normal
operation of <code>scsi_probe</code> by calling <code>scsi_hba_probe(9F)</code>
and returning its return value.</p>
</div>
<div class="paragraph">
<p>This entry point is not required, and if not needed, the HBA driver
should set the <code>tran_tgt_probe</code> vector in the
<code>scsi_hba_tran(9S)</code> structure to point to
<code>scsi_hba_probe</code>.</p>
</div>
<div class="paragraph">
<p><code>scsi_probe</code> allocates a <code>scsi_inquiry(9S)</code>
structure and sets the <code>sd_inq</code> field of the <code>scsi_device(9S)</code>
structure to point to the data in <code>scsi_inquiry</code>.
<code>scsi_hba_probe</code> handles this task automatically.
<code>scsi_unprobe(9F)</code> then frees the <code>scsi_inquiry</code> data.</p>
</div>
<div class="paragraph">
<p>Except for the allocation of <code>scsi_inquiry</code> data,
<code>tran_tgt_probe</code> must be stateless, because the same SCSI device
might call <code>tran_tgt_probe</code> several times. Normally, allocation
of <code>scsi_inquiry</code> data is handled by <code>scsi_hba_probe</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The allocation of the <code>scsi_inquiry(9S)</code> structure is handled
automatically by <code>scsi_hba_probe</code>. This information is only of
concern if you want custom <code>scsi_probe</code> handling.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_tran_tgt_probe(
    struct scsi_device    *sd,
    int                   (*callback)())
{
    /*
     * Perform any special probe customization needed.
     * Normal probe handling.
     */
    return (scsi_hba_probe(sd, callback));
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="trantgtfree-entry-point"><a class="anchor" href="#trantgtfree-entry-point"></a><code>tran_tgt_free</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_tgt_free(9E)</code> entry point enables the
HBA to perform any deallocation or clean-up procedures for an instance
of a target. This entry point is optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
isp_tran_tgt_free(
    dev_info_t            *hba_dip,
    dev_info_t            *tgt_dip,
    scsi_hba_tran_t       *hba_tran,
    struct scsi_device    *sd)
{
    /*
     * Undo any special per-target initialization done
     * earlier in tran_tgt_init(9F) and tran_tgt_probe(9F)
     */
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resource-allocation-1"><a class="anchor" href="#resource-allocation-1"></a>3.32.2. Resource Allocation</h4>
<div class="paragraph">
<p>The following sections discuss resource allocation.</p>
</div>
<div class="sect4">
<h5 id="traninitpkt-entry-point"><a class="anchor" href="#traninitpkt-entry-point"></a><code>tran_init_pkt</code> Entry Point</h5>
<div class="paragraph">
<p><code>tran_init_pkt(9E)</code> entry point allocates and initializes a
<code>scsi_pkt(9S)</code> structure and DMA resources for a target driver
request.</p>
</div>
<div class="paragraph">
<p>The <code>tran_init_pkt(9E)</code> entry point is called when the target
driver calls the SCSA function <code>scsi_init_pkt(9F)</code>.</p>
</div>
<div class="paragraph">
<p>Each call of the <code>tran_init_pkt(9E)</code> entry point is a request to
perform one or more of three possible services:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocation and initialization of a <code>scsi_pkt(9S)</code> structure</p>
</li>
<li>
<p>Allocation of DMA resources for data transfer</p>
</li>
<li>
<p>Reallocation of DMA resources for the next portion of the data</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="allocation-and-initialization-of-a-scsi_pkt9s-structure"><a class="anchor" href="#allocation-and-initialization-of-a-scsi_pkt9s-structure"></a>Allocation and Initialization of a <code>scsi_pkt(9S)</code> Structure</h5>
<div class="paragraph">
<p>The <code>tran_init_pkt(9E)</code> entry point must allocate a
<code>scsi_pkt(9S)</code> structure through
<code>scsi_hba_pkt_alloc(9F)</code> if <code>pkt</code> is <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p><code>scsi_hba_pkt_alloc(9F)</code> allocates space for
the following items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>scsi_pkt(9S)</code></p>
</li>
<li>
<p>SCSI CDB of length <code>cmdlen</code></p>
</li>
<li>
<p>Completion area for SCSI status of length <code>statuslen</code></p>
</li>
<li>
<p>Per-packet target driver private data area of length <code>tgtlen</code></p>
</li>
<li>
<p>Per-packet HBA driver private data area of length <code>hbalen</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>scsi_pkt(9S)</code> structure members, including <code>pkt</code>, must be
initialized to zero except for the following members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pkt_scbp</code> – Status completion</p>
</li>
<li>
<p><code>pkt_cdbp</code> – CDB</p>
</li>
<li>
<p><code>pkt_ha_private</code> – HBA driver private data</p>
</li>
<li>
<p><code>pkt_private</code> – Target driver private data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These members are pointers to memory space where the values of the
fields are stored, as shown in the following figure. For more
information, refer to <a href="#scsi_pkt-structure-hba"> Structure (HBA)</a>.</p>
</div>
<div id="scsihba-fig-59" class="paragraph">
<div class="title"><code>scsi_pkt(9S)</code> Structure Pointers</div>
<p>image::figures/scsihba-structptrs.png[Diagram shows the scsi_pkt structure with those members that point to values rather than being
initialized to zero.]</p>
</div>
<div class="paragraph">
<p>The following example shows allocation and initialization of a
<code>scsi_pkt</code> structure.</p>
</div>
<div id="scsihba-ex-61" class="paragraph">
<p>HBA Driver Initialization of a SCSI Packet Structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static struct scsi_pkt *
isp_scsi_init_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt,
    struct buf             *bp,
    int                    cmdlen,
    int                    statuslen,
    int                    tgtlen,
    int                    flags,
    int                    (*callback)(),
    caddr_t                arg)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct scsi_pkt        *new_pkt;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    /*
     * First step of isp_scsi_init_pkt:  pkt allocation
     */
    if (pkt == NULL) {
        pkt = scsi_hba_pkt_alloc(isp-&gt;isp_dip, ap, cmdlen,
            statuslen, tgtlen, sizeof (struct isp_cmd),
            callback, arg);
        if (pkt == NULL) {
            return (NULL);
        }

        sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
        /*
         * Initialize the new pkt
         */
        sp-&gt;cmd_pkt         = pkt;
        sp-&gt;cmd_flags       = 0;
        sp-&gt;cmd_scblen      = statuslen;
        sp-&gt;cmd_cdblen      = cmdlen;
        sp-&gt;cmd_dmahandle   = NULL;
        sp-&gt;cmd_ncookies    = 0;
        sp-&gt;cmd_cookie      = 0;
        sp-&gt;cmd_cookiecnt   = 0;
        sp-&gt;cmd_nwin        = 0;
        pkt-&gt;pkt_address    = *ap;
        pkt-&gt;pkt_comp       = (void (*)())NULL;
        pkt-&gt;pkt_flags      = 0;
        pkt-&gt;pkt_time       = 0;
        pkt-&gt;pkt_resid      = 0;
        pkt-&gt;pkt_statistics = 0;
        pkt-&gt;pkt_reason     = 0;
        new_pkt = pkt;
    } else {
        sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
        new_pkt = NULL;
    }
    /*
     * Second step of isp_scsi_init_pkt:  dma allocation/move
     */
    if (bp &amp;&amp; bp-&gt;b_bcount != 0) {
        if (sp-&gt;cmd_dmahandle == NULL) {
            if (isp_i_dma_alloc(isp, pkt, bp, flags, callback) == 0) {
                if (new_pkt) {
                    scsi_hba_pkt_free(ap, new_pkt);
                }
                return ((struct scsi_pkt *)NULL);
            }
        } else {
            ASSERT(new_pkt == NULL);
            if (isp_i_dma_move(isp, pkt, bp) == 0) {
                return ((struct scsi_pkt *)NULL);
            }
        }
    }
    return (pkt);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="allocation-of-dma-resources"><a class="anchor" href="#allocation-of-dma-resources"></a>Allocation of DMA Resources</h5>
<div class="paragraph">
<p>The <code>tran_init_pkt(9E)</code> entry point must allocate DMA resources
for a data transfer if the following conditions are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bp</code> is not null.</p>
</li>
<li>
<p><code>bp-&gt;b_bcount</code> is not zero.</p>
</li>
<li>
<p>DMA resources have not yet been allocated for this <code>scsi_pkt(9S)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The HBA driver needs to track how DMA resources are
allocated for a particular command. This allocation can take place with
a flag bit or a DMA handle in the per-packet HBA driver private data.</p>
</div>
<div class="paragraph">
<p>The <code>PKT_DMA_PARTIAL</code> flag in the <code>pkt</code> enables the target
driver to break up a data transfer into multiple SCSI commands to
accommodate the complete request. This approach is useful when the HBA
hardware scatter-gather capabilities or system DMA resources cannot
complete a request in a single SCSI command.</p>
</div>
<div class="paragraph">
<p>The <code>PKT_DMA_PARTIAL</code> flag enables the HBA driver to set the
<code>DDI_DMA_PARTIAL</code> flag. The <code>DDI_DMA_PARTIAL</code> flag is
useful when the DMA resources for this SCSI command are allocated. For
example the <code>ddi_dma_buf_bind_handle(9F)</code>) command can
be used to allocate DMA resources. The DMA attributes used when
allocating the DMA resources should accurately describe any constraints
placed on the ability of the HBA hardware to perform DMA. If the system
can only allocate DMA resources for part of the request,
<code>ddi_dma_buf_bind_handle(9F)</code> returns
<code>DDI_DMA_PARTIAL_MAP</code>.</p>
</div>
<div class="paragraph">
<p>The <code>tran_init_pkt(9E)</code> entry point must return the amount of
DMA resources not allocated for this transfer in the field
<code>pkt_resid</code>.</p>
</div>
<div class="paragraph">
<p>A target driver can make one request to <code>tran_init_pkt(9E)</code> to
simultaneously allocate both a <code>scsi_pkt(9S)</code> structure and DMA
resources for that <code>pkt</code>. In this case, if the HBA driver is unable to
allocate DMA resources, that driver must free the allocated
<code>scsi_pkt(9S)</code> before returning. The <code>scsi_pkt(9S)</code> must be
freed by calling <code>scsi_hba_pkt_free(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The target driver might first allocate the <code>scsi_pkt(9S)</code> and
allocate DMA resources for this <code>pkt</code> at a later time. In this case, if
the HBA driver is unable to allocate DMA resources, the driver must
<em>not</em> free <code>pkt</code>. The target driver in this case is responsible for
freeing the <code>pkt</code>.</p>
</div>
<div id="scsihba-ex-63" class="paragraph">
<p>HBA Driver Allocation of DMA Resources</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_i_dma_alloc(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp,
    int                flags,
    int                (*callback)())
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    int                dma_flags;
    ddi_dma_attr_t     tmp_dma_attr;
    int                (*cb)(caddr_t);
    int                i;

    ASSERT(callback == NULL_FUNC || callback == SLEEP_FUNC);

    if (bp-&gt;b_flags &amp; B_READ) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMASEND;
        dma_flags = DDI_DMA_READ;
    } else {
        sp-&gt;cmd_flags |= CFLAG_DMASEND;
        dma_flags = DDI_DMA_WRITE;
    }
    if (flags &amp; PKT_CONSISTENT) {
        sp-&gt;cmd_flags |= CFLAG_CMDIOPB;
        dma_flags |= DDI_DMA_CONSISTENT;
    }
    if (flags &amp; PKT_DMA_PARTIAL) {
        dma_flags |= DDI_DMA_PARTIAL;
    }

    tmp_dma_attr = isp_dma_attr;
    tmp_dma_attr.dma_attr_burstsizes = isp-&gt;isp_burst_size;

    cb = (callback == NULL_FUNC) ? DDI_DMA_DONTWAIT : DDI_DMA_SLEEP;

    if ((i = ddi_dma_alloc_handle(isp-&gt;isp_dip, &amp;tmp_dma_attr,
      cb, 0, &amp;sp-&gt;cmd_dmahandle)) != DDI_SUCCESS) {
        switch (i) {
          case DDI_DMA_BADATTR:
              bioerror(bp, EFAULT);
              return (0);
          case DDI_DMA_NORESOURCES:
              bioerror(bp, 0);
              return (0);
        }
    }

    i = ddi_dma_buf_bind_handle(sp-&gt;cmd_dmahandle, bp, dma_flags,
    cb, 0, &amp;sp-&gt;cmd_dmacookies[0], &amp;sp-&gt;cmd_ncookies);

    switch (i) {
      case DDI_DMA_PARTIAL_MAP:
          if (ddi_dma_numwin(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_nwin) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_numwin() failed\n");
          }

          if (ddi_dma_getwin(sp-&gt;cmd_dmahandle, sp-&gt;cmd_curwin,
            &amp;sp-&gt;cmd_dma_offset, &amp;sp-&gt;cmd_dma_len, &amp;sp-&gt;cmd_dmacookies[0],
            &amp;sp-&gt;cmd_ncookies) == DDI_FAILURE) {
              cmn_err(CE_PANIC, "ddi_dma_getwin() failed\n");
          }
          goto get_dma_cookies;

      case DDI_DMA_MAPPED:
          sp-&gt;cmd_nwin = 1;
          sp-&gt;cmd_dma_len = 0;
          sp-&gt;cmd_dma_offset = 0;

      get_dma_cookies:
          i = 0;
          sp-&gt;cmd_dmacount = 0;
          for (;;) {
              sp-&gt;cmd_dmacount += sp-&gt;cmd_dmacookies[i++].dmac_size;
              if (i == ISP_NDATASEGS || i == sp-&gt;cmd_ncookies)
                  break;
              ddi_dma_nextcookie(sp-&gt;cmd_dmahandle,
              &amp;sp-&gt;cmd_dmacookies[i]);
          }
          sp-&gt;cmd_cookie = i;
          sp-&gt;cmd_cookiecnt = i;
          sp-&gt;cmd_flags |= CFLAG_DMAVALID;
          pkt-&gt;pkt_resid = bp-&gt;b_bcount - sp-&gt;cmd_dmacount;
          return (1);

      case DDI_DMA_NORESOURCES:
          bioerror(bp, 0);
          break;

      case DDI_DMA_NOMAPPING:
          bioerror(bp, EFAULT);
          break;

      case DDI_DMA_TOOBIG:
          bioerror(bp, EINVAL);
          break;

      case DDI_DMA_INUSE:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " DDI_DMA_INUSE impossible\n");

      default:
          cmn_err(CE_PANIC, "ddi_dma_buf_bind_handle:"
            " 0x%x impossible\n", i);
    }
    ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
    sp-&gt;cmd_dmahandle = NULL;
    sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
    return (0);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reallocation-of-dma-resources-for-data-transfer"><a class="anchor" href="#reallocation-of-dma-resources-for-data-transfer"></a>Reallocation of DMA Resources for Data Transfer</h5>
<div class="paragraph">
<p>For a previously allocated packet with data remaining to be transferred,
the <code>tran_init_pkt(9E)</code> entry point must reallocate DMA
resources when the following conditions apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Partial DMA resources have already been allocated.</p>
</li>
<li>
<p>A non-zero pkt_resid was returned in the previous call to
<code>tran_init_pkt(9E)</code>.</p>
</li>
<li>
<p><code>bp</code> is not null.</p>
</li>
<li>
<p><code>bp-&gt;b_bcount</code> is not zero.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When reallocating DMA resources to the next portion of the transfer,
<code>tran_init_pkt(9E)</code> must return the amount of DMA resources not
allocated for this transfer in the field <code>pkt_resid</code>.</p>
</div>
<div class="paragraph">
<p>If an error occurs while attempting to move DMA resources,
<code>tran_init_pkt(9E)</code> must not free the <code>scsi_pkt(9S)</code>. The
target driver in this case is responsible for freeing the packet.</p>
</div>
<div class="paragraph">
<p>If the callback parameter is <code>NULL_FUNC</code>, the
<code>tran_init_pkt(9E)</code> entry point must not sleep or call any
function that might sleep. If the callback parameter is <code>SLEEP_FUNC</code>
and resources are not immediately available, the
<code>tran_init_pkt(9E)</code> entry point should sleep. Unless the request
is impossible to satisfy, <code>tran_init_pkt</code> should sleep until
resources become available.</p>
</div>
<div id="scsihba-ex-65" class="paragraph">
<p>DMA Resource Reallocation for HBA Drivers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_i_dma_move(
    struct isp         *isp,
    struct scsi_pkt    *pkt,
    struct buf         *bp)
{
    struct isp_cmd     *sp  = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    int                i;

    ASSERT(sp-&gt;cmd_flags &amp; CFLAG_COMPLETED);
    sp-&gt;cmd_flags &amp;= ~CFLAG_COMPLETED;
    /*
     * If there are no more cookies remaining in this window,
     * must move to the next window first.
     */
    if (sp-&gt;cmd_cookie == sp-&gt;cmd_ncookies) {
        /*
         * For small pkts, leave things where they are
         */
        if (sp-&gt;cmd_curwin == sp-&gt;cmd_nwin &amp;&amp; sp-&gt;cmd_nwin == 1)
            return (1);
        /*
         * At last window, cannot move
         */
        if (++sp-&gt;cmd_curwin &gt;= sp-&gt;cmd_nwin)
            return (0);
        if (ddi_dma_getwin(sp-&gt;cmd_dmahandle, sp-&gt;cmd_curwin,
          &amp;sp-&gt;cmd_dma_offset, &amp;sp-&gt;cmd_dma_len,
          &amp;sp-&gt;cmd_dmacookies[0], &amp;sp-&gt;cmd_ncookies) == DDI_FAILURE)
            return (0);
        sp-&gt;cmd_cookie = 0;
    } else {
        /*
         * Still more cookies in this window - get the next one
         */
        ddi_dma_nextcookie(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_dmacookies[0]);
    }
    /*
     * Get remaining cookies in this window, up to our maximum
     */
    i = 0;
    for (;;) {
        sp-&gt;cmd_dmacount += sp-&gt;cmd_dmacookies[i++].dmac_size;
        sp-&gt;cmd_cookie++;
        if (i == ISP_NDATASEGS || sp-&gt;cmd_cookie == sp-&gt;cmd_ncookies)
            break;
        ddi_dma_nextcookie(sp-&gt;cmd_dmahandle, &amp;sp-&gt;cmd_dmacookies[i]);
    }
    sp-&gt;cmd_cookiecnt = i;
    pkt-&gt;pkt_resid = bp-&gt;b_bcount - sp-&gt;cmd_dmacount;
    return (1);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="trandestroypkt-entry-point"><a class="anchor" href="#trandestroypkt-entry-point"></a><code>tran_destroy_pkt</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_destroy_pkt(9E)</code> entry point is the
HBA driver function that deallocates <code>scsi_pkt(9S)</code> structures. The
<code>tran_destroy_pkt</code> entry point is called when the target driver
calls <code>scsi_destroy_pkt(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>tran_destroy_pkt</code> entry point must free any
DMA resources that have been allocated for the packet. An implicit DMA
synchronization occurs if the DMA resources are freed and any cached
data remains after the completion of the transfer. The
<code>tran_destroy_pkt</code> entry point frees the SCSI packet by calling
<code>scsi_hba_pkt_free(9F)</code>.</p>
</div>
<div id="scsihba-ex-67" class="paragraph">
<p>HBA Driver <code>tran_destroy_pkt(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
isp_scsi_destroy_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt    *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    /*
     * Free the DMA, if any
     */
    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
        (void) ddi_dma_unbind_handle(sp-&gt;cmd_dmahandle);
        ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
        sp-&gt;cmd_dmahandle = NULL;
    }
    /*
     * Free the pkt
     */
    scsi_hba_pkt_free(ap, pkt);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="transyncpkt-entry-point"><a class="anchor" href="#transyncpkt-entry-point"></a><code>tran_sync_pkt</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_sync_pkt(9E)</code> entry
point synchronizes the DMA object allocated for the <code>scsi_pkt(9S)</code>
structure before or after a DMA transfer. The <code>tran_sync_pkt</code>
entry point is called when the target driver calls
<code>scsi_sync_pkt(9F)</code>.</p>
</div>
<div class="paragraph">
<p>If the data transfer direction is a DMA read from device to memory,
<code>tran_sync_pkt</code> must synchronize the CPU&#8217;s view of the data. If
the data transfer direction is a DMA write from memory to device,
<code>tran_sync_pkt</code> must synchronize the device&#8217;s view of the data.</p>
</div>
<div id="scsihba-ex-69" class="paragraph">
<p>HBA Driver <code>tran_sync_pkt(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
isp_scsi_sync_pkt(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;

    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        (void)ddi_dma_sync(sp-&gt;cmd_dmahandle, sp-&gt;cmd_dma_offset,
        sp-&gt;cmd_dma_len,
        (sp-&gt;cmd_flags &amp; CFLAG_DMASEND) ?
        DDI_DMA_SYNC_FORDEV : DDI_DMA_SYNC_FORCPU);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tran_dmafree-entry-point"><a class="anchor" href="#tran_dmafree-entry-point"></a><code>tran_dmafree</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_dmafree(9E)</code> entry point
deallocates DMA resources that have been allocated for a
<code>scsi_pkt(9S)</code> structure. The <code>tran_dmafree</code> entry point is
called when the target driver calls <code>scsi_dmafree(9F)</code>.</p>
</div>
<div class="paragraph">
<p><code>tran_dmafree</code> must free only DMA resources allocated for a
<code>scsi_pkt(9S)</code> structure, not the <code>scsi_pkt(9S)</code> itself. When
DMA resources are freed, a DMA synchronization is implicitly performed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>scsi_pkt(9S)</code> is freed in a separate request to
<code>tran_destroy_pkt(9E)</code>. Because <code>tran_destroy_pkt</code> must
also free DMA resources, the HBA driver must keep accurate note of
whether <code>scsi_pkt</code> structures have DMA resources allocated.
</td>
</tr>
</table>
</div>
<div id="scsihba-ex-71" class="paragraph">
<p>HBA Driver <code>tran_dmafree(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static void
isp_scsi_dmafree(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd    *sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;

    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        sp-&gt;cmd_flags &amp;= ~CFLAG_DMAVALID;
        (void)ddi_dma_unbind_handle(sp-&gt;cmd_dmahandle);
        ddi_dma_free_handle(&amp;sp-&gt;cmd_dmahandle);
        sp-&gt;cmd_dmahandle = NULL;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="command-transport"><a class="anchor" href="#command-transport"></a>3.32.3. Command Transport</h4>
<div class="paragraph">
<p>An HBA driver goes through the following steps as part of command
transport:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Accept a command from the target driver.</p>
</li>
<li>
<p>Issue the command to the device hardware.</p>
</li>
<li>
<p>Service any interrupts that occur.</p>
</li>
<li>
<p>Manage time outs.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="tran_start-entry-point"><a class="anchor" href="#tran_start-entry-point"></a><code>tran_start</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_start(9E)</code> entry point for a
SCSI HBA driver is called to transport a SCSI command to the addressed
target. The SCSI command is described entirely within the
<code>scsi_pkt(9S)</code> structure, which the target driver allocated through
the HBA driver&#8217;s <code>tran_init_pkt(9E)</code> entry point. If the command
involves a data transfer, DMA resources must also have been allocated
for the <code>scsi_pkt(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>tran_start</code> entry point is called when a target driver calls
<code>scsi_transport(9F)</code>.</p>
</div>
<div class="paragraph">
<p><code>tran_start</code> should perform basic error checking along with any
initialization that is required by the command. The <code>FLAG_NOINTR</code>
flag in the <code>pkt_flags</code> field of the <code>scsi_pkt(9S)</code> structure
can affect the behavior of <code>tran_start</code>. If <code>FLAG_NOINTR</code> is not
set, <code>tran_start</code> must queue the command for execution on the
hardware and return immediately. Upon completion of the command, the HBA
driver should call the <code>pkt</code> completion routine.</p>
</div>
<div class="paragraph">
<p>If the <code>FLAG_NOINTR</code> is set, then the HBA driver should not call the
<code>pkt</code> completion routine.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates how to handle the
<code>tran_start(9E)</code> entry point. The ISP hardware provides a queue
per-target device. For devices that can manage only one active
outstanding command, the driver is typically required to manage a
per-target queue. The driver then starts up a new command upon
completion of the current command in a round-robin fashion.</p>
</div>
<div id="scsihba-ex-74" class="paragraph">
<p>HBA Driver <code>tran_start(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_scsi_start(
    struct scsi_address    *ap,
    struct scsi_pkt        *pkt)
{
    struct isp_cmd         *sp;
    struct isp             *isp;
    struct isp_request     *req;
    u_long                 cur_lbolt;
    int                    xfercount;
    int                    rval = TRAN_ACCEPT;
    int                    i;

    sp = (struct isp_cmd *)pkt-&gt;pkt_ha_private;
    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;

    sp-&gt;cmd_flags = (sp-&gt;cmd_flags &amp; ~CFLAG_TRANFLAG) |
                CFLAG_IN_TRANSPORT;
    pkt-&gt;pkt_reason = CMD_CMPLT;
    /*
     * set up request in cmd_isp_request area so it is ready to
     * go once we have the request mutex
     */
    req = &amp;sp-&gt;cmd_isp_request;

    req-&gt;req_header.cq_entry_type = CQ_TYPE_REQUEST;
    req-&gt;req_header.cq_entry_count = 1;
    req-&gt;req_header.cq_flags        = 0;
    req-&gt;req_header.cq_seqno = 0;
    req-&gt;req_reserved = 0;
    req-&gt;req_token = (opaque_t)sp;
    req-&gt;req_target = TGT(sp);
    req-&gt;req_lun_trn = LUN(sp);
    req-&gt;req_time = pkt-&gt;pkt_time;
    ISP_SET_PKT_FLAGS(pkt-&gt;pkt_flags, req-&gt;req_flags);
    /*
     * Set up data segments for dma transfers.
     */
    if (sp-&gt;cmd_flags &amp; CFLAG_DMAVALID) {
        if (sp-&gt;cmd_flags &amp; CFLAG_CMDIOPB) {
            (void) ddi_dma_sync(sp-&gt;cmd_dmahandle,
            sp-&gt;cmd_dma_offset, sp-&gt;cmd_dma_len,
            DDI_DMA_SYNC_FORDEV);
        }

        ASSERT(sp-&gt;cmd_cookiecnt &gt; 0 &amp;&amp;
            sp-&gt;cmd_cookiecnt &lt;= ISP_NDATASEGS);

        xfercount = 0;
        req-&gt;req_seg_count = sp-&gt;cmd_cookiecnt;
        for (i = 0; i &lt; sp-&gt;cmd_cookiecnt; i++) {
            req-&gt;req_dataseg[i].d_count =
            sp-&gt;cmd_dmacookies[i].dmac_size;
            req-&gt;req_dataseg[i].d_base =
            sp-&gt;cmd_dmacookies[i].dmac_address;
            xfercount +=
            sp-&gt;cmd_dmacookies[i].dmac_size;
        }

        for (; i &lt; ISP_NDATASEGS; i++) {
            req-&gt;req_dataseg[i].d_count = 0;
            req-&gt;req_dataseg[i].d_base = 0;
        }

        pkt-&gt;pkt_resid = xfercount;

        if (sp-&gt;cmd_flags &amp; CFLAG_DMASEND) {
            req-&gt;req_flags |= ISP_REQ_FLAG_DATA_WRITE;
        } else {
            req-&gt;req_flags |= ISP_REQ_FLAG_DATA_READ;
        }
    } else {
        req-&gt;req_seg_count = 0;
        req-&gt;req_dataseg[0].d_count = 0;
    }
    /*
     * Set up cdb in the request
     */
    req-&gt;req_cdblen = sp-&gt;cmd_cdblen;
    bcopy((caddr_t)pkt-&gt;pkt_cdbp, (caddr_t)req-&gt;req_cdb,
    sp-&gt;cmd_cdblen);
    /*
     * Start the cmd.  If NO_INTR, must poll for cmd completion.
     */
    if ((pkt-&gt;pkt_flags &amp; FLAG_NOINTR) == 0) {
        mutex_enter(ISP_REQ_MUTEX(isp));
        rval = isp_i_start_cmd(isp, sp);
        mutex_exit(ISP_REQ_MUTEX(isp));
    } else {
        rval = isp_i_polled_cmd_start(isp, sp);
    }
    return (rval);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-handler-and-command-completion"><a class="anchor" href="#interrupt-handler-and-command-completion"></a>Interrupt Handler and Command Completion</h5>
<div class="paragraph">
<p>The interrupt handler must check the status of the
device to be sure the device is generating the interrupt in question.
The interrupt handler must also check for any errors that have occurred
and service any interrupts generated by the device.</p>
</div>
<div class="paragraph">
<p>If data is transferred, the hardware should be checked to determine how
much data was actually transferred. The <code>pkt_resid</code> field in the
<code>scsi_pkt(9S)</code> structure should be set to the residual of the
transfer.</p>
</div>
<div class="paragraph">
<p>Commands that are marked with the <code>PKT_CONSISTENT</code> flag when DMA
resources are allocated through <code>tran_init_pkt(9E)</code> take special
handling. The HBA driver must ensure that the data transfer for the
command is correctly synchronized before the target driver&#8217;s command
completion callback is performed.</p>
</div>
<div class="paragraph">
<p>Once a command has completed, you need to act on two requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a new command is queued up, start the command on the hardware as
quickly as possible.</p>
</li>
<li>
<p>Call the command completion callback. The callback has been set up in
the <code>scsi_pkt(9S)</code> structure by the target driver to notify the
target driver when the command is complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Start a new command on the hardware, if possible, before calling the
<code>PKT_COMP</code> command completion callback. The command completion
handling can take considerable time. Typically, the target driver calls
functions such as <code>biodone(9F)</code> and possibly <code>scsi_transport(9F)</code> to
begin a new command.</p>
</div>
<div class="paragraph">
<p>The interrupt handler must return DDI_INTR_CLAIMED if this
interrupt is claimed by this driver. Otherwise, the handler returns
DDI_INTR_UNCLAIMED.</p>
</div>
<div class="paragraph">
<p>The following example shows an interrupt handler for the SCSI HBA <code>isp</code>
driver. The <code>caddr_t</code> parameter is set up when the interrupt handler
is added in <code>attach(9E)</code>. This parameter is typically a pointer to the
state structure, which is allocated on a per instance basis.</p>
</div>
<div id="scsihba-ex-76" class="paragraph">
<p>HBA Driver Interrupt Handler</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static u_int
isp_intr(caddr_t arg)
{
    struct isp_cmd         *sp;
    struct isp_cmd         *head, *tail;
    u_short                response_in;
    struct isp_response    *resp;
    struct isp             *isp = (struct isp *)arg;
    struct isp_slot        *isp_slot;
    int                    n;

    if (ISP_INT_PENDING(isp) == 0) {
        return (DDI_INTR_UNCLAIMED);
    }

    do {
again:
        /*
         * head list collects completed packets for callback later
         */
        head = tail = NULL;
        /*
         * Assume no mailbox events (e.g., mailbox cmds, asynch
         * events, and isp dma errors) as common case.
         */
        if (ISP_CHECK_SEMAPHORE_LOCK(isp) == 0) {
            mutex_enter(ISP_RESP_MUTEX(isp));
            /*
             * Loop through completion response queue and post
             * completed pkts.  Check response queue again
             * afterwards in case there are more.
             */
            isp-&gt;isp_response_in =
            response_in = ISP_GET_RESPONSE_IN(isp);
            /*
             * Calculate the number of requests in the queue
             */
            n = response_in - isp-&gt;isp_response_out;
            if (n &lt; 0) {
                n = ISP_MAX_REQUESTS -
                isp-&gt;isp_response_out + response_in;
            }
            while (n-- &gt; 0) {
                ISP_GET_NEXT_RESPONSE_OUT(isp, resp);
                sp = (struct isp_cmd *)resp-&gt;resp_token;
                /*
                 * Copy over response packet in sp
                 */
                isp_i_get_response(isp, resp, sp);
            }
            if (head) {
                tail-&gt;cmd_forw = sp;
                tail = sp;
                tail-&gt;cmd_forw = NULL;
            } else {
                tail = head = sp;
                sp-&gt;cmd_forw = NULL;
            }
            ISP_SET_RESPONSE_OUT(isp);
            ISP_CLEAR_RISC_INT(isp);
            mutex_exit(ISP_RESP_MUTEX(isp));

            if (head) {
                isp_i_call_pkt_comp(isp, head);
            }
        } else {
            if (isp_i_handle_mbox_cmd(isp) != ISP_AEN_SUCCESS) {
                return (DDI_INTR_CLAIMED);
            }
            /*
             * if there was a reset then check the response
             * queue again
             */
            goto again;
        }

    } while (ISP_INT_PENDING(isp));

    return (DDI_INTR_CLAIMED);
}

static void
isp_i_call_pkt_comp(
    struct isp             *isp,
    struct isp_cmd         *head)
{
    struct isp             *isp;
    struct isp_cmd         *sp;
    struct scsi_pkt        *pkt;
    struct isp_response    *resp;
    u_char                 status;

    while (head) {
        sp = head;
        pkt = sp-&gt;cmd_pkt;
        head = sp-&gt;cmd_forw;

        ASSERT(sp-&gt;cmd_flags &amp; CFLAG_FINISHED);

        resp = &amp;sp-&gt;cmd_isp_response;

        pkt-&gt;pkt_scbp[0] = (u_char)resp-&gt;resp_scb;
        pkt-&gt;pkt_state = ISP_GET_PKT_STATE(resp-&gt;resp_state);
        pkt-&gt;pkt_statistics = (u_long)
            ISP_GET_PKT_STATS(resp-&gt;resp_status_flags);
        pkt-&gt;pkt_resid = (long)resp-&gt;resp_resid;
        /*
         * If data was xferred and this is a consistent pkt,
         * do a dma sync
         */
        if ((sp-&gt;cmd_flags &amp; CFLAG_CMDIOPB) &amp;&amp;
            (pkt-&gt;pkt_state &amp; STATE_XFERRED_DATA)) {
                (void) ddi_dma_sync(sp-&gt;cmd_dmahandle,
                sp-&gt;cmd_dma_offset, sp-&gt;cmd_dma_len,
                DDI_DMA_SYNC_FORCPU);
        }

        sp-&gt;cmd_flags = (sp-&gt;cmd_flags &amp; ~CFLAG_IN_TRANSPORT) |
            CFLAG_COMPLETED;
        /*
         * Call packet completion routine if FLAG_NOINTR is not set.
         */
        if (((pkt-&gt;pkt_flags &amp; FLAG_NOINTR) == 0) &amp;&amp;
            pkt-&gt;pkt_comp) {
                (*pkt-&gt;pkt_comp)(pkt);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="timeout-handler"><a class="anchor" href="#timeout-handler"></a>Timeout Handler</h5>
<div class="paragraph">
<p>The HBA driver is responsible for enforcing time outs. A
command must be complete within a specified time unless a zero time out
has been specified in the <code>scsi_pkt(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>When a command times out, the HBA driver should mark the
<code>scsi_pkt(9S)</code> with <code>pkt_reason</code> set to <code>CMD_TIMEOUT</code> and
<code>pkt_statistics</code> OR&#8217;d with <code>STAT_TIMEOUT</code>. The HBA driver should
also attempt to recover the target and bus. If this recovery can be
performed successfully, the driver should mark the <code>scsi_pkt(9S)</code>
using <code>pkt_statistics</code> OR&#8217;d with either <code>STAT_BUS_RESET</code> or
<code>STAT_DEV_RESET</code>.</p>
</div>
<div class="paragraph">
<p>After the recovery attempt has completed, the HBA driver should call the
command completion callback.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If recovery was unsuccessful or not attempted, the target driver might
attempt to recover from the timeout by calling <code>scsi_reset(9F)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The ISP hardware manages command timeout directly and returns timed-out
commands with the necessary status. The timeout handler for the <code>isp</code>
sample driver checks active commands for the time out state only once
every 60 seconds.</p>
</div>
<div class="paragraph">
<p>The <code>isp</code> sample driver uses the <code>timeout(9F)</code> facility to arrange for
the kernel to call the timeout handler every 60 seconds. The
<code>caddr_t</code> argument is the parameter set up when the timeout is
initialized at <code>attach(9E)</code> time. In this case, the <code>caddr_t</code>
argument is a pointer to the state structure allocated per driver
instance.</p>
</div>
<div class="paragraph">
<p>If timed-out commands have not been returned as timed-out by the ISP
hardware, a problem has occurred. The hardware is not functioning
correctly and needs to be reset.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="capability-management"><a class="anchor" href="#capability-management"></a>3.32.4. Capability Management</h4>
<div class="paragraph">
<p>The following sections discuss capability management.</p>
</div>
<div class="sect4">
<h5 id="tran_getcap-entry-point"><a class="anchor" href="#tran_getcap-entry-point"></a><code>tran_getcap</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_getcap(9E)</code>
entry point for a SCSI HBA driver is called by <code>scsi_ifgetcap(9F)</code>.
The target driver calls <code>scsi_ifgetcap</code> to determine the current
value of one of a set of SCSA-defined capabilities.</p>
</div>
<div class="paragraph">
<p>The target driver can request the current setting of the capability for
a particular target by setting the <code>whom</code> parameter to nonzero. A <code>whom</code>
value of zero indicates a request for the current setting of the general
capability for the SCSI bus or for adapter hardware.</p>
</div>
<div class="paragraph">
<p>The <code>tran_getcap</code> entry point should return <code>-1</code> for undefined
capabilities or the current value of the requested capability.</p>
</div>
<div class="paragraph">
<p>The HBA driver can use the function
<code>scsi_hba_lookup_capstr(9F)</code> to compare the capability
string against the canonical set of defined capabilities.</p>
</div>
<div id="scsihba-ex-80" class="paragraph">
<p>HBA Driver <code>tran_getcap(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_scsi_getcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap-&gt;a_target;
    /*
      * We don't allow getting capabilities for other targets
    */
    if (cap == NULL || whom  == 0) {
        return (-1);
    }
    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
          rval = 1 &lt;&lt; 24; /* Limit to 16MB max transfer */
          break;
      case SCSI_CAP_MSG_OUT:
          rval = 1;
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_DISCONNECT) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_SYNC) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_SYNC) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_WIDE) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_WIDE) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0 ||
            (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_TAG) == 0) {
              break;
          } else if (
              (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_TAG) == 0) {
                  break;
          }
          rval = 1;
          break;
      case SCSI_CAP_UNTAGGED_QING:
          rval = 1;
          break;
      case SCSI_CAP_PARITY:
          if (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_PARITY) {
              rval = 1;
          }
          break;
      case SCSI_CAP_INITIATOR_ID:
          rval = isp-&gt;isp_initiator_id;
          break;
      case SCSI_CAP_ARQ:
          if (isp-&gt;isp_cap[tgt] &amp; ISP_CAP_AUTOSENSE) {
              rval = 1;
          }
          break;
      case SCSI_CAP_LINKED_CMDS:
          break;
      case SCSI_CAP_RESET_NOTIFICATION:
         rval = 1;
          break;
      case SCSI_CAP_GEOMETRY:
          rval = (64 &lt;&lt; 16) | 32;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tran_setcap-entry-point"><a class="anchor" href="#tran_setcap-entry-point"></a><code>tran_setcap</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_setcap(9E)</code> entry point for
a SCSI HBA driver is called by <code>scsi_ifsetcap(9F)</code>. A target driver
calls <code>scsi_ifsetcap</code> to change the current one of a set of
SCSA-defined capabilities.</p>
</div>
<div class="paragraph">
<p>The target driver might request that the new value be set for a
particular target by setting the <code>whom</code> parameter to nonzero. A <code>whom</code>
value of zero means the request is to set the new value for the SCSI bus
or for adapter hardware in general.</p>
</div>
<div class="paragraph">
<p><code>tran_setcap</code> should return the following values as appropriate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-1</code> for undefined capabilities</p>
</li>
<li>
<p><code>0</code> if the HBA driver cannot set the capability to the requested value</p>
</li>
<li>
<p><code>1</code> if the HBA driver is able to set the capability to the requested</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The HBA driver can use the function
<code>scsi_hba_lookup_capstr(9F)</code> to compare the capability
string against the canonical set of defined capabilities.</p>
</div>
<div id="scsihba-ex-82" class="paragraph">
<p>HBA Driver <code>tran_setcap(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static int
isp_scsi_setcap(
    struct scsi_address    *ap,
    char                   *cap,
    int                    value,
    int                    whom)
{
    struct isp             *isp;
    int                    rval = 0;
    u_char                 tgt = ap-&gt;a_target;
    int                    update_isp = 0;
    /*
     * We don't allow setting capabilities for other targets
     */
    if (cap == NULL || whom == 0) {
        return (-1);
    }

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    ISP_MUTEX_ENTER(isp);

    switch (scsi_hba_lookup_capstr(cap)) {
      case SCSI_CAP_DMA_MAX:
      case SCSI_CAP_MSG_OUT:
      case SCSI_CAP_PARITY:
      case SCSI_CAP_UNTAGGED_QING:
      case SCSI_CAP_LINKED_CMDS:
      case SCSI_CAP_RESET_NOTIFICATION:
          /*
           * None of these are settable through
           * the capability interface.
           */
          break;
      case SCSI_CAP_DISCONNECT:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_DISCONNECT;
              } else {
                isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_DISCONNECT;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_SYNCHRONOUS:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_SYNC) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_SYNC;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_SYNC;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_TAGGED_QING:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_DR) == 0 ||
            (isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_TAG) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_TAG;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_TAG;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_WIDE_XFER:
          if ((isp-&gt;isp_target_scsi_options[tgt] &amp;
            SCSI_OPTIONS_WIDE) == 0) {
                break;
          } else {
              if (value) {
                  isp-&gt;isp_cap[tgt] |= ISP_CAP_WIDE;
              } else {
                  isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_WIDE;
              }
          }
          rval = 1;
          break;
      case SCSI_CAP_INITIATOR_ID:
          if (value &lt; N_ISP_TARGETS_WIDE) {
              struct isp_mbox_cmd mbox_cmd;
              isp-&gt;isp_initiator_id = (u_short) value;
              /*
               * set Initiator SCSI ID
               */
              isp_i_mbox_cmd_init(isp, &amp;mbox_cmd, 2, 2,
                ISP_MBOX_CMD_SET_SCSI_ID,
                isp-&gt;isp_initiator_id,
                0, 0, 0, 0);
              if (isp_i_mbox_cmd_start(isp, &amp;mbox_cmd) == 0) {
                  rval = 1;
              }
          }
          break;
      case SCSI_CAP_ARQ:
          if (value) {
              isp-&gt;isp_cap[tgt] |= ISP_CAP_AUTOSENSE;
          } else {
              isp-&gt;isp_cap[tgt] &amp;= ~ISP_CAP_AUTOSENSE;
          }
          rval = 1;
          break;
      default:
          rval = -1;
          break;
    }
    ISP_MUTEX_EXIT(isp);
    return (rval);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="abort-and-reset-management"><a class="anchor" href="#abort-and-reset-management"></a>3.32.5. Abort and Reset Management</h4>
<div class="paragraph">
<p>The following sections discuss the abort and reset entry points for SCSI
HBA.</p>
</div>
<div class="sect4">
<h5 id="tran_abort-entry-point"><a class="anchor" href="#tran_abort-entry-point"></a><code>tran_abort</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_abort(9E)</code>
entry point for a SCSI HBA driver is called to abort any commands that
are currently in transport for a particular target. This entry point is
called when a target driver calls <code>scsi_abort(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>tran_abort</code> entry point should attempt to abort the command
denoted by the <code>pkt</code> parameter. If the <code>pkt</code> parameter is <code>NULL</code>,
<code>tran_abort</code> should attempt to abort all outstanding commands in the
transport layer for the particular target or logical unit.</p>
</div>
<div class="paragraph">
<p>Each command successfully aborted must be marked with <code>pkt_reason</code>
<code>CMD_ABORTED</code> and <code>pkt_statistics</code> OR&#8217;d with <code>STAT_ABORTED</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="tran_reset-entry-point"><a class="anchor" href="#tran_reset-entry-point"></a><code>tran_reset</code> Entry Point</h5>
<div class="paragraph">
<p>The <code>tran_reset(9E)</code> entry point for a
SCSI HBA driver is called to reset either the SCSI bus or a particular
SCSI target device. This entry point is called when a target driver
calls <code>scsi_reset(9F)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>tran_reset</code> entry point must reset the SCSI bus if level is
<code>RESET_ALL</code>. If level is <code>RESET_TARGET</code>, just the particular
target or logical unit must be reset.</p>
</div>
<div class="paragraph">
<p>Active commands affected by the reset must be marked with
<code>pkt_reason</code> <code>CMD_RESET</code>. The type of reset determines whether
<code>STAT_BUS_RESET</code> or <code>STAT_DEV_RESET</code> should be used to
OR <code>pkt_statistics</code>.</p>
</div>
<div class="paragraph">
<p>Commands in the transport layer, but not yet active on the target, must
be marked with <code>pkt_reason</code> <code>CMD_RESET</code>, and
<code>pkt_statistics</code> OR&#8217;d with <code>STAT_ABORTED</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="tranbusreset-entry-point"><a class="anchor" href="#tranbusreset-entry-point"></a><code>tran_bus_reset</code> Entry Point</h5>
<div class="paragraph">
<p><code>tran_bus_reset(9E)</code> must reset the SCSI bus without resetting
targets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;sys/scsi/scsi.h&gt;

int tran_bus_reset(dev_info_t *hba-dip, int level);</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;*hba-dip&gt;</dt>
<dd>
<p>Pointer associated with the SCSI HBA</p>
</dd>
<dt class="hdlist1">&lt;level&gt;</dt>
<dd>
<p>Must be set to <code>RESET_BUS</code> so that only the SCSI bus is reset, not
the targets</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>tran_bus_reset</code> vector in the <code>scsi_hba_tran(9S)</code>
structure should be initialized during the HBA driver&#8217;s <code>attach(9E)</code>.
The vector should point to an HBA entry point that is to be called when
a user initiates a bus reset.</p>
</div>
<div class="paragraph">
<p>Implementation is hardware specific. If the HBA driver cannot reset the
SCSI bus without affecting the targets, the driver should fail
<code>RESET_BUS</code> or not initialize this vector.</p>
</div>
</div>
<div class="sect4">
<h5 id="tranresetnotify-entry-point"><a class="anchor" href="#tranresetnotify-entry-point"></a><code>tran_reset_notify</code> Entry Point</h5>
<div class="paragraph">
<p>Use the <code>tran_reset_notify(9E)</code>
entry point when a SCSI bus reset occurs. This function requests the
SCSI HBA driver to notify the target driver by callback.</p>
</div>
<div id="scsihba-ex-87" class="paragraph">
<p>HBA Driver <code>tran_reset_notify(9E)</code> Entry Point</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">isp_scsi_reset_notify(
    struct scsi_address    *ap,
    int                    flag,
    void                   (*callback)(caddr_t),
    caddr_t                arg)
{
    struct isp                       *isp;
    struct isp_reset_notify_entry    *p, *beforep;
    int                              rval = DDI_FAILURE;

    isp = (struct isp *)ap-&gt;a_hba_tran-&gt;tran_hba_private;
    mutex_enter(ISP_REQ_MUTEX(isp));
    /*
     * Try to find an existing entry for this target
     */
    p = isp-&gt;isp_reset_notify_listf;
    beforep = NULL;

    while (p) {
        if (p-&gt;ap == ap)
            break;
        beforep = p;
        p = p-&gt;next;
    }

    if ((flag &amp; SCSI_RESET_CANCEL) &amp;&amp; (p != NULL)) {
        if (beforep == NULL) {
            isp-&gt;isp_reset_notify_listf = p-&gt;next;
        } else {
            beforep-&gt;next = p-&gt;next;
        }
        kmem_free((caddr_t)p, sizeof (struct isp_reset_notify_entry));
        rval = DDI_SUCCESS;
    } else if ((flag &amp; SCSI_RESET_NOTIFY) &amp;&amp; (p == NULL)) {
        p = kmem_zalloc(sizeof (struct isp_reset_notify_entry),
          KM_SLEEP);
        p-&gt;ap = ap;
        p-&gt;callback = callback;
        p-&gt;arg = arg;
        p-&gt;next = isp-&gt;isp_reset_notify_listf;
        isp-&gt;isp_reset_notify_listf = p;
        rval = DDI_SUCCESS;
    }
    mutex_exit(ISP_REQ_MUTEX(isp));
    return (rval);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-reconfiguration"><a class="anchor" href="#dynamic-reconfiguration"></a>3.32.6. Dynamic Reconfiguration</h4>
<div class="paragraph">
<p>SCSI HBA driver</p>
</div>
<div class="paragraph">
<p>and hotplugging</p>
</div>
<div class="paragraph">
<p>and SCSI HBA driver</p>
</div>
<div class="paragraph">
<p>To support the minimal set of hot-plugging operations, drivers might
need to implement support for bus <em>quiesce</em>, bus <em>unquiesce</em>, and bus
<em>reset</em>. The <code>scsi_hba_tran(9S)</code> structure supports these
operations. If quiesce, unquiesce, or reset are not required by
hardware, no driver changes are needed.</p>
</div>
<div class="paragraph">
<p>The <code>scsi_hba_tran</code> structure includes the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int (*tran_quiesce)(dev_info_t *hba-dip);
int (*tran_unquiesce)(dev_info_t *hba-dip);
int (*tran_bus_reset)(dev_info_t *hba-dip, int level);</code></pre>
</div>
</div>
<div class="paragraph">
<p>These interfaces quiesce and unquiesce a SCSI bus.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;sys/scsi/scsi.h&gt;

int prefixtran_quiesce(dev_info_t *hba-dip);
int prefixtran_unquiesce(dev_info_t *hba-dip);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>tran_quiesce(9E)</code> and <code>tran_unquiesce(9E)</code> are used for SCSI
devices that are not designed for hot-plugging. These functions must be
implemented by an HBA driver to support dynamic reconfiguration (DR).</p>
</div>
<div class="paragraph">
<p>The <code>tran_quiesce</code> and <code>tran_unquiesce</code> vectors in the
<code>scsi_hba_tran(9S)</code> structure should be initialized to point to
HBA entry points during <code>attach(9E)</code>. These functions are called when a
user initiates quiesce and unquiesce operations.</p>
</div>
<div class="paragraph">
<p>The <code>tran_quiesce</code> entry point stops all activity on a SCSI bus
prior to and during the reconfiguration of devices that are attached to
the SCSI bus. The <code>tran_unquiesce</code> entry point is called by the SCSA
framework to resume activity on the SCSI bus after the reconfiguration
operation has been completed.</p>
</div>
<div class="paragraph">
<p>HBA drivers are required to handle <code>tran_quiesce</code> by waiting for all
outstanding commands to complete before returning success. After the
driver has quiesced the bus, any new I/O requests must be queued until
the SCSA framework calls the corresponding <code>tran_unquiesce</code> entry
point.</p>
</div>
<div class="paragraph">
<p>HBA drivers handle calls to <code>tran_unquiesce</code> by starting any target
driver I/O requests in the queue.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scsi-hba-driver-specific-issues"><a class="anchor" href="#scsi-hba-driver-specific-issues"></a>3.33. SCSI HBA Driver Specific Issues</h3>
<div class="paragraph">
<p>The section covers issues specific to SCSI HBA drivers.</p>
</div>
<div class="sect3">
<h4 id="installing-hba-drivers"><a class="anchor" href="#installing-hba-drivers"></a>3.33.1. Installing HBA Drivers</h4>
<div class="paragraph">
<p>A SCSI HBA driver is installed in similar fashion to a leaf driver. See
<a href="#compiling-loading-packaging-and-testing-drivers">Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers</a>. The difference is that the <code>add_drv(8)</code> command
must specify the driver class as SCSI, such as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># add_drv -m" * 0666 root root" -i'"pci1077,1020"' -c scsi isp</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hba-configuration-properties"><a class="anchor" href="#hba-configuration-properties"></a>3.33.2. HBA Configuration Properties</h4>
<div class="paragraph">
<p>When attaching an instance of an HBA
device, <code>scsi_hba_attach_setup(9F)</code> creates a number of SCSI
configuration properties for that HBA instance. A particular property is
created only if no existing property of the same name is already
attached to the HBA instance. This restriction avoids overriding any
default property values in an HBA configuration file.</p>
</div>
<div class="paragraph">
<p>An HBA driver must use
<code>ddi_prop_get_int(9F)</code> to retrieve each property. The HBA
driver then modifies or accepts the default value of the properties to
configure its specific operation.</p>
</div>
<div class="sect4">
<h5 id="scsi-reset-delay-property"><a class="anchor" href="#scsi-reset-delay-property"></a><code>scsi-reset-delay</code> Property</h5>
<div class="paragraph">
<p>The <code>scsi-reset-delay</code> property is an integer specifying the recovery
time in milliseconds for a reset delay by either a SCSI bus or SCSI
device.</p>
</div>
</div>
<div class="sect4">
<h5 id="scsi-options-property"><a class="anchor" href="#scsi-options-property"></a><code>scsi-options</code> Property</h5>
<div class="paragraph">
<p>The <code>scsi-options</code> property is an integer specifying a number of options
through individually defined bits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SCSI_OPTIONS_DR (0x008)</code> – If not set, the HBA should not
grant disconnect privileges to a target device.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_LINK (0x010)</code> – If not set, the HBA should not
enable linked commands.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_SYNC (0x020)</code> – If not set, the HBA driver must
not negotiate synchronous data transfer. The driver should reject any
attempt to negotiate synchronous data transfer initiated by a target.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_PARITY (0x040)</code> – If not set, the HBA should run
the SCSI bus without parity.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_TAG (0x080)</code> – If not set, the HBA should not
operate in Command Tagged Queuing mode.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_FAST (0x100)</code> – If not set, the HBA should not
operate the bus in FAST SCSI mode.</p>
</li>
<li>
<p><code>SCSI_OPTIONS_WIDE (0x200)</code> – If not set, the HBA should not
operate the bus in WIDE SCSI mode.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="per-target-scsi-options"><a class="anchor" href="#per-target-scsi-options"></a>Per-Target <code>scsi-options</code></h5>
<div class="paragraph">
<p>An HBA driver might support a per-target <code>scsi</code>-<code>options</code> feature in the
following format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>target&lt;n&gt;-scsi-options=&lt;hex value&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, &lt; <em>n</em>&gt; is the target ID. If the per-target
<code>scsi-options</code> property is defined, the HBA driver uses that value
rather than the per-HBA driver instance <code>scsi-options</code> property. This
approach can provide more precise control if, for example, synchronous
data transfer needs to be disabled for just one particular target
device. The per-target <code>scsi-options</code> property can be defined in the
<code>driver.conf(5)</code> file.</p>
</div>
<div class="paragraph">
<p>The following example shows a per-target <code>scsi-options</code> property
definition to disable synchronous data transfer for target device 3:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>target3-scsi-options=0x2d8</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x86-target-driver-configuration-properties"><a class="anchor" href="#x86-target-driver-configuration-properties"></a>3.33.3. x86 Target Driver Configuration Properties</h4>
<div class="literalblock">
<div class="content">
<pre>  Some x86 SCSI target drivers, such as the
driver for `cmdk` disk, use the following configuration properties:</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>disk</code></p>
</li>
<li>
<p><code>queue</code></p>
</li>
<li>
<p><code>flow_control</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use the <code>cmdk</code> sample driver to write an HBA
driver for an x86 platform, any appropriate properties must be defined
in the <code>driver.conf(5)</code> file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These property definitions should appear only in an HBA driver&#8217;s
<code>driver.conf(5)</code> file. The HBA driver itself should not inspect or
attempt to interpret these properties in any way. These properties are
advisory only and serve as an adjunct to the <code>cmdk</code> driver. The
properties should not be relied upon in any way. The property
definitions might not be used in future releases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>disk</code> property can be used to define the type of disk supported by
<code>cmdk</code>. For a SCSI HBA, the only possible value for the <code>disk</code> property
is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>disk="scdk"</code> – Disk type is a SCSI disk</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>queue</code> property defines how the disk driver sorts the queue of
incoming requests during <code>strategy(9E)</code>. Two values are possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>queue="qsort"</code> – One-way elevator queuing model, provided by
<code>disksort(9F)</code></p>
</li>
<li>
<p><code>queue="qfifo"</code> – FIFO, that is, first in, first out queuing model</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>flow_control</code> property defines how commands are transported to
the HBA driver. Three values are possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>flow_control="dsngl"</code> – Single command per HBA driver</p>
</li>
<li>
<p><code>flow_control="dmult"</code> – Multiple commands per HBA driver. When
the HBA queue is full, the driver returns TRAN_BUSY.</p>
</li>
<li>
<p><code>flow_control="duplx"</code> – The HBA can support separate read and
write queues, with multiple commands per queue. FIFO ordering is used
for the write queue. The queuing model that is used for the read queue
is described by the <em>queue</em> property. When an HBA queue is full, the
driver returns TRAN_BUSY</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example is a <code>driver.conf(5)</code> file for use with an x86 HBA
PCI device that has been designed for use with the <code>cmdk</code> sample driver:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#
# config file for ISP 1020 SCSI HBA driver
#
       flow_control="dsngl" queue="qsort" disk="scdk"
       scsi-initiator-id=7;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="support-for-queuing"><a class="anchor" href="#support-for-queuing"></a>3.34. Support for Queuing</h3>
<div class="paragraph">
<p>For a definition of <em>tagged queuing</em>,
refer to the SCSI-2 specification. To support tagged queuing, first
check the &lt;scsi_options&gt; flag <code>SCSI_OPTIONS_TAG</code> to
see whether tagged queuing is enabled globally. Next, check to see
whether the target is a SCSI-2 device and whether the target has tagged
queuing enabled. If these conditions are all true, attempt to enable
tagged queuing by using <code>scsi_ifsetcap(9F)</code>.</p>
</div>
<div class="paragraph">
<p>If tagged queuing fails, you can attempt to set
<em>untagged queuing</em>. In this mode, you submit as many commands as you
think necessary or optimal to the host adapter driver. Then the host
adapter queues the commands to the target one command at a time, in
contrast to tagged queuing. In tagged queuing, the host adapter submits
as many commands as possible until the target indicates that the queue
is full.</p>
</div>
</div>
<div class="sect2">
<h3 id="drivers-for-network-devices"><a class="anchor" href="#drivers-for-network-devices"></a>3.35. Drivers for Network Devices</h3>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>network drivers</p>
</div>
<div class="paragraph">
<p>network drivers</p>
</div>
<div class="paragraph">
<p>using GLD</p>
</div>
<div class="paragraph">
<p>illumos network drivers are STREAMS-based. These types of drivers are
covered in depth in the STREAMS Programming Guide. This chapter
discusses the Generic LAN driver (GLD), which is a kernel module
encapsulating features common to most network drivers. The GLD
implements much of the STREAMS and Data Link Provider Interface (DLPI)
functionality for an illumos network driver.</p>
</div>
<div class="paragraph">
<p>The GLD module is available for illumos network drivers for the SPARC
platform and for both 32-bit and 64-bit x86 platforms.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#generic-lan-driver-overview">Generic LAN Driver Overview</a></p>
</li>
<li>
<p><a href="#declarations-and-data-structures">Declarations and Data Structures</a></p>
</li>
<li>
<p><a href="#gld-arguments">GLD Arguments</a></p>
</li>
<li>
<p><a href="#gld-entry-points">GLD Entry Points</a></p>
</li>
<li>
<p><a href="#gld-service-routines">GLD Service Routines</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information on GLDs, see the <code>gld(4D)</code>, <code>dlpi(4P)</code>, <code>gld(9E)</code>,
<code>gld(9F)</code>, <code>gld_mac_info(9S)</code>, and <code>gld_stats(9S)</code> man
pages.</p>
</div>
</div>
<div class="sect2">
<h3 id="generic-lan-driver-overview"><a class="anchor" href="#generic-lan-driver-overview"></a>3.36. Generic LAN Driver Overview</h3>
<div class="paragraph">
<p>GLD is a multi-threaded, clonable, loadable kernel
module providing support to device drivers for local area networks.
Local area network (LAN) device drivers in illumos are STREAMS-based
drivers that use DLPI to communicate with network protocol stacks. These
protocol stacks use the network drivers to send and receive packets on a
local area network.</p>
</div>
<div class="paragraph">
<p>A network device driver must implement and conform to these
requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DDI/DKI specification</p>
</li>
<li>
<p>STREAMS specification</p>
</li>
<li>
<p>DLPI specification</p>
</li>
<li>
<p>programmatic interface for the device</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>GLD implements most STREAMS and DLPI functionality required of an
illumos LAN driver. Several illumos network drivers are implemented
using GLD.</p>
</div>
<div class="paragraph">
<p>An illumos
network driver that is implemented using GLD is made up of two distinct
parts: a generic component that deals with STREAMS and DLPI interfaces,
and a device-specific component that deals with the particular hardware
device. The device-specific module indicates its dependency on the GLD
module, which is found at <code>/kernel/misc/gld</code>. The device-specific module
then registers with GLD from within the driver&#8217;s <code>attach(9E)</code> function.
After the device-specific module is successfully loaded, the driver is
DLPI-compliant. The device-specific part of the driver calls <code>gld(9F)</code>
functions when that part receives data or needs some service from GLD.
When the device-specific driver registers with the GLD, the driver
provides pointers to the entry points for later use by GLD. GLD makes
calls into the <code>gld(9E)</code> using these pointers. The
<code>gld_mac_info(9S)</code> structure is the main data interface between
GLD and the device-specific driver.</p>
</div>
<div class="paragraph">
<p>The GLD facility currently supports the following types of devices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DL_ETHER</code>, that is, ISO 8802-3, IEEE 802.3 protocol</p>
</li>
<li>
<p><code>DL_TPR</code>, that is, IEEE 802.5, Token Passing Ring</p>
</li>
<li>
<p><code>DL_FDDI</code>, that is, ISO 9314-2, Fibre Distributed Data Interface</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>drivers are expected to process fully formed MAC-layer packets and
should not perform logical link control (LLC) handling.</p>
</div>
<div class="paragraph">
<p>In some cases, a full DLPI-compliant driver can be implemented without
using the GLD facility. One case would be devices that are not ISO
8802-style, that is, IEEE 802, LAN devices. Another case would be
devices or services that are not supported by GLD.</p>
</div>
<div class="sect3">
<h4 id="type-dl_ether-ethernet-v2-and-iso-8802-3-ieee-8023"><a class="anchor" href="#type-dl_ether-ethernet-v2-and-iso-8802-3-ieee-8023"></a>3.36.1. Type <code>DL_ETHER</code>: Ethernet V2 and ISO 8802-3 (IEEE 802.3)</h4>
<div class="paragraph">
<p>DL_ETHER</p>
</div>
<div class="paragraph">
<p>GLD support</p>
</div>
<div class="paragraph">
<p>DL_ETHER</p>
</div>
<div class="paragraph">
<p>Ethernet V2 packet processing</p>
</div>
<div class="paragraph">
<p>packet processing</p>
</div>
<div class="paragraph">
<p>Ethernet V2</p>
</div>
<div class="paragraph">
<p>DL_ETHER</p>
</div>
<div class="paragraph">
<p>ISO 8802-3 (IEEE 802.3) packet processing</p>
</div>
<div class="paragraph">
<p>packet processing</p>
</div>
<div class="paragraph">
<p>ISO 8802-3 (IEEE 802.3)</p>
</div>
<div class="paragraph">
<p>For devices designated type <code>DL_ETHER</code>, GLD provides
support for both Ethernet V2 and ISO 8802-3 (IEEE 802.3) packet
processing. Ethernet V2 enables a user to access a conforming provider
of data link services without special knowledge of the provider&#8217;s
protocol. A service access point (SAP) is the point through which the
user communicates with the service provider.</p>
</div>
<div class="paragraph">
<p>Streams bound to SAP values in the range [0-255] are treated as
equivalent and denote that the user wants to use 8802-3 mode. If the SAP
value of the <code>DL_BIND_REQ</code> is within this range, GLD computes
the length of each subsequent <code>DL_UNITDATA_REQ</code> message on that
stream. The length does not include the 14-byte media access control
(MAC) header. GLD then transmits 8802-3 frames that have those lengths
in the MAC frame header <code>type</code> fields. Such lengths never exceed 1500.</p>
</div>
<div class="paragraph">
<p>All frames that are received from the media that have a <code>type</code> field in
the range [0-1500] are assumed to be 8802-3 frames. These frames
are routed up all open streams in 8802-3 mode. Those streams with SAP
values in the [0-255] range are considered to be in 8802-3 mode.
If more than one stream is in 8802-3 mode, the incoming frame is
duplicated and routed up these streams.</p>
</div>
<div class="paragraph">
<p>Those streams that are bound to SAP values that are greater than 1500
are assumed to be in Ethernet V2 mode. These streams receive incoming
packets whose Ethernet MAC header <code>type</code> value exactly matches the value
of the SAP to which the stream is bound.</p>
</div>
</div>
<div class="sect3">
<h4 id="types-dltpr-and-dlfddi-snap-processing"><a class="anchor" href="#types-dltpr-and-dlfddi-snap-processing"></a>3.36.2. Types <code>DL_TPR</code> and <code>DL_FDDI</code>: SNAP Processing</h4>
<div class="paragraph">
<p>DL_TPR</p>
</div>
<div class="paragraph">
<p>GLD support</p>
</div>
<div class="paragraph">
<p>DL_FDDI</p>
</div>
<div class="paragraph">
<p>GLD support</p>
</div>
<div class="paragraph">
<p>DL_TPR</p>
</div>
<div class="paragraph">
<p>SNAP processing</p>
</div>
<div class="paragraph">
<p>DL_FDDI</p>
</div>
<div class="paragraph">
<p>SNAP processing</p>
</div>
<div class="paragraph">
<p>For media types <code>DL_TPR</code>
and <code>DL_FDDI</code>, GLD implements minimal SNAP (Sub-Net Access Protocol)
processing. This processing is for any stream that is bound to a SAP
value that is greater than 255. SAP values in the range [0-255]
are LLC SAP values. Such values are carried naturally by the media
packet format. SAP values that are greater than 255 require a SNAP
header, subordinate to the LLC header, to carry the 16-bit Ethernet
V2-style SAP value.</p>
</div>
<div class="paragraph">
<p>SNAP headers are carried under LLC headers with destination SAP 0xAA.
Outbound packets with SAP values that are greater than 255 require an
LLC&#43;SNAP header take the following form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>AA AA 03 00 00 00 XX XX</pre>
</div>
</div>
<div class="paragraph">
<p>``XX XX'' represents the 16-bit SAP, corresponding to the Ethernet
V2 style ``type.'' This header is unique in supporting non-zero
organizational unique identifier fields. LLC control fields other than
03 are considered to be LLC packets with SAP 0xAA. Clients wanting to
use SNAP formats other than this format must use LLC and bind to SAP
0xAA.</p>
</div>
<div class="paragraph">
<p>Incoming packets are checked for conformance with the above format.
Packets that conform are matched to any streams that have been bound to
the packet&#8217;s 16-bit SNAP type. In addition, these packets are considered
to match the LLC SNAP SAP 0xAA.</p>
</div>
<div class="paragraph">
<p>Packets received for any LLC SAP are passed up all streams that are
bound to an LLC SAP, as described for media type <code>DL_ETHER</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="type-dl_tpr-source-routing"><a class="anchor" href="#type-dl_tpr-source-routing"></a>3.36.3. Type <code>DL_TPR</code>: Source Routing</h4>
<div class="paragraph">
<p>DL_TPR</p>
</div>
<div class="paragraph">
<p>GLD support</p>
</div>
<div class="paragraph">
<p>DL_TPR</p>
</div>
<div class="paragraph">
<p>source routing</p>
</div>
<div class="paragraph">
<p>For type <code>DL_TPR</code> devices, GLD implements minimal support for source
routing. Source routing support includes the following items:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify routing information for a packet to be sent across a bridged
medium. The routing information is stored in the MAC header. This
information is used to determine the route.</p>
</li>
<li>
<p>Learn routes.</p>
</li>
<li>
<p>Solicit and respond to requests for information about possible
multiple routes</p>
</li>
<li>
<p>Select among available routes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Source routing adds routing information fields to the MAC headers of
outgoing packets. In addition, this support recognizes such fields in
incoming packets.</p>
</div>
<div class="paragraph">
<p>GLD&#8217;s source routing support does not implement the full route
determination entity (RDE) specified in Section 9 of ISO 8802-2 (IEEE
802.2). However, this support can interoperate with any RDE
implementations that might exist in the same or a bridged network.</p>
</div>
</div>
<div class="sect3">
<h4 id="style-1-and-style-2-dlpi-providers"><a class="anchor" href="#style-1-and-style-2-dlpi-providers"></a>3.36.4. Style 1 and Style 2 DLPI Providers</h4>
<div class="paragraph">
<p>DLPI providers</p>
</div>
<div class="paragraph">
<p>Style 1 DLPI provider</p>
</div>
<div class="paragraph">
<p>Style 2 DLPI provider</p>
</div>
<div class="paragraph">
<p>GLD implements both Style 1 and Style 2
DLPI providers. A physical point of attachment (PPA) is the point at
which a system attaches itself to a physical communication medium. All
communication on that physical medium funnels through the PPA. The Style
1 provider attaches the streams to a particular PPA based on the major
or minor device that has been opened. The Style 2 provider requires the
DLS, that is, the data link service, user to explicitly identify the
desired PPA using <code>DL_ATTACH_REQ</code>. In this case, <code>open(9E)</code>
creates a stream between the user and GLD, and <code>DL_ATTACH_REQ</code>
subsequently associates a particular PPA with that stream. Style 2 is
denoted by a minor number of zero. If a device node whose minor number
is not zero is opened, Style 1 is indicated and the associated PPA is
the minor number minus 1. In both Style 1 and Style 2 `open`s, the
device is cloned.</p>
</div>
</div>
<div class="sect3">
<h4 id="implemented-dlpi-primitives"><a class="anchor" href="#implemented-dlpi-primitives"></a>3.36.5. Implemented DLPI Primitives</h4>
<div class="paragraph">
<p>DLPI primitives</p>
</div>
<div class="paragraph">
<p>GLD implements several DLPI primitives.
The <code>DL_INFO_REQ</code> primitive requests information about the DLPI
streams. The message consists of one <code>M_PROTO</code> message block. GLD
returns device-dependent values in the <code>DL_INFO_ACK</code> response to
this request. These values are based on information that the GLD-based
driver specified in the <code>gldm_mac_info(9S)</code> structure that was
passed to <code>gld_register</code>.</p>
</div>
<div class="paragraph">
<p>GLD returns the following values on behalf of all GLD-based drivers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Version is <code>DL_VERSION_2</code></p>
</li>
<li>
<p>Service mode is <code>DL_CLDLS</code>, GLD
implements connectionless-mode service.</p>
</li>
<li>
<p>Provider
style is <code>DL_STYLE1</code> or <code>DL_STYLE2</code>, depending on how the stream
was opened.</p>
</li>
<li>
<p>No optional Quality of Service (QOS) support is present. The QOS
fields are zero.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Contrary to the DLPI specification, GLD returns the device&#8217;s correct
address length and broadcast address in <code>DL_INFO_ACK</code> even
before the stream has been attached to a PPA.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>DL_ATTACH_REQ</code> primitive is
used to associate a PPA with a stream. This request is needed for Style
2 DLS providers to identify the physical medium over which the
communication is sent. Upon completion, the state changes from
<code>DL_UNATTACHED</code> to <code>DL_UNBOUND</code>. The message consists of one
<code>M_PROTO</code> message block. This request is not allowed when Style 1
mode is used. Streams that are opened using Style 1 are already attached
to a PPA by the time the open completes.</p>
</div>
<div class="paragraph">
<p>The <code>DL_DETACH_REQ</code> primitive
requests to detach the PPA from the stream. This detachment is allowed
only if the stream was opened using Style 2.</p>
</div>
<div class="paragraph">
<p><code>DL_BIND_REQ</code> and <code>DL_UNBIND_REQ</code> primitives bind and
unbind a DLSAP (data link service access point) to the stream. The PPA
that is associated with a stream completes initialization before the
completion of the processing of the <code>DL_BIND_REQ</code> on that
stream. You can bind multiple streams to the same SAP. Each stream in
this case receives a copy of any packets that were received for that
SAP.</p>
</div>
<div class="paragraph">
<p><code>DL_ENABMULTI_REQ</code> and <code>DL_DISABMULTI_REQ</code> primitives
enable and disable reception of individual multicast group addresses.
Through iterative use of these primitives, an application or other DLS
user can create or modify a set of multicast addresses. The streams must
be attached to a PPA for these primitives to be accepted.</p>
</div>
<div class="paragraph">
<p><code>DL_PROMISCON_REQ</code> and <code>DL_PROMISCOFF_REQ</code> primitives
turn promiscuous mode on or off on a per-stream basis. These controls
operate at either at a physical level or at the SAP level. The DL
Provider routes all received messages on the media to the DLS user.
Routing continues until a <code>DL_DETACH_REQ</code> is received, a
<code>DL_PROMISCOFF_REQ</code> is received, or the stream is closed. You
can specify physical level promiscuous reception of all packets on the
medium or of multicast packets only.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The streams must be attached to a PPA for these promiscuous mode
primitives to be accepted.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>DL_UNITDATA_REQ</code> primitive is used to send
data in a connectionless transfer. Because this service is not
acknowledged, delivery is not guaranteed. The message consists of one
<code>M_PROTO</code> message block followed by one or more <code>M_DATA</code> blocks
containing at least one byte of data.</p>
</div>
<div class="paragraph">
<p>The <code>DL_UNITDATA_IND</code> type is used when a packet
is to be passed on upstream. The packet is put into an <code>M_PROTO</code>
message with the primitive set to <code>DL_UNITDATA_IND</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DL_PHYS_ADDR_REQ</code>
primitive requests the MAC address currently associated with the PPA
attached to the streams. The address is returned by the
<code>DL_PHYS_ADDR_ACK</code> primitive. When using Style 2, this
primitive is only valid following a successful <code>DL_ATTACH_REQ</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DL_SET_PHYS_ADDR_REQ</code>
primitive changes the MAC address currently associated with the PPA
attached to the streams. This primitive affects all other current and
future streams attached to this device. Once changed, all streams
currently or subsequently opened and attached to this device obtain this
new physical address. The new physical address remains in effect until
this primitive changes the physical address again or the driver is
reloaded.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The superuser is allowed to change the physical address of a PPA while
other streams are bound to the same PPA.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>DL_GET_STATISTICS_REQ</code> primitive requests a
<code>DL_GET_STATISTICS_ACK</code> response containing statistics
information associated with the PPA attached to the stream. Style 2
Streams must be attached to a particular PPA using
<code>DL_ATTACH_REQ</code> before this primitive can succeed.</p>
</div>
</div>
<div class="sect3">
<h4 id="implemented-ioctl-functions"><a class="anchor" href="#implemented-ioctl-functions"></a>3.36.6. Implemented <code>ioctl</code> Functions</h4>
<div class="paragraph">
<p>GLD implements the <code>ioctl</code> &lt;ioc_cmd&gt; function described
below. If GLD receives an unrecognizable <code>ioctl</code> command, GLD passes the
command to the device-specific driver&#8217;s <code>gldm_ioctl</code> routine, as
described in <code>gld(9E)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DLIOCRAW</code> <code>ioctl</code>
function is used by some DLPI applications, most notably the <code>snoop(8)</code>
command. The <code>DLIOCRAW</code> command puts the stream into a raw mode. In raw
mode, the driver passes full MAC-level incoming packets upstream in
<code>M_DATA</code> messages instead of transforming the packets into the
<code>DL_UNITDATA_IND</code> form. The <code>DL_UNITDATA_IND</code> form is
normally used for reporting incoming packets. Packet SAP filtering is
still performed on streams that are in raw mode. If a stream user wants
to receive all incoming packets, the user must also select the
appropriate promiscuous modes. After successfully selecting raw mode,
the application is also allowed to send fully formatted packets to the
driver as <code>M_DATA</code> messages for transmission. <code>DLIOCRAW</code> takes no
arguments. Once enabled, the stream remains in this mode until closed.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld-driver-requirements"><a class="anchor" href="#gld-driver-requirements"></a>3.36.7. GLD Driver Requirements</h4>
<div class="paragraph">
<p>GLD-based drivers must include the header file <code>&lt;sys/gld.h&gt;</code>.</p>
</div>
<div class="paragraph">
<p>GLD-based drivers must be linked with the <code>N`</code>“misc/gld”` option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>%ld -r -N"misc/gld" xx.o -o xx</pre>
</div>
</div>
<div class="paragraph">
<p>GLD implements the following functions on behalf of the device-specific
driver:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>open(9E)</code></p>
</li>
<li>
<p><code>close(9E)</code></p>
</li>
<li>
<p><code>put(9E)</code>, required for STREAMS</p>
</li>
<li>
<p><code>srv(9E)</code>, required for STREAMS</p>
</li>
<li>
<p><code>getinfo(9E)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>mi_idname</code> element of the <code>module_info(9S)</code>
structure is a string that specifies the name of the driver. This string
must exactly match the name of the driver module as defined in the file
system.</p>
</div>
<div class="paragraph">
<p>The read-side <code>qinit(9S)</code> structure should specify the following
elements:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>qi_putp</code></dt>
<dd>
<p><code>NULL</code></p>
</dd>
<dt class="hdlist1"><code>qi_srvp</code></dt>
<dd>
<p><code>gld_rsrv</code></p>
</dd>
<dt class="hdlist1"><code>qi_qopen</code></dt>
<dd>
<p><code>gld_open</code></p>
</dd>
<dt class="hdlist1"><code>qi_qclose</code></dt>
<dd>
<p><code>gld_close</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The write-side <code>qinit(9S)</code> structure should specify these elements:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>qi_putp</code></dt>
<dd>
<p><code>gld_wput</code></p>
</dd>
<dt class="hdlist1"><code>qi_srvp</code></dt>
<dd>
<p><code>gld_wsrv</code></p>
</dd>
<dt class="hdlist1"><code>qi_qopen</code></dt>
<dd>
<p><code>NULL</code></p>
</dd>
<dt class="hdlist1"><code>qi_qclose</code></dt>
<dd>
<p><code>NULL</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>devo_getinfo</code> element of the <code>dev_ops(9S)</code> structure should
specify <code>gld_getinfo</code> as the <code>getinfo(9E)</code> routine.</p>
</div>
<div class="paragraph">
<p>The driver&#8217;s <code>attach(9E)</code> function associates the hardware-specific
device driver with the GLD facility. <code>attach</code> then prepares the device
and driver for use.</p>
</div>
<div class="paragraph">
<p>The <code>attach(9E)</code> function allocates a
<code>gld_mac_info(9S)</code> structure using <code>gld_mac_alloc</code>. The
driver usually needs to save more information per device than is defined
in the <code>macinfo</code> structure. The driver should allocate the additional
required data structure and save a pointer to the structure in the
<code>gldm_private</code> member of the <code>gld_mac_info(9S)</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>attach(9E)</code> routine must initialize the <code>macinfo</code> structure as
described in the <code>gld_mac_info(9S)</code> man page. The <code>attach</code>
routine should then call <code>gld_register</code> to link the driver with the
GLD module. The driver should map registers if necessary and be fully
initialized and prepared to accept interrupts before calling
<code>gld_register</code>. The <code>attach(9E)</code> function should add interrupts but
should not enable the device to generate these interrupts. The driver
should reset the hardware before calling <code>gld_register</code> to ensure
the hardware is quiescent. A device must not be put into a state where
the device might generate an interrupt before <code>gld_register</code> is
called. The device is started later when GLD calls the driver&#8217;s
<code>gldm_start</code> entry point, which is described in the <code>gld(9E)</code> man
page. After <code>gld_register</code> succeeds, the <code>gld(9E)</code> entry points
might be called by GLD at any time.</p>
</div>
<div class="paragraph">
<p>The <code>attach(9E)</code> routine should return <code>DDI_SUCCESS</code> if
<code>gld_register</code> succeeds. If <code>gld_register</code> fails,
<code>DDI_FAILURE</code> is returned. If a failure occurs, the <code>attach(9E)</code>
routine should deallocate any resources that were allocated before
<code>gld_register</code> was called. The attach routine should then also
return <code>DDI_FAILURE</code>. A failed <code>macinfo</code> structure should never be
reused. Such a structure should be deallocated using
<code>gld_mac_free</code>.</p>
</div>
<div class="paragraph">
<p>The <code>detach(9E)`function should attempt to
unregister the driver from GLD by calling `gld_unregister</code>. For more
information about <code>gld_unregister</code>, see the <code>gld(9F)</code> man page. The
<code>detach(9E)</code> routine can get a pointer to the needed
<code>gld_mac_info(9S)</code> structure from the device&#8217;s private data
using <code>ddi_get_driver_private(9F)</code>. <code>gld_unregister</code>
checks certain conditions that could require that the driver not be
detached. If the checks fail, <code>gld_unregister</code> returns
<code>DDI_FAILURE</code>, in which case the driver&#8217;s <code>detach(9E)</code> routine must
leave the device operational and return <code>DDI_FAILURE</code>.</p>
</div>
<div class="paragraph">
<p>If the checks succeed, <code>gld_unregister</code> ensures that the device
interrupts are stopped. The driver&#8217;s <code>gldm_stop</code> routine is called
if necessary. The driver is unlinked from the GLD framework.
<code>gld_unregister</code> then returns <code>DDI_SUCCESS</code>. In this case, the
<code>detach(9E)</code> routine should remove interrupts and use
<code>gld_mac_free</code> to deallocate any <code>macinfo</code> data structures that
were allocated in the <code>attach(9E)</code> routine. The <code>detach</code> routine should
then return <code>DDI_SUCCESS</code>. The routine must remove the interrupt
&lt;before&gt; calling <code>gld_mac_free</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="network-statistics"><a class="anchor" href="#network-statistics"></a>3.36.8. Network Statistics</h4>
<div class="paragraph">
<p>GLD network statistics</p>
</div>
<div class="paragraph">
<p>illumos network drivers must
implement statistics variables. GLD tallies some network statistics, but
other statistics must be counted by each GLD-based driver. GLD provides
support for GLD-based drivers to report a standard set of network driver
statistics. Statistics are reported by GLD using the <code>kstat(4D)</code> and
<code>kstat(9S)</code> mechanisms. The <code>DL_GET_STATISTICS_REQ</code> DLPI
command can also be used to retrieve the current statistics counters.
All statistics are maintained as unsigned. The statistics are 32 bits
unless otherwise noted.</p>
</div>
<div class="paragraph">
<p>GLD maintains and reports the following statistics.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>rbytes64</code></dt>
<dd>
<p>Total bytes successfully received on the interface. Stores 64-bit
statistics.</p>
</dd>
<dt class="hdlist1"><code>rbytes</code></dt>
<dd>
<p>Total bytes successfully received on the interface</p>
</dd>
<dt class="hdlist1"><code>obytes64</code></dt>
<dd>
<p>Total bytes that have requested transmission on the interface. Stores
64-bit statistics.</p>
</dd>
<dt class="hdlist1"><code>obytes</code></dt>
<dd>
<p>Total bytes that have requested transmission on the interface.</p>
</dd>
<dt class="hdlist1"><code>ipackets64</code></dt>
<dd>
<p>Total packets successfully received on the interface. Stores 64-bit
statistics.</p>
</dd>
<dt class="hdlist1"><code>ipackets</code></dt>
<dd>
<p>Total packets successfully received on the interface.</p>
</dd>
<dt class="hdlist1"><code>opackets64</code></dt>
<dd>
<p>Total packets that have requested transmission on the interface.
Stores 64-bit statistics.</p>
</dd>
<dt class="hdlist1"><code>opackets</code></dt>
<dd>
<p>Total packets that have requested transmission on the interface.</p>
</dd>
<dt class="hdlist1"><code>multircv</code></dt>
<dd>
<p>Multicast packets successfully received, including group and
functional addresses (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>multixmt</code></dt>
<dd>
<p>Multicast packets requested to be transmitted, including group and
functional addresses (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>brdcstrcv</code></dt>
<dd>
<p>Broadcast packets successfully received (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>brdcstxmt</code></dt>
<dd>
<p>Broadcast packets that have requested transmission (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>unknowns</code></dt>
<dd>
<p>Valid received packets not accepted by any stream (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>noxmtbuf</code></dt>
<dd>
<p>Packets discarded on output because transmit buffer was busy, or no
buffer could be allocated for transmit (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>blocked</code></dt>
<dd>
<p>Number of times a received packet could not be put up a stream because
the queue was flow-controlled (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>xmtretry</code></dt>
<dd>
<p>Times transmit was retried after having been delayed due to lack of
resources (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>promisc</code></dt>
<dd>
<p>Current “promiscuous” state of the interface (string).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>device-dependent driver tracks the following statistics in a private
per-instance structure. To report statistics, GLD calls the driver&#8217;s
<code>gldm_get_stats</code> entry point. <code>gldm_get_stats</code> then
updates device-specific statistics in the <code>gld_stats(9S)</code> structure.
See the <code>gldm_get_stats(9E)</code> man page for more information. GLD
then reports the updated statistics using the named statistics variables
that are shown below.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ifspeed</code></dt>
<dd>
<p>Current estimated bandwidth of the interface in bits per second.
Stores 64-bit statistics.</p>
</dd>
<dt class="hdlist1"><code>media</code></dt>
<dd>
<p>Current media type in use by the device (string).</p>
</dd>
<dt class="hdlist1"><code>intr</code></dt>
<dd>
<p>Number of times that the interrupt handler was called, causing an
interrupt (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>norcvbuf</code></dt>
<dd>
<p>Number of times a valid incoming packet was known to have been
discarded because no buffer could be allocated for receive (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>ierrors</code></dt>
<dd>
<p>Total number of packets that were received but could not be processed
due to errors (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>oerrors</code></dt>
<dd>
<p>Total packets that were not successfully transmitted because of errors
(<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>missed</code></dt>
<dd>
<p>Packets known to have been dropped by the hardware on receive
(<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>uflo</code></dt>
<dd>
<p>Times FIFO underflowed on transmit (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>oflo</code></dt>
<dd>
<p>Times receiver overflowed during receive (<code>long</code>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following
group of statistics applies to networks of type <code>DL_ETHER</code>. These
statistics are maintained by device-specific drivers of that type, as
shown previously.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>align_errors</code></dt>
<dd>
<p>Packets that were received with framing errors, that is, the packets
did not contain an integral number of octets (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>fcs_errors</code></dt>
<dd>
<p>Packets received with CRC errors (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>duplex</code></dt>
<dd>
<p>Current duplex mode of the interface (string).</p>
</dd>
<dt class="hdlist1"><code>carrier_errors</code></dt>
<dd>
<p>Number of times carrier was lost or never detected on a transmission
attempt (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>collisions</code></dt>
<dd>
<p>Ethernet collisions during transmit (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>ex_collisions</code></dt>
<dd>
<p>Frames where excess collisions occurred on transmit, causing transmit
failure (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>tx_late_collisions</code></dt>
<dd>
<p>Number of times a transmit collision occurred late, that is, after 512
bit times (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>defer_xmts</code></dt>
<dd>
<p>Packets without collisions where first transmit attempt was delayed
because the medium was busy (<code>long</code>).</p>
</dd>
<dt class="hdlist1"><code>first_collisions</code></dt>
<dd>
<p>Packets successfully transmitted with exactly one collision.</p>
</dd>
<dt class="hdlist1"><code>multi_collisions</code></dt>
<dd>
<p>Packets successfully transmitted with multiple collisions.</p>
</dd>
<dt class="hdlist1"><code>sqe_errors</code></dt>
<dd>
<p>Number of times that SQE test error was reported.</p>
</dd>
<dt class="hdlist1"><code>macxmt_errors</code></dt>
<dd>
<p>Packets encountering transmit MAC failures, except carrier and
collision failures.</p>
</dd>
<dt class="hdlist1"><code>macrcv_errors</code></dt>
<dd>
<p>Packets received with MAC errors, except <code>align_errors</code>,
<code>fcs_errors</code>, and <code>toolong_errors</code>.</p>
</dd>
<dt class="hdlist1"><code>toolong_errors</code></dt>
<dd>
<p>Packets received larger than the maximum allowed length.</p>
</dd>
<dt class="hdlist1"><code>runt_errors</code></dt>
<dd>
<p>Packets received smaller than the minimum allowed length (<code>long</code>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following group of statistics applies to networks of type
<code>DL_TPR</code>. These statistics are maintained by device-specific drivers
of that type, as shown above.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>line_errors</code></dt>
<dd>
<p>Packets received with non-data bits or FCS errors.</p>
</dd>
<dt class="hdlist1"><code>burst_errors</code></dt>
<dd>
<p>Number of times an absence of transitions for five half-bit timers was
detected.</p>
</dd>
<dt class="hdlist1"><code>signal_losses</code></dt>
<dd>
<p>Number of times loss of signal condition on the ring was detected.</p>
</dd>
<dt class="hdlist1"><code>ace_errors</code></dt>
<dd>
<p>Number of times that an AMP or SMP frame, in which A is equal to C is
equal to 0, is followed by another SMP frame without an intervening
AMP frame.</p>
</dd>
<dt class="hdlist1"><code>internal_errors</code></dt>
<dd>
<p>Number of times the station recognized an internal error.</p>
</dd>
<dt class="hdlist1"><code>lost_frame_errors</code></dt>
<dd>
<p>Number of times the TRR timer expired during transmit.</p>
</dd>
<dt class="hdlist1"><code>frame_copied_errors</code></dt>
<dd>
<p>Number of times a frame addressed to this station was received with
the FS field `A' bit set to <code>1</code>.</p>
</dd>
<dt class="hdlist1"><code>token_errors</code></dt>
<dd>
<p>Number of times the station acting as the active monitor recognized an
error condition that needed a token transmitted.</p>
</dd>
<dt class="hdlist1"><code>freq_errors</code></dt>
<dd>
<p>Number of times the frequency of the incoming signal differed from the
expected frequency.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following group of statistics applies to networks of type
<code>DL_FDDI</code>. These statistics are maintained by device-specific
drivers of that type, as shown above.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mac_errors</code></dt>
<dd>
<p>Frames detected in error by this MAC that had not been detected in
error by another MAC.</p>
</dd>
<dt class="hdlist1"><code>mac_lost_errors</code></dt>
<dd>
<p>Frames received with format errors such that the frame was stripped.</p>
</dd>
<dt class="hdlist1"><code>mac_tokens</code></dt>
<dd>
<p>Number of tokens that were received, that is, the total of
non-restricted and restricted tokens.</p>
</dd>
<dt class="hdlist1"><code>mac_tvx_expired</code></dt>
<dd>
<p>Number of times that TVX has expired.</p>
</dd>
<dt class="hdlist1"><code>mac_late</code></dt>
<dd>
<p>Number of TRT expirations since either this MAC was reset or a token
was received.</p>
</dd>
<dt class="hdlist1"><code>mac_ring_ops</code></dt>
<dd>
<p>Number of times the ring has entered the “Ring Operational” state from
the “Ring Not Operational” state.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="declarations-and-data-structures-1"><a class="anchor" href="#declarations-and-data-structures-1"></a>3.37. Declarations and Data Structures</h3>
<div class="paragraph">
<p>This section describes the <code>gld_mac_info(9S)</code>
and <code>gld_stats</code> structures.</p>
</div>
<div class="sect3">
<h4 id="gldmacinfo-structure"><a class="anchor" href="#gldmacinfo-structure"></a>3.37.1. <code>gld_mac_info</code> Structure</h4>
<div class="paragraph">
<p>GLD data structures</p>
</div>
<div class="paragraph">
<p>gld_mac_info</p>
</div>
<div class="paragraph">
<p>gld_mac_info</p>
</div>
<div class="paragraph">
<p>The GLD MAC information (<code>gld_mac_info</code>) structure is the main
data interface that links the device-specific driver with GLD. This
structure contains data required by GLD and a pointer to an optional
additional driver-specific information structure.</p>
</div>
<div class="paragraph">
<p>Allocate the <code>gld_mac_info</code> structure using
<code>gld_mac_alloc</code>. Deallocate the structure using
<code>gld_mac_free</code>. Drivers must not make any assumptions about the
length of this structure, which might vary in different releases of the
illumos, GLD, or both. Structure members private to GLD, not documented
here, should neither be set nor be read by the device-specific driver.</p>
</div>
<div class="paragraph">
<p>The <code>gld_mac_info(9S)</code> structure contains the following fields.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">caddr_t              gldm_private;              /* Driver private data */
int                  (*gldm_reset)();           /* Reset device */
int                  (*gldm_start)();           /* Start device */
int                  (*gldm_stop)();            /* Stop device */
int                  (*gldm_set_mac_addr)();    /* Set device phys addr */
int                  (*gldm_set_multicast)();   /* Set/delete multicast addr */
int                  (*gldm_set_promiscuous)(); /* Set/reset promiscuous mode */
int                  (*gldm_send)();            /* Transmit routine */
uint_t               (*gldm_intr)();            /* Interrupt handler */
int                  (*gldm_get_stats)();       /* Get device statistics */
int                  (*gldm_ioctl)();           /* Driver-specific ioctls */
char                 *gldm_ident;               /* Driver identity string */
uint32_t             gldm_type;                 /* Device type */
uint32_t             gldm_minpkt;               /* Minimum packet size */
                                                /* accepted by driver */
uint32_t             gldm_maxpkt;               /* Maximum packet size */
                                                /* accepted by driver */
uint32_t             gldm_addrlen;              /* Physical address length */
int32_t              gldm_saplen;               /* SAP length for DL_INFO_ACK */
unsigned char        *gldm_broadcast_addr;      /* Physical broadcast addr */
unsigned char        *gldm_vendor_addr;         /* Factory MAC address */
t_uscalar_t          gldm_ppa;                  /* Physical Point of */
                                                /* Attachment (PPA) number */
dev_info_t           *gldm_devinfo;             /* Pointer to device's */
                                                /* dev_info node */
ddi_iblock_cookie_t  gldm_cookie;               /* Device's interrupt */
                                                /* block cookie */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>gldm_private</code> structure member is visible to the device driver.
<code>gldm_private</code> is also private to the device-specific driver.
<code>gldm_private</code> is not used or modified by GLD. Conventionally,
<code>gldm_private</code> is used as a pointer to private data, pointing to a
per-instance data structure that is both defined and allocated by the
driver.</p>
</div>
<div class="paragraph">
<p>The following group of structure members must be set by
the driver before calling <code>gld_register</code>, and should not thereafter
be modified by the driver. Because <code>gld_register</code> might use or cache
the values of structure members, changes made by the driver after
calling <code>gld_register</code> might cause unpredictable results. For more
information on these structures, see the <code>gld(9E)</code> man page.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>gldm_reset</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_start</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_stop</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_set_mac_addr</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_set_multicast</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_set_promiscuous</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_send</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_intr</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_get_stats</code></dt>
<dd>
<p>Pointer to driver entry point.</p>
</dd>
<dt class="hdlist1"><code>gldm_ioctl</code></dt>
<dd>
<p>Pointer to driver entry point. This pointer is allowed to be null.</p>
</dd>
<dt class="hdlist1"><code>gldm_ident</code></dt>
<dd>
<p>Pointer to a string that contains a short description of the device.
This pointer is used to identify the device in system messages.</p>
</dd>
<dt class="hdlist1"><code>gldm_type</code></dt>
<dd>
<p>Type of device the driver handles. GLD currently supports the
following values:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>DL_ETHER</code> (ISO 8802-3 (IEEE 802.3) and Ethernet Bus)</p>
</li>
<li>
<p><code>DL_TPR</code> (IEEE 802.5 Token Passing Ring)</p>
</li>
<li>
<p><code>DL_FDDI</code> (ISO 9314-2 Fibre Distributed Data Interface)
+
This structure member must be correctly set for GLD to function
properly.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>gldm_minpkt</code></dt>
<dd>
<p>Minimum &lt;Service&gt; &lt;Data&gt; &lt;Unit&gt; size: the
minimum packet size, not including the MAC header, that the device can
transmit. This size is allowed to be zero if the device-specific
driver handles any required padding.</p>
</dd>
<dt class="hdlist1"><code>gldm_maxpkt</code></dt>
<dd>
<p>Maximum &lt;Service&gt; &lt;Data&gt; &lt;Unit&gt; size: the
maximum size of packet, not including the MAC header, that can be
transmitted by the device. For Ethernet, this number is 1500.</p>
</dd>
<dt class="hdlist1"><code>gldm_addrlen</code></dt>
<dd>
<p>The length in bytes of physical addresses handled by the device. For
Ethernet, Token Ring, and FDDI, the value of this structure member
should be 6.</p>
</dd>
<dt class="hdlist1"><code>gldm_saplen</code></dt>
<dd>
<p>The length in bytes of the SAP address used by the driver. For
GLD-based drivers, the length should always be set to <code>-2</code>. A length
of <code>-2</code> indicates that 2-byte SAP values are supported and that the
SAP appears &lt;after&gt; the physical address in a DLSAP address.
See Appendix A.2, “Message DL_INFO_ACK,” in the DLPI
specification for more details.</p>
</dd>
<dt class="hdlist1"><code>gldm_broadcast_addr</code></dt>
<dd>
<p>Pointer to an array of bytes of length <code>gldm_addrlen</code> containing
the broadcast address to be used for transmit. The driver must provide
space to hold the broadcast address, fill the space with the
appropriate value, and set <code>gldm_broadcast_addr</code> to point to
the address. For Ethernet, Token Ring, and FDDI, the broadcast address
is normally <code>0xFF-FF-FF-FF-FF-FF</code>.</p>
</dd>
<dt class="hdlist1"><code>gldm_vendor_addr</code></dt>
<dd>
<p>Pointer to an array of bytes of length <code>gldm_addrlen</code> that
contains the vendor-provided network physical address of the device.
The driver must provide space to hold the address, fill the space with
information from the device, and set <code>gldm_vendor_addr</code> to
point to the address.</p>
</dd>
<dt class="hdlist1"><code>gldm_ppa</code></dt>
<dd>
<p>PPA number for this instance of the device. The PPA
number should always be set to the instance number that is returned
from <code>ddi_get_instance(9F)</code>.</p>
</dd>
<dt class="hdlist1"><code>gldm_devinfo</code></dt>
<dd>
<p>Pointer to the <code>dev_info</code> node for this device.</p>
</dd>
<dt class="hdlist1"><code>gldm_cookie</code></dt>
<dd>
<p>Interrupt block cookie returned by one of the following routines:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>ddi_get_iblock_cookie(9F)</code></p>
</li>
<li>
<p><code>ddi_add_intr(9F)</code></p>
</li>
<li>
<p><code>ddi_get_soft_iblock_cookie(9F)</code></p>
</li>
<li>
<p><code>ddi_add_softintr(9F)</code>
+
This cookie must correspond to the device&#8217;s receive-interrupt, from
which <code>gld_recv</code> is called.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="gld_stats-structure"><a class="anchor" href="#gld_stats-structure"></a>3.37.2. <code>gld_stats</code> Structure</h4>
<div class="paragraph">
<p>GLD data structures</p>
</div>
<div class="paragraph">
<p>gld_stats</p>
</div>
<div class="paragraph">
<p>After calling <code>gldm_get_stats</code>, a GLD-based driver uses the
(<code>gld_stats</code>) structure to communicate statistics and state
information to GLD. See the <code>gld(9E)</code> and <code>gld(4D)</code> man pages. The
members of this structure, having been filled in by the GLD-based
driver, are used when GLD reports the statistics. In the tables below,
the name of the statistics variable reported by GLD is noted in the
comments. See the <code>gld(4D)</code> man page for a more detailed description of
the meaning of each statistic.</p>
</div>
<div class="paragraph">
<p>Drivers must not make any assumptions about the length of this
structure. The structure length might vary in different releases of the
illumos, GLD, or both. Structure members private to GLD, which are not
documented here, should not be set or be read by the device-specific
driver.</p>
</div>
<div class="paragraph">
<p>The following structure members are defined for all media types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint64_t    glds_speed;                   /* ifspeed */
uint32_t    glds_media;                   /* media */
uint32_t    glds_intr;                    /* intr */
uint32_t    glds_norcvbuf;                /* norcvbuf */
uint32_t    glds_errrcv;                  /* ierrors */
uint32_t    glds_errxmt;                  /* oerrors */
uint32_t    glds_missed;                  /* missed */
uint32_t    glds_underflow;               /* uflo */
uint32_t    glds_overflow;                /* oflo */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following structure members are defined for media type
<code>DL_ETHER</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t    glds_frame;                   /* align_errors */
uint32_t    glds_crc;                     /* fcs_errors */
uint32_t    glds_duplex;                  /* duplex */
uint32_t    glds_nocarrier;               /* carrier_errors */
uint32_t    glds_collisions;              /* collisions */
uint32_t    glds_excoll;                  /* ex_collisions */
uint32_t    glds_xmtlatecoll;             /* tx_late_collisions */
uint32_t    glds_defer;                   /* defer_xmts */
uint32_t    glds_dot3_first_coll;         /* first_collisions */
uint32_t    glds_dot3_multi_coll;         /* multi_collisions */
uint32_t    glds_dot3_sqe_error;          /* sqe_errors */
uint32_t    glds_dot3_mac_xmt_error;      /* macxmt_errors */
uint32_t    glds_dot3_mac_rcv_error;      /* macrcv_errors */
uint32_t    glds_dot3_frame_too_long;     /* toolong_errors */
uint32_t    glds_short;                   /* runt_errors */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following structure members are defined for media type <code>DL_TPR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t    glds_dot5_line_error          /* line_errors */
uint32_t    glds_dot5_burst_error         /* burst_errors */
uint32_t    glds_dot5_signal_loss         /* signal_losses */
uint32_t    glds_dot5_ace_error           /* ace_errors */
uint32_t    glds_dot5_internal_error      /* internal_errors */
uint32_t    glds_dot5_lost_frame_error    /* lost_frame_errors */
uint32_t    glds_dot5_frame_copied_error  /* frame_copied_errors */
uint32_t    glds_dot5_token_error         /* token_errors */
uint32_t    glds_dot5_freq_error          /* freq_errors */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following structure members are defined for media type
<code>DL_FDDI</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t    glds_fddi_mac_error;          /* mac_errors */
uint32_t    glds_fddi_mac_lost;           /* mac_lost_errors */
uint32_t    glds_fddi_mac_token;          /* mac_tokens */
uint32_t    glds_fddi_mac_tvx_expired;    /* mac_tvx_expired */
uint32_t    glds_fddi_mac_late;           /* mac_late */
uint32_t    glds_fddi_mac_ring_op;        /* mac_ring_ops */</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the above statistics variables are counters that denote the
number of times that the particular event was observed. The following
statistics do not represent the number of times:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>glds_speed</code></dt>
<dd>
<p>Estimate of the interface&#8217;s current bandwidth in bits per second. This
object should contain the nominal bandwidth for those interfaces that
do not vary in bandwidth or where an accurate estimate cannot be made.</p>
</dd>
<dt class="hdlist1"><code>glds_media</code></dt>
<dd>
<p>Type of media (wiring) or connector used by the hardware. The
following media names are supported:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>GLDM_AUI</code></p>
</li>
<li>
<p><code>GLDM_BNC</code></p>
</li>
<li>
<p><code>GLDM_TP</code></p>
</li>
<li>
<p><code>GLDM_10BT</code></p>
</li>
<li>
<p><code>GLDM_100BT</code></p>
</li>
<li>
<p><code>GLDM_100BTX</code></p>
</li>
<li>
<p><code>GLDM_100BT4</code></p>
</li>
<li>
<p><code>GLDM_RING4</code></p>
</li>
<li>
<p><code>GLDM_RING16</code></p>
</li>
<li>
<p><code>GLDM_FIBER</code></p>
</li>
<li>
<p><code>GLDM_PHYMII</code></p>
</li>
<li>
<p><code>GLDM_UNKNOWN</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>glds_duplex</code></dt>
<dd>
<p>Current duplex state of the interface. Supported values are
<code>GLD_DUPLEX_HALF</code> and <code>GLD_DUPLEX_FULL</code>.
<code>GLD_DUPLEX_UNKNOWN</code> is also allowed.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gld-arguments"><a class="anchor" href="#gld-arguments"></a>3.38. GLD Arguments</h3>
<div class="paragraph">
<p>The following arguments are used by the GLD routines.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;macinfo&gt;</dt>
<dd>
<p>Pointer to a <code>gld_mac_info(9S)</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;macaddr&gt;</dt>
<dd>
<p>Pointer to the beginning of a character array that contains a valid
MAC address. The array is of the length specified by the driver in the
<code>gldm_addrlen</code> element of the <code>gld_mac_info(9S)</code>
structure.</p>
</dd>
<dt class="hdlist1">&lt;multicastaddr&gt;</dt>
<dd>
<p>Pointer to the beginning of a character array that contains a
multicast, group, or functional address. The array is of the length
specified by the driver in the <code>gldm_addrlen</code> element of the
<code>gld_mac_info(9S)</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;multiflag&gt;</dt>
<dd>
<p>Flag indicating whether to enable or disable reception of the
multicast address. This argument is specified as
<code>GLD_MULTI_ENABLE</code> or <code>GLD_MULTI_DISABLE</code>.</p>
</dd>
<dt class="hdlist1">&lt;promiscflag&gt;</dt>
<dd>
<p>Flag indicating what type
of promiscuous mode, if any, is to be enabled. This argument is
specified as <code>GLD_MAC_PROMISC_PHYS</code>,
<code>GLD_MAC_PROMISC_MULTI</code>, or
<code>GLD_MAC_PROMISC_NONE</code>.</p>
</dd>
<dt class="hdlist1">&lt;mp&gt;</dt>
<dd>
<p><code>gld_ioctl</code> uses &lt;mp&gt; as a pointer to a STREAMS message
block containing the <code>ioctl</code> to be executed. <code>gldm_send</code> uses
&lt;mp&gt; as a pointer to a STREAMS message block containing the
packet to be transmitted. <code>gld_recv</code> uses &lt;mp&gt; as a
pointer to a message block containing a received packet.</p>
</dd>
<dt class="hdlist1">&lt;stats&gt;</dt>
<dd>
<p>Pointer to a <code>gld_stats(9S)</code> structure to be filled in with the
current values of statistics counters.</p>
</dd>
<dt class="hdlist1">&lt;q&gt;</dt>
<dd>
<p>Pointer to the <code>queue(9S)</code> structure to be used in the reply to the
<code>ioctl</code>.</p>
</dd>
<dt class="hdlist1">&lt;dip&gt;</dt>
<dd>
<p>Pointer to the device&#8217;s <code>dev_info</code> structure.</p>
</dd>
<dt class="hdlist1">&lt;name&gt;</dt>
<dd>
<p>Device interface name.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="gld-entry-points"><a class="anchor" href="#gld-entry-points"></a>3.39. GLD Entry Points</h3>
<div class="paragraph">
<p>for network drivers</p>
</div>
<div class="paragraph">
<p>Entry points must be implemented by a device-specific network driver
that has been designed to interface with GLD.</p>
</div>
<div class="paragraph">
<p>The <code>gld_mac_info(9S)</code> structure is the main structure for
communication between the device-specific driver and the GLD module. See
the <code>gld(4D)</code> man page. Some elements in that structure are function
pointers to the entry points that are described here. The
device-specific driver must, in its <code>attach(9E)</code> routine, initialize
these function pointers before calling <code>gld_register</code>.</p>
</div>
<div class="sect3">
<h4 id="gldm_reset-entry-point"><a class="anchor" href="#gldm_reset-entry-point"></a>3.39.1. <code>gldm_reset</code> Entry Point</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_reset(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_reset</code> resets the hardware to its initial state.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldm_start-entry-point"><a class="anchor" href="#gldm_start-entry-point"></a>3.39.2. <code>gldm_start</code> Entry Point</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_start(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_start</code> enables the device to generate
interrupts. <code>gldm_start</code> also prepares the driver to call
<code>gld_recv</code> to deliver received data packets to GLD.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldm_stop-entry-point"><a class="anchor" href="#gldm_stop-entry-point"></a>3.39.3. <code>gldm_stop</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_stop</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_stop(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_stop</code> disables the device from generating any interrupts and
stops the driver from calling <code>gld_recv</code> for delivering data packets
to GLD. GLD depends on the <code>gldm_stop</code> routine to ensure that the
device will no longer interrupt. <code>gldm_stop</code> must do so without
fail. This function should always return <code>GLD_SUCCESS</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldmsetmac_addr-entry-point"><a class="anchor" href="#gldmsetmac_addr-entry-point"></a>3.39.4. <code>gldm_set_mac_addr</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_set_mac_addr</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_set_mac_addr(gld_mac_info_t *macinfo, unsigned char *macaddr);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_set_mac_addr</code> sets the physical address
that the hardware is to use for receiving data. This function enables
the device to be programmed through the passed MAC address
&lt;macaddr&gt;. If sufficient resources are currently not available
to carry out the request, <code>gldm_set_mac_add</code> should return
GLD_NORESOURCES. If the requested function is not supported,
<code>gldm_set_mac_add</code> should return GLD_NOTSUPPORTED.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldmsetmulticast-entry-point"><a class="anchor" href="#gldmsetmulticast-entry-point"></a>3.39.5. <code>gldm_set_multicast</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_set_multicast</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_set_multicast(gld_mac_info_t *macinfo,
     unsigned char *multicastaddr, int multiflag);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_set_multicast</code> enables and
disables device-level reception of specific multicast addresses. If the
third argument &lt;multiflag&gt; is set to <code>GLD_MULTI_ENABLE</code>,
then <code>gldm_set_multicast</code> sets the interface to receive packets
with the multicast address. <code>gldm_set_multicast</code> uses the
multicast address that is pointed to by the second argument. If
&lt;multiflag&gt; is set to <code>GLD_MULTI_DISABLE</code>, the driver is
allowed to disable reception of the specified multicast address.</p>
</div>
<div class="paragraph">
<p>This function is called whenever GLD wants to enable or disable
reception of a multicast, group, or functional address. GLD makes no
assumptions about how the device does multicast support and calls this
function to enable or disable a specific multicast address. Some devices
might use a hash algorithm and a bitmask to enable collections of
multicast addresses. This procedure is allowed, and GLD filters out any
superfluous packets. If disabling an address could result in disabling
more than one address at the device level, the device driver should keep
any necessary information. This approach avoids disabling an address
that GLD has enabled but not disabled.</p>
</div>
<div class="paragraph">
<p><code>gldm_set_multicast</code> is not called to enable a particular
multicast address that is already enabled. Similarly,
<code>gldm_set_multicast</code> is not called to disable an address that is
not currently enabled. GLD keeps track of multiple requests for the same
multicast address. GLD only calls the driver&#8217;s entry point when the
first request to enable, or the last request to disable, a particular
multicast address is made. If sufficient resources are currently not
available to carry out the request, the function should return
<code>GLD_NORESOURCES</code>. The function should return GLD_NOTSUPPORTED
if the requested function is not supported.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldmsetpromiscuous-entry-point"><a class="anchor" href="#gldmsetpromiscuous-entry-point"></a>3.39.6. <code>gldm_set_promiscuous</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_set_promiscuous</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_set_promiscuous(gld_mac_info_t *macinfo, int promiscflag);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_set_promiscuous</code> enables and disables promiscuous mode.
This function is called whenever GLD wants to enable or disable the
reception of all packets on the medium. The function can also be limited
to multicast packets on the medium. If the second argument
&lt;promiscflag&gt; is set to the value of
<code>GLD_MAC_PROMISC_PHYS</code>, then the function enables
physical-level promiscuous mode. Physical-level promiscuous mode causes
the reception of all packets on the medium. If &lt;promiscflag&gt; is
set to <code>GLD_MAC_PROMISC_MULTI</code>, then reception of all
multicast packets are enabled. If &lt;promiscflag&gt; is set to
<code>GLD_MAC_PROMISC_NONE</code>, then promiscuous mode is disabled.</p>
</div>
<div class="paragraph">
<p>In promiscuous multicast mode, drivers for devices without
multicast-only promiscuous mode must set the device to physical
promiscuous mode. This approach ensures that all multicast packets are
received. In this case, the routine should return <code>GLD_SUCCESS</code>. The
GLD software filters out any superfluous packets. If sufficient
resources are currently not available to carry out the request, the
function should return <code>GLD_NORESOURCES</code>.
<code>gld_set_promiscuous</code> should return <code>GLD_NOTSUPPORTED</code> if
the requested function is not supported.</p>
</div>
<div class="paragraph">
<p>For forward compatibility, <code>gldm_set_promiscuous</code> routines
should treat any unrecognized values for &lt;promiscflag&gt; as though
these values were <code>GLD_MAC_PROMISC_PHYS</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldm_send-entry-point"><a class="anchor" href="#gldm_send-entry-point"></a>3.39.7. <code>gldm_send</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_send</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_send(gld_mac_info_t *macinfo, mblk_t *mp);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_send</code> queues a packet to the device for transmission. This
routine is passed a STREAMS message containing the packet to be sent.
The message might include multiple message blocks. The <code>send</code> routine
must traverse all the message blocks in the message to access the entire
packet to be sent. The driver should be prepared to handle and skip over
any zero-length message continuation blocks in the chain. The driver
should also check that the packet does not exceed the maximum allowable
packet size. The driver must pad the packet, if necessary, to the
minimum allowable packet size. If the send routine successfully
transmits or queues the packet, <code>GLD_SUCCESS</code> should be returned.</p>
</div>
<div class="paragraph">
<p>The send routine should return <code>GLD_NORESOURCES</code> if the packet for
transmission cannot be immediately accepted. In this case, GLD retries
later. If <code>gldm_send</code> ever returns <code>GLD_NORESOURCES</code>, the driver
must call <code>gld_sched</code> at a later time when resources have become
available. This call to <code>gld_sched</code> informs GLD to retry packets
that the driver previously failed to queue for transmission. (If the
driver&#8217;s <code>gldm_stop</code> routine is called, the driver is absolved from
this obligation until the driver returns <code>GLD_NORESOURCES</code> from the
<code>gldm_send</code> routine. However, extra calls to <code>gld_sched</code> do not
cause incorrect operation.)</p>
</div>
<div class="paragraph">
<p>If the driver&#8217;s send routine returns <code>GLD_SUCCESS</code>,
then the driver is responsible for freeing the message when the message
is no longer needed. If the hardware uses DMA to read the data directly,
the driver must not free the message until the hardware has completely
read the data. In this case, the driver can free the message in the
interrupt routine. Alternatively, the driver can reclaim the buffer at
the start of a future send operation. If the send routine returns
anything other than <code>GLD_SUCCESS</code>, then the driver must not free the
message. Return <code>GLD_NOLINK</code> if <code>gldm_send</code> is called when there
is no physical connection to the network or link partner.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldm_intr-entry-point"><a class="anchor" href="#gldm_intr-entry-point"></a>3.39.8. <code>gldm_intr</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_intr</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_intr(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_intr</code> is called when the device might have interrupted.
Because interrupts can be shared with other devices, the driver must
check the device status to determine whether that device actually caused
the interrupt. If the device that the driver controls did not cause the
interrupt, then this routine must return <code>DDI_INTR_UNCLAIMED</code>.
Otherwise, the driver must service the interrupt and return
<code>DDI_INTR_CLAIMED</code>. If the interrupt was caused by successful
receipt of a packet, this routine should put the received packet into a
STREAMS message of type <code>M_DATA</code> and pass that message to
<code>gld_recv</code>.</p>
</div>
<div class="paragraph">
<p><code>gld_recv</code> passes the inbound packet upstream to the appropriate
next layer of the network protocol stack. The routine must correctly set
the <code>b_rptr</code> and <code>b_wptr</code> members of the STREAMS message before
calling <code>gld_recv</code>.</p>
</div>
<div class="paragraph">
<p>The driver should avoid holding mutex or other locks during the call to
<code>gld_recv</code>. In particular, locks that could be taken by a transmit
thread must not be held during a call to <code>gld_recv</code>. In some cases,
the interrupt thread that calls <code>gld_recv</code> sends an outgoing packet,
which results in a call to the driver&#8217;s <code>gldm_send</code> routine. If
<code>gldm_send</code> tries to acquire a mutex that is held by <code>gldm_intr</code>
when <code>gld_recv</code> is called, a panic occurs due to recursive mutex
entry. If other driver entry points attempt to acquire a mutex that the
driver holds across a call to <code>gld_recv</code>, deadlock can result.</p>
</div>
<div class="paragraph">
<p>The interrupt code should increment statistics counters for any errors.
Errors include the failure to allocate a buffer that is needed for the
received data and any hardware-specific errors, such as CRC errors or
framing errors.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldmgetstats-entry-point"><a class="anchor" href="#gldmgetstats-entry-point"></a>3.39.9. <code>gldm_get_stats</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_get_stats</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_get_stats(gld_mac_info_t *macinfo, struct gld_stats *stats);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_get_stats</code> gathers statistics from the hardware, driver
private counters, or both, and updates the <code>gld_stats(9S)</code> structure
pointed to by &lt;stats&gt;. This routine is called by GLD for
statistics requests. GLD uses the <code>gldm_get_stats</code> mechanism to
acquire device-dependent statistics from the driver before GLD composes
the reply to the statistics request. See the <code>gld_stats(9S)</code>,
<code>gld(4D)</code>, and <code>qreply(9F)</code> man pages for more information about defined
statistics counters.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldm_ioctl-entry-point"><a class="anchor" href="#gldm_ioctl-entry-point"></a>3.39.10. <code>gldm_ioctl</code> Entry Point</h4>
<div class="paragraph">
<p>GLD entry points</p>
</div>
<div class="paragraph">
<p>gldm_ioctl</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int prefix_ioctl(gld_mac_info_t *macinfo, queue_t *q, mblk_t *mp);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gldm_ioctl</code> implements any device-specific <code>ioctl</code> commands. This
element is allowed to be null if the driver does not implement any
<code>ioctl</code> functions. The driver is responsible for converting the message
block into an <code>ioctl</code> reply message and calling the <code>qreply(9F)</code>
function before returning <code>GLD_SUCCESS</code>. This function should always
return <code>GLD_SUCCESS</code>. The driver should report any errors as needed
in a message to be passed to <code>qreply(9F)</code>. If the <code>gldm_ioctl</code>
element is specified as <code>NULL</code>, GLD returns a message of type
<code>M_IOCNAK</code> with an error of EINVAL.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld-return-values"><a class="anchor" href="#gld-return-values"></a>3.39.11. GLD Return Values</h4>
<div class="paragraph">
<p>Some entry point functions in GLD can return the following values,
subject to the restrictions above:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>GLD_BADARG</code></dt>
<dd>
<p>If the function detected an unsuitable argument, for
example, a bad multicast address, a bad MAC address, or a bad packet</p>
</dd>
<dt class="hdlist1"><code>GLD_FAILURE</code></dt>
<dd>
<p>On hardware failure</p>
</dd>
<dt class="hdlist1"><code>GLD_SUCCESS</code></dt>
<dd>
<p>On success</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gld-service-routines"><a class="anchor" href="#gld-service-routines"></a>3.40. GLD Service Routines</h3>
<div class="paragraph">
<p>This section provides the syntax and description for the GLD service
routines.</p>
</div>
<div class="sect3">
<h4 id="gldmacalloc-function"><a class="anchor" href="#gldmacalloc-function"></a>3.40.1. <code>gld_mac_alloc</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_mac_alloc</p>
</div>
<div class="paragraph">
<p>gld_mac_alloc</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">gld_mac_info_t *gld_mac_alloc(dev_info_t *dip);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_mac_alloc</code> allocates a new <code>gld_mac_info(9S)</code>
structure and returns a pointer to the structure. Some of the
GLD-private elements of the structure might be initialized before
<code>gld_mac_alloc</code> returns. All other elements are initialized to
zero. The device driver must initialize some structure members, as
described in the <code>gld_mac_info(9S)</code> man page, before passing the
pointer to the <code>gld_mac_info</code> structure to <code>gld_register</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gldmacfree-function"><a class="anchor" href="#gldmacfree-function"></a>3.40.2. <code>gld_mac_free</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_mac_free</p>
</div>
<div class="paragraph">
<p>gld_mac_free</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void gld_mac_free(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_mac_free</code> frees a <code>gld_mac_info(9S)</code> structure
previously allocated by <code>gld_mac_alloc</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld_register-function"><a class="anchor" href="#gld_register-function"></a>3.40.3. <code>gld_register</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_register</p>
</div>
<div class="paragraph">
<p>gld_register</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int gld_register(dev_info_t *dip, char *name, gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_register</code> is called from the device driver&#8217;s <code>attach(9E)</code>
routine. <code>gld_register</code> links the GLD-based device driver with the
GLD framework. Before calling <code>gld_register</code>, the device driver&#8217;s
<code>attach(9E)</code> routine uses <code>gld_mac_alloc</code> to allocate a
<code>gld_mac_info(9S)</code> structure, and then initializes several
structure elements. See <code>gld_mac_info(9S)</code> for more information.
A successful call to <code>gld_register</code> performs the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Links the device-specific driver with the GLD system</p>
</li>
<li>
<p>Sets the device-specific driver&#8217;s private data pointer, using
<code>ddi_set_driver_private(9F)</code> to point to the <code>macinfo</code>
structure</p>
</li>
<li>
<p>Creates the minor device node</p>
</li>
<li>
<p>Returns <code>DDI_SUCCESS</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The device interface name passed to <code>gld_register</code> must exactly
match the name of the driver module as that name exists in the file
system.</p>
</div>
<div class="paragraph">
<p>The driver&#8217;s <code>attach(9E)</code> routine should return <code>DDI_SUCCESS</code> if
<code>gld_register</code> succeeds. If <code>gld_register</code> does not return
<code>DDI_SUCCESS</code>, the <code>attach(9E)</code> routine should deallocate any
allocated resources before calling <code>gld_register</code>, and then return
<code>DDI_FAILURE</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld_unregister-function"><a class="anchor" href="#gld_unregister-function"></a>3.40.4. <code>gld_unregister</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_unregister</p>
</div>
<div class="paragraph">
<p>gld_unregister</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int gld_unregister(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_unregister</code> is called by the device driver&#8217;s <code>detach(9E)</code>
function, and if successful, performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensures that the device&#8217;s interrupts are stopped, calling the driver&#8217;s
<code>gldm_stop</code> routine if necessary</p>
</li>
<li>
<p>Removes the minor device node</p>
</li>
<li>
<p>Unlinks the device-specific driver from the GLD system</p>
</li>
<li>
<p>Returns <code>DDI_SUCCESS</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>gld_unregister</code> returns <code>DDI_SUCCESS</code>, the <code>detach(9E)</code>
routine should deallocate any data structures allocated in the
<code>attach(9E)</code> routine, using <code>gld_mac_free</code> to deallocate the
<code>macinfo</code> structure, and return <code>DDI_SUCCESS</code>. If
<code>gld_unregister</code> does not return <code>DDI_SUCCESS</code>, the driver&#8217;s
<code>detach(9E)</code> routine must leave the device operational and return
<code>DDI_FAILURE</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld_recv-function"><a class="anchor" href="#gld_recv-function"></a>3.40.5. <code>gld_recv</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_recv</p>
</div>
<div class="paragraph">
<p>gld_recv</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void gld_recv(gld_mac_info_t *macinfo, mblk_t *mp);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_recv</code> is called by the driver&#8217;s interrupt handler to pass a
received packet upstream. The driver must construct and pass a STREAMS
<code>M_DATA</code> message containing the raw packet. <code>gld_recv</code>
determines which STREAMS queues should receive a copy of the packet,
duplicating the packet if necessary. <code>gld_recv</code> then formats a
<code>DL_UNITDATA_IND</code> message, if required, and passes the data up
all appropriate streams.</p>
</div>
<div class="paragraph">
<p>The driver should avoid holding mutex or other locks during the call to
<code>gld_recv</code>. In particular, locks that could be taken by a transmit
thread must not be held during a call to <code>gld_recv</code>. The interrupt
thread that calls <code>gld_recv</code> in some cases carries out processing
that includes sending an outgoing packet. Transmission of the packet
results in a call to the driver&#8217;s <code>gldm_send</code> routine. If
<code>gldm_send</code> tries to acquire a mutex that is held by <code>gldm_intr</code>
when <code>gld_recv</code> is called, a panic occurs due to a recursive mutex
entry. If other driver entry points attempt to acquire a mutex that the
driver holds across a call to <code>gld_recv</code>, deadlock can result.</p>
</div>
</div>
<div class="sect3">
<h4 id="gld_sched-function"><a class="anchor" href="#gld_sched-function"></a>3.40.6. <code>gld_sched</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_sched</p>
</div>
<div class="paragraph">
<p>gld_sched</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void gld_sched(gld_mac_info_t *macinfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_sched</code> is called by the device driver to
reschedule stalled outbound packets. Whenever the driver&#8217;s
<code>gldm_send</code> routine returns <code>GLD_NORESOURCES</code>, the driver must
call <code>gld_sched</code> to inform the GLD framework to retry previously
unsendable packets. <code>gld_sched</code> should be called as soon as possible
after resources become available so that GLD resumes passing outbound
packets to the driver&#8217;s <code>gldm_send</code> routine. (If the driver&#8217;s
<code>gldm_stop</code> routine is called, the driver need not retry until
<code>GLD_NORESOURCES</code> is returned from <code>gldm_send</code>. However, extra
calls to <code>gld_sched</code> do not cause incorrect operation.)</p>
</div>
</div>
<div class="sect3">
<h4 id="gld_intr-function"><a class="anchor" href="#gld_intr-function"></a>3.40.7. <code>gld_intr</code> Function</h4>
<div class="paragraph">
<p>GLD service routines</p>
</div>
<div class="paragraph">
<p>gld_intr</p>
</div>
<div class="paragraph">
<p>gld_intr</p>
</div>
<div class="paragraph">
<p>interrupt handling</p>
</div>
<div class="paragraph">
<p>gld_intr</p>
</div>
<div class="literalblock">
<div class="content">
<pre>uint_t gld_intr(caddr_t);</pre>
</div>
</div>
<div class="paragraph">
<p><code>gld_intr</code> is GLD&#8217;s main interrupt handler. Normally,
<code>gld_intr</code> is specified as the interrupt routine in the device
driver&#8217;s call to <code>ddi_add_intr(9F)</code>. The argument to the
interrupt handler is specified as &lt;int_handler_arg&gt; in
the call to <code>ddi_add_intr(9F)</code>. This argument must be a pointer
to the <code>gld_mac_info(9S)</code> structure. <code>gld_intr</code>, when
appropriate, calls the device driver&#8217;s <code>gldm_intr</code> function, passing
that pointer to the <code>gld_mac_info(9S)</code> structure. However, to
use a high-level interrupt, the driver must provide its own high-level
interrupt handler and trigger a soft interrupt from within the handler.
In this case, <code>gld_intr</code> would normally be specified as the soft
interrupt handler in the call to <code>ddi_add_softintr</code>.
<code>gld_intr</code> returns a value that is appropriate for an interrupt
handler.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="usb-drivers"><a class="anchor" href="#usb-drivers"></a>3.41. USB Drivers</h3>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>USB driver</p>
</div>
<div class="paragraph">
<p>USBA (illumos USB Architecture)</p>
</div>
<div class="paragraph">
<p>USBA 2.0 framework</p>
</div>
<div class="paragraph">
<p>This chapter describes how to write a client USB device driver using the
USBA 2.0 framework for the illumos environment. This chapter discusses
the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#usb-in-the-illumos-environment">USB in the illumos Environment</a></p>
</li>
<li>
<p><a href="#binding-client-drivers">Binding Client Drivers</a></p>
</li>
<li>
<p><a href="#basic-device-access">Basic Device Access</a></p>
</li>
<li>
<p><a href="#device-communication">Device Communication</a></p>
</li>
<li>
<p><a href="#device-state-management">Device State Management</a></p>
</li>
<li>
<p><a href="#utility-functions">Utility Functions</a></p>
</li>
<li>
<p><a href="#sample-usb-device-driver">Sample USB Device Driver</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="usb-in-the-illumos-environment"><a class="anchor" href="#usb-in-the-illumos-environment"></a>3.42. USB in the illumos Environment</h3>
<div class="paragraph">
<p>The illumos USB architecture includes the USBA 2.0 framework and USB
client drivers.</p>
</div>
<div class="sect3">
<h4 id="usba-20-framework"><a class="anchor" href="#usba-20-framework"></a>3.42.1. USBA 2.0 Framework</h4>
<div class="paragraph">
<p>USB 2.0 specification</p>
</div>
<div class="paragraph">
<p>The USBA 2.0 framework is a service layer that presents an abstract view
of USB devices to USBA-compliant client drivers. The framework enables
USBA-compliant client drivers to manage their USB devices. The USBA 2.0
framework supports the USB 2.0 specification except for high speed
isochronous pipes. For information on the USB 2.0 specification, see
<a href="http://www.usb.org/" class="bare">http://www.usb.org/</a>.</p>
</div>
<div class="paragraph">
<p>The USBA 2.0 framework is platform-independent. The illumos USB
architecture is shown in the following figure. The USBA 2.0 framework is
the USBA layer in the figure. This layer interfaces through a
hardware-independent host controller driver interface to
hardware-specific host controller drivers. The host controller drivers
access the USB physical devices through the host controllers they
manage.</p>
</div>
<div id="euxbt" class="paragraph">
<div class="title">illumos USB Architecture</div>
<p>image::figures/usb-arch.png[Diagram shows the flow of control from client and hub drivers, through the USB Architecture Interfaces, to the
controllers and devices.]</p>
</div>
</div>
<div class="sect3">
<h4 id="usb-client-drivers"><a class="anchor" href="#usb-client-drivers"></a>3.42.2. USB Client Drivers</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>nexus driver</p>
</div>
<div class="paragraph">
<p>hub driver</p>
</div>
<div class="paragraph">
<p>The USBA 2.0 framework is not a device driver itself. This chapter
describes the client drivers shown in <a href="#euxbt">illumos USB
Architecture</a> and <a href="#euxbg">Driver and Controller Interfaces</a>. The
client drivers interact with various kinds of USB devices such as mass
storage devices, printers, and human interface devices. The hub driver
is a client driver that is also a nexus driver. The hub driver
enumerates devices on its ports and creates <code>devinfo</code> nodes for those
devices and then attaches the client drivers. This chapter does not
describe how to write a hub driver.</p>
</div>
<div class="paragraph">
<p>USB drivers have the same structure as any other illumos driver. USB
drivers can be block drivers, character drivers, or STREAMS drivers. USB
drivers follow the calling conventions and use the data structures and
routines described in the illumos section 9 man pages. See <code>Intro(9E)</code>,
<code>Intro(9F)</code>, and <code>Intro(9S)</code>.</p>
</div>
<div class="paragraph">
<p>The difference
between USB drivers and other illumos drivers is that USB drivers call
USBA 2.0 framework functions to access the device instead of directly
accessing the device. The USBA 2.0 framework supplements the standard
illumos DDI routines. See the following figure.</p>
</div>
<div id="euxbg" class="paragraph">
<div class="title">Driver and Controller Interfaces</div>
<p>image::figures/usb-drv-ctrl-int.png[Diagram shows DDI and USBAI functions, different versions of the USBA framework, and different types of host
controllers.]</p>
</div>
<div class="paragraph">
<p><a href="#euxbg">Driver and Controller Interfaces</a> shows interfaces in more
detail than <a href="#euxbt">illumos USB Architecture</a> does.
<a href="#euxbg">Driver and Controller Interfaces</a> shows that the USBA is a
kernel subsystem into which a client driver can call, just as a client
driver can call DDI functions.</p>
</div>
<div class="paragraph">
<p>Not all systems have all of the host controller interfaces shown in
<a href="#euxbg">Driver and Controller Interfaces</a>. OHCI (Open Host
Controller Interface) hardware is most prevalent on SPARC systems and
third-party USB PCI cards. UHCI (Universal Host Controller Interface)
hardware is most prevalent on x86 systems. However, both OHCI and UHCI
hardware can be used on any system. When EHCI (Enhanced Host Controller
Interface) hardware is present, the EHCI hardware is on the same card
and shares the same ports with either OHCI or UHCI.</p>
</div>
<div class="paragraph">
<p>The host controllers, host controller drivers, and HCDI make up a
transport layer that is commanded by the USBA. You cannot directly call
into the OHCI, EHCI, or UHCI. You call into them indirectly through the
platform-independent USBA interface.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="binding-client-drivers"><a class="anchor" href="#binding-client-drivers"></a>3.43. Binding Client Drivers</h3>
<div class="paragraph">
<p>This section discusses binding a driver to a device. It discusses
compatible device names for devices with single interfaces and devices
with multiple interfaces.</p>
</div>
<div class="sect3">
<h4 id="how-usb-devices-appear-to-the-system"><a class="anchor" href="#how-usb-devices-appear-to-the-system"></a>3.43.1. How USB Devices Appear to the System</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>current configuration</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>multiple configurations</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>alternate settings</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>alternate settings</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB devices</p>
</div>
<div class="paragraph">
<p>A USB device can support multiple configurations. Only one configuration
is active at any given time. The active configuration is called the
<em>current configuration</em>.</p>
</div>
<div class="paragraph">
<p>A configuration can have more than one <em>interface</em>, possibly with
intervening interface-associations that group two or more interfaces for
a function. All interfaces of a configuration are active simultaneously.
Different interfaces might be operated by different device drivers.</p>
</div>
<div class="paragraph">
<p>An interface can represent itself to the host system in different ways
by using <em>alternate settings</em>. Only one alternate setting is active for
any given interface.</p>
</div>
<div class="paragraph">
<p>Each alternate setting provides device access through <em>endpoints</em>. Each
endpoint has a specific purpose. The host system communicates with the
device by establishing a communication channel to an endpoint. This
communication channel is called a <em>pipe</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="usb-devices-and-the-illumos-device-tree"><a class="anchor" href="#usb-devices-and-the-illumos-device-tree"></a>3.43.2. USB Devices and the illumos Device Tree</h4>
<div class="paragraph">
<p>single device node</p>
</div>
<div class="paragraph">
<p>device node</p>
</div>
<div class="paragraph">
<p>If a USB device has one configuration, one interface, and device class
zero, the device is represented as a single <em>device node</em>. If a USB
device has multiple interfaces, the device is represented as a
hierarchical device structure. In a hierarchical device structure, the
device node for each interface is a child of the top-level device node.
An example of a device with multiple interfaces is an audio device that
presents simultaneously to the host computer both an audio control
interface and an audio streaming interface. The audio control interface
and the audio streaming interface each could be controlled by its own
driver.</p>
</div>
</div>
<div class="sect3">
<h4 id="compatible-device-names"><a class="anchor" href="#compatible-device-names"></a>3.43.3. Compatible Device Names</h4>
<div class="paragraph">
<p>device information</p>
</div>
<div class="paragraph">
<p>compatible device names</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>compatible device names</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>binding to device node</p>
</div>
<div class="paragraph">
<p>device information</p>
</div>
<div class="paragraph">
<p>binding a driver to a USB device</p>
</div>
<div class="paragraph">
<p>binding a driver to a USB device</p>
</div>
<div class="paragraph">
<p>displaying device names</p>
</div>
<div class="paragraph">
<p>The illumos software builds an ordered list of compatible device names
for USB binding based on identification information kept within each
device. This information includes device class, subclass, vendor ID,
product ID, revision, and protocol. See <a href="http://www.usb.org/" class="bare">http://www.usb.org/</a> for a list
of USB classes and subclasses.</p>
</div>
<div class="paragraph">
<p>This name hierarchy enables binding to a general driver if a more
device-specific driver is not available. An example of a general driver
is a class-specific driver. Device names that begin with <code>usbif</code>
designate single interface devices. See
<a href="#usb-fig-27">example_title</a> for examples. The USBA 2.0 framework
defines all compatible names for a device. Use the <code>prtconf</code> command to
display these device names, as shown in <a href="#ewatq">example_title</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows an example of compatible device names for a
USB mouse device. This mouse device represents a combined node entirely
operated by a single driver. The USBA 2.0 framework gives this device
node the names shown in the example, in the order shown.</p>
</div>
<div id="usb-fig-27" class="paragraph">
<p>USB Mouse Compatible Device Names</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1. 'usb430,100.102'      Vendor 430, product 100, revision 102
2. 'usb430,100'      Vendor 430, product 100
3. 'usbif430,class3.1.2' Vendor 430, class 3, subclass 1, protocol 2
4. 'usbif430,class3.1'   Vendor 430, class 3, subclass 1
5. 'usbif430,class3'     Vendor 430, class 3
6. 'usbif,class3.1.2'    Class 3, subclass 1, protocol 2
7. 'usbif,class3.1'      Class 3, subclass 1
8. 'usbif,class3'    Class 3</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the names in the above example progress from
the most specific to the most general. Entry 1 binds only to a
particular revision of a specific product from a particular vendor.
Entries 3, 4, and 5 are for class 3 devices manufactured by vendor 430.
Entries 6, 7, and 8 are for class 3 devices from any vendor. The binding
process looks for a match on the name from the top name down. To bind,
drivers must be added to the system with an alias that matches one of
these names. To get a list of compatible device names to which to bind
when you add your driver, check the <code>compatible</code> property of the device
in the output from the <code>prtconf</code> <code>vp</code> command.</p>
</div>
<div class="paragraph">
<p>The following example shows compatible property lists for a keyboard and
a mouse. Use the <code>prtconf</code> <code>D</code> command to display the bound driver.</p>
</div>
<div id="ewatq" class="paragraph">
<p>Compatible Device Names Shown by the Print Configuration Command</p>
</div>
<div class="literalblock">
<div class="content">
<pre># prtconf -vD | grep compatible
            compatible: 'usb430,5.200' + 'usb430,5' + 'usbif430,class3.1.1'
+ 'usbif430,class3.1' + 'usbif430,class3' + 'usbif,class3.1.1' +
'usbif,class3.1' + 'usbif,class3'
            compatible: 'usb2222,2071.200' + 'usb2222,2071' +
'usbif2222,class3.1.2' + 'usbif2222,class3.1' + 'usbif2222,class3' +
'usbif,class3.1.2' + 'usbif,class3.1' + 'usbif,class3'</pre>
</div>
</div>
<div class="paragraph">
<p>Use the most specific name you can to more accurately
identify a driver for a device or group of devices. To bind drivers
written for a specific revision of a specific product, use the most
specific name match possible. For example, if you have a USB mouse
driver written by vendor 430 for revision 102 of their product 100, use
the following command to add that driver to the system:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usb430,100.102"' specific_mouse_driver</pre>
</div>
</div>
<div class="paragraph">
<p>To add a driver written for any USB mouse (class 3, subclass 1, protocol
2) from vendor 430, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usbif430,class3.1.2"' more_generic_mouse_driver</pre>
</div>
</div>
<div class="paragraph">
<p>If you install both of these drivers and then connect a compatible
device, the system binds the correct driver to the connected device. For
example, if you install both of these drivers and then connect a vendor
430, model 100, revision 102 device, this device is bound to
<code>specific_mouse_driver</code>. If you connect a vendor 430, model 98
device, this device is bound to <code>more_generic_mouse_driver</code>.
If you connect a mouse from another vendor, this device also is bound to
<code>more_generic_mouse_driver</code>. If multiple drivers are
available for a specific device, the driver binding framework selects
the driver with the first matching compatible name in the compatible
names list.</p>
</div>
</div>
<div class="sect3">
<h4 id="devices-with-multiple-interfaces"><a class="anchor" href="#devices-with-multiple-interfaces"></a>3.43.4. Devices With Multiple Interfaces</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p><em>Composite devices</em> are devices that support multiple interfaces.
Composite devices have a list of compatible names for each interface.
This compatible names list ensures that the best available driver is
bound to the interface. The most general multiple interface entry is
<code>usb,device</code>.</p>
</div>
<div class="paragraph">
<p>For a USB audio composite device, the compatible names are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1. 'usb471,101.100'     Vendor 471, product 101, revision 100
2. 'usb471,101'         Vendor 471, product 101
3. 'usb,device'         Generic USB device</pre>
</div>
</div>
<div class="paragraph">
<p>The name <code>usb,device</code> is a
compatible name that represents any whole USB device. The
<code>usb_mid(4D)</code> driver (USB multiple-interface driver) binds to the
<code>usb,device</code> device node if no other driver has claimed the whole
device. The <code>usb_mid</code> driver creates a child device node for each
interface of the physical device. The <code>usb_mid</code> driver also
generates a set of compatible names for each interface. Each of these
generated compatible names begins with <code>usbif</code>. The system then uses
these generated compatible names to find the best driver for each
interface. In this way, different interfaces of one physical device can
be bound to different drivers.</p>
</div>
<div class="paragraph">
<p>For example, the <code>usb_mid</code> driver binds to a multiple-interface
audio device through the <code>usb,device</code> node name of that audio device.
The <code>usb_mid</code> driver then creates interface-specific device nodes.
Each of these interface-specific device nodes has its own compatible
name list. For an audio control interface node, the compatible name list
might look like the list shown in the following example.</p>
</div>
<div id="ekyic" class="paragraph">
<p>USB Audio Compatible Device Names</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1. 'usbif471,101.100.config1.0' Vend 471, prod 101, rev 100, cnfg 1, iface 0
2. 'usbif471,101.config1.0'     Vend 471, product 101, config 1, interface 0
3. 'usbif471,class1.1.0'    Vend 471, class 1, subclass 1, protocol 0
4. 'usbif471,class1.1'      Vend 471, class 1, subclass 1
5. 'usbif471,class1'        Vend 471, class 1
6. 'usbif,class1.1.0'       Class 1, subclass 1, protocol 0
7. 'usbif,class1.1'         Class 1, subclass 1
8. 'usbif,class1'           Class 1</pre>
</div>
</div>
<div class="paragraph">
<p>Use the following command to bind a vendor-specific, device-specific
client driver named <code>vendor_model_audio_usb</code> to the
vendor-specific, device-specific configuration 1, interface 0 interface
compatible name shown in <a href="#ekyic">example_title</a>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usbif471,101.config1.0"' vendor_model_audio_usb</pre>
</div>
</div>
<div class="paragraph">
<p>Use the following command to bind a class driver named
<code>audio_class_usb_if_driver</code> to the more general class 1,
subclass 1 interface compatible name shown in
<a href="#ekyic">example_title</a>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usbif,class1.1"' audio_class_usb_if_driver</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>   Use the `prtconf` `D`
command to show a list of devices and their drivers. In the following
example, the `prtconf` `D` command shows that the `usb++_++mid` driver
manages the `audio` device. The `usb++_++mid` driver is splitting the
`audio` device into interfaces. Each interface is indented under the
`audio` device name. For each interface shown in the indented list, the
`prtconf` `D` command shows which driver manages the interface.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>audio, instance #0 (driver name: usb_mid)
    sound-control, instance #2 (driver name: usb_ac)
    sound, instance #2 (driver name: usb_as)
    input, instance #8 (driver name: hid)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="devices-with-interface-association-descriptors"><a class="anchor" href="#devices-with-interface-association-descriptors"></a>3.43.5. Devices With Interface-Association Descriptors</h4>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>interface association nodes</p>
</div>
<div class="paragraph">
<p>interface association nodes</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>usb_ia</p>
</div>
<div class="paragraph">
<p>USB interface association driver</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>usb_ia</p>
</div>
<div class="paragraph">
<p>USB interface association driver</p>
</div>
<div class="paragraph">
<p>usb_ia</p>
</div>
<div class="paragraph">
<p>USB interface association driver</p>
</div>
<div class="paragraph">
<p>If the device includes an interface-association descriptor, the device
tree can be parsed at the following three levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>usb_mid(4D)</code> USB multi-interface driver binds to device level
nodes of a composite device if no vendor or class-specific driver is
available.</p>
</li>
<li>
<p>A client driver is bound to the interface association nodes.</p>
</li>
<li>
<p>The <code>usb_ia(4D)</code> USB interface association driver is bound by
default if no client driver is found. Then client drivers can be bound
to the interface level of this interface association.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>usb_mid</code> driver creates an <code>ia</code> (interface association) node
for each <code>ia</code>. The compatible names of <code>ia</code> nodes generally begin with
<code>usbia</code>. The name <code>usb,ia</code> is a compatible name that represents any <code>ia</code>
as the tail of the compatible names. The <code>usb_ia</code> driver is bound to
an <code>ia</code> node if no other driver has claimed this <code>ia</code>. The <code>usb_ia</code>
driver creates a child node for each interface. An interface node as the
child node of an <code>ia</code> node has the same properties with an interface
node as the child of a device node.</p>
</div>
<div id="usb-51" class="paragraph">
<p>USB Video Interface Association Compatible Names</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1. 'usbia46d,8c9.5.config1.0' vend 46d, prod 8c9, rev 5, cnfg 1, first_if_in_ia 0
2. 'usbia46d,8c9.config1.0'   vend 46d, prod 8c9, cnfg 1, first_if_in_ia 0
3. 'usbia46d,classe.3.0'      vend 46d, class e, subclass 3, protocol 0
4. 'usbia46d,classe.3'        vend 46d, class e, subclass 3
5. 'usbia46d,classe'          vend 46d, class e
6. 'usbia,classe.3.0'         class e, subclass 3, protocol 0
7. 'usbia,classe.3'           class e, subclass 3
8. 'usbia,classe'             class e
9. 'usb,ia'                   by default</pre>
</div>
</div>
<div class="paragraph">
<p>Use the following command to bind a vendor-specific, device-specific
client driver named <code>vendor_model_video_usb</code> to the
vendor-specific, device-specific configuration 1,
first_if_in_ia 0 compatible name shown in
<a href="#usb-51">example_title</a>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usbia46d,8c9.config1.0"' vendor_model_video_usb</pre>
</div>
</div>
<div class="paragraph">
<p>Use the following command to bind a class driver named
<code>video_class_usb_ia_driver</code> to the more general class e
compatible names shown in <a href="#usb-51">example_title</a>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>add_drv -n -i '"usbia,classee"' video_class_usb_ia_driver</pre>
</div>
</div>
<div class="paragraph">
<p>In the following example, the <code>prtconf</code> <code>D</code> command shows a device tree
of a webcam with <code>ia</code> of <code>video</code> and <code>audio</code>. The <code>usb_mid</code> driver
manages the device and creates two <code>ia</code> respectively for video and
audio. A video driver <code>usbvc</code> is bound to the video <code>ia</code>, and audio
drivers are bound to the interface of the audio <code>ia</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>miscellaneous, instance #28 (driver name: usb_mid)
    video, instance #24 (driver name: usbvc)
    audio, instance #30 (driver name: usb_ia)
        sound-control, instance #38 (driver name: usb_ac)
        sound, instance #47 (driver name: usb_as)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="checking-device-driver-bindings"><a class="anchor" href="#checking-device-driver-bindings"></a>3.43.6. Checking Device Driver Bindings</h4>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>/etc/driver_aliases</p>
</div>
<div class="paragraph">
<p>add_drv</p>
</div>
<div class="paragraph">
<p>update_drv</p>
</div>
<div class="paragraph">
<p>The file <code>/etc/driver_aliases</code> contains entries for the bindings
that already exist on a system. Each line of the
<code>/etc/driver_aliases</code> file shows a driver name, followed by a space,
followed by a device name. Use this file to check existing device driver
bindings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not edit the <code>/etc/driver_aliases</code> file manually. Use the
<code>add_drv(8)</code> command to establish a binding. Use the
<code>update_drv(8)</code> command to change a binding.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basic-device-access"><a class="anchor" href="#basic-device-access"></a>3.44. Basic Device Access</h3>
<div class="paragraph">
<p>This section describes how to access a USB device and how to register a
client driver. This section also discusses the descriptor tree.</p>
</div>
<div class="sect3">
<h4 id="before-the-client-driver-is-attached"><a class="anchor" href="#before-the-client-driver-is-attached"></a>3.44.1. Before the Client Driver Is Attached</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>default control</p>
</div>
<div class="paragraph">
<p>use before</p>
</div>
<div class="paragraph">
<p>The following events take place before the client driver is attached:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The PROM (OBP/BIOS) and USBA framework gain access to the device
before any client driver is attached.</p>
</li>
<li>
<p>The hub driver probes devices on each of its hub&#8217;s ports for identity
and configuration.</p>
</li>
<li>
<p>The default control pipe to each device is opened, and each device is
probed for its device descriptor.</p>
</li>
<li>
<p>Compatible names properties are constructed for each device, using the
device and interface descriptors.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The compatible names properties define different parts of the device
that can be individually bound to client drivers. Client drivers can
bind either to the entire device or to just one interface. See
<a href="#binding-client-drivers">Binding Client Drivers</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="the-descriptor-tree"><a class="anchor" href="#the-descriptor-tree"></a>3.44.2. The Descriptor Tree</h4>
<div class="paragraph">
<p>descriptor tree</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>descriptor tree</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>configuration descriptors</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_dev_data</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_parse_data</p>
</div>
<div class="paragraph">
<p>Parsing descriptors involves aligning structure members at natural
boundaries and converting the structure members to the endianness of the
host CPU. Parsed standard USB configuration descriptors, interface
descriptors, and endpoint descriptors are available to the client driver
in the form of a hierarchical tree for each configuration. Any raw
class-specific or vendor-specific descriptor information also is
available to the client driver in the same hierarchical tree.</p>
</div>
<div class="paragraph">
<p>Call the <code>usb_get_dev_data(9F)</code> function to retrieve the
hierarchical descriptor tree. The “SEE ALSO” section of the
<code>usb_get_dev_data(9F)</code> man page lists the man pages for each
standard USB descriptor. Use the <code>usb_parse_data(9F)</code> function
to parse raw descriptor information.</p>
</div>
<div class="paragraph">
<p>A descriptor tree for a device with two configurations might look like
the tree shown in the following figure.</p>
</div>
<div id="euxbn" class="imageblock">
<div class="content">
<img src="figures/usb-descr-tree.png" alt="Diagram shows a tree of pairs of descriptors for each interface of a device with two configurations.">
</div>
<div class="title">Figure 19. A Hierarchical USB Descriptor Tree</div>
</div>
<div class="paragraph">
<p>The <code>dev_cfg</code> array shown in the above figure contains nodes that
correspond to configurations. Each node contains the following
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A parsed configuration descriptor</p>
</li>
<li>
<p>A pointer to an array of descriptors that correspond to the interfaces
of that configuration</p>
</li>
<li>
<p>A pointer to an array of class-specific or vendor-specific raw data,
if any exists</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The node that represents the second interface of the second indexed
configuration is at <code>dev_cfg[1].cfg_if[1]</code> in
the diagram. That node contains an array of nodes that represent the
alternate settings for that interface. The hierarchy of USB descriptors
propagates through the tree. ASCII strings from string descriptor data
are attached where the USB specification says these strings exist.</p>
</div>
<div class="paragraph">
<p>The array of configurations is non-sparse and is indexed by the
configuration index. The first valid configuration (configuration 1) is
<code>dev_cfg[0]</code>. Interfaces and alternate settings have indices
that align with their numbers. Endpoints of each alternate setting are
indexed consecutively. The first endpoint of each alternate setting is
at index 0.</p>
</div>
<div class="paragraph">
<p>This numbering scheme makes the tree easy to traverse. For example, the
raw descriptor data of endpoint index 0, alternate 0, interface 1,
configuration index 1 is at the node defined by the following path:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dev_cfg[1].cfg_if[1].if_alt[0].altif_ep[0].ep_descr</pre>
</div>
</div>
<div class="paragraph">
<p>An alternative to using the descriptor tree directly is
using the <code>usb_lookup_ep_data(9F)</code> function. The
<code>usb_lookup_ep_data(9F)</code> function takes as arguments the
interface, alternate, which endpoint, endpoint type, and direction. You
can use the <code>usb_lookup_ep_data(9F)</code> function to traverse
the descriptor tree to get a particular endpoint. See the
<code>usb_get_dev_data(9F)</code> man page for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-drivers-to-gain-device-access"><a class="anchor" href="#registering-drivers-to-gain-device-access"></a>3.44.3. Registering Drivers to Gain Device Access</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_client_attach</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_dev_data</p>
</div>
<div class="paragraph">
<p>Two of the first calls into the USBA 2.0 framework by a client driver
are calls to the <code>usb_client_attach(9F)</code> function and the
<code>usb_get_dev_data(9F)</code> function. These two calls come from
the client driver&#8217;s <code>attach(9E)</code> entry point. You must call the
<code>usb_client_attach(9F)</code> function before you call the
<code>usb_get_dev_data(9F)</code> function.</p>
</div>
<div class="paragraph">
<p>The <code>usb_client_attach(9F)</code> function registers a
client driver with the USBA 2.0 framework. The
<code>usb_client_attach(9F)</code> function enforces versioning. All client
driver source files must start with the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define USBDRV_MAJOR_VER        2
#define USBDRV_MINOR_VER        minor-version
#include &lt;sys/usb/usba.h&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of &lt;minor-version&gt; must be less than or equal to
<code>USBA_MINOR_VER</code>. The symbol <code>USBA_MINOR_VER</code> is defined
in the <code>&lt;sys/usb/usbai.h&gt;</code> header file. The
<code>&lt;sys/usb/usbai.h&gt;</code> header file is included by the
<code>&lt;sys/usb/usba.h&gt;</code> header file.</p>
</div>
<div class="paragraph">
<p><code>USBDRV_VERSION</code> is a macro that generates the version number from
<code>USBDRV_MAJOR_VERSION</code> and <code>USBDRV_MINOR_VERSION</code>. The
second argument to <code>usb_client_attach</code> must be
<code>USBDRV_VERSION</code>. The <code>usb_client_attach</code> function fails if
the second argument is not <code>USBDRV_VERSION</code> or if
<code>USBDRV_VERSION</code> reflects an invalid version. This restriction
ensures programming interface compatibility.</p>
</div>
<div class="paragraph">
<p><code>usb_get_dev_data</code> function returns information that is
required for proper USB device management. For example, the
<code>usb_get_dev_data</code> function returns the following
information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The default control pipe</p>
</li>
<li>
<p>The &lt;iblock_cookie&gt; to use in mutex initializations (see
<code>mutex_init(9F)</code>)</p>
</li>
<li>
<p>The parsed device descriptor</p>
</li>
<li>
<p>ID strings</p>
</li>
<li>
<p>The tree hierarchy as described in <a href="#the-descriptor-tree">The Descriptor Tree</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The call to the <code>usb_get_dev_data</code> function is mandatory.
Calling <code>usb_get_dev_data</code> is the only way to retrieve the
default control pipe and retrieve the &lt;iblock_cookie&gt;
required for mutex initialization.</p>
</div>
<div class="paragraph">
<p>calling <code>usb_get_dev_data</code>, the client driver&#8217;s <code>attach(9E)</code>
routine typically copies the desired descriptors and data from the
descriptor tree to the driver&#8217;s soft state. Endpoint descriptors copied
to the soft state are used later to open pipes to those endpoints. The
<code>attach(9E)</code> routine usually calls <code>usb_free_descr_tree(9F)</code>
to free the descriptor tree after copying descriptors. Alternatively,
you might choose to keep the descriptor tree and not copy the
descriptors.</p>
</div>
<div class="paragraph">
<p>Specify one of the following three parse levels to the
<code>usb_get_dev_data(9F)</code> function to request the breadth of
the descriptor tree you want returned. You need greater tree breadth if
your driver needs to bind to more of the device.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>USB_PARSE_LVL_IF</code>. If your client driver binds to a
specific interface, the driver needs the descriptors for only that
interface. Specify <code>USB_PARSE_LVL_IF</code> for the parse level in
the <code>usb_get_dev_data</code> call to retrieve only those
descriptors.</p>
</li>
<li>
<p><code>USB_PARSE_LVL_CFG</code>. If your client driver binds to the
whole device, specify <code>USB_PARSE_LVL_CFG</code> to retrieve all
descriptors of the current configuration.</p>
</li>
<li>
<p><code>USB_PARSE_LVL_ALL</code>. Specify
<code>USB_PARSE_LVL_ALL</code> to retrieve all descriptors of all
configurations. For example, you need this greatest tree breadth to use
<code>usb_print_descr_tree(9F)</code> to print a descriptor dump of all
configurations of a device.</p>
<div class="literalblock">
<div class="content">
<pre>  The client driver's `detach(9E)` routine
must call the `usb++_++free++_++dev++_++data(9F)` function to release
all resources allocated by the `usb++_++get++_++dev++_++data` function.
The `usb++_++free++_++dev++_++data` function accepts handles where the
descriptor tree has already been freed with the
`usb++_++free++_++descr++_++tree` function. The client driver's `detach`
routine also must call the `usb++_++client++_++detach(9F)` function to
release all resources allocated by the `usb++_++client++_++attach(9F)`
function.</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-communication"><a class="anchor" href="#device-communication"></a>3.45. Device Communication</h3>
<div class="paragraph">
<p>USB device communication</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB devices operate by passing requests through communication channels
called <em>pipes</em>. Pipes must be open before you can submit requests. Pipes
also can be flushed, queried, and closed. This section discusses pipes,
data transfers and callbacks, and data requests.</p>
</div>
<div class="sect3">
<h4 id="usb-endpoints"><a class="anchor" href="#usb-endpoints"></a>3.45.1. USB Endpoints</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>The four kinds of pipes that communicate with the four kinds of USB
endpoints are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Control</strong>. Control pipes are used primarily to send commands and
retrieve status. Control pipes are intended for non-periodic,
host-initiated request and response communication of small-sized
structured data. Control pipes are bidirectional. The default pipe is a
control pipe. See <a href="#the-default-pipe">The Default Pipe</a>.</p>
</li>
<li>
<p><strong>Bulk</strong>. Bulk pipes are used primarily for data transfer. Bulk pipes
offer reliable transportation of large amounts of data. Bulk pipes do
not necessarily deliver the data in a timely manner. Bulk pipes are
unidirectional.</p>
</li>
<li>
<p><strong>Interrupt</strong>. Interrupt pipes offer timely, reliable communication of
small amounts of unstructured data. Periodic polling often is started on
interrupt-IN pipes. Interrupt-IN pipes return data to the host when the
data becomes present on the device. Some devices have interrupt-OUT
pipes. Interrupt-OUT pipes transfer data to the device with the same
timely, reliable “interrupt pipe” characteristics of interrupt-IN pipes.
Interrupt pipes are unidirectional.</p>
</li>
<li>
<p><strong>Isochronous</strong>. Isochronous pipes offer a channel for transferring
constant-rate, time-relevant data, such as for audio devices. Data is
not retried on error. Isochronous pipes are unidirectional.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See Chapter 5 of the USB 2.0 specification or see <a href="#requests">Requests</a>
for more information on the transfer types that correspond to these
endpoints.</p>
</div>
</div>
<div class="sect3">
<h4 id="the-default-pipe"><a class="anchor" href="#the-default-pipe"></a>3.45.2. The Default Pipe</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_dev_data</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>default control</p>
</div>
<div class="paragraph">
<p>default control</p>
</div>
<div class="paragraph">
<p>Each USB device has a special control endpoint called the <em>default</em>
endpoint. Its communication channel is called the default pipe. Most, if
not all, device setup is done through this pipe. Many USB devices have
this pipe as their only control pipe.</p>
</div>
<div class="paragraph">
<p>The <code>usb_get_dev_data(9F)</code> function provides the default
control pipe to the client driver. This pipe is pre-opened to
accommodate any special setup needed before opening other pipes. This
default control pipe is special in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This pipe is shared. Drivers that are operating other interfaces of
the same device use the same default control pipe. The USBA 2.0
framework arbitrates this pipe among the different drivers.</p>
</li>
<li>
<p>This pipe cannot be opened, closed, or reset by the client driver.
This restriction exists because the pipe is shared.</p>
</li>
<li>
<p>The pipe is autocleared on an exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other pipes, including other control pipes, must be opened explicitly
and are exclusive-open only.</p>
</div>
</div>
<div class="sect3">
<h4 id="pipe-states"><a class="anchor" href="#pipe-states"></a>3.45.3. Pipe States</h4>
<div class="paragraph">
<p>Pipes are in one of the following states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>USB_PIPE_STATE_IDLE</code></p>
<div class="ulist">
<ul>
<li>
<p>All control and bulk pipes, interrupt-OUT pipes, and isochronous-OUT
pipes: No request is in progress.</p>
</li>
<li>
<p>Interrupt-IN and isochronous-IN pipes: No polling is in progress.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>USB_PIPE_STATE_ACTIVE</code></p>
<div class="ulist">
<ul>
<li>
<p>All control and bulk pipes, interrupt-OUT pipes, and isochronous-OUT
pipes: The pipe is transferring data or an I/O request is active.</p>
</li>
<li>
<p>Interrupt-IN and isochronous-IN pipes: Polling is active.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>USB_PIPE_STATE_ERROR</code>. An error occurred.
If this pipe is not the default pipe and if autoclearing is not enabled,
then the client driver must call the <code>usb_pipe_reset(9F)</code>
function.</p>
</li>
<li>
<p><code>USB_PIPE_STATE_CLOSING</code>. The pipe is being closed.</p>
</li>
<li>
<p><code>USB_PIPE_STATE_CLOSED</code>. The pipe is closed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Call the <code>usb_pipe_get_state(9F)</code> function to
retrieve the state of a pipe.</p>
</div>
</div>
<div class="sect3">
<h4 id="opening-pipes"><a class="anchor" href="#opening-pipes"></a>3.45.4. Opening Pipes</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_lookup_ep_data</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_open</p>
</div>
<div class="paragraph">
<p>To open a pipe, pass to the <code>usb_pipe_open(9F)</code> function the
endpoint descriptor that corresponds to the pipe you want to open. Use
the <code>usb_get_dev_data(9F)</code> and
<code>usb_lookup_ep_data(9F)</code> functions to retrieve the endpoint
descriptor from the descriptor tree. The <code>usb_pipe_open(9F)</code>
function returns a handle to the pipe.</p>
</div>
<div class="paragraph">
<p>You must specify a pipe policy when you open a pipe. The pipe policy
contains an estimate of the number of concurrent asynchronous operations
that require separate threads that will be needed for this pipe. An
estimate of the number of threads is the number of parallel operations
that could occur during a callback. The value of this estimate must be
at least 2. See the <code>usb_pipe_open(9F)</code> man page for more
information on pipe policy.</p>
</div>
</div>
<div class="sect3">
<h4 id="closing-pipes"><a class="anchor" href="#closing-pipes"></a>3.45.5. Closing Pipes</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_close</p>
</div>
<div class="paragraph">
<p>The driver must use the <code>usb_pipe_close(9F)</code> function to close
pipes other than the default pipe. The <code>usb_pipe_close(9F)</code>
function enables all remaining requests in the pipe to complete. The
function then allows one second for all callbacks of those requests to
complete.</p>
</div>
</div>
<div class="sect3">
<h4 id="data-transfer"><a class="anchor" href="#data-transfer"></a>3.45.6. Data Transfer</h4>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_bulk_xfer</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_ctrl_xfer</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_intr_xfer</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_isoc_xfer</p>
</div>
<div class="paragraph">
<p>For all pipe types, the programming model is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocate a request.</p>
</li>
<li>
<p>Submit the request using one of the pipe transfer functions. See the
<code>usb_pipe_bulk_xfer(9F)</code>,
<code>usb_pipe_ctrl_xfer(9F)</code>,
<code>usb_pipe_intr_xfer(9F)</code>, and
<code>usb_pipe_isoc_xfer(9F)</code> man pages.</p>
</li>
<li>
<p>Wait for completion notification.</p>
</li>
<li>
<p>Free the request.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See <a href="#requests">Requests</a> for more information on requests. The
following sections describe the features of different request types.</p>
</div>
<div class="sect4">
<h5 id="synchronous-and-asynchronous-transfers-and-callbacks"><a class="anchor" href="#synchronous-and-asynchronous-transfers-and-callbacks"></a>Synchronous and Asynchronous Transfers and Callbacks</h5>
<div class="paragraph">
<p>synchronous data transfers</p>
</div>
<div class="paragraph">
<p>asynchronous data transfers</p>
</div>
<div class="paragraph">
<p>Transfers are either synchronous or asynchronous. Synchronous transfers
block until they complete. Asynchronous transfers callback into the
client driver when they complete. Most transfer functions called with
the <code>USB_FLAGS_SLEEP</code> flag set in the &lt;flags&gt; argument
are synchronous.</p>
</div>
<div class="paragraph">
<p>Continuous transfers such as polling and isochronous transfers cannot be
synchronous. Calls to transfer functions for continuous transfers made
with the <code>USB_FLAGS_SLEEP</code> flag set block only to wait for
resources before the transfer begins.</p>
</div>
<div class="paragraph">
<p>Synchronous transfers are the most simple transfers to set up because
synchronous transfers do not require any callback functions. Synchronous
transfer functions return a transfer start status, even though
synchronous transfer functions block until the transfer is completed.
Upon completion, you can find additional information about the transfer
status in the completion reason field and callback flags field of the
request. Completion reasons and callback flags fields are discussed
below.</p>
</div>
<div class="paragraph">
<p>If the <code>USB_FLAGS_SLEEP</code> flag is not specified in the
&lt;flags&gt; argument, that transfer operation is asynchronous. The
exception to this rule are isochronous transfers. Asynchronous transfer
operations set up and start the transfer, and then return before the
transfer is complete. Asynchronous transfer operations return a transfer
start status. The client driver receives transfer completion status
through callback handlers.</p>
</div>
<div class="paragraph">
<p>Callback handlers are functions that are called when
asynchronous transfers complete. Do not set up an asynchronous transfer
without callbacks. The two types of callback handlers are normal
completion handlers and exception handlers. You can specify one handler
to be called in both of these cases.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Normal completion</strong>. A normal completion callback handler is called to
notify of a normally completed transfer.</p>
</li>
<li>
<p><strong>Exception</strong>. An exception callback handler is called to notify of an
abnormally completed transfer and to process its errors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>completion handlers and exception handlers receive the transfer&#8217;s
request as an argument. Exception handlers use the completion reason and
callback status in the request to find out what happened. The completion
reason (<code>usb_cr_t</code>) indicates how the original transaction
completed. For example, a completion reason of <code>USB_CR_TIMEOUT</code>
indicates that the transfer timed out. As another example, if a USB
device is removed while in use, client drivers might receive
<code>USB_CR_DEV_NOT_RESP</code> as the completion reason on their
outstanding requests. The callback status (<code>usb_cb_flags_t</code>)
indicates what the USBA framework did to remedy the situation. For
example, a callback status of <code>USB_CB_STALL_CLEARED</code>
indicates that the USBA framework cleared a functional stall condition.
See the <code>usb_completion_reason(9S)</code> man page for more
information on completion reasons. See the
<code>usb_callback_flags(9S)</code> man page for more information on
callback status flags.</p>
</div>
<div class="paragraph">
<p>The context of the callback and the policy of the pipe
on which the requests are run limit what you can do in the callback.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callback context</strong>. Most callbacks execute in kernel context and
usually can block. Some callbacks execute in interrupt context and
cannot block. The <code>USB_CB_INTR_CONTEXT</code> flag is set in the
callback flags to denote interrupt context. See the
<code>usb_callback_flags(9S)</code> man page for more information on
callback context and details on blocking.</p>
</li>
<li>
<p><strong>Pipe policy</strong>. The pipe policy&#8217;s hint on concurrent
asynchronous operations limits the number of operations that can be run
in parallel, including those executed from a callback handler. Blocking
on a synchronous operation counts as one operation. See the
<code>usb_pipe_open(9F)</code> man page for more information on pipe
policy.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="requests"><a class="anchor" href="#requests"></a>Requests</h5>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>data transfer requests</p>
</div>
<div class="paragraph">
<p>This section discusses request structures and allocating and
deallocating different types of requests.</p>
</div>
<div class="sect5">
<h6 id="usb-25"><a class="anchor" href="#usb-25"></a>Request Allocation and Deallocation</h6>
<div class="paragraph">
<p>Requests are implemented as initialized request structures. Each
different endpoint type takes a different type of request. Each type of
request has a different request structure type. The following table
shows the structure type for each type of request. This table also lists
the functions to use to allocate and free each type of structure.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 20. Request Initialization</caption>
<colgroup>
<col style="width: 16%;">
<col style="width: 26%;">
<col style="width: 30%;">
<col style="width: 28%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pipe or Endpoint Type</th>
<th class="tableblock halign-left valign-top">Request Structure</th>
<th class="tableblock halign-left valign-top">Request Structure Allocation
Function</th>
<th class="tableblock halign-left valign-top">Request Structure Free Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_ctrl_req_t</code> (see the
<code>usb_ctrl_request(9S)</code> man page)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_alloc_ctrl_req(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_free_ctrl_req(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bulk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_bulk_req_t</code> (see the
<code>usb_bulk_request(9S)</code> man page)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_alloc_bulk_req(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_free_bulk_req(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_intr_req_t</code> (see the
<code>usb_intr_request(9S)</code> man page)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_alloc_intr_req(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_free_intr_req(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Isochronous</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_isoc_req_t</code> (see the
<code>usb_isoc_request(9S)</code> man page)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_alloc_isoc_req(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_free_isoc_req(9F)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table lists the transfer functions that you can use for
each type of request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 21. Request Transfer Setup</caption>
<colgroup>
<col style="width: 26%;">
<col style="width: 74%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pipe or Endpoint Type</th>
<th class="tableblock halign-left valign-top">Transfer Functions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_pipe_ctrl_xfer(9F)</code>,
<code>usb_pipe_ctrl_xfer_wait(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bulk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_pipe_bulk_xfer(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_pipe_intr_xfer(9F)</code>,
<code>usb_pipe_stop_intr_polling(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Isochronous</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>usb_pipe_isoc_xfer(9F)</code>,
<code>usb_pipe_stop_isoc_polling(9F)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Use the following procedure to allocate and deallocate a request:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the appropriate allocation function to allocate a request
structure for the type of request you need. The man pages for the
request structure allocation functions are listed in
<a href="#usb-tbl-33">Request Initialization</a>.</p>
</li>
<li>
<p>Initialize any fields you need in the structure. See
<a href="#usb-26">Request Features and Fields</a> or the appropriate request
structure man page for more information. The man pages for the request
structures are listed in <a href="#usb-tbl-33">Request Initialization</a>.</p>
</li>
<li>
<p>When the data transfer is complete, use the appropriate free function
to free the request structure. The man pages for the request structure
free functions are listed in <a href="#usb-tbl-33">Request Initialization</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="usb-26"><a class="anchor" href="#usb-26"></a>Request Features and Fields</h6>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>message blocks</p>
</div>
<div class="paragraph">
<p>Data for all requests is passed in message blocks so that the data is
handled uniformly whether the driver is a STREAMS, character, or block
driver. The message block type, <code>mblk_t</code>, is described in the
<code>mblk(9S)</code> man page. The DDI offers several routines for manipulating
message blocks. Examples include <code>allocb(9F)</code> and <code>freemsg(9F)</code>. To
learn about other routines for manipulating message blocks, see the “SEE
ALSO” sections of the <code>allocb(9F)</code> and <code>freemsg(9F)</code> man pages. Also see
the STREAMS Programming Guide.</p>
</div>
<div class="paragraph">
<p>The following request fields are included in all transfer types. In each
field name, the possible values for &lt;xxxx&gt; are: &lt;ctrl&gt;,
&lt;bulk&gt;, &lt;intr&gt;, or &lt;isoc&gt;.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;xxxx_client_private&gt;</dt>
<dd>
<p>This field value is a pointer that is intended for internal data to be
passed around the client driver along with the request. This pointer
is not used to transfer data to the device.</p>
</dd>
<dt class="hdlist1">&lt;xxxx_attributes&gt;</dt>
<dd>
<p>This field value is a set of transfer attributes.
While this field is common to all request structures, the
initialization of this field is somewhat different for each transfer
type. See the appropriate request structure man page for more
information. These man pages are listed in <a href="#usb-tbl-33">Request
Initialization</a>. See also the <code>usb_request_attributes(9S)</code> man
page.</p>
</dd>
<dt class="hdlist1">&lt;xxxx_cb&gt;</dt>
<dd>
<p>This field value is a callback function for normal transfer
completion. This function is called when an asynchronous transfer
completes without error.</p>
</dd>
<dt class="hdlist1">&lt;xxxx_exc_cb&gt;</dt>
<dd>
<p>This field value is a callback function for error handling. This
function is called only when asynchronous transfers complete with
errors.</p>
</dd>
<dt class="hdlist1">&lt;xxxx_completion_reason&gt;</dt>
<dd>
<p>This field holds the completion status
of the transfer itself. If an error occurred, this field shows what
went wrong. See the <code>usb_completion_reason(9S)</code> man page for
more information. This field is updated by the USBA 2.0 framework.</p>
</dd>
<dt class="hdlist1">&lt;xxxx_cb_flags&gt;</dt>
<dd>
<p>This field lists the recovery actions
that were taken by the USBA 2.0 framework before calling the callback
handler. The <code>USB_CB_INTR_CONTEXT</code> flag indicates whether
a callback is running in interrupt context. See the
<code>usb_callback_flags(9S)</code> man page for more information. This
field is updated by the USBA 2.0 framework.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following sections describe the request fields that are different
for the four different transfer types. These sections describe how to
initialize these structure fields. These sections also describe the
restrictions on various combinations of attributes and parameters.</p>
</div>
</div>
<div class="sect5">
<h6 id="eqxri"><a class="anchor" href="#eqxri"></a>Control Requests</h6>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>control data transfer requests</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>synchronous control requests</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_ctrl_xfer_wait</p>
</div>
<div class="paragraph">
<p>USB structures</p>
</div>
<div class="paragraph">
<p>usb_ctrl_request</p>
</div>
<div class="paragraph">
<p>Use control requests to initiate message transfers down a control pipe.
You can set up transfers manually, as described below. You can also set
up and send synchronous transfers using the
<code>usb_pipe_ctrl_xfer_wait(9F)</code> wrapper function.</p>
</div>
<div class="paragraph">
<p>The client driver must initialize the &lt;ctrl_bmRequestType&gt;,
&lt;ctrl_bRequest&gt;, &lt;ctrl_wValue&gt;,
&lt;ctrl_wIndex&gt;, and &lt;ctrl_wLength&gt; fields as
described in the USB 2.0 specification.</p>
</div>
<div class="paragraph">
<p>The &lt;ctrl_data&gt; field of the request must be initialized to
point to a data buffer. The <code>usb_alloc_ctrl_req(9F)</code>
function initializes this field when you pass a positive value as the
buffer &lt;len&gt;. The buffer must, of course, be initialized for any
outbound transfers. In all cases, the client driver must free the
request when the transfer is complete.</p>
</div>
<div class="paragraph">
<p>Multiple control requests can be queued. Queued requests can be a
combination of synchronous and asynchronous requests.</p>
</div>
<div class="paragraph">
<p>The &lt;ctrl_timeout&gt; field defines the maximum wait time for
the request to be processed, excluding wait time on the queue. This
field applies to both synchronous and asynchronous requests. The
&lt;ctrl_timeout&gt; field is specified in seconds.</p>
</div>
<div class="paragraph">
<p>The &lt;ctrl_exc_cb&gt; field accepts the address of a
function to call if an exception occurs. The arguments of this exception
handler are specified in the <code>usb_ctrl_request(9S)</code> man page.
The second argument of the exception handler is the
<code>usb_ctrl_req_t</code> structure. Passing the request structure as
an argument allows the exception handler to check the
&lt;ctrl_completion_reason&gt; and
&lt;ctrl_cb_flags&gt; fields of the request to determine the
best recovery action.</p>
</div>
<div class="paragraph">
<p>The <code>USB_ATTRS_ONE_XFER</code> and <code>USB_ATTRS_ISOC_*</code>
flags are invalid attributes for all control requests. The
<code>USB_ATTRS_SHORT_XFER_OK</code> flag is valid only for
host-bound requests.</p>
</div>
</div>
<div class="sect5">
<h6 id="eqxrp"><a class="anchor" href="#eqxrp"></a>Bulk Requests</h6>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>bulk data transfer requests</p>
</div>
<div class="paragraph">
<p>USB structures</p>
</div>
<div class="paragraph">
<p>usb_bulk_request</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_get_max_bulk_transfer_ size</p>
</div>
<div class="paragraph">
<p>bulk requests</p>
</div>
<div class="paragraph">
<p>Use bulk requests to send data that is not time-critical. Bulk requests
can take several USB frames to complete, depending on overall bus load.</p>
</div>
<div class="paragraph">
<p>All requests must receive an initialized message block. See the
<code>mblk(9S)</code> man page for a description of the <code>mblk_t</code> message block
type. This message block either supplies the data or stores the data,
depending on the transfer direction. Refer to the
<code>usb_bulk_request(9S)</code> man page for more details.</p>
</div>
<div class="paragraph">
<p>The <code>USB_ATTRS_ONE_XFER</code> and <code>USB_ATTRS_ISOC_*</code>
flags are invalid attributes for all bulk requests. The
<code>USB_ATTRS_SHORT_XFER_OK</code> flag is valid only for
host-bound requests.</p>
</div>
<div class="paragraph">
<p>The <code>usb_pipe_get_max_bulk_transfer_size(9F)</code>
function specifies the maximum number of bytes per request. The value
retrieved can be the maximum value used in the client driver&#8217;s
<code>minphys(9F)</code> routine.</p>
</div>
<div class="paragraph">
<p>Multiple bulk requests can be queued.</p>
</div>
</div>
<div class="sect5">
<h6 id="eqxrk"><a class="anchor" href="#eqxrk"></a>Interrupt Requests</h6>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>interrupt data transfer requests</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_intr_xfer</p>
</div>
<div class="paragraph">
<p>USB structures</p>
</div>
<div class="paragraph">
<p>usb_alloc_intr_request</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_stop_intr_polling</p>
</div>
<div class="paragraph">
<p>Interrupt requests typically are for periodic inbound data. Interrupt
requests periodically poll the device for data. However, the USBA 2.0
framework supports one-time inbound interrupt data requests, as well as
outbound interrupt data requests. All interrupt requests can take
advantage of the USB interrupt transfer features of timeliness and
retry.</p>
</div>
<div class="paragraph">
<p>The <code>USB_ATTRS_ISOC_*</code> flags are invalid attributes for all
interrupt requests. The <code>USB_ATTRS_SHORT_XFER_OK</code> and
<code>USB_ATTRS_ONE_XFER</code> flags are valid only for host-bound
requests.</p>
</div>
<div class="paragraph">
<p>Only one-time polls can be done as synchronous interrupt transfers.
Specifying the <code>USB_ATTRS_ONE_XFER</code> attribute in the request
results in a one-time poll.</p>
</div>
<div class="paragraph">
<p>Periodic polling is started as an asynchronous interrupt transfer. An
original interrupt request is passed to
<code>usb_pipe_intr_xfer(9F)</code>. When polling finds new data to
return, a new <code>usb_intr_req_t</code> structure is cloned from the
original and is populated with an initialized data block. When
allocating the request, specify zero for the &lt;len&gt; argument to
the <code>usb_alloc_intr_req(9F)</code> function. The &lt;len&gt;
argument is zero because the USBA 2.0 framework allocates and fills in a
new request with each callback. After you allocate the request
structure, fill in the &lt;intr_len&gt; field to specify the
number of bytes you want the framework to allocate with each poll. Data
beyond &lt;intr_len&gt; bytes is not returned.</p>
</div>
<div class="paragraph">
<p>The client driver must free each request it receives. If the message
block is sent upstream, decouple the message block from the request
before you send the message block upstream. To decouple the message
block from the request, set the data pointer of the request to <code>NULL</code>.
Setting the data pointer of the request to <code>NULL</code> prevents the message
block from being freed when the request is deallocated.</p>
</div>
<div class="paragraph">
<p>Call the <code>usb_pipe_stop_intr_polling(9F)</code> function to
cancel periodic polling. When polling is stopped or the pipe is closed,
the original request structure is returned through an exception
callback. This returned request structure has its completion reason set
to <code>USB_CR_STOPPED_POLLING</code>.</p>
</div>
<div class="paragraph">
<p>Do not start polling while polling is already in progress. Do not start
polling while a call to <code>usb_pipe_stop_intr_polling(9F)</code>
is in progress.</p>
</div>
</div>
<div class="sect5">
<h6 id="eqxrl"><a class="anchor" href="#eqxrl"></a>Isochronous Requests</h6>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>isochronous data transfer requests</p>
</div>
<div class="paragraph">
<p>Isochronous requests are for streaming, constant-rate, time-relevant
data. Retries are not made on errors. Isochronous requests have the
following request-specific fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;isoc_frame_no&gt;</dt>
<dd>
<p>Specify this field when the overall transfer must
start from a specific frame number. The value of this field must be
greater than the current frame number. Use
<code>usb_get_current_frame_number(9F)</code> to find the current
frame number. Note that the current frame number is a moving target.
For low-speed and full-speed buses, the current frame is new each
millisecond. For high-speed buses, the current frame is new each 0.125
millisecond. Set the <code>USB_ATTR_ISOC_START_FRAME</code>
attribute so that the &lt;isoc_frame_no&gt; field is
recognized.
+
To ignore this frame number field and start as soon as possible, set
the <code>USB_ATTR_ISOC_XFER_ASAP</code> flag.</p>
</dd>
<dt class="hdlist1">&lt;isoc_pkts_count&gt;</dt>
<dd>
<p>This field is the number of packets in the request.
This value is bounded by the value returned by the
<code>usb_get_max_pkts_per_isoc_request(9F)</code>
function and by the size of the &lt;isoc_pkt_descr&gt; array
(see below). The number of bytes transferable with this request is
equal to the product of this &lt;isoc_pkts_count&gt; value
and the &lt;wMaxPacketSize&gt; value of the endpoint.</p>
</dd>
<dt class="hdlist1">&lt;isoc_pkts_length&gt;</dt>
<dd>
<p>This field is the sum of the lengths of all packets of the request.
This value is set by the initiator. This value should be set to zero
so that the sum of &lt;isoc_pkts_length&gt; in the
&lt;isoc_pkt_descr&gt; list will be used automatically and
no check will be applied to this element.</p>
</dd>
<dt class="hdlist1">&lt;isoc_error_count&gt;</dt>
<dd>
<p>This field is the number of packets that completed with errors. This
value is set by the USBA 2.0 framework.</p>
</dd>
<dt class="hdlist1">&lt;isoc_pkt_descr&gt;</dt>
<dd>
<p>This field points to an array of packet descriptors
that define how much data to transfer per packet. For an outgoing
request, this value defines a private queue of sub-requests to
process. For an incoming request, this value describes how the data
arrived in pieces. The client driver allocates these descriptors for
outgoing requests. The framework allocates and initializes these
descriptors for incoming requests. Descriptors in this array contain
framework-initialized fields that hold the number of bytes actually
transferred and the status of the transfer. See the
<code>usb_isoc_request(9S)</code> man page for more details.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>All requests must receive an initialized message block.
This message block either supplies the data or stores the data. See the
<code>mblk(9S)</code> man page for a description of the <code>mblk_t</code> message block
type.</p>
</div>
<div class="paragraph">
<p>The <code>USB_ATTR_ONE_XFER</code> flag is an illegal attribute because
the system decides how to vary the amounts of data through available
packets. The <code>USB_ATTR_SHORT_XFER_OK</code> flag is valid only
on host-bound data.</p>
</div>
<div class="paragraph">
<p>The <code>usb_pipe_isoc_xfer(9F)</code> function makes
all isochronous transfers asynchronous, regardless of whether the
<code>USB_FLAGS_SLEEP</code> flag is set. All isochronous input requests
start polling.</p>
</div>
<div class="paragraph">
<p>Call the <code>usb_pipe_stop_isoc_polling(9F)</code> function to
cancel periodic polling. When polling is stopped or the pipe is closed,
the original request structure is returned through an exception
callback. This returned request structure has its completion reason set
to <code>USB_CR_STOPPED_POLLING</code>.</p>
</div>
<div class="paragraph">
<p>Polling continues until one of the following events occurs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>usb_pipe_stop_isoc_polling(9F)</code> call is received.</p>
</li>
<li>
<p>A device disconnect is reported through an exception callback.</p>
</li>
<li>
<p>A <code>usb_pipe_close(9F)</code> call is received.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="flushing-pipes"><a class="anchor" href="#flushing-pipes"></a>3.45.7. Flushing Pipes</h4>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_reset</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_get_state</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_drain_reqs</p>
</div>
<div class="paragraph">
<p>You might need to clean up a pipe after errors, or you might want to
wait for a pipe to clear. Use one of the following methods to flush or
clear pipes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>usb_pipe_reset(9F)</code> function resets the pipe and flushes
all of its requests. Do this for pipes that are in an error state if
autoclearing is not enabled on those pipes. Use
<code>usb_pipe_get_state(9F)</code> to determine the state of a pipe.</p>
</li>
<li>
<p>The <code>usb_pipe_drain_reqs(9F)</code> function blocks waiting for
all pending requests to complete before continuing. This function can
wait indefinitely, or it can time-out after a specified period of time.
The <code>usb_pipe_drain_reqs(9F)</code> function neither closes nor
flushes the pipe.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-state-management"><a class="anchor" href="#device-state-management"></a>3.46. Device State Management</h3>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>Managing a USB device includes accounting for hotplugging, system power
management (checkpoint and resume), and device power management. All
client drivers should implement the basic state machine shown in the
following figure. For more information, see
<code>/usr/include/sys/usb/usbai.h</code>.</p>
</div>
<div id="euxbq" class="imageblock">
<div class="content">
<img src="figures/usb-hotplug-state.png" alt="Diagram shows what state the device goes to after each of seven different events.">
</div>
<div class="title">Figure 20. USB Device State Machine</div>
</div>
<div class="paragraph">
<p>This state machine and its four states can be augmented with
driver-specific states. Device states <code>0x80</code> to <code>0xff</code> can be defined
and used only by client drivers.</p>
</div>
<div class="sect3">
<h4 id="hotplugging-usb-devices"><a class="anchor" href="#hotplugging-usb-devices"></a>3.46.1. Hotplugging USB Devices</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>USB devices support hotplugging. A USB device can be inserted or removed
at any time. The client driver must handle removal and reinsertion of an
open device. Use hotplug callbacks to handle open devices. Insertion and
removal of closed devices is handled by the <code>attach(9E)</code> and
<code>detach(9E)</code> entry points.</p>
</div>
<div class="sect4">
<h5 id="hotplug-callbacks"><a class="anchor" href="#hotplug-callbacks"></a>Hotplug Callbacks</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>The USBA 2.0
framework supports the following event notifications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The client driver receives a callback when the device is hot removed.</p>
</li>
<li>
<p>The client driver receives a callback when the device is returned
after hot removal. This event callback can occur when the user returns
the device to its original port if the driver instance of the device is
not offlined. If the driver instance is held open, then the driver
instance cannot be offlined.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Client drivers must call
<code>usb_register_hotplug_cbs(9F)</code> in their <code>attach(9E)</code> routine
to register for event callbacks. Drivers must call
<code>usb_unregister_hotplug_cbs(9F)</code> in their <code>detach(9E)</code>
routine before dismantling.</p>
</div>
</div>
<div class="sect4">
<h5 id="hot-insertion"><a class="anchor" href="#hot-insertion"></a>Hot Insertion</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>USB hub driver</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>USB hub driver</p>
</div>
<div class="paragraph">
<p>USB hub driver</p>
</div>
<div class="paragraph">
<p>The sequence of events for hot insertion of a USB device is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The hub driver, <code>hubd(4D)</code>, waits for a port connect status change.</p>
</li>
<li>
<p>The <code>hubd</code> driver detects a port connect.</p>
</li>
<li>
<p>The <code>hubd</code> driver enumerates the device, creates child device nodes,
and attaches client drivers. Refer to <a href="#binding-client-drivers">Binding Client
Drivers</a> for compatible names definitions.</p>
</li>
<li>
<p>The client driver manages the device. The driver is in the <code>ONLINE</code>
state.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="hot-removal"><a class="anchor" href="#hot-removal"></a>Hot Removal</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>hot removal</p>
</div>
<div class="paragraph">
<p>hot removal</p>
</div>
<div class="paragraph">
<p>The sequence of events for hot removal of a USB device is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The hub driver, <code>hubd(4D)</code>, waits for a port connect status change.</p>
</li>
<li>
<p>The <code>hubd</code> driver detects a port disconnect.</p>
</li>
<li>
<p>The <code>hubd</code> driver sends a disconnect event to the child client driver.
If the child client driver is the <code>hubd</code> driver or the <code>usb_mid(4D)</code>
multi-interface driver, then the child client driver propagates the
event to its children.</p>
</li>
<li>
<p>The client driver receives the disconnect event notification in kernel
thread context. Kernel thread context enables the driver&#8217;s disconnect
handler to block.</p>
</li>
<li>
<p>The client driver moves to the <code>DISCONNECTED</code> state. Outstanding I/O
transfers fail with the completion reason of <code>device not responding</code>.
All new I/O transfers and attempts to open the device node also fail.
The client driver is not required to close pipes. The driver is required
to save the device and driver context that needs to be restored if the
device is reconnected.</p>
</li>
<li>
<p>The <code>hubd</code> driver attempts to offline the OS device node and its
children in bottom-up order.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following events take place if the device node is not open when the
<code>hubd</code> driver attempts to offline the device node:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client driver&#8217;s <code>detach(9E)</code> entry point is called.</p>
</li>
<li>
<p>The device node is destroyed.</p>
</li>
<li>
<p>The port becomes available for a new device.</p>
</li>
<li>
<p>The hotplug sequence of events starts over. The <code>hubd</code> driver waits
for a port connect status change.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following events take place if the device node is open when the
<code>hubd</code> driver attempts to offline the device node:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>hubd</code> driver puts the offline request in the periodic offline
retry queue.</p>
</li>
<li>
<p>The port remains unavailable for a new device.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the device node was open when the <code>hubd</code> driver attempted to offline
the device node and the user later closes the device node, the <code>hubd</code>
driver periodic offlining of that device node succeeds and the following
events take place:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client driver&#8217;s <code>detach(9E)</code> entry point is called.</p>
</li>
<li>
<p>The device node is destroyed.</p>
</li>
<li>
<p>The port becomes available for a new device.</p>
</li>
<li>
<p>The hotplug sequence of events starts over. The <code>hubd</code> driver waits
for a port connect status change.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the user closes all applications that use the device, the port
becomes available again. If the application does not terminate or does
not close the device, the port remains unavailable.</p>
</div>
</div>
<div class="sect4">
<h5 id="hot-reinsertion"><a class="anchor" href="#hot-reinsertion"></a>Hot Reinsertion</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>configuration descriptor clouds</p>
</div>
<div class="paragraph">
<p>configuration descriptor clouds</p>
</div>
<div class="paragraph">
<p>The following events take place if a previously-removed device is
reinserted into the same port while the device node of the device is
still open:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The hub driver, <code>hubd(4D)</code>, detects a port connect.</p>
</li>
<li>
<p>The <code>hubd</code> driver restores the bus address and the device
configuration.</p>
</li>
<li>
<p>The <code>hubd</code> driver cancels the offline retry request.</p>
</li>
<li>
<p>The <code>hubd</code> driver sends a connect event to the client driver.</p>
</li>
<li>
<p>The client driver receives the connect event.</p>
</li>
<li>
<p>The client driver determines whether the new device is the same as the
device that was previously connected. The client driver makes this
determination first by comparing device descriptors. The client driver
might also compare serial numbers and configuration descriptor clouds.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following events might take place if the client driver determines
that the current device is not the same as the device that was
previously connected:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client driver might issue a warning message to the console.</p>
</li>
<li>
<p>The user might remove the device again. If the user removes the device
again, the hot remove sequence of events starts over. The <code>hubd</code> driver
detects a port disconnect. If the user does not remove the device again,
the following events take place:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client driver remains in the <code>DISCONNECTED</code> state, failing all
requests and opens.</p>
</li>
<li>
<p>The port remains unavailable. The user must close and disconnect the
device to free the port.</p>
</li>
<li>
<p>The hotplug sequence of events starts over when the port is freed.
The <code>hubd</code> driver waits for a port connect status change.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following events might take place if the client driver determines
that the current device is the same as the device that was previously
connected:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client driver might restore its state and continue normal
operation. This policy is up to the client driver. Audio speakers are a
good example where the client driver should continue.</p>
</li>
<li>
<p>If it is safe to continue using the reconnected device, the hotplug
sequence of events starts over. The <code>hubd</code> driver waits for a port
connect status change. The device is in service once again.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="power-management-1"><a class="anchor" href="#power-management-1"></a>3.46.2. Power Management</h4>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>USB devices</p>
</div>
<div class="paragraph">
<p>This section discusses device power management and system power
management.</p>
</div>
<div class="paragraph">
<p>Device power management manages individual USB devices depending on
their I/O activity or idleness.</p>
</div>
<div class="paragraph">
<p>System power management uses checkpoint and resume to checkpoint the
state of the system into a file and shut down the system completely.
(Checkpoint is sometimes called “system suspend.”) The system is resumed
to its pre-suspend state when the system is powered up again.</p>
</div>
<div class="sect4">
<h5 id="device-power-management-1"><a class="anchor" href="#device-power-management-1"></a>Device Power Management</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>USB devices</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_create_pm_components</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>usb_create_pm_components</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_busy_component</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_idle_component</p>
</div>
<div class="paragraph">
<p>device power management</p>
</div>
<div class="paragraph">
<p>pm_raise_power</p>
</div>
<div class="paragraph">
<p>pm_busy_component</p>
</div>
<div class="paragraph">
<p>pm_idle_component</p>
</div>
<div class="paragraph">
<p>pm_raise_power</p>
</div>
<div class="paragraph">
<p>The following summary lists what your driver needs to do to power manage
a USB device. A more detailed description of power management follows
this summary.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create power management components during <code>attach(9E)</code>. See the
<code>usb_create_pm_components(9F)</code> man page.</p>
</li>
<li>
<p>Implement the <code>power(9E)</code> entry point.</p>
</li>
<li>
<p>Call <code>pm_busy_component(9F)</code> and <code>pm_raise_power(9F)</code>
before accessing the device.</p>
</li>
<li>
<p>Call <code>pm_idle_component(9F)</code> when finished accessing the
device.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The USBA 2.0 framework supports four power levels as specified by the
USB interface power management specification. See
<code>/usr/include/sys/usb/usbai.h</code> for information on mapping USB power
levels to operating system power levels.</p>
</div>
<div class="paragraph">
<p>The <code>hubd</code> driver suspends the port when the device goes to the
<code>USB_DEV_OS_PWR_OFF</code> state. The <code>hubd</code> driver resumes
the port when the device goes to the <code>USB_DEV_OS_PWR_1</code>
state and above. Note that port suspend is different from system
suspend. In port suspend, only the USB port is shut off. System suspend
is defined in <a href="#system-power-management">System Power Management</a>.</p>
</div>
<div class="paragraph">
<p>The client driver might choose to enable
remote wakeup on the device. See the
<code>usb_handle_remote_wakeup(9F)</code> man page. When the <code>hubd</code>
driver sees a remote wakeup on a port, the <code>hubd</code> driver completes the
wakeup operation and calls <code>pm_raise_power(9F)</code> to notify the
child.</p>
</div>
<div class="paragraph">
<p>The following figure shows the relationship between the different pieces
of power management.</p>
</div>
<div id="euxbo" class="imageblock">
<div class="content">
<img src="figures/usb-pwr-mgmt.png" alt="Diagram shows when to employ two different power management schemes.">
</div>
<div class="title">Figure 21. USB Power Management</div>
</div>
<div class="paragraph">
<p>The driver can implement one of the two power management schemes
described at the bottom of <a href="#euxbo">USB Power Management</a>. The
passive scheme is simpler than the active scheme because the passive
scheme does not do power management during device transfers.</p>
</div>
<div class="sect5">
<h6 id="ewavf"><a class="anchor" href="#ewavf"></a>Active Power Management</h6>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>section describes the functions you need to use to implement the active
power management scheme.</p>
</div>
<div class="paragraph">
<p>Do the following work in the <code>attach(9E)</code> entry point for your driver:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>usb_create_pm_components(9F)</code>.</p>
</li>
<li>
<p>Optionally call <code>usb_handle_remote_wakeup(9F)</code> with
<code>USB_REMOTE_WAKEUP_ENABLE</code> as the second argument to enable
a remote wakeup on the device.</p>
</li>
<li>
<p>Call <code>pm_busy_component(9F)</code>.</p>
</li>
<li>
<p>Call <code>pm_raise_power(9F)</code> to take power to the
<code>USB_DEV_OS_FULL_PWR</code> level.</p>
</li>
<li>
<p>Communicate with the device to initialize the device.</p>
</li>
<li>
<p>Call <code>pm_idle_component(9F)</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Do the following work in the <code>detach(9E)</code> entry point for your driver:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>pm_busy_component(9F)</code>.</p>
</li>
<li>
<p>Call <code>pm_raise_power(9F)</code> to take power to the
<code>USB_DEV_OS_FULL_PWR</code> level.</p>
</li>
<li>
<p>If you called the <code>usb_handle_remote_wakeup(9F)</code> function
in your <code>attach(9E)</code> entry point, call
<code>usb_handle_remote_wakeup(9F)</code> here with
<code>USB_REMOTE_WAKEUP_DISABLE</code> as the second argument.</p>
</li>
<li>
<p>Communicate with the device to cleanly shut down the device.</p>
</li>
<li>
<p>Call <code>pm_lower_power(9F)</code> to take power to the
<code>USB_DEV_OS_PWR_OFF</code> level.</p>
<div class="paragraph">
<p>This is the only time a client driver calls
<code>pm_lower_power(9F)</code>.</p>
</div>
</li>
<li>
<p>Call <code>pm_idle_component(9F)</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When a driver thread wants to start I/O to the device, that thread does
the following tasks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>pm_busy_component(9F)</code>.</p>
</li>
<li>
<p>Call <code>pm_raise_power(9F)</code> to take power to the
<code>USB_DEV_OS_FULL_PWR</code> level.</p>
</li>
<li>
<p>Begin the I/O transfer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The driver calls <code>pm_idle_component(9F)</code> when the driver
receives notice that an I/O transfer has completed.</p>
</div>
<div class="paragraph">
<p>In the <code>power(9E)</code> entry
point for your driver, check whether the power level to which you are
transitioning is valid. You might also need to account for different
threads calling into <code>power(9E)</code> at the same time.</p>
</div>
<div class="paragraph">
<p>The <code>power(9E)</code> routine might be called to take the device to the
<code>USB_DEV_OS_PWR_OFF</code> state if the device has been idle
for some time or the system is shutting down. This state corresponds to
the <code>PWRED_DWN</code> state shown in <a href="#euxbq">USB Device State
Machine</a>. If the device is going to the
<code>USB_DEV_OS_PWR_OFF</code> state, do the following work in
your <code>power(9E)</code> routine:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Put all open pipes into the idle state. For example, stop polling on
the interrupt pipe.</p>
</li>
<li>
<p>Save any device or driver context that needs to be saved.</p>
<div class="paragraph">
<p>The port to which the device is connected is suspended after the call to
<code>power(9E)</code> completes.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>power(9E)</code> routine might be called to power on the device when
either a device-initiated remote wakeup or a system-initiated wakeup is
received. Wakeup notices occur after the device has been powered down
due to extended idle time or system suspend. If the device is going to
the <code>USB_DEV_OS_PWR_1</code> state or above, do the following
work in your <code>power(9E)</code> routine:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Restore any needed device and driver context.</p>
</li>
<li>
<p>Restart activity on the pipe that is appropriate to the specified
power level. For example, start polling on the interrupt pipe.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the port to which the device is connected was previously suspended,
that port is resumed before <code>power(9E)</code> is called.</p>
</div>
</div>
<div class="sect5">
<h6 id="ewavb"><a class="anchor" href="#ewavb"></a>Passive Power Management</h6>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>The passive power management scheme is simpler than the active power
management scheme described above. In this passive scheme, no power
management is done during transfers. To implement this passive scheme,
call <code>pm_busy_component(9F)</code> and <code>pm_raise_power(9F)</code>
when you open the device. Then call <code>pm_idle_component(9F)</code> when
you close the device.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="system-power-management-1"><a class="anchor" href="#system-power-management-1"></a>System Power Management</h5>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>power management</p>
</div>
<div class="paragraph">
<p>system power management</p>
</div>
<div class="paragraph">
<p>USB devices</p>
</div>
<div class="paragraph">
<p>CPR (CheckPoint and Resume)</p>
</div>
<div class="paragraph">
<p>system power management</p>
</div>
<div class="paragraph">
<p>system power management</p>
</div>
<div class="paragraph">
<p>system power management</p>
</div>
<div class="paragraph">
<p>system power management</p>
</div>
<div class="paragraph">
<p>System power management consists of turning off the entire system after
saving its state, and restoring the state after the system is turned
back on. This process is called <em>CPR</em> (checkpoint and resume). USB
client drivers operate the same way that other client drivers operate
with respect to CPR. To suspend a device, the driver&#8217;s <code>detach(9E)</code>
entry point is called with a &lt;cmd&gt; argument of
<code>DDI_SUSPEND</code>. To resume a device, the driver&#8217;s <code>attach(9E)</code> entry
point is called with a &lt;cmd&gt; argument of <code>DDI_RESUME</code>. When
you handle the <code>DDI_SUSPEND</code> command in your <code>detach(9E)</code> routine,
clean up device state and clean up driver state as much as necessary for
a clean resume later. (Note that this corresponds to the <code>SUSPENDED</code>
state in <a href="#euxbq">USB Device State Machine</a>.) When you handle the
<code>DDI_RESUME</code> command in your <code>attach(9E)</code> routine, always take the
device to full power to put the system in sync with the device.</p>
</div>
<div class="paragraph">
<p>For USB devices, suspend and resume are handled similarly to a hotplug
disconnect and reconnect (see <a href="#hotplugging-usb-devices">Hotplugging USB Devices</a>). An
important difference between CPR and hotplugging is that with CPR the
driver can fail the checkpoint process if the device is not in a state
from which it can be suspended. For example, the device cannot be
suspended if the device has an error recovery in progress. The device
also cannot be suspended if the device is busy and cannot be stopped
safely.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="serialization"><a class="anchor" href="#serialization"></a>3.46.3. Serialization</h4>
<div class="paragraph">
<p>In general, a driver should not call USBA functions while the driver is
holding a mutex. Therefore, race conditions in a client driver can be
difficult to prevent.</p>
</div>
<div class="paragraph">
<p>Do not allow normal operational code to run simultaneously with the
processing of asynchronous events such as a disconnect or CPR. These
types of asynchronous events normally clean up and dismantle pipes and
could disrupt the normal operational code.</p>
</div>
<div class="paragraph">
<p>One way to manage race conditions and protect normal operational code is
to write a serialization facility that can acquire and release an
exclusive-access synchronization object. You can write the serialization
facility in such a way that the synchronization object is safe to hold
through calls to USBA functions. The <code>usbskel</code> sample driver
demonstrates this technique. See <a href="#sample-usb-device-driver">Sample USB Device Driver</a>
for information on the <code>usbskel</code> driver.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="utility-functions"><a class="anchor" href="#utility-functions"></a>3.47. Utility Functions</h3>
<div class="paragraph">
<p>This section describes several functions that are of general use.</p>
</div>
<div class="sect3">
<h4 id="device-configuration-facilities"><a class="anchor" href="#device-configuration-facilities"></a>3.47.1. Device Configuration Facilities</h4>
<div class="paragraph">
<p>This section describes functions related to device configuration.</p>
</div>
<div class="sect4">
<h5 id="getting-interface-numbers"><a class="anchor" href="#getting-interface-numbers"></a>Getting Interface Numbers</h5>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>usb_mid</p>
</div>
<div class="paragraph">
<p>USB multi-interface driver</p>
</div>
<div class="paragraph">
<p>interface number</p>
</div>
<div class="paragraph">
<p>USB device</p>
</div>
<div class="paragraph">
<p>interface number</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_if_number</p>
</div>
<div class="paragraph">
<p>If you are using a multiple-interface device where the <code>usb_mid(4D)</code>
driver is making only one of its interfaces available to the calling
driver, you might need to know the number of the interface to which the
calling driver is bound. Use the <code>usb_get_if_number(9F)</code>
function to do any of the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Return the number of the interface to which the calling driver is
bound. The <code>usb_get_if_number(9F)</code> function returns an
interface number greater than zero in this case.</p>
</li>
<li>
<p>Discover that the calling driver manages an entire multi-interface
device. The driver is bound at the device level so that <code>usb_mid</code>
has not split it. The <code>usb_get_if_number(9F)</code> function
returns <code>USB_DEVICE_NODE</code> in this case.</p>
</li>
<li>
<p>Discover that the calling driver manages an entire device by managing
the only interface that device offers in its current configuration. The
<code>usb_get_if_number(9F)</code> function returns
<code>USB_COMBINED_NODE</code> in this case.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="managing-entire-devices"><a class="anchor" href="#managing-entire-devices"></a>Managing Entire Devices</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_owns_device</p>
</div>
<div class="paragraph">
<p>If a driver manages an entire composite
device, that driver can bind to the entire device by using a compatible
name that contains vendor ID, product ID, and revision ID. A driver that
is bound to an entire composite device must manage all the interfaces of
that device as a nexus driver would. In general, you should not bind
your driver to an entire composite device. Instead, you should use the
generic multiple-interface driver <code>usb_mid(4D)</code>.</p>
</div>
<div class="paragraph">
<p>Use the <code>usb_owns_device(9F)</code> function to determine whether a
driver owns an entire device. The device might be a composite device.
The <code>usb_owns_device(9F)</code> function returns <code>TRUE</code> if the driver
owns the entire device.</p>
</div>
</div>
<div class="sect4">
<h5 id="multiple-configuration-devices"><a class="anchor" href="#multiple-configuration-devices"></a>Multiple-Configuration Devices</h5>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>set configuration</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_cfg</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>cfgadm_usb</p>
</div>
<div class="paragraph">
<p>cfgadm_usb</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_set_cfg</p>
</div>
<div class="paragraph">
<p>USB devices make only a single configuration available to the host at
any particular time. Most devices support only a single configuration.
However, a few USB devices support multiple configurations.</p>
</div>
<div class="paragraph">
<p>Any device that has multiple
configurations is placed into the first configuration for which a driver
is available. When seeking a match, device configurations are considered
in numeric order. If no matching driver is found, the device is set to
the first configuration. In this case, the <code>usb_mid</code> driver takes
over the device and splits the device into interface nodes. Use the
<code>usb_get_cfg(9F)</code> function to return the current configuration
of a device.</p>
</div>
<div class="paragraph">
<p>You can use either of the following two methods to request a different
configuration. Using either of these two methods to modify the device
configuration ensures that the USBA module remains in sync with the
device.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>cfgadm_usb(8)</code> command.</p>
</li>
<li>
<p>Call the <code>usb_set_cfg(9F)</code> function from the driver.</p>
<div class="paragraph">
<p>Because changing device configuration affects an entire device, the
client driver must meet all of the following criteria to call the
<code>usb_set_cfg(9F)</code> function successfully:
<strong> The client driver must own the entire device.
</strong> The device must have no child nodes, because other drivers could
drive the device through them.
<strong> All pipes except the default pipe must be closed.
</strong> The device must have multiple configurations.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Do not change the device configuration by doing a
<code>SET_CONFIGURATION</code> USB request manually. Using a
<code>SET_CONFIGURATION</code> request to change the configuration is not
supported.
===
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="modifying-or-getting-the-alternate-setting"><a class="anchor" href="#modifying-or-getting-the-alternate-setting"></a>Modifying or Getting the Alternate Setting</h5>
<div class="paragraph">
<p>USB drivers</p>
</div>
<div class="paragraph">
<p>set alternate</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_set_alt_if</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_alt_if</p>
</div>
<div class="paragraph">
<p>alternate setting</p>
</div>
<div class="paragraph">
<p>A client driver can call the <code>usb_set_alt_if(9F)</code> function
to change the selected alternate setting of the currently selected
interface. Be sure to close all pipes that were opened explicitly. When
switching alternate settings, the <code>usb_set_alt_if(9F)</code>
function verifies that only the default pipe is open. Be sure the device
is settled before you call <code>usb_set_alt_if(9F)</code>.</p>
</div>
<div class="paragraph">
<p>Changing the alternate setting can affect which endpoints and which
class-specific and vendor-specific descriptors are available to the
driver. See <a href="#the-descriptor-tree">The Descriptor Tree</a> for more information about
endpoints and descriptors.</p>
</div>
<div class="paragraph">
<p>Call the <code>usb_get_alt_if(9F)</code> function to retrieve the
number of the current alternate setting.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you request a new alternate setting, a new configuration, or a new
interface, all pipes except the default pipe to the device must be
closed. This is because changing an alternate setting, a configuration,
or an interface changes the mode of operation of the device. Also,
changing an alternate setting, a configuration, or an interface changes
the device&#8217;s presentation to the system.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="other-utility-functions"><a class="anchor" href="#other-utility-functions"></a>3.47.2. Other Utility Functions</h4>
<div class="paragraph">
<p>This section describes other functions that are useful in USB device
drivers.</p>
</div>
<div class="sect4">
<h5 id="retrieving-a-string-descriptor"><a class="anchor" href="#retrieving-a-string-descriptor"></a>Retrieving a String Descriptor</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_string_descr</p>
</div>
<div class="paragraph">
<p>Call the <code>usb_get_string_descr(9F)</code> function to retrieve a
string descriptor given its index. Some configuration, interface, or
device descriptors have string IDs associated with them. Such
descriptors contain string index fields with nonzero values. Pass a
string index field value to the <code>usb_get_string_descr(9F)</code>
to retrieve the corresponding string.</p>
</div>
</div>
<div class="sect4">
<h5 id="pipe-private-data-facility"><a class="anchor" href="#pipe-private-data-facility"></a>Pipe Private Data Facility</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_get_private</p>
</div>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_pipe_set_private</p>
</div>
<div class="paragraph">
<p>Each pipe has one pointer of space set aside for the client driver&#8217;s
private use. Use the <code>usb_pipe_set_private(9F)</code> function to
install a value. Use the <code>usb_pipe_get_private(9F)</code> function
to retrieve the value. This facility is useful in callbacks, when pipes
might need to bring their own client-defined state to the callback for
specific processing.</p>
</div>
</div>
<div class="sect4">
<h5 id="clearing-a-usb-condition"><a class="anchor" href="#clearing-a-usb-condition"></a>Clearing a USB Condition</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_clr_feature</p>
</div>
<div class="paragraph">
<p>Use the <code>usb_clr_feature(9F)</code> function to do the following
tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Issue a USB <code>CLEAR_FEATURE</code> request to clear a halt condition on
an endpoint.</p>
</li>
<li>
<p>Clear a remote wakeup condition on a device.</p>
</li>
<li>
<p>Clear a device-specific condition at a device, interface, or endpoint
level.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="getting-device-interface-or-endpoint-status"><a class="anchor" href="#getting-device-interface-or-endpoint-status"></a>Getting Device, Interface, or Endpoint Status</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_status</p>
</div>
<div class="paragraph">
<p>Use the <code>usb_get_status(9F)</code> function to issue a USB
<code>GET_STATUS</code> request to retrieve the status of a device, interface,
or endpoint.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Device status</strong>. Self-powered and remote-wakeup-enabled.</p>
</li>
<li>
<p><strong>Interface status</strong>. Returns zero, per USB 2.0 specification.</p>
</li>
<li>
<p><strong>Endpoint status</strong>. Endpoint halted. This status indicates a functional
stall. A halt must be cleared before the device can operate again.</p>
<div class="paragraph">
<p>A protocol stall indicates that an unsupported control pipe request has
been made. A protocol stall is cleared automatically at the beginning of
the next control transfer.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="getting-the-bus-address-of-a-device"><a class="anchor" href="#getting-the-bus-address-of-a-device"></a>Getting the Bus Address of a Device</h5>
<div class="paragraph">
<p>USB functions</p>
</div>
<div class="paragraph">
<p>usb_get_addr</p>
</div>
<div class="paragraph">
<p>Use the <code>usb_get_addr(9F)</code> function to get the USB bus address
of a device for debugging purposes. This address maps to a particular
USB port.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sample-usb-device-driver"><a class="anchor" href="#sample-usb-device-driver"></a>3.48. Sample USB Device Driver</h3>
<div class="paragraph">
<p>This section describes a template USB device driver that uses the
USBA 2.0 framework for the illumos environment. This driver demonstrates
many of the features discussed in this chapter. This template or
skeleton driver is named <code>usbskel</code>.</p>
</div>
<div class="paragraph">
<p>The <code>usbskel</code> driver is a template that you can use to start your own
USB device driver. The <code>usbskel</code> driver demonstrates the following
features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reading the raw configuration data of a device. Every USB device needs
to be able to report device raw configuration data.</p>
</li>
<li>
<p>Managing pipes. The <code>usbskel</code> driver opens an interrupt pipe to show
how to manage pipes.</p>
</li>
<li>
<p>Polling. Comments in the <code>usbskel</code> driver discuss how to do polling.</p>
</li>
<li>
<p>USB version management and registration.</p>
</li>
<li>
<p>USB logging.</p>
</li>
<li>
<p>Accommodations for USB hotplugging.</p>
</li>
<li>
<p>Accommodations for illumos suspend and resume.</p>
</li>
<li>
<p>Accommodations for power management.</p>
</li>
<li>
<p>USB serialization.</p>
</li>
<li>
<p>Use of USB callbacks.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This <code>usbskel</code> driver is available on Sun&#8217;s web site at
<a href="http://www.sun.com/bigadmin/software/usbskel/" class="bare">http://www.sun.com/bigadmin/software/usbskel/</a>.</p>
</div>
<div class="paragraph">
<p>For source for additional USB drivers, see the illumos web site. Go to
<a href="http://src.illumos.org/" class="bare">http://src.illumos.org/</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_a_device_driver"><a class="anchor" href="#_building_a_device_driver"></a>4. Building a Device Driver</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The third part of this book provides advice on building device drivers
for the illumos Operating illumos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#compiling-loading-packaging-and-testing-drivers">Compiling&#44; Loading&#44; Packaging&#44; and
Testing Drivers</a> provides information on compiling, linking, and
installing a driver.</p>
</li>
<li>
<p><a href="#debugging-testing-and-tuning-device-drivers">Debugging&#44; Testing&#44; and Tuning Device Drivers</a>
describes techniques for debugging, testing, and tuning drivers.</p>
</li>
<li>
<p><a href="#recommended-coding-practices">Recommended Coding Practices</a> describes the
recommended coding practices for writing drivers.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="compiling-loading-packaging-and-testing-drivers"><a class="anchor" href="#compiling-loading-packaging-and-testing-drivers"></a>4.1. Compiling, Loading, Packaging, and Testing Drivers</h3>
<div class="paragraph">
<p>This chapter describes the procedure for driver development, including
code layout, compilation, packaging, and testing.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#driver-code-layout">Driver Code Layout</a></p>
</li>
<li>
<p><a href="#preparing-for-driver-installation">Preparing for Driver Installation</a></p>
</li>
<li>
<p><a href="#installing-updating-and-removing-drivers">Installing&#44; Updating&#44; and Removing
Drivers</a></p>
</li>
<li>
<p><a href="#loading-and-unloading-drivers">Loading and Unloading Drivers</a></p>
</li>
<li>
<p><a href="#driver-packaging">Driver Packaging</a></p>
</li>
<li>
<p><a href="#criteria-for-testing-drivers">Criteria for Testing Drivers</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="driver-development-summary"><a class="anchor" href="#driver-development-summary"></a>4.2. Driver Development Summary</h3>
<div class="paragraph">
<p>This chapter and the following two chapters,
<a href="#debugging-testing-and-tuning-device-drivers">Debugging&#44; Testing&#44; and Tuning Device Drivers</a>
and <a href="#recommended-coding-practices">Recommended Coding Practices</a>, provide
detailed information on developing a device driver.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Write, compile, and link the new code.</p>
<div class="paragraph">
<p>See <a href="#driver-code-layout">Driver Code Layout</a> for the conventions on naming
files. Use a C compiler to compile the driver. Link the driver using
<code>ld(1)</code>. See <a href="#compiling-and-linking-the-driver">Compiling and Linking the Driver</a> and
<a href="#module-dependencies">Module Dependencies</a>.</p>
</div>
</li>
<li>
<p>Create the necessary hardware configuration files.</p>
<div class="paragraph">
<p>Create a hardware configuration file unique to the device called
<em>xx</em>`.conf` where <em>xx</em> is the prefix for the device. This file is used
to update the <code>driver.conf(5)</code> file. See <a href="#writing-a-hardware-configuration-file">Writing a
Hardware Configuration File</a>. For a pseudo device driver, create a
<code>pseudo(5)</code> file.</p>
</div>
</li>
<li>
<p>Copy the driver to the appropriate module directory.</p>
<div class="paragraph">
<p>See <a href="#copying-the-driver-to-a-module-directory">Copying the Driver to a Module Directory</a>.</p>
</div>
</li>
<li>
<p>Install the device driver using <code>add_drv(8)</code>.</p>
<div class="paragraph">
<p>Installing the driver with <code>add_drv</code> is usually done as part of a
postinstall script. See <a href="#installing-drivers-with-add_drv">Installing Drivers with </a>. Use
the <code>update_drv(8)</code> command to make any changes to the driver. See
<a href="#updating-driver-information">Updating Driver Information</a>.</p>
</div>
</li>
<li>
<p>Load the driver.</p>
<div class="paragraph">
<p>The driver can be loaded automatically by accessing the device. See
<a href="#loading-and-unloading-drivers">Loading and Unloading Drivers</a> and
<a href="#package-postinstall">Package Postinstall</a>. Drivers can also be loaded by
using the <code>modload(8)</code> command. The <code>modload</code> command does not call any
routines in the module and therefore is useful for testing. See
<a href="#loading-and-unloading-test-modules">Loading and Unloading Test Modules</a>.</p>
</div>
</li>
<li>
<p>Test the driver.</p>
<div class="paragraph">
<p>Drivers should be rigorously tested in the following areas:
* <a href="#configuration-testing">Configuration Testing</a>
* <a href="#functionality-testing">Functionality Testing</a>
* <a href="#error-handling">Error Handling</a>
* <a href="#testing-loading-and-unloading">Testing Loading and Unloading</a>
* <a href="#stress-performance-and-interoperability-testing">Stress&#44; Performance&#44; and Interoperability
Testing</a>
* <a href="#ddidki-compliance-testing">DDI/DKI Compliance Testing</a>
* <a href="#installation-and-packaging-testing">Installation and Packaging Testing</a></p>
</div>
<div class="paragraph">
<p>+
For additional driver-specific testing, see <a href="#testing-specific-types-of-drivers">Testing
Specific Types of Drivers</a>.</p>
</div>
</li>
<li>
<p>Remove the driver if necessary.</p>
<div class="paragraph">
<p>Use the <code>rem_drv(8)</code> command to remove a device driver. See
<a href="#removing-the-driver">Removing the Driver</a> and <a href="#package-preremove">Package
Preremove</a>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="driver-code-layout"><a class="anchor" href="#driver-code-layout"></a>4.3. Driver Code Layout</h3>
<div class="ulist">
<ul>
<li>
<p>Header files (<code>.h</code> files)</p>
</li>
<li>
<p>Source files (<code>.c</code> files)</p>
</li>
<li>
<p>Optional configuration file (<code>driver.conf</code> file)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="header-files"><a class="anchor" href="#header-files"></a>4.3.1. Header Files</h4>
<div class="ulist">
<ul>
<li>
<p>Data structures specific to the device, such as a structure
representing the device registers</p>
</li>
<li>
<p>Data structures defined by the driver for maintaining state
information</p>
</li>
<li>
<p>Defined constants, such as those representing the bits of the device
registers</p>
</li>
<li>
<p>Macros, such as those defining the static mapping between the minor
device number and the instance number</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some of the header file definitions, such as the state structure, might
be needed only by the device driver. This information should go in
<em>private</em> header files that are only included by the device driver
itself.</p>
</div>
<div class="paragraph">
<p>Any information that an application might require, such as the I/O
control commands, should be in <em>public</em> header files. These files are
included by the driver and by any applications that need information
about the device.</p>
</div>
<div class="paragraph">
<p>While there is no standard for naming private and public files, one
convention is to name the private header file <code>xximpl.h</code> and the public
header file <code>xxio.h</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="source-files"><a class="anchor" href="#source-files"></a>4.3.2. Source Files</h4>
<div class="ulist">
<ul>
<li>
<p>Contains the data declarations and the code for the entry points of
the driver</p>
</li>
<li>
<p>Contains the <code>#include</code> statements that are needed by the driver</p>
</li>
<li>
<p>Declares <code>extern</code> references</p>
</li>
<li>
<p>Declares local data</p>
</li>
<li>
<p>Sets up the <code>cb_ops</code> and <code>dev_ops</code> structures</p>
</li>
<li>
<p>Declares and initializes the module configuration section, that is,
the <code>modlinkage(9S)</code> and <code>modldrv(9S)</code> structures</p>
</li>
<li>
<p>Makes any other necessary declarations</p>
</li>
<li>
<p>Defines the driver entry points</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="configuration-files"><a class="anchor" href="#configuration-files"></a>4.3.3. Configuration Files</h4>
<div class="paragraph">
<p>In general, the configuration file for a
driver defines all of the properties that the driver needs. Entries in
the driver configuration file specify possible device instances that the
driver can probe for existence. Driver global properties can be set in
the driver&#8217;s configuration file. See the <code>driver.conf(5)</code> man page for
more information.</p>
</div>
<div class="paragraph">
<p>Driver configuration files are required for devices that are not
self-identifying.</p>
</div>
<div class="paragraph">
<p>Driver configuration files are optional for self-identifying devices
(SID). For self-identifying devices, the configuration file can be used
to add properties into SID nodes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Drivers that use the SBus peripheral bus generally get property
information from the SBus card. In cases where additional properties are
needed, the driver configuration file can contain properties that are
defined by <code>sbus(5)</code>.</p>
</li>
<li>
<p>The properties of a PCI bus can generally be derived from the PCI
configuration space. In cases where private driver properties are
needed, the driver configuration file can contain properties that are
defined by <code>pci(5)</code>.</p>
</li>
<li>
<p>Drivers on the ISA bus can use additional properties that are defined
by <code>isa(5)</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="preparing-for-driver-installation"><a class="anchor" href="#preparing-for-driver-installation"></a>4.4. Preparing for Driver Installation</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compile the driver.</p>
</li>
<li>
<p>Create a configuration file if necessary.</p>
</li>
<li>
<p>Identify the driver module to the system through either of the
following alternatives:</p>
<div class="ulist">
<ul>
<li>
<p>Match the driver&#8217;s name to the name of the device node.</p>
</li>
<li>
<p>Use either <code>add_drv(8)</code> or <code>update_drv(8)</code> to inform the
system of the module names.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The system maintains a one-to-one association between the name of the
driver module and the name of the <code>dev_info</code> node. For example,
consider a <code>dev_info</code> node for a device that is named <code>mydevice</code>.
The device <code>mydevice</code> is handled by a driver module that is also named
<code>mydevice</code>. The <code>mydevice</code> module resides in a subdirectory that is
called <code>drv</code>, which is in the module path. The module is in
<code>drv/mydevice</code> if you are using a 32-bit kernel. The module is in
<code>drv/sparcv9/mydevice</code> if you are using a 64-bit SPARC kernel. The
module is in <code>drv/amd64/mydevice</code> if you are using a 64-bit x86 kernel.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only alphanumeric characters (a-z, A-Z, 0-9), plus the underbar
('_'), are allowed.</p>
</li>
<li>
<p>Neither the first nor the last character of the name can be a digit.</p>
</li>
<li>
<p>The name cannot exceed 16 characters in length. Names in the range of
3-8 characters in length are preferable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the driver must manage <code>dev_info</code> nodes with different names, the
<code>add_drv(8)</code> utility can create aliases. The <code>-i</code> flag specifies the
names of other <code>dev_info</code> nodes that the driver handles. The
<code>update_drv</code> command can also modify aliases for an installed device
driver.</p>
</div>
<div class="sect3">
<h4 id="compiling-and-linking-the-driver"><a class="anchor" href="#compiling-and-linking-the-driver"></a>4.4.1. Compiling and Linking the Driver</h4>
<div class="paragraph">
<p>compiling drivers</p>
</div>
<div class="paragraph">
<p>linking drivers</p>
</div>
<div class="paragraph">
<p>loading drivers</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>compiling drivers</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>linking drivers</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>loading drivers</p>
</div>
<div class="paragraph">
<p>Sun Studio</p>
</div>
<div class="paragraph">
<p>You need to compile each driver source file and link the resulting
object files into a driver module. illumos is compatible with both the
Sun Studio C compiler and the GNU C compiler from the Free Software
Foundation, Inc. The examples in this section use the Sun Studio C
compiler unless otherwise noted. For information on the Sun Studio C
compiler, see the Sun Studio 12: C User’s Guide and the
<a href="http://developers.sun.com/sunstudio/documentation/">Sun Studio
Documentation</a> on the Sun Developer Network web site. For more
information on compile and link options, see the Sun Studio Man Pages.
The GNU C compiler is supplied in the <code>/usr/sfw</code> directory. For
information on the GNU C compiler, see <a href="http://gcc.gnu.org/" class="bare">http://gcc.gnu.org/</a> or check the
man pages in <code>/usr/sfw/man</code>.</p>
</div>
<div class="paragraph">
<p>The example below shows a driver that is called &lt;xx&gt; with two C
source files. A driver module that is called &lt;xx&gt; is generated.
The driver that is created in this example is for a 32-bit kernel. You
must use <code>ld</code> <code>r</code> even if your driver has only one object module.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -D_KERNEL -c xx1.c
% cc -D_KERNEL -c xx2.c
% ld -r -o xx xx1.o xx2.o</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>_KERNEL</code> symbol
must be defined to indicate that this code defines a kernel module. No
other symbols should be defined, except for driver private symbols. The
<code>DEBUG</code> symbol can be defined to enable any calls to <code>ASSERT(9F)</code>.</p>
</div>
<div class="paragraph">
<p>If you are compiling for a 64-bit SPARC architecture using Sun Studio 9,
Sun Studio 10, or Sun Studio 11, use the <code>xarch=v9</code> option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -D_KERNEL -xarch=v9 -c xx.c</pre>
</div>
</div>
<div class="paragraph">
<p>If you are compiling for a 64-bit SPARC architecture using Sun Studio
12, use the <code>m64</code> option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -D_KERNEL -m64 -c xx.c</pre>
</div>
</div>
<div class="paragraph">
<p>If you are compiling for a 64-bit x86 architecture using Sun Studio 10
or Sun Studio 11, use both the <code>xarch=amd64</code> option and the
<code>xmodel=kernel</code> option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -D_KERNEL -xarch=amd64 -xmodel=kernel -c xx.c</pre>
</div>
</div>
<div class="paragraph">
<p>If you are compiling for a 64-bit x86 architecture using Sun Studio 12,
use the <code>m64</code> option, the <code>xarch=sse2a</code> option, and the <code>xmodel=kernel</code>
option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cc -D_KERNEL -m64 -xarch=sse2a -xmodel=kernel -c xx.c</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sun Studio 9 does not support 64-bit x86 architectures. Use Sun Studio
10, Sun Studio 11, or Sun Studio 12 to compile and debug drivers for
64-bit x86 architectures.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After the driver is stable, you might want to add optimization flags to
build a production quality driver. See the <code>cc</code>(1) man page in Sun
Studio Man Pages for specific information on optimizations in the Sun
Studio C compiler.</p>
</div>
<div class="paragraph">
<p>Global variables should be treated as <code>volatile</code> in device drivers. The
<code>volatile</code> tag is discussed in greater detail in
<a href="#declaring-a-variable-volatile">Declaring a Variable Volatile</a>. Use of the flag
depends on the platform. See the man pages.</p>
</div>
</div>
<div class="sect3">
<h4 id="module-dependencies"><a class="anchor" href="#module-dependencies"></a>4.4.2. Module Dependencies</h4>
<div class="paragraph">
<p>If the driver module depends on symbols exported by another kernel
module, the dependency can be specified by the <code>dy</code> and <code>N</code> options of
the loader, <code>ld(1)</code>. If the driver depends on a symbol exported by
<code>misc/mySymbol</code>, the example below should be used to create the driver
binary.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% ld -dy -r -o xx xx1.o xx2.o -N misc/mySymbol</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-a-hardware-configuration-file"><a class="anchor" href="#writing-a-hardware-configuration-file"></a>4.4.3. Writing a Hardware Configuration File</h4>
<div class="paragraph">
<p>If a device
is non-self-identifying, the kernel might require a hardware
configuration file for that device. If the driver is called
&lt;xx&gt;, the hardware configuration file for the driver should be
called &lt;xx&gt;<code>.conf</code>.</p>
</div>
<div class="paragraph">
<p>On the x86 platform, device information is now supplied by the booting
system. Hardware configuration files should no longer be needed, even
for non-self-identifying devices.</p>
</div>
<div class="paragraph">
<p>See the <code>driver.conf(5)</code>, <code>pseudo(5)</code>, <code>sbus(5)</code>,
<code>scsi_free_consistent_buf(9F)</code>, and <code>update_drv(8)</code> man
pages for more information on hardware configuration files.</p>
</div>
<div class="paragraph">
<p>Arbitrary properties can be defined in hardware configuration files.
Entries in the configuration file are in the form
&lt;property&gt;=&lt;value&gt;, where &lt;property&gt; is the
property name and &lt;value&gt; is its initial value. The
configuration file approach enables devices to be configured by changing
the property values.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="installing-updating-and-removing-drivers"><a class="anchor" href="#installing-updating-and-removing-drivers"></a>4.5. Installing, Updating, and Removing Drivers</h3>
<div class="paragraph">
<p>Before a driver can be used, the system must be informed that the driver
exists. The <code>add_drv(8)</code> utility must be used to correctly install
the device driver. After a driver is installed, that driver can be
loaded and unloaded from memory without using the <code>add_drv</code> command.</p>
</div>
<div class="sect3">
<h4 id="copying-the-driver-to-a-module-directory"><a class="anchor" href="#copying-the-driver-to-a-module-directory"></a>4.5.1. Copying the Driver to a Module Directory</h4>
<div class="paragraph">
<p>loading modules</p>
</div>
<div class="paragraph">
<p>module directory</p>
</div>
<div class="paragraph">
<p>module directory</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The platform that the driver runs on</p>
</li>
<li>
<p>The architecture for which the driver is compiled</p>
</li>
<li>
<p>Whether the path is needed at boot time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Device drivers reside in the following locations:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>/platform/`uname -i``</code>/kernel/drv`</dt>
<dd>
<p>Contains 32-bit drivers that run only on a specific platform.</p>
</dd>
<dt class="hdlist1"><code>/platform/`uname -i``</code>/kernel/drv/sparcv9`</dt>
<dd>
<p>Contains 64-bit drivers that run only on a specific SPARC-based
platform.</p>
</dd>
<dt class="hdlist1"><code>/platform/`uname -i``</code>/kernel/drv/amd64`</dt>
<dd>
<p>Contains 64-bit drivers that run only on a specific x86-based
platform.</p>
</dd>
<dt class="hdlist1"><code>/platform/`uname -m``</code>/kernel/drv`</dt>
<dd>
<p>Contains 32-bit drivers that run only on a specific family of
platforms.</p>
</dd>
<dt class="hdlist1"><code>/platform/`uname -m``</code>/kernel/drv/sparcv9`</dt>
<dd>
<p>Contains 64-bit drivers that run only on a specific family of
SPARC-based platforms.</p>
</dd>
<dt class="hdlist1"><code>/platform/`uname -m``</code>/kernel/drv/amd64`</dt>
<dd>
<p>Contains 64-bit drivers that run only on a specific family of
x86-based platforms.</p>
</dd>
<dt class="hdlist1"><code>/usr/kernel/drv</code></dt>
<dd>
<p>Contains 32-bit drivers that are independent of platforms.</p>
</dd>
<dt class="hdlist1"><code>/usr/kernel/drv/sparcv9</code></dt>
<dd>
<p>Contains 64-bit drivers on SPARC-based systems that are independent of
platforms.</p>
</dd>
<dt class="hdlist1"><code>/usr/kernel/drv/amd64</code></dt>
<dd>
<p>Contains 64-bit drivers on x86-based systems that are independent of
platforms.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To install a 32-bit driver, the driver and its configuration file must
be copied to a <code>drv</code> directory in the module path. For example, to copy
a driver to <code>/usr/kernel/drv</code>, type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su
# cp xx /usr/kernel/drv
# cp xx.conf /usr/kernel/drv</pre>
</div>
</div>
<div class="paragraph">
<p>To install a SPARC driver, copy the driver to a <code>drv/sparcv9</code> directory
in the module path. Copy the driver configuration file to the <code>drv</code>
directory in the module path. For example, to copy a driver to
<code>/usr/kernel/drv</code>, you would type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su
# cp xx /usr/kernel/drv/sparcv9
# cp xx.conf /usr/kernel/drv</pre>
</div>
</div>
<div class="paragraph">
<p>To install a 64-bit x86 driver, copy the driver to a <code>drv/amd64</code>
directory in the module path. Copy the driver configuration file to the
<code>drv</code> directory in the module path. For example, to copy a driver to
<code>/usr/kernel/drv</code>, you would type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ su
# cp xx /usr/kernel/drv/amd64
# cp xx.conf /usr/kernel/drv</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All driver configuration files (<code>.conf</code>
files) must go in the <code>drv</code> directory in the module path. The <code>.conf</code>
files cannot go into any subdirectory of the <code>drv</code> directory.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="installing-drivers-with-add_drv"><a class="anchor" href="#installing-drivers-with-add_drv"></a>4.5.2. Installing Drivers with <code>add_drv</code></h4>
<div class="paragraph">
<p>loading drivers</p>
</div>
<div class="paragraph">
<p>add_drv</p>
</div>
<div class="paragraph">
<p>add_drv</p>
</div>
<div class="paragraph">
<p>Use the <code>add_drv(8)</code> command to install the driver in the system. If
the driver installs successfully, <code>add_drv</code> runs <code>devfsadm(8)</code> to
create the logical names in the <code>/dev</code> directory.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># add_drv xx</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the device identifies itself as &lt;xx&gt;. The device
special files have default ownership and permissions (<code>0600</code> <code>root</code>
<code>sys</code>). The <code>add_drv</code> command also allows additional names for the
device (aliases) to be specified. See the <code>add_drv</code>(1M) man page for
information on adding aliases and setting file permissions explicitly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not use the <code>add_drv</code> command to install a STREAMS module. See
the STREAMS Programming Guide for details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the driver creates minor nodes that do not
represent terminal devices such as disks, tapes, or ports, you can
modify <code>/etc/devlink.tab</code> to cause <code>devfsadm</code> to create logical device
names in <code>/dev</code>. Alternatively, logical names can be created by a
program that is run at driver installation time.</p>
</div>
</div>
<div class="sect3">
<h4 id="updating-driver-information"><a class="anchor" href="#updating-driver-information"></a>4.5.3. Updating Driver Information</h4>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>modifying information with</p>
</div>
<div class="paragraph">
<p>update_drv</p>
</div>
<div class="paragraph">
<p>update_drv</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>modifying permissions</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>minor device node</p>
</div>
<div class="paragraph">
<p>modifying permissions of</p>
</div>
<div class="paragraph">
<p>Use the <code>update_drv(8)</code> command to notify the system of any changes
to an installed device driver. By default, the system re-reads the
driver configuration file and reloads the driver binary module.</p>
</div>
</div>
<div class="sect3">
<h4 id="removing-the-driver"><a class="anchor" href="#removing-the-driver"></a>4.5.4. Removing the Driver</h4>
<div class="paragraph">
<p>To remove a driver from the system, use the <code>rem_drv(8)</code> command,
and then delete the driver module and configuration file from the module
path. A driver cannot be used again until that driver is reinstalled
with <code>add_drv(8)</code>. The removal of a SCSI HBA driver requires a
reboot to take effect.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading-and-unloading-drivers"><a class="anchor" href="#loading-and-unloading-drivers"></a>4.6. Loading and Unloading Drivers</h3>
<div class="paragraph">
<p>Opening a special file (accessing the device) that is associated with a
device driver causes that driver to be loaded. You can use the
<code>modload(8)</code> command to load the driver into memory, but <code>modload</code> does
not call any routines in the module. The preferred method is to open the
device.</p>
</div>
<div class="paragraph">
<p>Normally, the system automatically unloads device drivers when the
device is no longer in use. During development, you might want to use
<code>modunload(8)</code> to unload the driver explicitly. In order for <code>modunload</code>
to be successful, the device driver must be inactive. No outstanding
references to the device should exist, such as through <code>open(2)</code> or
<code>mmap(2)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>modunload</code> command takes a
runtime-dependent <code>module_id</code> as an argument. To find the
<code>module_id</code>, use <code>grep</code> to search the output of <code>modinfo(8)</code> for the
driver name in question. Check in the first column.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># modunload -i module-id</pre>
</div>
</div>
<div class="paragraph">
<p>To unload all currently unloadable modules, specify module ID zero:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># modunload -i 0</pre>
</div>
</div>
<div class="paragraph">
<p>In addition to being inactive, the driver must have working <code>detach(9E)</code>
and <code>_fini(9E)</code> routines for <code>modunload(8)</code> to succeed.</p>
</div>
</div>
<div class="sect2">
<h3 id="driver-packaging"><a class="anchor" href="#driver-packaging"></a>4.7. Driver Packaging</h3>
<div class="paragraph">
<p>The normal delivery vehicle for software
is to create a package that contains all of the software components. A
package provides a controlled mechanism for installation and removal of
all the components of a software product. In addition to the files for
using the product, the package includes control files for installing and
uninstalling the application. The postinstall and preremove installation
scripts are two such control files.</p>
</div>
<div class="sect3">
<h4 id="package-postinstall"><a class="anchor" href="#package-postinstall"></a>4.7.1. Package Postinstall</h4>
<div class="paragraph">
<p>After a package with a driver binary is installed onto a system, the
<code>add_drv(8)</code> command must be run. The <code>add_drv</code> command
completes the installation of the driver. Typically, <code>add_drv</code> is
run in a postinstall script, as in the following example.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/sh
#
#       @(#)postinstall 1.1

PATH="/usr/bin:/usr/sbin:${PATH}"
export PATH

#
# Driver info
#
DRV=&lt;driver-name&gt;
DRVALIAS="&lt;company-name&gt;,&lt;driver-name&gt;"
DRVPERM='* 0666 root sys'

ADD_DRV=/usr/sbin/add_drv

#
# Select the correct add_drv options to execute.
# add_drv touches /reconfigure to cause the
# next boot to be a reconfigure boot.
#
if [ "${BASEDIR}" = "/" ]; then
    #
    # On a running system, modify the
    # system files and attach the driver
    #
    ADD_DRV_FLAGS=""
    #
    # On a client, modify the system files
    # relative to BASEDIR
    #
    ADD_DRV_FLAGS="-b ${BASEDIR}"

#
# Make sure add_drv has not been previously executed
# before attempting to add the driver.
#
grep "^${DRV} " $BASEDIR/etc/name_to_major &gt; /dev/null 2&gt;&amp;1
if [ $? -ne 0 ]; then
    ${ADD_DRV} ${ADD_DRV_FLAGS} -m "${DRVPERM}" -i "${DRVALIAS}" ${DRV}
    if [ $? -ne 0 ]; then
        echo "postinstall: add_drv $DRV failed\n" &gt;&amp;2
        exit 1
exit 0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="package-preremove"><a class="anchor" href="#package-preremove"></a>4.7.2. Package Preremove</h4>
<div class="paragraph">
<p>When removing a package that includes a driver, the <code>rem_drv(8)</code>
command must be run prior to removing the driver binary and other
components. The following example demonstrates a preremove script that
uses the <code>rem_drv</code> command for driver removal.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/sh
#
#       @(#)preremove  1.1

PATH="/usr/bin:/usr/sbin:${PATH}"
export PATH

#
# Driver info
#
DRV=&lt;driver-name&gt;
REM_DRV=/usr/sbin/rem_drv

#
# Select the correct rem_drv options to execute.
# rem_drv touches /reconfigure to cause the
# next boot to be a reconfigure boot.
#
if [ "${BASEDIR}" = "/" ]; then
    #
    # On a running system, modify the
    # system files and remove the driver
    #
    REM_DRV_FLAGS=""
    #
    # On a client, modify the system files
    # relative to BASEDIR
    #
    REM_DRV_FLAGS="-b ${BASEDIR}"

${REM_DRV} ${REM_DRV_FLAGS} ${DRV}

exit 0</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="criteria-for-testing-drivers"><a class="anchor" href="#criteria-for-testing-drivers"></a>4.8. Criteria for Testing Drivers</h3>
<div class="paragraph">
<p>Once a device driver is functional, that
driver should be thoroughly tested prior to distribution. Besides
testing the features in traditional UNIX device drivers, illumos drivers
require testing power management features, such as dynamic loading and
unloading of drivers.</p>
</div>
<div class="sect3">
<h4 id="configuration-testing"><a class="anchor" href="#configuration-testing"></a>4.8.1. Configuration Testing</h4>
<div class="paragraph">
<p>A driver&#8217;s ability to handle multiple device configurations is an
important part of the test process. Once the driver is working on a
simple, or default, configuration, additional configurations should be
tested. Depending on the device, configuration testing can be
accomplished by changing jumpers or DIP switches. If the number of
possible configurations is small, all configurations should be tried. If
the number is large, various classes of possible configurations should
be defined, and a sampling of configurations from each class should be
tested. Defining these classes depends on the potential interactions
among the different configuration parameters. These interactions are a
function of the type of the device and the way in which the driver was
written.</p>
</div>
<div class="paragraph">
<p>For each device configuration, the basic functions must be tested, which
include loading, opening, reading, writing, closing, and unloading the
driver. Any function that depends upon the configuration deserves
special attention. For example, changing the base memory address of
device registers is not likely to affect the behavior of most driver
functions. If a driver works well with one address, that driver is
likely to work as well with a different address. On the other hand, a
special I/O control call might have different effects depending on the
particular device configuration.</p>
</div>
<div class="paragraph">
<p>Loading the driver with varying configurations ensures that the
<code>probe(9E)</code> and <code>attach(9E)</code> entry points can find the device at
different addresses. For basic functional testing, using regular UNIX
commands such as <code>cat(1)</code> or <code>dd(8)</code> is usually sufficient for character
devices. Mounting or booting might be required for block devices.</p>
</div>
</div>
<div class="sect3">
<h4 id="functionality-testing"><a class="anchor" href="#functionality-testing"></a>4.8.2. Functionality Testing</h4>
<div class="paragraph">
<p>After a driver has been completely tested for
configuration, all of the driver&#8217;s functionality should be thoroughly
tested. These tests require exercising the operation of all of the
driver&#8217;s entry points.</p>
</div>
<div class="paragraph">
<p>Many drivers require custom applications to test functionality. However,
basic drivers for devices such as disks, tapes, or asynchronous boards
can be tested using standard system utilities. All entry points should
be tested in this process, including <code>devmap(9E)</code>, <code>chpoll(9E)</code>, and
<code>ioctl(9E)</code>, if applicable. The <code>ioctl</code> tests might be quite different
for each driver. For nonstandard devices, a custom testing application
is generally required.</p>
</div>
</div>
<div class="sect3">
<h4 id="error-handling-1"><a class="anchor" href="#error-handling-1"></a>4.8.3. Error Handling</h4>
<div class="paragraph">
<p>A driver might perform correctly in an
ideal environment but fail in cases of errors, such as erroneous
operations or bad data. Therefore, an important part of driver testing
is the testing of the driver&#8217;s error handling.</p>
</div>
<div class="paragraph">
<p>All possible error conditions of a driver should be exercised, including
error conditions for actual hardware malfunctions. Some hardware error
conditions might be difficult to induce, but an effort should be made to
force or to simulate such errors if possible. All of these conditions
could be encountered in the field. Cables should be removed or be
loosened, boards should be removed, and erroneous user application code
should be written to test those error paths. See also
<a href="#hardening-illumos-drivers">Hardening illumos Drivers</a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Be sure to take proper electrical precautions when testing.
===
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testing-loading-and-unloading"><a class="anchor" href="#testing-loading-and-unloading"></a>4.8.4. Testing Loading and Unloading</h4>
<div class="paragraph">
<p>Because a driver that does not load or unload can force unscheduled
downtime, loading and unloading must be thoroughly tested.</p>
</div>
<div class="paragraph">
<p>A script like the following example should suffice:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/sh
cd &lt;location_of_driver&gt;
while [ 1 ]
    modunload -i 'modinfo | grep " &lt;driver_name&gt; " | cut -cl-3' &amp;
    modload &lt;driver_name&gt; &amp;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stress-performance-and-interoperability-testing"><a class="anchor" href="#stress-performance-and-interoperability-testing"></a>4.8.5. Stress, Performance, and Interoperability Testing</h4>
<div class="paragraph">
<p>To help ensure that a driver performs well, that driver should be
subjected to vigorous stress testing. For example, running single
threads through a driver does not test locking logic or conditional
variables that have to wait. Device operations should be performed by
multiple processes at once to cause several threads to execute the same
code simultaneously.</p>
</div>
<div class="paragraph">
<p>Techniques for performing simultaneous tests depend upon the driver.
Some drivers require special testing applications, while starting
several UNIX commands in the background is suitable for others.
Appropriate testing depends upon where the particular driver uses locks
and condition variables. Testing a driver on a multiprocessor machine is
more likely to expose problems than testing on a single-processor
machine.</p>
</div>
<div class="paragraph">
<p>Interoperability between drivers must also be tested, particularly
because different devices can share interrupt levels. If possible,
configure another device at the same interrupt level as the one being
tested. A stress test can determine whether the driver correctly claims
its own interrupts and operates according to expectations. Stress tests
should be run on both devices at once. Even if the devices do not share
an interrupt level, this test can still be valuable. For example,
consider a case in which serial communication devices experience errors
when a network driver is tested. The same problem might be causing the
rest of the system to encounter interrupt latency problems as well.</p>
</div>
<div class="paragraph">
<p>Driver performance under these stress tests should be measured using
UNIX performance-measuring tools. This type of testing can be as simple
as using the <code>time(1)</code> command along with commands to be used in the
stress tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="ddidki-compliance-testing"><a class="anchor" href="#ddidki-compliance-testing"></a>4.8.6. DDI/DKI Compliance Testing</h4>
<div class="paragraph">
<p>To ensure compatibility with later
releases and reliable support for the current release, every driver
should be DDI/DKI compliant. Check that only kernel routines in
<a href="https://illumos.org/man/9f">manual pages section 9F: DDI and DKI Kernel
Functions</a> and <a href="https://illumos.org/man/9e/">manual pages section 9E: DDI
and DKI Driver Entry Points</a> and data structures in
<a href="https://illumos.org/man/9s">manual pages section 9S: DDI and DKI
Properties and Data Structures</a> are used.</p>
</div>
</div>
<div class="sect3">
<h4 id="installation-and-packaging-testing"><a class="anchor" href="#installation-and-packaging-testing"></a>4.8.7. Installation and Packaging Testing</h4>
<div class="paragraph">
<p>Drivers are delivered to customers in <em>packages</em>. A
package can be added or be removed from the system using a standard
mechanism (see the Application Packaging Developer’s Guide).</p>
</div>
<div class="paragraph">
<p>The ability of a user to add or remove the package from a system should
be tested. In testing, the package should be both installed and removed
from every type of media to be used for the release. This testing should
include several system configurations. Packages must not make
unwarranted assumptions about the directory environment of the target
system. Certain valid assumptions, however, can be made about where
standard kernel files are kept. Also test adding and removing of
packages on newly installed machines that have not been modified for a
development environment. A common packaging error is for a package to
rely on a tool or file that is used in development only. For example, no
tools from the Source Compatibility package, <code>SUNWscpu</code>, should be used
in driver installation programs.</p>
</div>
<div class="paragraph">
<p>The driver installation must be tested on a minimal illumos system
without any optional packages.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-specific-types-of-drivers"><a class="anchor" href="#testing-specific-types-of-drivers"></a>4.8.8. Testing Specific Types of Drivers</h4>
<div class="paragraph">
<p>This section provides some suggestions about how to test
certain types of standard devices.</p>
</div>
<div class="sect4">
<h5 id="tape-drivers"><a class="anchor" href="#tape-drivers"></a>Tape Drivers</h5>
<div class="paragraph">
<p>tape drivers</p>
</div>
<div class="paragraph">
<p>Tape drivers should be tested by performing several archive and restore
operations. The <code>cpio(1)</code> and <code>tar(1)</code> commands can be used for this
purpose. Use the <code>dd(8)</code> command to write an entire disk partition to
tape. Next, read back the data, and write the data to another partition
of the same size. Then compare the two copies. The <code>mt(1)</code> command can
exercise most of the I/O controls that are specific to tape drivers. See
the <code>mtio(4I)</code> man page. Try to use all the options. These three
techniques can test the error-handling capabilities of tape drivers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove the tape and try various operations</p>
</li>
<li>
<p>Write-protect the tape and try a write</p>
</li>
<li>
<p>Turn off power in the middle of different operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tape drivers typically implement exclusive-access <code>open(9E)</code> calls.
These <code>open</code> calls can be tested by opening a device and then having a
second process try to open the same device.</p>
</div>
</div>
<div class="sect4">
<h5 id="disk-drivers"><a class="anchor" href="#disk-drivers"></a>Disk Drivers</h5>
<div class="paragraph">
<p>Disk drivers should be tested in both the
raw and block device modes. For block device tests, create a new file
system on the device. Then try to mount the new file system. Then try to
perform multiple file operations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The file system uses a page cache, so reading the same file over and
over again does not really exercise the driver. The page cache can be
forced to retrieve data from the device by memory-mapping the file with
<code>mmap(2)</code>. Then use <code>msync(3C)</code> to invalidate the in-memory copies.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Copy another (unmounted) partition of the same size to the raw device.
Then use a command such as <code>fsck(8)</code> to verify the correctness of the
copy. The new partition can also be mounted and then later compared to
the old partition on a file-by-file basis.</p>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-communication-drivers"><a class="anchor" href="#asynchronous-communication-drivers"></a>Asynchronous Communication Drivers</h5>
<div class="paragraph">
<p>Asynchronous drivers can be tested at the
basic level by setting up a <code>login</code> line to the serial ports. A good
test is to see whether a user can log in on this line. To sufficiently
test an asynchronous driver, however, all the I/O control functions must
be tested, with many interrupts at high speed. A test involving a
loopback serial cable and high data transfer rates can help determine
the reliability of the driver. You can run <code>uucp(1C)</code> over the line to
provide some exercise. However, because <code>uucp</code> performs its own error
handling, verify that the driver is not reporting excessive numbers of
errors to the <code>uucp</code> process.</p>
</div>
<div class="paragraph">
<p>These types of devices are usually STREAMS-based. See the STREAMS
Programming Guide for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="network-drivers"><a class="anchor" href="#network-drivers"></a>Network Drivers</h5>
<div class="paragraph">
<p>Network drivers can be tested using
standard network utilities. The <code>ftp(1)</code> and <code>rcp(1)</code> commands are
useful because the files can be compared on each end of the network. The
driver should be tested under heavy network loading, so that various
commands can be run by multiple processes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Traffic to the test machine is heavy.</p>
</li>
<li>
<p>Traffic among all machines on the network is heavy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Network cables should be unplugged while the tests are executing to
ensure that the driver recovers gracefully from the resulting error
conditions. Another important test is for the driver to receive multiple
packets in rapid succession, that is, <em>back-to-back</em> packets. In this
case, a relatively fast host on a lightly loaded network should send
multiple packets in quick succession to the test machine. Verify that
the receiving driver does not drop the second and subsequent packets.</p>
</div>
<div class="paragraph">
<p>These types of devices are usually STREAMS-based. See the STREAMS
Programming Guide for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="debugging-testing-and-tuning-device-drivers"><a class="anchor" href="#debugging-testing-and-tuning-device-drivers"></a>4.9. Debugging, Testing, and Tuning Device Drivers</h3>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>This chapter presents an overview of the various tools that are provided
to assist with testing, debugging, and tuning device drivers. This
chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#testing-drivers">Testing Drivers</a> – Testing a driver can potentially
impair a system&#8217;s ability to function. Use of both serial connections
and alternate kernels helps facilitate recovery from crashes.</p>
</li>
<li>
<p><a href="#debugging-tools">Debugging Tools</a> – Integral debugging facilities enable
you to exercise and observe driver features conveniently without having
to run a separate debugger.</p>
</li>
<li>
<p><a href="#tuning-drivers">Tuning Drivers</a> – illumos provides facilities for
measuring the performance of device drivers. Writing kernel statistics
structures for your device exports continuous statistics as the device
is running. If an area for performance improvement is determined, then
the DTrace dynamic instrumentation tool can help determine any problems
more precisely.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="testing-drivers"><a class="anchor" href="#testing-drivers"></a>4.10. Testing Drivers</h3>
<div class="paragraph">
<p>testing device drivers</p>
</div>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>testing device drivers</p>
</div>
<div class="paragraph">
<p>To avoid data loss and other problems, you should take special care when
testing a new device driver. This section discusses various testing
strategies. For example, setting up a separate system that you control
through a serial connection is the safest way to test a new driver. You
can load test modules with various kernel variable settings to test
performance under different kernel conditions. Should your system crash,
you should be prepared to restore backup data, analyze any crash dumps,
and rebuild the device directory.</p>
</div>
<div class="sect3">
<h4 id="enable-the-deadman-feature-to-avoid-a-hard-hang"><a class="anchor" href="#enable-the-deadman-feature-to-avoid-a-hard-hang"></a>4.10.1. Enable the Deadman Feature to Avoid a Hard Hang</h4>
<div class="paragraph">
<p>If your system is in a hard
hang, then you cannot break into the debugger. If you enable the deadman
feature, the system panics instead of hanging indefinitely. You can then
use the <code>kmdb(1)</code> kernel debugger to analyze your problem.</p>
</div>
<div class="paragraph">
<p>The deadman feature checks every second whether the system clock is
updating. If the system clock is not updating, then you are in an
indefinite hang. If the system clock has not been updated for 50
seconds, the deadman feature induces a panic and puts you in the
debugger.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure you are capturing crash images with <code>dumpadm(8)</code>.</p>
</li>
<li>
<p>Set the <code>snooping</code> variable in the <code>/etc/system</code> file. See the
<code>system(5)</code> man page for information on the <code>/etc/system</code> file.</p>
<div class="literalblock">
<div class="content">
<pre>set snooping=1</pre>
</div>
</div>
</li>
<li>
<p>Reboot the system so that the <code>/etc/system</code> file is read again and the
<code>snooping</code> setting takes effect.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that any zones on your system inherit the deadman setting as well.</p>
</div>
<div class="paragraph">
<p>If your system hangs while the deadman feature is enabled, you should
see output similar to the following example on your console:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>panic[cpu1]/thread=30018dd6cc0: deadman: timed out after 9 seconds of
clock inactivity

panic: entering debugger (continue to save dump)</pre>
</div>
</div>
<div class="paragraph">
<p>Inside the debugger, use the <code>::cpuinfo</code> command to investigate why the
clock interrupt was not able to fire and advance the system time.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-with-a-serial-connection"><a class="anchor" href="#testing-with-a-serial-connection"></a>4.10.2. Testing With a Serial Connection</h4>
<div class="paragraph">
<p>Using a serial
connection is a good way to test drivers. Use the <code>tip(1)</code> command to
make a serial connection between a host system and a test system. With
this approach, the <em>tip window</em> on the host console is used as the
console of the test machine. See the <code>tip(1)</code> man page for additional
information.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interactions with the test system and kernel debuggers can be
monitored. For example, the window can keep a log of the session for use
if the driver crashes the test system.</p>
</li>
<li>
<p>The test machine can be accessed remotely by logging into a <em>tip host</em>
machine and using <code>tip(1)</code> to connect to the test machine.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although using a tip connection and a second machine are not required to
debug an illumos device driver, this technique is still recommended.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Connect the host system to the test machine using serial port A on
both machines.</p>
<div class="paragraph">
<p>This connection must be made with a null modem cable.</p>
</div>
</li>
<li>
<p>On the host system, make sure there is an entry in <code>/etc/remote</code> for
the connection. See the <code>remote(5)</code> man page for details.</p>
<div class="paragraph">
<p>The terminal entry must match the serial port that is used. illumos
comes with the correct entry for serial port B, but a terminal entry
must be added for serial port A:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>debug:\
        :dv=/dev/term/a:br#9600:el=^C^S^Q^U^D:ie=%$:oe=^D:</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The baud rate must be set to 9600.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>In a shell window on the host, run <code>tip(1)</code> and specify the name of
the entry:</p>
<div class="literalblock">
<div class="content">
<pre>% tip debug</pre>
</div>
</div>
<div class="paragraph">
<p>The shell window is now a tip window with a connection to the console of
the test machine.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Do not use <code>STOP-A</code> for SPARC machines or <code>F1-A</code> for x86 architecture
machines on the host machine to stop the test machine. This action
actually stops the host machine. To send a break to the test machine,
type <code>~<mark></code> in the tip window. Commands such as <code>~</mark></code> are recognized only
if these characters on first on the line. If the command has no effect,
press either the Return key or Control-U.
===
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="setting-up-a-target-system-on-the-sparc-platform"><a class="anchor" href="#setting-up-a-target-system-on-the-sparc-platform"></a>Setting Up a Target System on the SPARC Platform</h5>
<div class="paragraph">
<p>setting up a SPARC test system</p>
</div>
<div class="paragraph">
<p>A quick way to set up the test machine on the SPARC platform is to
unplug the keyboard before turning on the machine. The machine then
automatically uses serial port A as the console.</p>
</div>
<div class="paragraph">
<p>Another way to set up the test machine is to use boot PROM commands to
make serial port A the console. On the test machine, at the boot PROM
<code>ok</code> prompt, direct console I/O to the serial line. To make the test
machine always come up with serial port A as the console, set the
environment variables: <code>input-device</code> and <code>output-device</code>.</p>
</div>
<div id="faaxq" class="paragraph">
<p>Setting <code>input-device</code> and <code>output-device</code> With Boot PROM Commands</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok setenv input-device ttya
ok setenv output-device ttya</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>eeprom</code> command can also be used to make serial port A the console.
As superuser, execute the following commands to make the <code>input-device</code>
and <code>output-device</code> parameters point to serial port A. The following
example demonstrates the <code>eeprom</code> command.</p>
</div>
<div id="faasj" class="paragraph">
<p>Setting <code>input-device</code> and <code>output-device</code> With the <code>eeprom</code> Command</p>
</div>
<div class="literalblock">
<div class="content">
<pre># eeprom input-device=ttya
# eeprom output-device=ttya</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>eeprom</code> commands cause the console to be redirected to serial port
A at each subsequent system boot.</p>
</div>
</div>
<div class="sect4">
<h5 id="setting-up-a-target-system-on-the-x86-platform"><a class="anchor" href="#setting-up-a-target-system-on-the-x86-platform"></a>Setting Up a Target System on the x86 Platform</h5>
<div class="paragraph">
<p>setting up an x86 test system</p>
</div>
<div class="paragraph">
<p>On x86 platforms, use the <code>eeprom</code> command to make serial port A the
console. This procedure is the same as the SPARC platform procedure. See
<a href="#setting-up-a-target-system-on-the-sparc-platform">Setting Up a Target System on the SPARC Platform</a>. The
<code>eeprom</code> command causes the console to switch to serial port A (COM1)
during reboot.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
x86 machines do not transfer console control to the <code>tip</code> connection
until an early stage in the boot process unless the BIOS supports
console redirection to a serial port. In SPARC machines, the <code>tip</code>
connection maintains console control throughout the boot process.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-up-test-modules"><a class="anchor" href="#setting-up-test-modules"></a>4.10.3. Setting Up Test Modules</h4>
<div class="paragraph">
<p><code>system(5)</code> file in the <code>/etc</code> directory enables you to set the value of
kernel variables at boot time. With kernel variables, you can toggle
different behaviors in a driver and take advantage of debugging features
that are provided by the kernel. The kernel variables <code>moddebug</code> and
<code>kmem_flags</code>, which can be very useful in debugging, are discussed
later in this section. See also <a href="#enable-the-deadman-feature-to-avoid-a-hard-hang">Enable the Deadman Feature
to Avoid a Hard Hang</a>.</p>
</div>
<div class="paragraph">
<p>Changes to kernel variables after boot are unreliable, because
<code>/etc/system</code> is read only once when the kernel boots. After this file
is modified, the system must be rebooted for the changes to take effect.
If a change in the file causes the system not to work, boot with the ask
(<code>-a</code>) option. Then specify <code>/dev/null</code> as the system file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kernel variables cannot be relied on to be present in subsequent
releases.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="setting-kernel-variables"><a class="anchor" href="#setting-kernel-variables"></a>Setting Kernel Variables</h5>
<div class="paragraph">
<p>kernel variables</p>
</div>
<div class="paragraph">
<p>The <code>set</code> command changes the value of module or kernel variables. To
set module variables, specify the module name and the variable:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set module_name:variable=value</pre>
</div>
</div>
<div class="paragraph">
<p>For example, to set the variable <code>test_debug</code> in a driver that is
named <code>myTest</code>, use <code>set</code> as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% set myTest:test_debug=1</pre>
</div>
</div>
<div class="paragraph">
<p>To set a variable that is exported by the kernel itself, omit the module
name.</p>
</div>
<div class="paragraph">
<p>You can also use a bitwise OR operation to set a value, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% set moddebug | 0x80000000</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="loading-and-unloading-test-modules"><a class="anchor" href="#loading-and-unloading-test-modules"></a>Loading and Unloading Test Modules</h5>
<div class="paragraph">
<p>loading test modules</p>
</div>
<div class="paragraph">
<p>unloading test modules</p>
</div>
<div class="paragraph">
<p>The commands <code>modload(8)</code>, <code>modunload(8)</code>, and <code>modinfo(8)</code> can be used
to add test modules, which is a useful technique for debugging and
stress-testing drivers. These commands are generally not needed in
normal operation, because the kernel automatically loads needed modules
and unloads unused modules. The <code>moddebug</code> kernel variable works with
these commands to provide information and set controls.</p>
</div>
<div class="sect5">
<h6 id="faato"><a class="anchor" href="#faato"></a>Using the <code>modload</code> Function</h6>
<div class="paragraph">
<p>Use <code>modload(8)</code> to force a module into memory. The <code>modload</code> command
verifies that the driver has no unresolved references when that driver
is loaded. Loading a driver does <em>not</em> necessarily mean that the driver
can attach. When a driver loads successfully, the driver&#8217;s
<code>_info(9E)</code> entry point is called. The <code>attach</code> entry point is not
necessarily called.</p>
</div>
</div>
<div class="sect5">
<h6 id="faasm"><a class="anchor" href="#faasm"></a>Using the <code>modinfo</code> Function</h6>
<div class="paragraph">
<p>Use <code>modinfo(8)</code> to confirm that the driver is loaded.</p>
</div>
<div id="faatr" class="paragraph">
<p>Using <code>modinfo</code> to Confirm a Loaded Driver</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ modinfo
Id Loadaddr   Size Info Rev Module Name
  6 101b6000    732   -   1  obpsym (OBP symbol callbacks)
  7 101b65bd  1acd0 226   1  rpcmod (RPC syscall)
  7 101b65bd  1acd0 226   1  rpcmod (32-bit RPC syscall)
  7 101b65bd  1acd0   1   1  rpcmod (rpc interface str mod)
  8 101ce8dd  74600   0   1  ip (IP STREAMS module)
  8 101ce8dd  74600   3   1  ip (IP STREAMS device)
...
$ modinfo | grep mydriver
169 781a8d78   13fb   0   1  mydriver (Test Driver 1.5)</pre>
</div>
</div>
<div class="paragraph">
<p>The number in the <code>info</code> field is the major number that has been chosen
for the driver. The <code>modunload(8)</code> command can be used to unload a
module if the module ID is provided. The module ID is found in the left
column of <code>modinfo</code> output.</p>
</div>
<div class="paragraph">
<p>Sometimes a driver does not unload as expected after a <code>modunload</code> is
issued, because the driver is determined to be busy. This situation
occurs when the driver fails <code>detach(9E)</code>, either because the driver
really is busy, or because the <code>detach</code> entry point is implemented
incorrectly.</p>
</div>
</div>
<div class="sect5">
<h6 id="faaur"><a class="anchor" href="#faaur"></a>Using <code>modunload</code></h6>
<div class="paragraph">
<p>To remove all of the currently unused modules from memory, run
<code>modunload(8)</code> with a module ID of 0:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># modunload -i 0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="faawr"><a class="anchor" href="#faawr"></a>Setting the <code>moddebug</code> Kernel Variable</h6>
<div class="paragraph">
<p>The <code>moddebug</code> kernel variable controls the module
loading process. The possible values of <code>moddebug</code> are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>0x80000000</code></dt>
<dd>
<p>Prints messages to the console when loading or unloading modules.</p>
</dd>
<dt class="hdlist1"><code>0x40000000</code></dt>
<dd>
<p>Gives more detailed error messages.</p>
</dd>
<dt class="hdlist1"><code>0x20000000</code></dt>
<dd>
<p>Prints more detail when loading or unloading, such as including the
address and size.</p>
</dd>
<dt class="hdlist1"><code>0x00001000</code></dt>
<dd>
<p>No auto-unloading drivers. The system does not attempt to unload the
device driver when the system resources become low.</p>
</dd>
<dt class="hdlist1"><code>0x00000080</code></dt>
<dd>
<p>No auto-unloading streams. The system does not attempt to unload the
STREAMS module when the system resources become low.</p>
</dd>
<dt class="hdlist1"><code>0x00000010</code></dt>
<dd>
<p>No auto-unloading of kernel modules of any type.</p>
</dd>
<dt class="hdlist1"><code>0x00000001</code></dt>
<dd>
<p>If running with <code>kmdb</code>, <code>moddebug</code> causes a breakpoint to be executed
and a return to <code>kmdb</code> immediately before each module&#8217;s <code>_init</code>
routine is called. This setting also generates additional debug
messages when the module&#8217;s <code>_info</code> and <code>_fini</code> routines are
executed.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="setting-kmem_flags-debugging-flags"><a class="anchor" href="#setting-kmem_flags-debugging-flags"></a>Setting <code>kmem_flags</code> Debugging Flags</h5>
<div class="paragraph">
<p>kmem_flags</p>
</div>
<div class="paragraph">
<p>kmem_flags</p>
</div>
<div class="paragraph">
<p>kernel variable</p>
</div>
<div class="paragraph">
<p>The <code>kmem_flags</code> kernel variable enables debugging features in the
kernel&#8217;s memory allocator. Set <code>kmem_flags</code> to <code>0xf</code> to enable the
allocator&#8217;s debugging features. These features include runtime checks to
find the following code conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing to a buffer after the buffer is freed</p>
</li>
<li>
<p>Using memory before the memory is initialized</p>
</li>
<li>
<p>Writing past the end of a buffer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Modular Debugger Guide describes how to use the kernel memory
allocator to analyze such problems.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Testing and developing with <code>kmem_flags</code> set to <code>0xf</code> can help
detect latent memory corruption bugs. Because setting <code>kmem_flags</code>
to <code>0xf</code> changes the internal behavior of the kernel memory allocator,
you should thoroughly test without <code>kmem_flags</code> as well.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="avoiding-data-loss-on-a-test-system"><a class="anchor" href="#avoiding-data-loss-on-a-test-system"></a>4.10.4. Avoiding Data Loss on a Test System</h4>
<div class="paragraph">
<p>avoiding data loss while testing</p>
</div>
<div class="paragraph">
<p>testing debuggers</p>
</div>
<div class="paragraph">
<p>avoiding data loss</p>
</div>
<div class="paragraph">
<p>A driver bug can sometimes render a system incapable of
booting. By taking precautions, you can avoid system reinstallation in
this event, as described in this section.</p>
</div>
<div class="sect4">
<h5 id="back-up-critical-system-files"><a class="anchor" href="#back-up-critical-system-files"></a>Back Up Critical System Files</h5>
<div class="paragraph">
<p>A number of driver-related system files are difficult, if not
impossible, to reconstruct. Files such as <code>/etc/name_to_major</code>,
<code>/etc/driver_aliases</code>, <code>/etc/driver_classes</code>, and
<code>/etc/minor_perm</code> can be corrupted if the driver crashes the system
during installation. See the <code>add_drv(8)</code> man page.</p>
</div>
<div class="paragraph">
<p>To be safe, make a backup copy of the root file system after the test
machine is in the proper configuration. If you plan to modify the
<code>/etc/system</code> file, make a backup copy of the file before making
modifications.</p>
</div>
<div class="paragraph">
<p>booting an alternate kernel</p>
</div>
<div class="paragraph">
<p>booting an alternate kernel</p>
</div>
<div class="paragraph">
<p>To avoid rendering a system inoperable, you should boot from a copy of
the kernel and associated binaries rather than from the default kernel.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make a copy of the drivers in <code>/platform/*</code>.</p>
<div class="literalblock">
<div class="content">
<pre># cp -r /platform/`uname -i`/kernel /platform/`uname -i`/kernel.test</pre>
</div>
</div>
</li>
<li>
<p>Place the driver module in
<code>/platform/`uname -i`/kernel.test/drv</code>.</p>
</li>
<li>
<p>Boot the alternate kernel instead of the default kernel.</p>
<div class="paragraph">
<p>After you have created and stored the alternate kernel, you can boot
this kernel in a number of ways.
* You can boot the alternate kernel by rebooting:</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock">
<div class="content">
<pre># reboot -- kernel.test/unix</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>On a SPARC-based system, you can also boot from the PROM:</p>
<div class="literalblock">
<div class="content">
<pre>ok boot kernel.test/sparcv9/unix</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To boot with the <code>kmdb</code> debugger, use the <code>k</code> option as described in
<a href="#getting-started-with-the-modular-debugger">Getting Started With the Modular Debugger</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>On an x86-based system, when the <code>Select (b)oot or (i)nterpreter:</code>
message is displayed in the boot process, type the following:</p>
<div class="literalblock">
<div class="content">
<pre>boot kernel.test/unix</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="faavq" class="paragraph">
<p>Booting an Alternate Kernel</p>
</div>
<div class="paragraph">
<p>The following example demonstrates booting with an alternate kernel.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok boot kernel.test/sparcv9/unix
Rebooting with command: boot kernel.test/sparcv9/unix
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a File and \
    args:
kernel.test/sparcv9/unix</pre>
</div>
</div>
<div id="faayx" class="paragraph">
<p>Booting an Alternate Kernel With the <code>a</code> Option</p>
</div>
<div class="paragraph">
<p>Alternatively, the module path can be changed by booting with the ask
(<code>-a</code>) option. This option results in a series of prompts for
configuring the boot method.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok boot -a
Rebooting with command: boot -a
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a File and \
args: -a
Enter filename [kernel/sparcv9/unix]: kernel.test/sparcv9/unix
Enter default directory for modules
[/platform/sun4u/kernel.test /kernel /usr/kernel]: &lt;CR&gt;
Name of system file [etc/system]: &lt;CR&gt;
SunOS Release 5.10 Version Generic 64-bit
Copyright 1983-2002 Sun Microsystems, Inc. All rights reserved.
root filesystem type [ufs]: &lt;CR&gt;
Enter physical name of root device
[/sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@0,0:a]: &lt;CR&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="consider-alternative-back-up-plans"><a class="anchor" href="#consider-alternative-back-up-plans"></a>Consider Alternative Back-Up Plans</h5>
<div class="paragraph">
<p>If the system is attached to a network, the test machine can be added as
a client of a server. If a problem occurs, the system can be booted from
the network. The local disks can then be mounted, and any fixes can be
made. Alternatively, the system can be booted directly from the illumos
system CD-ROM.</p>
</div>
<div class="paragraph">
<p>Another way to recover from disaster is to have another bootable root
file system. Use <code>format(8)</code> to make a partition that is the exact size
of the original. Then use <code>dd(8)</code> to copy the bootable root file system.
After making a copy, run <code>fsck(8)</code> on the new file system to ensure its
integrity.</p>
</div>
<div class="paragraph">
<p>Subsequently, if the system cannot boot from the original root
partition, boot the backup partition. Use <code>dd(8)</code> to copy the backup
partition onto the original partition. You might have a situation where
the system cannot boot even though the root file system is undamaged.
For example, the damage might be limited to the boot block or the boot
program. In such a case, you can boot from the backup partition with the
ask (<code>a</code>) option. You can then specify the original file system as the
root file system.</p>
</div>
</div>
<div class="sect4">
<h5 id="capture-system-crash-dumps"><a class="anchor" href="#capture-system-crash-dumps"></a>Capture System Crash Dumps</h5>
<div class="paragraph">
<p>When a system panics, the system writes an
image of kernel memory to the dump device. The dump device is by default
the most suitable swap device. The dump is a system crash dump, similar
to core dumps generated by applications. On rebooting after a panic,
<code>savecore(8)</code> checks the dump device for a crash dump. If a dump is
found, <code>savecore</code> makes a copy of the kernel&#8217;s symbol table, which is
called <code>unix.n</code>. The <code>savecore</code> utility then dumps a core file that is
called <code>vmcore.n</code> in the core image directory. By default, the core
image directory is <code>/var/crash/machine_name</code>. If <code>/var/crash</code> has
insufficient space for a core dump, the system displays the needed space
but does not actually save the dump. The <code>mdb(1)</code> debugger can then be
used on the core dump and the saved kernel.</p>
</div>
<div class="paragraph">
<p>In most illumos distributions, crash dump is enabled by default. The
<code>dumpadm(8)</code> command is used to configure system crash dumps. Use the
<code>dumpadm</code> command to verify that crash dumps are enabled and to
determine the location of core files that have been saved.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can prevent the <code>savecore</code> utility from filling the file system. Add
a file that is named <code>minfree</code> to the directory in which the dumps are
to be saved. In this file, specify the number of kilobytes to remain
free after <code>savecore</code> has run. If insufficient space is available, the
core file is not saved.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="recovering-the-device-directory"><a class="anchor" href="#recovering-the-device-directory"></a>4.10.5. Recovering the Device Directory</h4>
<div class="paragraph">
<p>disaster recovery</p>
</div>
<div class="paragraph">
<p>recovering the device directory</p>
</div>
<div class="paragraph">
<p>device directory</p>
</div>
<div class="paragraph">
<p>Damage to the <code>/devices</code> and <code>/dev</code> directories can occur if the driver
crashes during <code>attach(9E)</code>. If either directory is damaged, you can
rebuild the directory by booting the system and running <code>fsck(8)</code> to
repair the damaged root file system. The root file system can then be
mounted. Recreate the <code>/devices</code> and <code>/dev</code> directories by running
<code>devfsadm(8)</code> and specifying the <code>/devices</code> directory on the mounted
disk.</p>
</div>
<div class="paragraph">
<p>The following example shows how to repair a damaged root file system on
a SPARC system. In this example, the damaged disk is
<code>/dev/dsk/c0t3d0s0</code>, and an alternate boot disk is <code>/dev/dsk/c0t1d0s0</code>.</p>
</div>
<div id="faauw" class="paragraph">
<p>Recovering a Damaged Device Directory</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok boot disk1
...
Rebooting with command: boot kernel.test/sparcv9/unix
Boot device: /sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@31,0:a File and \
    args:
kernel.test/sparcv9/unix
...
# fsck /dev/dsk/c0t3d0s0** /dev/dsk/c0t3d0s0
** Last Mounted on /
** Phase 1 - Check Blocks and Sizes
** Phase 2 - Check Pathnames
** Phase 3 - Check Connectivity
** Phase 4 - Check Reference Counts
** Phase 5 - Check Cyl groups
1478 files, 9922 used, 29261 free
     (141 frags, 3640 blocks, 0.4% fragmentation)
# mount /dev/dsk/c0t3d0s0 /mnt
# devfsadm -r /mnt</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A fix to the <code>/devices</code> and <code>/dev</code> directories can allow the system to
boot while other parts of the system are still corrupted. Such repairs
are only a temporary fix to save information, such as system crash
dumps, before reinstalling the system.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="debugging-tools"><a class="anchor" href="#debugging-tools"></a>4.11. Debugging Tools</h3>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>kmdb(1)</code> <strong>kernel debugger</strong> provides typical runtime debugger
facilities, such as breakpoints, watch points, and single-stepping. The
<code>kmdb</code> debugger supersedes <code>kadb</code>, which was available in previous
releases. The commands that were previously available from <code>kadb</code> are
used in <code>kmdb</code>, in addition to new functionality. Where <code>kadb</code> could
only be loaded at boot time, <code>kmdb</code> can be loaded at any time. The
<code>kmdb</code> debugger is preferred for live, interactive debugging due to its
execution controls.</p>
</li>
<li>
<p>The <code>mdb(1)</code> <strong>modular debugger</strong> is more limited than <code>kmdb</code> as a
real-time debugger, but <code>mdb</code> has rich facilities for postmortem
debugging.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>kmdb</code> and <code>mdb</code> debuggers mostly share the same user interface.
Many debugging techniques therefore can be applied with the same
commands in both tools. Both debuggers support macros, dcmds, and dmods.
A <em>dcmd</em> (pronounced dee-command) is a routine in the debugger that can
access any of the properties of the current target program. A dcmd can
be dynamically loaded at runtime. A <em>dmod</em>, which is short for debugger
module, is a package of dcmds that can be loaded to provide non-standard
behavior.</p>
</div>
<div class="paragraph">
<p>Both <code>mdb</code> and <code>kmdb</code> are backward-compatible with legacy debuggers such
as <code>adb</code> and <code>kadb</code>. The <code>mdb</code> debugger can execute all of the macros
that are available to <code>kmdb</code> as well as any legacy user-defined macros
for <code>adb</code>. See the Modular Debugger Guide for information about where to
find standard macro sets.</p>
</div>
<div class="sect3">
<h4 id="postmortem-debugging"><a class="anchor" href="#postmortem-debugging"></a>4.11.1. Postmortem Debugging</h4>
<div class="paragraph">
<p>postmortem debugging</p>
</div>
<div class="paragraph">
<p>Postmortem analysis offers numerous advantages to driver developers.
More than one developer can examine a problem in parallel. Multiple
instances of the debugger can be used simultaneously on a single crash
dump. The analysis can be performed offline so that the crashed system
can be returned to service, if possible. Postmortem analysis enables the
use of user-developed debugger functionality in the form of dmods. Dmods
can bundle functionality that would be too memory-intensive for
real-time debuggers, such as <code>kmdb</code>.</p>
</div>
<div class="paragraph">
<p>When a system panics while <code>kmdb</code> is loaded, control is passed to the
debugger for immediate investigation. If <code>kmdb</code> does not seem
appropriate for analyzing the current problem, a good strategy is to use
<code>:c</code> to continue execution and save the crash dump. When the system
reboots, you can perform postmortem analysis with <code>mdb</code> on the saved
crash dump. This process is analogous to debugging an application crash
from a process core file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In earlier versions of the Solaris operating system,
<code>adb(1)</code> was the recommended tool for postmortem analysis. In the
current illumos releases, <code>mdb(1)</code> is the recommended tool for
postmortem analysis. The <code>mdb</code> feature set surpasses the set of commands
from the legacy <code>crash(8)</code> utility. The <code>crash</code> utility is no longer
available in illumos.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-the-kmdb-kernel-debugger"><a class="anchor" href="#using-the-kmdb-kernel-debugger"></a>4.11.2. Using the <code>kmdb</code> Kernel Debugger</h4>
<div class="ulist">
<ul>
<li>
<p>Control of kernel execution</p>
</li>
<li>
<p>Inspection of the kernel state</p>
</li>
<li>
<p>Live modifications to the code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section assumes that you are already familiar with the <code>kmdb</code>
debugger. The focus in this section is on <code>kmdb</code> capabilities that are
useful in device driver design. To learn how to use <code>kmdb</code> in detail,
refer to the <code>kmdb(1)</code> man page and to the Modular Debugger Guide. If
you are familiar with <code>kadb</code>, refer to the <code>kadb(8)</code> man page for the
major differences between <code>kadb</code> and <code>kmdb</code>.</p>
</div>
<div class="paragraph">
<p>The <code>kmdb</code> debugger can be loaded and unloaded at will. Instructions for
loading and unloading <code>kmdb</code> are in the Modular Debugger Guide. For
safety and convenience, booting with an alternate kernel is highly
encouraged. The boot process is slightly different between the SPARC
platform and the x86 platform, as described in this section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, <code>kmdb</code> uses the CPU ID as the prompt when <code>kmdb</code> is running.
In the examples in this chapter <code>[0]</code> is used as the prompt
unless otherwise noted.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="booting-kmdb-with-an-alternate-kernel-on-the-sparc-platform"><a class="anchor" href="#booting-kmdb-with-an-alternate-kernel-on-the-sparc-platform"></a>Booting <code>kmdb</code> With an Alternate Kernel on the SPARC Platform</h5>
<div class="paragraph">
<p>booting the</p>
</div>
<div class="paragraph">
<p>on SPARC systems</p>
</div>
<div class="paragraph">
<p>booting on SPARC systems</p>
</div>
<div class="paragraph">
<p>Use either of the following commands to boot a SPARC system with both
<code>kmdb</code> and an alternate kernel:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>boot kmdb -D kernel.test/sparcv9/unix
boot kernel.test/sparcv9/unix -k</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="booting-kmdb-with-an-alternate-kernel-on-the-x86-platform"><a class="anchor" href="#booting-kmdb-with-an-alternate-kernel-on-the-x86-platform"></a>Booting <code>kmdb</code> With an Alternate Kernel on the x86 Platform</h5>
<div class="paragraph">
<p>booting the</p>
</div>
<div class="paragraph">
<p>on x86 systems</p>
</div>
<div class="paragraph">
<p>booting on x86 systems</p>
</div>
<div class="paragraph">
<p>Use either of the following commands to boot an x86 system with both
<code>kmdb</code> and an alternate kernel:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b kmdb -D kernel.test/unix
b kernel.test/unix -k</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="setting-breakpoints-in-kmdb"><a class="anchor" href="#setting-breakpoints-in-kmdb"></a>Setting Breakpoints in <code>kmdb</code></h5>
<div class="paragraph">
<p>setting breakpoints</p>
</div>
<div class="paragraph">
<p>Use the <code>bp</code> command to set a breakpoint, as shown in the following
example.</p>
</div>
<div id="ezsuo" class="paragraph">
<p>Setting Standard Breakpoints in <code>kmdb</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]&gt; myModule`myBreakpointLocation::bp</pre>
</div>
</div>
<div class="paragraph">
<p>If the target module has not been loaded, then an error message that
indicates this condition is displayed, and the breakpoint is not
created. In this case you can use a <em>deferred breakpoint</em>. A deferred
breakpoint activates automatically when the specified module is loaded.
Set a deferred breakpoint by specifying the target location after the
<code>bp</code> command. The following example demonstrates a deferred breakpoint.</p>
</div>
<div id="ezsup" class="paragraph">
<p>Setting Deferred Breakpoints in <code>kmdb</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]&gt;::bp myModule`myBreakpointLocation</pre>
</div>
</div>
<div class="paragraph">
<p>For more information on using breakpoints, see the Modular Debugger
Guide. You can also get help by typing either of the following two
lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::help bp
&gt; ::bp dcmd</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kmdb-macros-for-driver-developers"><a class="anchor" href="#kmdb-macros-for-driver-developers"></a><code>kmdb</code> Macros for Driver Developers</h5>
<div class="paragraph">
<p>The <code>kmdb</code>(1M) debugger supports macros that can be used to display
kernel data structures. Use <code>$M</code> to display <code>kmdb</code> macros. Macros are
used in the form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[ address ] $&lt;macroname</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Neither the information displayed by these macros nor the format in
which the information is displayed, constitutes an interface. Therefore,
the information and format can change at any time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>kmdb</code> macros in the following table are particularly useful to
developers of device drivers. For convenience, legacy macro names are
shown where applicable.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 22. <code>kmdb</code> Macros</caption>
<colgroup>
<col style="width: 34%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dcmd</th>
<th class="tableblock halign-left valign-top">Legacy Macro</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::devinfo</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>devinfo</code></p>
</div>
<div class="paragraph">
<p><code>devinfo_brief</code></p>
</div>
<div class="paragraph">
<p><code>devinfo.prop</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Print a summary of a device node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::walk devinfo_parents</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devinfo.parent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Walk the ancestors of a
device node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::walk devinfo_sibling</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devinfo.sibling</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Walk the siblings of a
device node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::minornodes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devinfo.minor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Print the minor nodes that correspond
to the given device node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::major2name</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Print the name of a device that is bound to a given
device node.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::devbindings</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Print the device nodes that are bound to a given
device node or major number.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>::devinfo</code> dcmd displays a node state that can have one of the
following values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>DS_ATTACHED</code></dt>
<dd>
<p>The driver&#8217;s <code>attach(9E)</code> routine returned successfully.</p>
</dd>
<dt class="hdlist1"><code>DS_BOUND</code></dt>
<dd>
<p>The node is bound to a driver, but the driver&#8217;s <code>probe(9E)</code> routine
has not yet been called.</p>
</dd>
<dt class="hdlist1"><code>DS_INITIALIZED</code></dt>
<dd>
<p>The parent nexus has assigned a bus address for the driver. The
implementation-specific initializations have been completed. The
driver&#8217;s <code>probe(9E)</code> routine has not yet been called at this point.</p>
</dd>
<dt class="hdlist1"><code>DS_LINKED</code></dt>
<dd>
<p>The device node has been linked into the kernel&#8217;s device tree, but the
system has not yet found a driver for this node.</p>
</dd>
<dt class="hdlist1"><code>DS_PROBED</code></dt>
<dd>
<p>The driver&#8217;s <code>probe(9E)</code> routine returned successfully.</p>
</dd>
<dt class="hdlist1"><code>DS_READY</code></dt>
<dd>
<p>The device is fully configured.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mdb-modular-debugger"><a class="anchor" href="#using-the-mdb-modular-debugger"></a>4.11.3. Using the <code>mdb</code> Modular Debugger</h4>
<div class="paragraph">
<p>modular debugger</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Live operating system components</p>
</li>
<li>
<p>Operating system crash dumps</p>
</li>
<li>
<p>User processes</p>
</li>
<li>
<p>User process core dumps</p>
</li>
<li>
<p>Object files</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>mdb</code> debugger provides sophisticated debugging support for
analyzing kernel problems. This section provides an overview of <code>mdb</code>
features. For a complete discussion of <code>mdb</code>, refer to the Modular
Debugger Guide.</p>
</div>
<div class="paragraph">
<p>Although <code>mdb</code> can be used to alter live kernel state, <code>mdb</code> lacks the
kernel execution control that is provided by <code>kmdb</code>. As a result <code>kmdb</code>
is preferred for runtime debugging. The <code>mdb</code> debugger is used more for
static situations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The prompt for <code>mdb</code> is <code>&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="getting-started-with-the-modular-debugger"><a class="anchor" href="#getting-started-with-the-modular-debugger"></a>Getting Started With the Modular Debugger</h5>
<div class="paragraph">
<p>The <code>mdb</code> debugger provides an extensive programming API for
implementing debugger modules so that driver developers can implement
custom debugging support. The <code>mdb</code> debugger also provides many
usability features, such as command-line editing, command history, an
output pager, and online help.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>adb</code> macros should no longer be used. That functionality has
largely been superseded by the dcmds in <code>mdb</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>mdb</code> debugger provides a rich set of modules and dcmds. With these
tools, you can debug the illumos kernel, any associated modules, and
device drivers. These facilities enable you to perform tasks such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Formulate complex debugging queries</p>
</li>
<li>
<p>Locate all the memory allocated by a particular thread</p>
</li>
<li>
<p>Print a visual picture of a kernel STREAM</p>
</li>
<li>
<p>Determine what type of structure a particular address refers to</p>
</li>
<li>
<p>Locate leaked memory blocks in the kernel</p>
</li>
<li>
<p>Analyze memory to locate stack traces</p>
</li>
<li>
<p>Assemble dcmds into modules called <em>dmods</em> for creating customized</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get started, switch to the crash directory and type <code>mdb</code>, specifying
a system crash dump, as illustrated in the following example.</p>
</div>
<div id="fahpd" class="paragraph">
<p>Invoking <code>mdb</code> on a Crash Dump</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% cd /var/crash/testsystem
% ls
bounds     unix.0    vmcore.0
% mdb unix.0 vmcore.0
Loading modules: [ unix krtld genunix ufs_log ip usba s1394 cpc nfs ]
&gt; ::status
debugging crash dump vmcore.0 (64-bit) from testsystem
operating system: 5.10 Generic (sun4u)
panic message: zero
dump content: kernel pages only</pre>
</div>
</div>
<div class="paragraph">
<p>When <code>mdb</code> responds with the <code>&gt;</code> prompt, you can run commands.</p>
</div>
<div class="paragraph">
<p>To examine the running kernel on a live system, run <code>mdb</code> from the
system prompt as follows.</p>
</div>
<div id="fahpg" class="paragraph">
<p>Invoking <code>mdb</code> on a Running Kernel</p>
</div>
<div class="literalblock">
<div class="content">
<pre># mdb -k
Loading modules: [ unix krtld genunix ufs_log ip usba s1394 ptm cpc ipc nfs ]
&gt; ::status
debugging live kernel (64-bit) on testsystem
operating system: 5.10 Generic (sun4u)</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="useful-debugging-tasks-with-kmdb-and-mdb"><a class="anchor" href="#useful-debugging-tasks-with-kmdb-and-mdb"></a>4.11.4. Useful Debugging Tasks With <code>kmdb</code> and <code>mdb</code></h4>
<div class="paragraph">
<p>common tasks</p>
</div>
<div class="paragraph">
<p>This section provides examples of useful debugging tasks. The tasks in
this section can be performed with either <code>mdb</code> or <code>kmdb</code> unless
specifically noted. This section assumes a basic knowledge of the use of
<code>kmdb</code> and <code>mdb</code>. Note that the information presented here is dependent
on the type of system used. A Sun Blade 100 workstation running the
64-bit kernel was used to produce these examples.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Because irreversible destruction of data can result from modifying data
in kernel structures, you should exercise extreme caution. Do not modify
or rely on data in structures that are not part of the illumos DDI. See
the <code>Intro(9S)</code> man page for information on structures that are part of
the illumos DDI.
===
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="exploring-system-registers-with-kmdb"><a class="anchor" href="#exploring-system-registers-with-kmdb"></a>Exploring System Registers With <code>kmdb</code></h5>
<div class="paragraph">
<p>system registers</p>
</div>
<div class="paragraph">
<p>system registers</p>
</div>
<div class="paragraph">
<p>reading and writing</p>
</div>
<div class="paragraph">
<p>The <code>kmdb</code> debugger can display machine registers as a group or
individually. To display all registers as a group, use <code>$r</code> as shown in
the following example.</p>
</div>
<div id="ezsuj" class="paragraph">
<p>Reading All Registers on a SPARC Processor With <code>kmdb</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]: $r

g0    0                                 l0      0
g1    100130a4      debug_enter         l1      edd00028
g2    10411c00      tsbmiss_area+0xe00  l2      10449c90
g3    10442000      ti_statetbl+0x1ba   l3      1b
g4    3000061a004                       l4      10474400     ecc_syndrome_tab+0x80
g5    0                                 l5      3b9aca00
g6    0                                 l6      0
g7    2a10001fd40                       l7      0
o0    0                                 i0      0
o1    c                                 i1      10449e50
o2    20                                i2      0
o3    300006b2d08                       i3      10
o4    0                                 i4      0
o5    0                                 i5      b0
sp    2a10001b451                       fp      2a10001b521
o7    1001311c      debug_enter+0x78    i7      1034bb24     zsa_xsint+0x2c4
y     0
tstate: 1604  (ccr=0x0, asi=0x0, pstate=0x16, cwp=0x4)
pstate: ag:0 ie:1 priv:1 am:0 pef:1 mm:0 tle:0 cle:0 mg:0 ig:0
winreg: cur:4 other:0 clean:7 cansave:1 canrest:5 wstate:14
tba   0x10000000
pc    edd000d8 edd000d8:        ta      %icc,%g0 + 125
npc   edd000dc edd000dc:        nop</pre>
</div>
</div>
<div class="paragraph">
<p>The debugger exports each register value to a variable with the same
name as the register. If you read the variable, the current value of the
register is returned. If you write to the variable, the value of the
associated machine register is changed. The following example changes
the value of the <code>%o0</code> register from 0 to 1 on an x86 machine.</p>
</div>
<div id="ezsul" class="paragraph">
<p>Reading and Writing Registers on an x86 Machine With <code>kmdb</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]&gt; &amp;lt;eax=K
[0]&gt; 0&gt;eax
[0]&gt; &amp;lt;eax=K
[0]&gt;  c1e6e0f0&gt;eax</pre>
</div>
</div>
<div class="paragraph">
<p>If you need to inspect the registers of a different processor, you can
use the <code>::cpuregs</code> dcmd. The ID of the processor to be examined can be
supplied as either the address to the dcmd or as the value of the <code>c</code>
option, as shown in the following example.</p>
</div>
<div id="fapkf" class="paragraph">
<p>Inspecting the Registers of a Different Processor</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]&gt; 0::cpuregs
   %cs = 0x0158            %eax = 0xc1e6e0f0 kmdbmod`kaif_dvec
   %ds = 0x0160            %ebx = 0x00000000</pre>
</div>
</div>
<div class="paragraph">
<p>The following example switches from processor <code>0</code> to processor <code>3</code> on a
SPARC machine. The <code>%g3</code> register is inspected and then cleared. To
confirm the new value, <code>%g3</code> is read again.</p>
</div>
<div id="ezsuq" class="paragraph">
<p>Retrieving the Value of an Individual Register From a Specified</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[0]&gt; 3::switch
[3]&gt; &lt;g3=K
[3]&gt; 0&gt;g3
[3]&gt; &lt;g3</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="detecting-kernel-memory-leaks"><a class="anchor" href="#detecting-kernel-memory-leaks"></a>Detecting Kernel Memory Leaks</h5>
<div class="paragraph">
<p>detecting kernel memory leaks</p>
</div>
<div class="paragraph">
<p>memory leaks, detecting with</p>
</div>
<div class="paragraph">
<p>detecting kernel memory leaks with</p>
</div>
<div class="paragraph">
<p>detecting leaks with</p>
</div>
<div class="paragraph">
<p>detecting kernel memory leaks</p>
</div>
<div class="paragraph">
<p>The <code>::findleaks</code> dcmd provides powerful, efficient detection of memory
leaks in kernel crash dumps. The full set of kernel-memory debugging
features must be enabled for <code>::findleaks</code> to be effective. For more
information, see <a href="#setting-kmem_flags-debugging-flags">Setting Debugging Flags</a>. Run <code>::findleaks</code>
during driver development and testing to detect code that leaks memory,
thus wasting kernel resources. See Modular Debugger Guide for a complete
discussion of <code>::findleaks</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Code that leaks kernel memory can render the system vulnerable to
denial-of-service attacks.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="writing-debugger-commands-with-mdb"><a class="anchor" href="#writing-debugger-commands-with-mdb"></a>Writing Debugger Commands With <code>mdb</code></h5>
<div class="paragraph">
<p>writing commands</p>
</div>
<div class="paragraph">
<p>The <code>mdb</code> debugger provides a powerful API for implementing debugger
facilities that you customize to debug your driver. The Modular Debugger
Guide explains the programming API in detail.</p>
</div>
<div class="paragraph">
<p>The <code>SUNWmdbdm</code> package installs sample <code>mdb</code> source code in the
directory <code>/usr/demo/mdb</code>. You can use <code>mdb</code> to automate lengthy
debugging chores or help to validate that your driver is behaving
properly. You can also package your <code>mdb</code> debugging modules with your
driver product. With packaging, these facilities are available to
service personnel at a customer site.</p>
</div>
</div>
<div class="sect4">
<h5 id="obtaining-kernel-data-structure-information"><a class="anchor" href="#obtaining-kernel-data-structure-information"></a>Obtaining Kernel Data Structure Information</h5>
<div class="paragraph">
<p>kernel data structures</p>
</div>
<div class="paragraph">
<p>displaying kernel data structures</p>
</div>
<div class="paragraph">
<p>The illumos kernel provides data type information in structures that can
be inspected with either <code>kmdb</code> or <code>mdb</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>kmdb</code> and <code>mdb</code> dcmds can be used only with objects that contain
compressed symbolic debugging information that has been designed for use
with <code>mdb</code>. This information is currently available only for certain
illumos kernel modules. The <code>SUNWzlib</code> package must be installed to
process the symbolic debugging information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example demonstrates how to display the data in the
<code>scsi_pkt</code> structure.</p>
</div>
<div id="fahqd" class="paragraph">
<p>Displaying Kernel Data Structures With a Debugger</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">&gt; 7079ceb0::print -t 'struct scsi_pkt'
{
    opaque_t pkt_ha_private = 0x7079ce20
    struct scsi_address pkt_address = {
        struct scsi_hba_tran *a_hba_tran = 0x70175e68
        ushort_t a_target = 0x6
        uchar_t a_lun = 0
        uchar_t a_sublun = 0
    }
    opaque_t pkt_private = 0x708db4d0
    int (*)() *pkt_comp = sd_intr
    uint_t pkt_flags = 0
    int pkt_time = 0x78
    uchar_t *pkt_scbp = 0x7079ce74
    uchar_t *pkt_cdbp = 0x7079ce64
    ssize_t pkt_resid = 0
    uint_t pkt_state = 0x37
    uint_t pkt_statistics = 0
    uchar_t pkt_reason = 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The size of a data structure can be useful in debugging. Use the
<code>::sizeof</code> dcmd to obtain the size of a structure, as shown in the
following example.</p>
</div>
<div id="fahpl" class="paragraph">
<p>Displaying the Size of a Kernel Data Structure</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::sizeof struct scsi_pkt
sizeof (struct scsi_pkt) = 0x58</pre>
</div>
</div>
<div class="paragraph">
<p>The address of a specific member within a structure is also useful in
debugging. Several methods are available for determining a member&#8217;s
address.</p>
</div>
<div class="paragraph">
<p>Use the <code>::offsetof</code> dcmd to obtain the offset for a given member of a
structure, as in the following example.</p>
</div>
<div id="fahpt" class="paragraph">
<p>Displaying the Offset to a Kernel Data Structure</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::offsetof struct scsi_pkt pkt_state
offsetof (struct pkt_state) = 0x48</pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>::print</code> dcmd with the <code>a</code> option to display the addresses of
all members of a structure, as in the following example.</p>
</div>
<div id="fahph" class="paragraph">
<p>Displaying the Relative Addresses of a Kernel Data Structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">&gt; ::print -a struct scsi_pkt
{
    0 pkt_ha_private
    8 pkt_address {
    ...
    }
    18 pkt_private
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an address is specified with <code>::print</code> in conjunction with the <code>a</code>
option, the absolute address for each member is displayed.</p>
</div>
<div id="fahqj" class="paragraph">
<p>Displaying the Absolute Addresses of a Kernel Data Structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">&gt; 10000000::print -a struct scsi_pkt
{
    10000000 pkt_ha_private
    10000008 pkt_address {
    ...
    }
    10000018 pkt_private
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>::print</code>, <code>::sizeof</code> and <code>::offsetof</code> dcmds enable you to debug
problems when your driver interacts with the illumos kernel.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This facility provides access to <em>raw</em> kernel data structures. You can
examine any structure whether or not that structure appears as part of
the DDI. Therefore, you should refrain from relying on any data
structure that is not explicitly part of the DDI.
===
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These dcmds should be used only with objects that contain compressed
symbolic debugging information that has been designed for use with
<code>mdb</code>. Symbolic debugging information is currently available for certain
illumos kernel modules only. The <code>SUNWzlib</code> (32-bit) or <code>SUNWzlibx</code>
(64-bit) decompression software must be installed to process the
symbolic debugging information. The <code>kmdb</code> debugger can process symbolic
type data with or without the <code>SUNWzlib</code> or <code>SUNWzlibx</code> packages.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="obtaining-device-tree-information"><a class="anchor" href="#obtaining-device-tree-information"></a>Obtaining Device Tree Information</h5>
<div class="paragraph">
<p>device tree</p>
</div>
<div class="paragraph">
<p>navigating, in debugger</p>
</div>
<div class="paragraph">
<p>navigating device tree with</p>
</div>
<div class="paragraph">
<p>The <code>mdb</code> debugger provides the <code>::prtconf</code> dcmd for displaying the
kernel device tree. The output of the <code>::prtconf</code> dcmd is similar to the
output of the <code>prtconf(8)</code> command.</p>
</div>
<div id="fahqi" class="paragraph">
<p>Using the <code>::prtconf</code> Dcmd</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::prtconf
300015d3e08      SUNW,Sun-Blade-100
    300015d3c28      packages (driver not attached)
        300015d3868      SUNW,builtin-drivers (driver not attached)
        300015d3688      deblocker (driver not attached)
        300015d34a8      disk-label (driver not attached)
        300015d32c8      terminal-emulator (driver not attached)
        300015d30e8      obp-tftp (driver not attached)
        300015d2f08      dropins (driver not attached)
        300015d2d28      kbd-translator (driver not attached)
        300015d2b48      ufs-file-system (driver not attached)
    300015d3a48      chosen (driver not attached)
    300015d2968      openprom (driver not attached)</pre>
</div>
</div>
<div class="paragraph">
<p>You can display the node by using a macro, such as the <code>::devinfo</code> dcmd,
as shown in the following example.</p>
</div>
<div id="fahpi" class="paragraph">
<p>Displaying Device Information for an Individual Node</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; 300015d3e08::devinfo
300015d3e08      SUNW,Sun-Blade-100
        System properties at 0x300015abdc0:
            name='relative-addressing' type=int items=1
                value=00000001
            name='MMU_PAGEOFFSET' type=int items=1
                value=00001fff
            name='MMU_PAGESIZE' type=int items=1
                value=00002000
            name='PAGESIZE' type=int items=1
                value=00002000
        Driver properties at 0x300015abe00:
            name='pm-hardware-state' type=string items=1
                value='no-suspend-resume'</pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>::prtconf</code> to see where your driver has attached in the device
tree, and to display device properties. You can also specify the verbose
(<code>v</code>) flag to <code>::prtconf</code> to display the properties for each device
node, as follows.</p>
</div>
<div id="fahpu" class="paragraph">
<p>Using the <code>::prtconf</code> Dcmd in Verbose Mode</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::prtconf -v
DEVINFO          NAME
300015d3e08      SUNW,Sun-Blade-100
        System properties at 0x300015abdc0:
            name='relative-addressing' type=int items=1
                value=00000001
            name='MMU_PAGEOFFSET' type=int items=1
                value=00001fff
            name='MMU_PAGESIZE' type=int items=1
                value=00002000
            name='PAGESIZE' type=int items=1
                value=00002000
        Driver properties at 0x300015abe00:
            name='pm-hardware-state' type=string items=1
                value='no-suspend-resume'
        ...
        300015ce798      pci10b9,5229, instance #0
                Driver properties at 0x300015ab980:
                    name='target2-dcd-options' type=any items=4
                        value=00.00.00.a4
                    name='target1-dcd-options' type=any items=4
                        value=00.00.00.a2
                    name='target0-dcd-options' type=any items=4
                        value=00.00.00.a4</pre>
</div>
</div>
<div class="paragraph">
<p>Another way to locate instances of your driver is the <code>::devbindings</code>
dcmd. Given a driver name, the command displays a list of all instances
of the named driver as demonstrated in the following example.</p>
</div>
<div id="fahpr" class="paragraph">
<p>Using the <code>::devbindings</code> Dcmd to Locate Driver Instances</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ::devbindings dad
300015ce3d8      ide-disk (driver not attached)
300015c9a60      dad, instance #0
        System properties at 0x300015ab400:
            name='lun' type=int items=1
                value=00000000
            name='target' type=int items=1
                value=00000000
            name='class_prop' type=string items=1
                value='ata'
            name='type' type=string items=1
                value='ata'
            name='class' type=string items=1
                value='dada'
...
300015c9880      dad, instance #1
        System properties at 0x300015ab080:
            name='lun' type=int items=1
                value=00000000
            name='target' type=int items=1
                value=00000002
            name='class_prop' type=string items=1
                value='ata'
            name='type' type=string items=1
                value='ata'
            name='class' type=string items=1
                value='dada'</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="retrieving-driver-soft-state-information"><a class="anchor" href="#retrieving-driver-soft-state-information"></a>Retrieving Driver Soft State Information</h5>
<div class="paragraph">
<p>retrieving soft state information</p>
</div>
<div class="paragraph">
<p>soft state information</p>
</div>
<div class="paragraph">
<p>retrieving in</p>
</div>
<div class="paragraph">
<p>A common problem when debugging a driver is retrieving the <em>soft state</em>
for a particular driver instance. The soft state is allocated with the
<code>ddi_soft_state_zalloc(9F)</code> routine. The driver can obtain
the soft state through <code>ddi_get_soft_state(9F)</code>. The name of
the <em>soft state pointer</em> is the first argument to
<code>ddi_soft_state_init(9F)</code>). With the name, you can use <code>mdb</code>
to retrieve the soft state for a particular driver instance through the
<code>::softstate</code> dcmd:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; *bst_state::softstate 0x3</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>::softstate</code> is used to fetch the soft state for instance
3 of the <code>bst</code> sample driver. This pointer references a <code>bst_soft</code>
structure that is used by the driver to track state for this instance.</p>
</div>
</div>
<div class="sect4">
<h5 id="modifying-kernel-variables"><a class="anchor" href="#modifying-kernel-variables"></a>Modifying Kernel Variables</h5>
<div class="paragraph">
<p>using kernel variables</p>
</div>
<div class="paragraph">
<p>kernel variables</p>
</div>
<div class="paragraph">
<p>use with debuggers</p>
</div>
<div class="paragraph">
<p>You can use both <code>kmdb</code> and <code>mdb</code> to modify kernel variables or other
kernel state. Kernel state modification with <code>mdb</code> should be done with
care, because <code>mdb</code> does not stop the kernel before making
modifications. Groups of modifications can be made atomically by using
<code>kmdb</code>, because <code>kmdb</code> stops the kernel before allowing access by the
user. The <code>mdb</code> debugger is capable of making single atomic
modifications only.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>w</code> – Writes the lowest two bytes of the value of each expression to
the target beginning at the location specified by dot</p>
</li>
<li>
<p><code>W</code> – Writes the lowest 4 bytes of the value of each expression to the
target beginning at the location specified by dot</p>
</li>
<li>
<p><code>Z</code> – Write the complete 8 bytes of the value of each expression to
the target beginning at the location specified by dot</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the <code>::sizeof</code> dcmd to determine the size of the variable to be
modified.</p>
</div>
<div class="paragraph">
<p>The following example overwrites the value of <code>moddebug</code> with the value
0x80000000.</p>
</div>
<div id="fahpy" class="paragraph">
<p>Modifying a Kernel Variable With a Debugger</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; moddebug/W 0x80000000
    moddebug:       0 = 0x80000000</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tuning-drivers"><a class="anchor" href="#tuning-drivers"></a>4.12. Tuning Drivers</h3>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>tuning device drivers</p>
</div>
<div class="paragraph">
<p>illumos provides kernel statistics structures so that you can implement
counters for your driver. The DTrace facility enables you to analyze
performance in real time. This section presents the following topics on
device performance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#kernel-statistics">Kernel Statistics</a> – illumos provides a set of data
structures and functions for capturing performance statistics in the
kernel. Kernel statistics (called <em>kstats</em>) enable your driver to export
continuous statistics while the system is running. The kstat data is
handled programmatically by using the kstat functions.</p>
</li>
<li>
<p><a href="#dtrace-for-dynamic-instrumentation">DTrace for Dynamic Instrumentation</a> – DTrace enables you
to add instrumentation to your driver dynamically so that you can
perform tasks like analyzing the system and measuring performance.
DTrace takes advantage of predefined kstat structures.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="kernel-statistics"><a class="anchor" href="#kernel-statistics"></a>4.12.1. Kernel Statistics</h4>
<div class="paragraph">
<p>device drivers</p>
</div>
<div class="paragraph">
<p>using kstats</p>
</div>
<div class="paragraph">
<p>tuning device drivers</p>
</div>
<div class="paragraph">
<p>kernel statistics</p>
</div>
<div class="paragraph">
<p>To assist in performance tuning, the illumos kernel provides the
<code>kstat(3KSTAT)</code> facility. The kstat facility provides a set of functions
and data structures for device drivers and other kernel modules to
export module-specific kernel statistics.</p>
</div>
<div class="paragraph">
<p>A kstat is a data structure for recording quantifiable aspects of a
device&#8217;s usage. A kstat is stored as a null-terminated linked list. Each
kstat has a common header section and a type-specific data section. The
header section is defined by the <code>kstat_t</code> structure.</p>
</div>
<div class="paragraph">
<p>The article “Using kstat From Within a Program in the Solaris OS” on the
Sun Developer Network at
<a href="http://developers.sun.com/solaris/articles/kstat_api.html" class="bare">http://developers.sun.com/solaris/articles/kstat_api.html</a> provides two
practical examples on how to use the <code>kstat(3KSTAT)</code> and
<code>libkstat(3LIB)</code> APIs to extract metrics from illumos. The examples
include “Walking Through All the kstat” and “Getting NIC kstat Output
Using the Java Platform.”</p>
</div>
<div class="sect4">
<h5 id="kernel-statistics-structure-members"><a class="anchor" href="#kernel-statistics-structure-members"></a>Kernel Statistics Structure Members</h5>
<div class="paragraph">
<p>The members of a kstat structure are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ks_class[KSTAT_STRLEN]</code></dt>
<dd>
<p>Categorizes the kstat type as <code>bus</code>, <code>controller</code>, <code>device_error</code>,
<code>disk</code>, <code>hat</code>, <code>kmem_cache</code>, <code>kstat</code>, <code>misc</code>, <code>net</code>, <code>nfs</code>,
<code>pages</code>, <code>partition</code>, <code>rps</code>, <code>ufs</code>, <code>vm</code>, or <code>vmem</code>.</p>
</dd>
<dt class="hdlist1"><code>ks_crtime</code></dt>
<dd>
<p>Time at which the kstat was created. <code>ks_crtime</code> is commonly used
in calculating rates of various counters.</p>
</dd>
<dt class="hdlist1"><code>ks_data</code></dt>
<dd>
<p>Points to the data section for the kstat.</p>
</dd>
<dt class="hdlist1"><code>ks_data_size</code></dt>
<dd>
<p>Total size of the data section in bytes.</p>
</dd>
<dt class="hdlist1"><code>ks_instance</code></dt>
<dd>
<p>The instance of the kernel module that created this kstat.
<code>ks_instance</code> is combined with <code>ks_module</code> and <code>ks_name</code>
to give the kstat a unique, meaningful name.</p>
</dd>
<dt class="hdlist1"><code>ks_kid</code></dt>
<dd>
<p>Unique ID for the kstat.</p>
</dd>
<dt class="hdlist1"><code>ks_module[KSTAT_STRLEN]</code></dt>
<dd>
<p>Identifies the kernel module that created this kstat. <code>ks_module</code>
is combined with <code>ks_instance</code> and <code>ks_name</code> to give the kstat
a unique, meaningful name. <code>KSTAT_STRLEN</code> sets the maximum length
of <code>ks_module</code>.</p>
</dd>
<dt class="hdlist1"><code>ks_name[KSTAT_STRLEN]</code></dt>
<dd>
<p>A name assigned to the kstat in combination with <code>ks_module</code> and
<code>ks_instance</code>. <code>KSTAT_STRLEN</code> sets the maximum length of
<code>ks_module</code>.</p>
</dd>
<dt class="hdlist1"><code>ks_ndata</code></dt>
<dd>
<p>Indicates the number of data records for those kstat types that
support multiple records: <code>KSTAT_TYPE_RAW</code>,
<code>KSTAT_TYPE_NAMED</code>, and <code>KSTAT_TYPE_TIMER</code></p>
</dd>
<dt class="hdlist1"><code>ks_next</code></dt>
<dd>
<p>Points to next kstat in the chain.</p>
</dd>
<dt class="hdlist1"><code>ks_resv</code></dt>
<dd>
<p>A reserved field.</p>
</dd>
<dt class="hdlist1"><code>ks_snaptime</code></dt>
<dd>
<p>The timestamp for the last data snapshot, useful in calculating rates.</p>
</dd>
<dt class="hdlist1"><code>ks_type</code></dt>
<dd>
<p>The data type, which can be <code>KSTAT_TYPE_RAW</code> for binary data,
<code>KSTAT_TYPE_NAMED</code> for name/value pairs,
<code>KSTAT_TYPE_INTR</code> for interrupt statistics,
<code>KSTAT_TYPE_IO</code> for I/O statistics, and
<code>KSTAT_TYPE_TIMER</code> for event timers.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="kernel-statistics-structures"><a class="anchor" href="#kernel-statistics-structures"></a>Kernel Statistics Structures</h5>
<div class="paragraph">
<p>The structures for the different kinds of kstats are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>kstat(9S)</code></dt>
<dd>
<p>Each kernel statistic (kstat) that is exported by device drivers
consists of a header section and a data section. The <code>kstat(9S)</code>
structure is the header portion of the statistic.</p>
</dd>
<dt class="hdlist1"><code>kstat_intr(9S)</code></dt>
<dd>
<p>Structure for interrupt kstats. The types of interrupts are:
+</p>
<div class="ulist">
<ul>
<li>
<p>Hard interrupt – Sourced from the hardware device itself</p>
</li>
<li>
<p>Soft interrupt – Induced by the system through the use of some
system interrupt source</p>
</li>
<li>
<p>Watchdog interrupt – Induced by a periodic timer call</p>
</li>
<li>
<p>Spurious interrupt – An interrupt entry point was entered but there
was no interrupt to service</p>
</li>
<li>
<p>Multiple service – An interrupt was detected and serviced just prior
to returning from any of the other types
+
Drivers generally report only claimed hard interrupts and soft
interrupts from their handlers, but measurement of the spurious class
of interrupts is useful for auto-vectored devices to locate any
interrupt latency problems in a particular system configuration.
Devices that have more than one interrupt of the same type should use
multiple structures.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>kstat_io(9S)</code></dt>
<dd>
<p>Structure for I/O kstats.</p>
</dd>
<dt class="hdlist1"><code>kstat_named(9S)</code></dt>
<dd>
<p>Structure for named kstats. A named kstat is an array of name-value
pairs. These pairs are kept in the <code>kstat_named</code> structure.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="kernel-statistics-functions"><a class="anchor" href="#kernel-statistics-functions"></a>Kernel Statistics Functions</h5>
<div class="paragraph">
<p>The functions for using kstats are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>kstat_create(9F)</code></dt>
<dd>
<p>Allocate and initialize a <code>kstat(9S)</code> structure.</p>
</dd>
<dt class="hdlist1"><code>kstat_delete(9F)</code></dt>
<dd>
<p>Remove a kstat from the system.</p>
</dd>
<dt class="hdlist1"><code>kstat_install(9F)</code></dt>
<dd>
<p>Add a fully initialized kstat to the system.</p>
</dd>
<dt class="hdlist1"><code>kstat_named_init(9F)</code>, <code>kstat_named_setstr(9F)</code></dt>
<dd>
<p>Initialize a named kstat. <code>kstat_named_setstr</code> associates
<code>str</code>, a string, with the named kstat pointer.</p>
</dd>
<dt class="hdlist1"><code>kstat_queue(9F)</code></dt>
<dd>
<p>A large number of I/O subsystems have at least two basic queues of
transactions to be managed. One queue is for transactions that have
been accepted for processing but for which processing has yet to
begin. The other queue is for transactions that are actively being
processed but not yet done. For this reason, two cumulative time
statistics are kept:_wait time_ and <em>run time</em>. Wait time is prior to
service. Run time is during the service. The <code>kstat_queue</code> family
of functions manages these times based on the transitions between the
driver wait queue and run queue:
+</p>
<div class="ulist">
<ul>
<li>
<p><code>kstat_runq_back_to_waitq(9F)</code></p>
</li>
<li>
<p><code>kstat_runq_enter(9F)</code></p>
</li>
<li>
<p><code>kstat_runq_exit(9F)</code></p>
</li>
<li>
<p><code>kstat_waitq_enter(9F)</code></p>
</li>
<li>
<p><code>kstat_waitq_exit(9F)</code></p>
</li>
<li>
<p><code>kstat_waitq_to_runq(9F)</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="kernel-statistics-for-illumos-ethernet-drivers"><a class="anchor" href="#kernel-statistics-for-illumos-ethernet-drivers"></a>Kernel Statistics for illumos Ethernet Drivers</h5>
<div class="paragraph">
<p>Ethernet drivers</p>
</div>
<div class="paragraph">
<p>The kstat interface described in the following table is an effective way
to obtain Ethernet physical layer statistics from the driver. Ethernet
drivers should export these statistics to guide users in better
diagnosis and repair of Ethernet physical layer problems. With exception
of <code>link_up</code>, all statistics have a default value of 0 when not
present. The value of the <code>link_up</code> statistic should be assumed to
be 1.</p>
</div>
<div class="paragraph">
<p>The following example gives all the shared link setup. In this case
<code>mii</code> is used to filter statistics.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kstat ce:0:mii:link_*</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 23. Ethernet MII/GMII Physical Layer Interface Kernel Statistics</caption>
<colgroup>
<col style="width: 21%;">
<col style="width: 26%;">
<col style="width: 53%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Kstat Variable</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xcvr_addr</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_UINT32</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Provides the MII address of the transceiver that is currently in use.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(0) - (31) are for the MII address of the physical layer device
in use for a given Ethernet device.</p>
</li>
<li>
<p>(-1) is used where there is no externally accessible MII interface,
and therefore the MII address is undefined or irrelevant.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xcvr_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_UINT32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides the specific
vendor ID or device ID of the transceiver that is currently in use.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xcvr_inuse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_UINT32</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the type of transceiver that is currently in use. The IEEE
<code>aPhytType</code> enumerates the following set:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(0) other undefined</p>
</li>
<li>
<p>(1) no MII interface is present, but no transceiver is
connected</p>
</li>
<li>
<p>(2) 10 Mbits/s Clause 7 10 Mbits/s Manchester</p>
</li>
<li>
<p>(3) 100BASE-T4 Clause 23 100 Mbits/s 8B/6T</p>
</li>
<li>
<p>(4) 100BASE-X Clause 24 100 Mbits/s 4B/5B</p>
</li>
<li>
<p>(5) 100BASE-T2 Clause 32 100 Mbits/s PAM5X5</p>
</li>
<li>
<p>(6) 1000BASE-X Clause 36 1000 Mbits/s 8B/10B</p>
</li>
<li>
<p>(7) 1000BASE-T Clause 40 1000 Mbits/s 4D-PAM5</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This set is smaller than the set specified by <code>ifMauType</code>, which is
defined to include all of the above plus their half duplex/full duplex
options. Since this information can be provided by the <code>cap_</code>*
statistics, the missing definitions can be derived from the combination
of <code>xcvr_inuse</code> and <code>cap_</code>* to provide all the combinations
of <code>ifMayType</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_1000fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is 1
Gbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_1000hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is 1
Gbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_100fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is
100 Mbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_100hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is
100 Mbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_10fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is 10
Mbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_10hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is 10
Mbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_asmpause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is
capable of asymmetric pause Ethernet flow control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_pause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the device is capable of symmetric pause Ethernet flow control
when <code>cap_pause</code> is set to 1 and <code>cap_asmpause</code> is set to 0.
When <code>cap_asmpause</code> is set to 1, <code>cap_pause</code> has the following
meaning:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cap_pause</code> = 0 Transmit pauses based on receive congestion.</p>
</li>
<li>
<p><code>cap_pause</code> = 1 Receive pauses and slow down transmit to avoid
congestion.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_rem_fault</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is capable of remote fault indication.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cap_autoneg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the device is
capable of auto-negotiation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_1000fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 1 Gbits/s full duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_1000hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 1 Gbits/s half duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_100fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 100 Mbits/s full duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_100hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 100 Mbits/s half duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_10fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 10 Mbits/s full duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_10hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising 10 Mbits/s half duplex capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_asmpause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising the capability of asymmetric pause Ethernet flow
control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_pause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the device is advertising the capability of symmetric pause
Ethernet flow control when <code>adv_cap_pause</code> is set to 1 and
<code>adv_cap_asmpause</code> is set to 0. When <code>adv_cap_asmpause</code>
is set to 1, <code>adv_cap_pause</code> has the following meaning:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>adv_cap_pause</code> = 0 Transmit pauses based on receive
congestion.</p>
</li>
<li>
<p><code>adv_cap_pause</code> = 1 Receive pauses and slow down transmit to
avoid congestion.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_rem_fault</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is experiencing a fault that it is going to forward to the link
partner.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>adv_cap_autoneg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
device is advertising the capability of auto-negotiation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_1000fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 1 Gbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_1000hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 1 Gbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_100fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 100 Mbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_100hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 100 Mbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_10fdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 10 Mbits/s full duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_10hdx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is 10 Mbits/s half duplex capable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_asmpause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the
link partner device is capable of asymmetric pause Ethernet flow
control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_pause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the link partner device is capable of symmetric pause Ethernet
flow control when <code>lp_cap_pause</code> is set to 1 and
<code>lp_cap_asmpause</code> is set to 0. When <code>lp_cap_asmpause</code> is
set to 1, <code>lp_cap_pause</code> has the following meaning:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lp_cap_pause</code> = 0 Link partner will transmit pauses based on
receive congestion.</p>
</li>
<li>
<p><code>lp_cap_pause</code> = 1 Link partner will receive pauses and slow
down transmit to avoid congestion.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_rem_fault</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner is experiencing a fault with the link.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lp_cap_autoneg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link
partner device is capable of auto-negotiation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>link_asmpause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the link is
operating with asymmetric pause Ethernet flow control.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>link_pause</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the resolution of the pause capability. Indicates the link is
operating with symmetric pause Ethernet flow control when
<code>link_pause</code> is set to 1 and <code>link_asmpause</code> is set to 0. When
<code>link_asmpause</code> is set to 1 and is relative to a local view of the
link, <code>link_pause</code> has the following meaning:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>link_pause</code> = 0 This station will transmit pauses based on
receive congestion.</p>
</li>
<li>
<p><code>link_pause</code> = 1 This station will receive pauses and slow down
transmit to avoid congestion.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>link_duplex</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the link duplex.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>link_duplex</code> = 0 Link is down and duplex is unknown.</p>
</li>
<li>
<p><code>link_duplex</code> = 1 Link is up and in half duplex mode.</p>
</li>
<li>
<p><code>link_duplex</code> = 2 Link is up and in full duplex mode.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>link_up</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KSTAT_DATA_CHAR</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates whether the link is up or down.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>link_up</code> = 0 Link is down.</p>
</li>
<li>
<p><code>link_up</code> = 1 Link is up.</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="dtrace-for-dynamic-instrumentation"><a class="anchor" href="#dtrace-for-dynamic-instrumentation"></a>4.12.2. DTrace for Dynamic Instrumentation</h4>
<div class="paragraph">
<p>tuning device drivers</p>
</div>
<div class="paragraph">
<p>DTrace is a comprehensive dynamic tracing facility for examining the
behavior of both user programs and the operating system itself. With
DTrace, you can collect data at strategic locations in your environment,
referred to as <em>probes</em>. DTrace enables you to record such data as stack
traces, timestamps, the arguments to a function, or simply counts of how
often the probe fires. Because DTrace enables you to insert probes
dynamically, you do not need to recompile your code. For more
information on DTrace, see the Dynamic Tracing Guide and the
<a href="http://www.dtrace.org/guide">DTrace User Guide</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recommended-coding-practices"><a class="anchor" href="#recommended-coding-practices"></a>4.13. Recommended Coding Practices</h3>
<div class="paragraph">
<p>This chapter describes how to write drivers that are robust. Drivers
that are written in accordance with the guidelines that are discussed in
this chapter are easier to debug. The recommended practices also protect
the system from hardware and software faults.</p>
</div>
<div class="paragraph">
<p>This chapter provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#debugging-preparation-techniques">Debugging Preparation Techniques</a></p>
</li>
<li>
<p><a href="#declaring-a-variable-volatile">Declaring a Variable Volatile</a></p>
</li>
<li>
<p><a href="#serviceability">Serviceability</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="debugging-preparation-techniques"><a class="anchor" href="#debugging-preparation-techniques"></a>4.14. Debugging Preparation Techniques</h3>
<div class="paragraph">
<p>Driver code is more difficult to debug than user programs because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The driver interacts directly with the hardware</p>
</li>
<li>
<p>The driver operates without the protection of the operating system
that is available to user processes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Be sure to build debugging support into
your driver. This support facilitates both maintenance work and future
development.</p>
</div>
<div class="sect3">
<h4 id="use-a-unique-prefix-to-avoid-kernel-symbol-collisions"><a class="anchor" href="#use-a-unique-prefix-to-avoid-kernel-symbol-collisions"></a>4.14.1. Use a Unique Prefix to Avoid Kernel Symbol Collisions</h4>
<div class="paragraph">
<p>unique prefix for driver symbols</p>
</div>
<div class="paragraph">
<p>unique prefix for driver symbols</p>
</div>
<div class="paragraph">
<p>The name of each function, data element, and driver preprocessor
definition must be unique for each driver.</p>
</div>
<div class="paragraph">
<p>A driver module is linked into the kernel. The name of each symbol
unique to a particular driver must not collide with other kernel
symbols. To avoid such collisions, each function and data element for a
particular driver must be named with a prefix common to that driver. The
prefix must be sufficient to uniquely name each driver symbol.
Typically, this prefix is the name of the driver or an abbreviation for
the name of the driver. For example, <code>xx_open</code> would be the name of
the <code>open(9E)</code> routine of driver <code>xx</code>.</p>
</div>
<div class="paragraph">
<p>When building a driver, a driver must necessarily include a number of
system header files. The globally-visible names within these header
files cannot be predicted. To avoid collisions with these names, each
driver preprocessor definition must be given a unique name by using an
identifying prefix.</p>
</div>
<div class="paragraph">
<p>A distinguishing driver symbol prefix also is an aid to deciphering
system logs and panics when troubleshooting. Instead of seeing an error
related to an ambiguous <code>attach</code> function, you see an error message
about <code>xx_attach</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="use-cmn_err-to-log-driver-activity"><a class="anchor" href="#use-cmn_err-to-log-driver-activity"></a>4.14.2. Use <code>cmn_err</code> to Log Driver Activity</h4>
<div class="paragraph">
<p>Use the <code>cmn_err(9F)</code> function to print messages to
a system log from within the device driver. The <code>cmn_err(9F)</code>
function for kernel modules is similar to the <code>printf(3C)</code> function for
applications. The <code>cmn_err(9F)</code> function provides additional format
characters, such as the <code>%b</code> format to print device register bits. The
<code>cmn_err(9F)</code> function writes messages to a system log. Use the
<code>tail(1)</code> command to monitor these messages on <code>/var/adm/messages</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% tail -f /var/adm/messages</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="use-assert-to-catch-invalid-assumptions"><a class="anchor" href="#use-assert-to-catch-invalid-assumptions"></a>4.14.3. Use <code>ASSERT</code> to Catch Invalid Assumptions</h4>
<div class="paragraph">
<p>Assertions are an extremely valuable form of active documentation. The
syntax for <code>ASSERT(9F)</code> is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void ASSERT(EXPRESSION)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ASSERT</code> macro halts the execution of the kernel if a condition that
is expected to be true is actually false. <code>ASSERT</code> provides a way for
the programmer to validate the assumptions made by a piece of code.</p>
</div>
<div class="paragraph">
<p>The <code>ASSERT</code> macro is defined only when the <code>DEBUG</code> compilation symbol
is defined. When <code>DEBUG</code> is not defined, the <code>ASSERT</code> macro has no
effect.</p>
</div>
<div class="paragraph">
<p>The following example assertion tests the assumption that a particular
pointer value is not <code>NULL</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ASSERT(ptr != NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>If the driver has been compiled with <code>DEBUG</code>, and if the value of <code>ptr</code>
is <code>NULL</code> at this point in execution, then the following panic message
is printed to the console:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>panic: assertion failed: ptr != NULL, file: driver.c, line: 56</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because <code>ASSERT(9F)</code> uses the <code>DEBUG</code> compilation symbol, any
conditional debugging code should also use <code>DEBUG</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="use-mutex_owned-to-validate-and-document-locking-requirements"><a class="anchor" href="#use-mutex_owned-to-validate-and-document-locking-requirements"></a>4.14.4. Use <code>mutex_owned</code> to Validate and Document Locking Requirements</h4>
<div class="paragraph">
<p>The syntax for <code>mutex_owned(9F)</code> is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int mutex_owned(kmutex_t *mp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A significant portion of driver development involves
properly handling multiple threads. Comments should always be used when
a mutex is acquired. Comments can be even more useful when an apparently
necessary mutex is <em>not</em> acquired. To determine whether a mutex is held
by a thread, use <code>mutex_owned</code> within <code>ASSERT(9F)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void helper(void)
{
    /* this routine should always be called with xsp's mutex held */
    ASSERT(mutex_owned(&amp;xsp-&gt;mu));
    /* ... */
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>mutex_owned</code> is only valid within <code>ASSERT</code> macros. You should use
<code>mutex_owned</code> to control the behavior of a driver.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="use-conditional-compilation-to-toggle-costly-debugging-features"><a class="anchor" href="#use-conditional-compilation-to-toggle-costly-debugging-features"></a>4.14.5. Use Conditional Compilation to Toggle Costly Debugging Features</h4>
<div class="paragraph">
<p>You can insert code for debugging into a driver through
conditional compiles by using a preprocessor symbol such as <code>DEBUG</code> or
by using a global variable. With conditional compilation, unnecessary
code can be removed in the production driver. Use a variable to set the
amount of debugging output at runtime. The output can be specified by
setting a debugging level at runtime with an <code>ioctl</code> or through a
debugger. Commonly, these two methods are combined.</p>
</div>
<div class="paragraph">
<p>The following example relies on the compiler to remove unreachable code,
in this case, the code following the always-false test of zero. The
example also provides a local variable that can be set in <code>/etc/system</code>
or patched by a debugger.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#ifdef DEBUG
/* comments on values of xxdebug and what they do */
static int xxdebug;
#define dcmn_err if (xxdebug) cmn_err
#else
#define dcmn_err if (0) cmn_err
#endif
/* ... */
    dcmn_err(CE_NOTE, "Error!\n");</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method handles the fact that <code>cmn_err(9F)</code> has a variable
number of arguments. Another method relies on the fact that the macro
has one argument, a parenthesized argument list for <code>cmn_err(9F)</code>.
The macro removes this argument. This macro also removes the reliance on
the optimizer by expanding the macro to nothing if <code>DEBUG</code> is not
defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#ifdef DEBUG
/* comments on values of xxdebug and what they do */
static int xxdebug;
#define dcmn_err(X) if (xxdebug) cmn_err X
#else
#define dcmn_err(X) /* nothing */
#endif
/* ... */
/* Note:double parentheses are required when using dcmn_err. */
    dcmn_err((CE_NOTE, "Error!"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can extend this technique in many ways. One way is to specify
different messages from <code>cmn_err(9F)</code>, depending on the value of
<code>xxdebug</code>. However, in such a case, you must be careful not to obscure
the code with too much debugging information.</p>
</div>
<div class="paragraph">
<p>Another common scheme is to write an <code>xxlog</code> function, which uses
<code>vsprintf(9F)</code> or <code>vcmn_err(9F)</code> to handle variable argument lists.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="declaring-a-variable-volatile"><a class="anchor" href="#declaring-a-variable-volatile"></a>4.15. Declaring a Variable Volatile</h3>
<div class="paragraph">
<p><code>volatile</code> is a keyword that must be applied when declaring any variable
that will reference a device register. Without the use of <code>volatile</code>,
the compile-time optimizer can inadvertently delete important accesses.
Neglecting to use <code>volatile</code> might result in bugs that are difficult to
track down.</p>
</div>
<div class="paragraph">
<p>The correct use of <code>volatile</code> is necessary to prevent
elusive bugs. The <code>volatile</code> keyword instructs the compiler to use exact
semantics for the declared objects, in particular, not to remove or
reorder accesses to the object. Two instances where device drivers must
use the <code>volatile</code> qualifier are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When data refers to an external hardware device register, that is,
memory that has side effects other than just storage. Note, however,
that if the DDI data access functions are used to access device
registers, you do not have to use <code>volatile</code>.</p>
</li>
<li>
<p>When data refers to global memory that is accessible by more than one
thread, that is not protected by locks, and that relies on the
sequencing of memory accesses. Using `volatile`consumes fewer resources
than using lock.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example uses <code>volatile</code>. A busy flag is used to prevent a
thread from continuing while the device is busy and the flag is not
protected by a lock:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">while (busy) {
    /* do something else */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The testing thread will continue when another thread turns off the
<code>busy</code> flag:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>busy = 0;</pre>
</div>
</div>
<div class="paragraph">
<p>Because <code>busy</code> is accessed frequently in the testing thread, the
compiler can potentially optimize the test by placing the value of
<code>busy</code> in a register and test the contents of the register without
reading the value of <code>busy</code> in memory before every test. The testing
thread would never see <code>busy</code> change and the other thread would only
change the value of <code>busy</code> in memory, resulting in deadlock. Declaring
the <code>busy</code> flag as <code>volatile</code> forces its value to be read before each
test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An alternative to the <code>busy</code> flag is to use a condition variable. See
<a href="#condition-variables-in-thread-synchronization">Condition Variables in Thread Synchronization</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using the <code>volatile</code> qualifier, avoid the risk of accidental
omission. For example, the following code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct device_reg {
    volatile uint8_t csr;
    volatile uint8_t data;
};
struct device_reg *regp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>is preferable to the next example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct device_reg {
    uint8_t csr;
    uint8_t data;
};
volatile struct device_reg *regp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the two examples are functionally equivalent, the second one
requires the writer to ensure that <code>volatile</code> is used in every
declaration of type <code>struct</code> <code>device_reg</code>. The first example results
in the data being treated as volatile in all declarations and is
therefore preferred. As mentioned above, using the DDI data access
functions to access device registers makes qualifying variables as
<code>volatile</code> unnecessary.</p>
</div>
</div>
<div class="sect2">
<h3 id="_serviceability"><a class="anchor" href="#_serviceability"></a>4.16. Serviceability</h3>
<div class="paragraph">
<p>To ensure serviceability, the driver must be enabled to take the
following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Detect faulty devices and report the
fault</p>
</li>
<li>
<p>Remove a device as supported by the illumos hot-plug
model</p>
</li>
<li>
<p>Add a new device as supported by the illumos hot-plug
model</p>
</li>
<li>
<p>Perform periodic health checks to enable the detection
of latent faults</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_periodic_health_checks"><a class="anchor" href="#_periodic_health_checks"></a>4.16.1. Periodic Health Checks</h4>
<div class="paragraph">
<p>A latent fault is one that does not show
itself until some other action occurs. For example, a hardware failure
occurring in a device that is a cold standby could remain undetected
until a fault occurs on the master device. At this point, the system now
contains two defective devices and might be unable to continue
operation.</p>
</div>
<div class="paragraph">
<p>Latent faults that remain undetected typically cause system failure
eventually. Without latent fault checking, the overall availability of a
redundant system is jeopardized. To avoid this situation, a device
driver must detect latent faults and report them in the same way as
other faults.</p>
</div>
<div class="paragraph">
<p>You should provide the driver with a mechanism for making periodic
health checks on the device. In a fault-tolerant situation where the
device can be the secondary or failover device, early detection of a
failed secondary device is essential to ensure that the secondary device
can be repaired or replaced before any failure in the primary device
occurs.</p>
</div>
<div class="paragraph">
<p>Periodic health checks can be used to perform the following activities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check any register or memory location on the device whose value might
have been altered since the last poll.</p>
<div class="paragraph">
<p>Features of a device that typically exhibit deterministic behavior
include heartbeat semaphores, device timers (for example, local <code>lbolt</code>
used by download), and event counters. Reading an updated predictable
value from the device gives a degree of confidence that things are
proceeding satisfactorily.</p>
</div>
</li>
<li>
<p>Timestamp outgoing requests such as transmit blocks or commands that
are issued by the driver.</p>
<div class="paragraph">
<p>The periodic health check can look for any suspect requests that have
not completed.</p>
</div>
</li>
<li>
<p>Initiate an action on the device that should be completed before the
next scheduled check.</p>
<div class="paragraph">
<p>If this action is an interrupt, this check is an ideal way to ensure
that the device&#8217;s circuitry can deliver an interrupt.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendixes"><a class="anchor" href="#_appendixes"></a>5. Appendixes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The appendixes provide the following background material:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hardware-overview">appendix_title</a> discusses multiplatform hardware
issues for device drivers.</p>
</li>
<li>
<p><a href="#summary-of-illumos-ddidki-services">appendix_title</a> provides tables of kernel
functions for device drivers. Deprecated functions are indicated as
well.</p>
</li>
<li>
<p><a href="#making-a-device-driver-64-bit-ready">appendix_title</a> provides guidelines for updating
a device driver to run in a 64-bit environment.</p>
</li>
<li>
<p><a href="#console-frame-buffer-drivers">appendix_title</a> describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="hardware-overview"><a class="anchor" href="#hardware-overview"></a>5.1. Hardware Overview</h3>
<div class="paragraph">
<p>This appendix discusses general issues about hardware that is capable of
supporting illumos. The discussion includes the processor, bus
architectures, and memory models that are supported by illumos. Various
device issues and the PROM used in Sun platforms are also covered.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The material in this appendix is for informational purposes only. This
information might be of use during driver debugging. However, many of
these implementation details are hidden from device drivers by the
illumos DDI/DKI interfaces.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This appendix provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sparc-processor-issues">SPARC Processor Issues</a></p>
</li>
<li>
<p><a href="#x86-processor-issues">x86 Processor Issues</a></p>
</li>
<li>
<p><a href="#endianness">Endianness</a></p>
</li>
<li>
<p><a href="#store-buffers">Store Buffers</a></p>
</li>
<li>
<p><a href="#system-memory-model">System Memory Model</a></p>
</li>
<li>
<p><a href="#bus-architectures">Bus Architectures</a></p>
</li>
<li>
<p><a href="#bus-specifics">Bus Specifics</a></p>
</li>
<li>
<p><a href="#device-issues">Device Issues</a></p>
</li>
<li>
<p><a href="#prom-on-sparc-machines">PROM on SPARC Machines</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sparc-processor-issues"><a class="anchor" href="#sparc-processor-issues"></a>5.2. SPARC Processor Issues</h3>
<div class="literalblock">
<div class="content">
<pre>  This section describes a
number of SPARC processor-specific topics such as data alignment, byte
ordering, register windows, and availability of floating-point
instructions. For information on x86 processor-specific topics, see
link:#x86-processor-issues[x86 Processor Issues].</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Drivers should never perform floating-point operations, because these
operations are not supported in the kernel.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="sparc-data-alignment"><a class="anchor" href="#sparc-data-alignment"></a>5.2.1. SPARC Data Alignment</h4>
<div class="paragraph">
<p>SPARC processor</p>
</div>
<div class="paragraph">
<p>data alignment</p>
</div>
<div class="paragraph">
<p>data alignment for SPARC</p>
</div>
<div class="paragraph">
<p>All quantities must be aligned on their natural boundaries, using
standard C data types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>short</code> integers are aligned on 16-bit boundaries.</p>
</li>
<li>
<p><code>int</code> integers are aligned on 32-bit boundaries.</p>
</li>
<li>
<p><code>long</code> integers are aligned on 64-bit boundaries for SPARC systems.
For information on data models, see
<a href="#making-a-device-driver-64-bit-ready">appendix_title</a>.</p>
</li>
<li>
<p><code>long long</code> integers are aligned on 64-bit boundaries.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Usually, the compiler handles any alignment issues. However, driver
writers are more likely to be concerned about alignment because the
proper data types must be used to access the devices. Because device
registers are commonly accessed through a pointer reference, drivers
must ensure that pointers are properly aligned when accessing the
device.</p>
</div>
</div>
<div class="sect3">
<h4 id="member-alignment-in-sparc-structures"><a class="anchor" href="#member-alignment-in-sparc-structures"></a>5.2.2. Member Alignment in SPARC Structures</h4>
<div class="paragraph">
<p>SPARC processor</p>
</div>
<div class="paragraph">
<p>structure member alignment</p>
</div>
<div class="paragraph">
<p>Because of the data alignment restrictions imposed by the SPARC
processor, C structures also have alignment requirements. Structure
alignment requirements are imposed by the most strictly aligned
structure component. For example, a structure containing only characters
has no alignment restrictions, while a structure containing a <code>long</code>
<code>long</code> member must be constructed to guarantee that this member falls on
a 64-bit boundary.</p>
</div>
</div>
<div class="sect3">
<h4 id="sparc-byte-ordering"><a class="anchor" href="#sparc-byte-ordering"></a>5.2.3. SPARC Byte Ordering</h4>
<div class="paragraph">
<p>SPARC processor</p>
</div>
<div class="paragraph">
<p>byte ordering</p>
</div>
<div class="paragraph">
<p>The SPARC processor uses <em>big-endian</em> byte ordering. The most
significant byte (MSB) of an integer is stored at the lowest address of
the integer. The least significant byte is stored at the highest address
for words in this processor. For example, byte 63 is the least
significant byte for 64-bit processors.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="figures/hwovr-sparcbyteorder" alt="Diagram shows how bytes are ordered in big-endian architectures" width="that is" height="byte 0 is the most significant byte."></span></p>
</div>
</div>
<div class="sect3">
<h4 id="sparc-register-windows"><a class="anchor" href="#sparc-register-windows"></a>5.2.4. SPARC Register Windows</h4>
<div class="paragraph">
<p>SPARC processor</p>
</div>
<div class="paragraph">
<p>register windows</p>
</div>
<div class="paragraph">
<p>SPARC processors use register windows. Each register window consists of
eight <em>in</em> registers, eight <em>local</em> registers, eight <em>out</em> registers,
and eight <em>global</em> registers. Out registers are the in registers for the
next window. The number of register windows ranges from 2 to 32,
depending on the processor implementation.</p>
</div>
<div class="paragraph">
<p>Because drivers are normally written in C, the compiler
usually hides the fact that register windows are used. However, you
might have to use register windows when debugging the driver.</p>
</div>
</div>
<div class="sect3">
<h4 id="sparc-multiply-and-divide-instructions"><a class="anchor" href="#sparc-multiply-and-divide-instructions"></a>5.2.5. SPARC Multiply and Divide Instructions</h4>
<div class="paragraph">
<p>SPARC processor</p>
</div>
<div class="paragraph">
<p>multiply and divide instructions</p>
</div>
<div class="paragraph">
<p>The Version 7 SPARC processors do not have multiply or
divide instructions. The multiply and divide instructions are emulated
in software. Because a driver might run on a Version 7, Version 8, or
Version 9 processor, avoid intensive integer multiplication and
division. Instead, use bitwise left and right shifts to multiply and
divide by powers of two.</p>
</div>
<div class="paragraph">
<p>The SPARC Architecture Manual, Version 9, contains more specific
information on the SPARC CPU. The SPARC Compliance Definition, Version
2.4, contains details of the application binary interface (ABI) for
SPARC V9. The manual describes the 32-bit SPARC V8 ABI and the 64-bit
SPARC V9 ABI. You can obtain this document from SPARC International at
<a href="http://www.sparc.com" class="bare">http://www.sparc.com</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x86-processor-issues"><a class="anchor" href="#x86-processor-issues"></a>5.3. x86 Processor Issues</h3>
<div class="paragraph">
<p>Data types have
no alignment restrictions. However, extra memory cycles might be
required for the x86 processor to properly handle misaligned data
transfers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Drivers should not perform floating-point operations, as these
operations are not supported in the kernel.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="x86-byte-ordering"><a class="anchor" href="#x86-byte-ordering"></a>5.3.1. x86 Byte Ordering</h4>
<div class="paragraph">
<p>x86 processor</p>
</div>
<div class="paragraph">
<p>byte ordering</p>
</div>
<div class="paragraph">
<p>The x86 processors use <em>little-endian</em> byte ordering. The least
significant byte (LSB) of an integer is stored at the lowest address of
the integer. The most significant byte is stored at the highest address
for data items in this processor. For example, byte 7 is the most
significant byte for 64-bit processors.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="figures/hwovr-iabyteorder" alt="Diagram shows how bytes are ordered in little-endian architectures" width="that is" height="byte 0 is the least significant byte."></span></p>
</div>
</div>
<div class="sect3">
<h4 id="x86-architecture-manuals"><a class="anchor" href="#x86-architecture-manuals"></a>5.3.2. x86 Architecture Manuals</h4>
<div class="paragraph">
<p>Both Intel Corporation and AMD publish a number of books on the x86
family of processors. See <a href="http://www.intel.com" class="bare">http://www.intel.com</a> and <a href="http://www.amd.com/" class="bare">http://www.amd.com/</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="endianness"><a class="anchor" href="#endianness"></a>5.4. Endianness</h3>
<div class="paragraph">
<p>To achieve the goal of multiple-platform,
multiple-instruction-set architecture portability, host bus dependencies
were removed from the drivers. The first dependency issue to be
addressed was the endianness, that is, byte ordering, of the processor.
For example, the x86 processor family is little-endian while the SPARC
architecture is big-endian.</p>
</div>
<div class="paragraph">
<p>Bus architectures display the same endianness types as processors. The
PCI local bus, for example, is little-endian, the SBus is big-endian,
the ISA bus is little-endian, and so on.</p>
</div>
<div class="paragraph">
<p>To maintain portability between processors and buses,
DDI-compliant drivers must be endian neutral. Although drivers can
manage their endianness by runtime checks or by preprocessor directives
like <code>#ifdef _LITTLE_ENDIAN</code> in the source code, long-term
maintenance can be troublesome. In some cases, the DDI framework
performs the byte swapping using a software approach. In other cases,
byte swapping can be done by hardware page-level swapping as in memory
management unit (MMU) or by special machine instructions. The DDI
framework can take advantage of the hardware features to improve
performance.</p>
</div>
<div id="hwovr-fig-67" class="imageblock">
<div class="content">
<img src="figures/hwovr-byteorderbusdepend.png" alt="Diagram shows byte swapping to reverse endianness.">
</div>
<div class="title">Figure 22. Byte Ordering Required for Host Bus Dependency</div>
</div>
<div class="paragraph">
<p>Along with being endian-neutral, portable drivers must also be
independent from data ordering of the processor. Under most
circumstances, data must be transferred in the sequence instructed by
the driver. However, sometimes data can be merged, batched, or reordered
to streamline the data transfer, as illustrated in the following figure.
For example, data merging can be applied to accelerate graphics display
on frame buffers. Drivers have the option to advise the DDI framework to
use other optimal data transfer mechanisms during the transfer.</p>
</div>
<div id="hwovr-fig-69" class="imageblock">
<div class="content">
<img src="figures/hwovr-dataorderbusdepend.png" alt="Diagram shows reordering of bytes by CPU.">
</div>
<div class="title">Figure 23. Data Ordering Host Bus Dependency</div>
</div>
</div>
<div class="sect2">
<h3 id="store-buffers"><a class="anchor" href="#store-buffers"></a>5.5. Store Buffers</h3>
<div class="paragraph">
<p>memory model</p>
</div>
<div class="paragraph">
<p>store buffers</p>
</div>
<div class="paragraph">
<p>store buffers</p>
</div>
<div class="paragraph">
<p>To improve performance, the CPU uses internal store buffers to
temporarily store data. Using internal buffers can affect the
synchronization of device I/O operations. Therefore, the driver needs to
take explicit steps to make sure that writes to registers are completed
at the proper time.</p>
</div>
<div class="paragraph">
<p>For example, consider the case where access to device space, such as
registers or a frame buffer, is synchronized by a lock. The driver needs
to check that the store to the device space has actually completed
before releasing the lock. The release of the lock does not guarantee
the flushing of I/O buffers.</p>
</div>
<div class="paragraph">
<p>To give another example, when acknowledging an interrupt, the driver
usually sets or clears a bit in a device control register. The driver
must ensure that the write to the control register has reached the
device before the interrupt handler returns. Similarly, a device might
require a delay, that is, driver busy-waits, after writing a command to
the control register. In such a case, the driver must ensure that the
write has reached the device before delaying.</p>
</div>
<div class="paragraph">
<p>Where device registers can be read without undesirable side effects,
verification of a write can simply consist of reading the register
immediately after the write. If that particular register cannot be read
without undesirable side effects, another device register in the same
register set can be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="system-memory-model"><a class="anchor" href="#system-memory-model"></a>5.6. System Memory Model</h3>
<div class="paragraph">
<p>The system memory model defines the
semantics of memory operations such as <em>load</em> and <em>store</em> and specifies
how the order in which these operations are issued by a processor is
related to the order in which they reach memory. The memory model
applies to both uniprocessors and shared-memory multiprocessors. Two
memory models are supported: total store ordering (TSO) and partial
store ordering (PSO).</p>
</div>
<div class="sect3">
<h4 id="total-store-ordering-tso"><a class="anchor" href="#total-store-ordering-tso"></a>5.6.1. Total Store Ordering (TSO)</h4>
<div class="paragraph">
<p>TSO guarantees that the sequence in which store, FLUSH, and atomic
load-store instructions appear in memory for a given processor is
identical to the sequence in which they were issued by the processor.</p>
</div>
<div class="paragraph">
<p>Both x86 and SPARC processors support TSO.</p>
</div>
</div>
<div class="sect3">
<h4 id="partial-store-ordering-pso"><a class="anchor" href="#partial-store-ordering-pso"></a>5.6.2. Partial Store Ordering (PSO)</h4>
<div class="paragraph">
<p>PSO does not guarantee that the sequence in which store,
FLUSH, and atomic load-store instructions appear in memory for a given
processor is identical to the sequence in which they were issued by the
processor. The processor can reorder the stores so that the sequence of
stores to memory is not the same as the sequence of stores issued by the
CPU.</p>
</div>
<div class="paragraph">
<p>SPARC processors support PSO; x86 processors do not.</p>
</div>
<div class="paragraph">
<p>For SPARC processors, conformance between <em>issuing</em> order and <em>memory</em>
order is provided by the system framework using the STBAR instruction.
If two of the above instructions are separated by an STBAR instruction
in the issuing order of a processor, or if the instructions reference
the same location, the memory order of the two instructions is the same
as the issuing order. Enforcement of strong data-ordering in
DDI-compliant drivers is provided by the
<code>ddi_regs_map_setup(9F)</code> interface. Compliant drivers cannot
use the STBAR instruction directly.</p>
</div>
<div class="paragraph">
<p>See the SPARC Architecture Manual, Version 9, for more details on the
SPARC memory model.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bus-architectures"><a class="anchor" href="#bus-architectures"></a>5.7. Bus Architectures</h3>
<div class="paragraph">
<p>This section describes device
identification, device addressing, and interrupts.</p>
</div>
<div class="sect3">
<h4 id="device-identification"><a class="anchor" href="#device-identification"></a>5.7.1. Device Identification</h4>
<div class="paragraph">
<p>identification is the process of determining which devices are present
in the system. Some devices are self-identifying meaning that the device
itself provides information to the system so that the system can
identify the device driver that needs to be used. SBus and PCI local bus
devices are examples of self-identifying devices. On SBus, the
information is usually derived from a small Forth program stored in the
FCode PROM on the device. Most PCI devices provide a configuration space
containing device configuration information. See the <code>sbus(5)</code> and
<code>pci(5)</code> man pages for more information.</p>
</div>
<div class="paragraph">
<p>All modern bus architectures require devices to be self-identifying.</p>
</div>
</div>
<div class="sect3">
<h4 id="supported-interrupt-types"><a class="anchor" href="#supported-interrupt-types"></a>5.7.2. Supported Interrupt Types</h4>
<div class="paragraph">
<p>The illumos platform supports both polling and vectored interrupts. The
illumos DDI/DKI interrupt model is the same for both types of
interrupts. See <a href="#interrupt-handlers">Interrupt Handlers</a> for more
information about interrupt handling.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bus-specifics"><a class="anchor" href="#bus-specifics"></a>5.8. Bus Specifics</h3>
<div class="paragraph">
<p>This section covers addressing and device configuration issues specific
to the buses that the illumos platform supports.</p>
</div>
<div class="sect3">
<h4 id="pci-local-bus"><a class="anchor" href="#pci-local-bus"></a>5.8.1. PCI Local Bus</h4>
<div class="literalblock">
<div class="content">
<pre>  The PCI local bus
is a high-performance bus designed for high-speed data transfer. The PCI
bus resides on the system board. This bus is normally used as an
interconnect mechanism between highly integrated peripheral components,
peripheral add-on boards, and host processor or memory systems. The host
processor, main memory, and the PCI bus itself are connected through a
PCI host bridge, as shown in link:#hwovr-fig-23[Machine Block Diagram].</pre>
</div>
</div>
<div class="paragraph">
<p>A tree structure of interconnected I/O buses is supported through a
series of PCI bus bridges. Subordinate PCI bus bridges can be extended
underneath the PCI host bridge to enable a single bus system to be
expanded into a complex system with multiple secondary buses. PCI
devices can be connected to one or more of these secondary buses. In
addition, other bus bridges, such as SCSI or USB, can be connected.</p>
</div>
<div class="paragraph">
<p>Every PCI device has a unique vendor ID and
device ID. Multiple devices of the same kind are further identified by
their unique device numbers on the bus where they reside.</p>
</div>
<div id="hwovr-fig-23" class="imageblock">
<div class="content">
<img src="figures/hwovr-machinediagram.png" alt="Diagram shows how a PCI host bridge connects the CPU and main memory to a PCI bus.">
</div>
<div class="title">Figure 24. Machine Block Diagram</div>
</div>
<div class="paragraph">
<p>The PCI host bridge provides an interconnect between the processor and
peripheral components. Through the PCI host bridge, the processor can
directly access main memory independent of other PCI bus masters. For
example, while the CPU is fetching data from the cache controller in the
host bridge, other PCI devices can also access the system memory through
the host bridge. The advantage of this architecture is that this
architecture separates the I/O bus from the processor&#8217;s host bus.</p>
</div>
<div class="paragraph">
<p>The PCI host bridge also provides data access mappings between the CPU
and peripheral I/O devices. The bridge maps every peripheral device to
the host address domain so that the processor can access the device
through programmed I/O. On the local bus side, the PCI host bridge maps
the system memory to the PCI address domain so that the PCI device can
access the host memory as a bus master. <a href="#hwovr-fig-23">Machine Block
Diagram</a> shows the two address domains.</p>
</div>
</div>
<div class="sect3">
<h4 id="pci-address-domain"><a class="anchor" href="#pci-address-domain"></a>5.8.2. PCI Address Domain</h4>
<div class="paragraph">
<p>The PCI address domain consists of three distinct address spaces:
configuration, memory, and I/O space.</p>
</div>
<div class="sect4">
<h5 id="pci-configuration-address-space"><a class="anchor" href="#pci-configuration-address-space"></a>PCI Configuration Address Space</h5>
<div class="paragraph">
<p>Configuration space is defined
geographically. The location of a peripheral device is determined by its
physical location within an interconnected tree of PCI bus bridges. A
device is located by its <em>bus number</em> and <em>device</em> (<em>slot</em>) <em>number</em>.
Each peripheral device contains a set of well-defined configuration
registers in its PCI configuration space. The registers are used not
only to identify devices but also to supply device configuration
information to the configuration framework. For example, base address
registers in the device configuration space must be mapped before a
device can respond to data access.</p>
</div>
<div class="paragraph">
<p>The method for generating configuration cycles is host dependent. In x86
machines, special I/O ports are used. On other platforms, the PCI
configuration space can be memory-mapped to certain address locations
corresponding to the PCI host bridge in the host address domain. When a
device configuration register is accessed by the processor, the request
is routed to the PCI host bridge. The bridge then translates the access
into proper configuration cycles on the bus.</p>
</div>
</div>
<div class="sect4">
<h5 id="pci-configuration-base-address-registers"><a class="anchor" href="#pci-configuration-base-address-registers"></a>PCI Configuration Base Address Registers</h5>
<div class="paragraph">
<p>The PCI configuration space consists of up
to six 32-bit base address registers for each device. These registers
provide both size and data type information. System firmware assigns
base addresses in the PCI address domain to these registers.</p>
</div>
<div class="paragraph">
<p>Each addressable region can be either memory or I/O space. The value
contained in bit 0 of the base address register identifies the type. A
value of 0 in bit 0 indicates a memory space and a value of 1 indicates
an I/O space. The following figure shows two base address registers: one
for memory and the other for I/O types.</p>
</div>
<div id="hwovr-fig-29" class="imageblock">
<div class="content">
<img src="figures/hwovr-memiobaseaddr.png" alt="Diagram shows how bit 0 in a base address indicates a memory or I/O space.">
</div>
<div class="title">Figure 25. Base Address Registers for Memory and I/O</div>
</div>
</div>
<div class="sect4">
<h5 id="pci-memory-address-space"><a class="anchor" href="#pci-memory-address-space"></a>PCI Memory Address Space</h5>
<div class="paragraph">
<p>PCI supports both 32-bit and 64-bit addresses
for memory space. System firmware assigns regions of memory space in the
PCI address domain to PCI peripherals. The base address of a region is
stored in the base address register of the device&#8217;s PCI configuration
space. The size of each region must be a power of two, and the assigned
base address must be aligned on a boundary equal to the size of the
region. Device addresses in memory space are <em>memory-mapped</em> into the
host address domain so that data access to any device can be performed
by the processor&#8217;s native load or store instructions.</p>
</div>
</div>
<div class="sect4">
<h5 id="pci-io-address-space"><a class="anchor" href="#pci-io-address-space"></a>PCI I/O Address Space</h5>
<div class="paragraph">
<p>PCI supports 32-bit I/O space. I/O space can
be accessed differently on different platforms. Processors with special
I/O instructions, like the Intel processor family, access the I/O space
with <code>in</code> and <code>out</code> instructions. Machines without special I/O
instructions will map to the address locations corresponding to the PCI
host bridge in the host address domain. When the processor accesses the
memory-mapped addresses, an I/O request will be sent to the PCI host
bridge, which then translates the addresses into I/O cycles and puts
them on the PCI bus. Memory-mapped I/O is performed by the native
load/store instructions of the processor.</p>
</div>
</div>
<div class="sect4">
<h5 id="pci-hardware-configuration-files"><a class="anchor" href="#pci-hardware-configuration-files"></a>PCI Hardware Configuration Files</h5>
<div class="paragraph">
<p>configuration files should be unnecessary for PCI local bus devices.
However, on some occasions drivers for PCI devices need to use hardware
configuration files to augment the driver private information. See the
<code>driver.conf(5)</code> and <code>pci(5)</code> man pages for further details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pci-express"><a class="anchor" href="#pci-express"></a>5.8.3. PCI Express</h4>
<div class="paragraph">
<p>The standard PCI bus has evolved into PCI Express. PCI Express is the
next generation high performance I/O bus for connecting peripheral
devices in such applications as desktop, mobile, workstation, server,
embedded computing and communication platforms.</p>
</div>
<div class="paragraph">
<p>PCI Express improves bus performance, reduces overall system cost and
takes advantage of new developments in computer design. PCI Express uses
a serial, point-to-point type interconnect for communication between two
devices. Using switches enables users to connect a large number of
devices together in a system. Serial interconnect implies fewer pins per
device package, which reduces cost and makes the performance highly
scalable.</p>
</div>
<div class="paragraph">
<p>The PCI Express bus has built-in features to accommodate the following
technologies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>QoS (Quality of Service)</p>
</li>
<li>
<p>Hotplugging and hot swap</p>
</li>
<li>
<p>Advanced power management</p>
</li>
<li>
<p>RAS (Reliability, Available, Serviceable)</p>
</li>
<li>
<p>Improved error handling</p>
</li>
<li>
<p>MSI interrupts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A PCI Express interconnect that connects two devices together is called
a <em>link</em>. A link can either be x1, x2, x4, x8, x12, x16 or x32
bidirectional signal pairs. These signals are called <em>lanes</em>. The
bandwidth (x1) of each lane is 500 MB/sec in duplex mode. Although PCI-X
and PCI Express have different hardware connections, the two buses are
identical from a driver writer&#8217;s point of view. PCI-X is a shared bus.
For example, all the devices on the bus share a single set of data lines
and signal lines. PCI-Express is a switched bus, which enables more
efficient use of the bandwidth between the devices and the system bus.</p>
</div>
<div class="paragraph">
<p>For more information on PCI Express, please refer to the following web
site: <a href="http://www.pcisig.com/" class="bare">http://www.pcisig.com/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="sbus"><a class="anchor" href="#sbus"></a>5.8.4. SBus</h4>
<div class="paragraph">
<p>Typical SBus systems consist of a
motherboard (containing the CPU and SBus interface logic), a number of
SBus devices on the motherboard itself, and a number of SBus expansion
slots. An SBus can also be connected to other types of buses through an
appropriate bus bridge.</p>
</div>
<div class="paragraph">
<p>The SBus is geographically addressed. Each
SBus slot exists at a fixed physical address in the system. An SBus card
has a different address, depending on which slot it is plugged into.
Moving an SBus device to a new slot causes the system to treat this
device as a new device.</p>
</div>
<div class="paragraph">
<p>The SBus uses polling interrupts. When an SBus device interrupts, the
system only knows which of several devices might have issued the
interrupt. The system interrupt handler must ask the driver for each
device whether that device is responsible for the interrupt.</p>
</div>
<div class="sect4">
<h5 id="sbus-physical-address-space"><a class="anchor" href="#sbus-physical-address-space"></a>SBus Physical Address Space</h5>
<div class="paragraph">
<p>The following table shows the physical
address space layout of the Sun UltraSPARC 2 computer. A physical
address on the UltraSPARC 2 model consists of 41 bits. The 41-bit
physical address space is further broken down into multiple 33-bit
address spaces identified by <code>PA(40:33)</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 24. Device Physical Space in the Ultra 2</caption>
<colgroup>
<col style="width: 23%;">
<col style="width: 44%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">PA(40:33)</th>
<th class="tableblock halign-left valign-top">33-bit Space</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x000000000 - 0x07FFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 Gbytes main memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x80 – 0xDF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Reserved on Ultra 2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved on Ultra 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xE0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Processor 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Processor 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xE1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Processor 1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Processor 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xE2 – 0xFD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Reserved on Ultra 2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved on Ultra 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x000000000 - 0x1FFFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UPA Slave (FFB)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x000000000 - 0x0FFFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System I/O space</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x100000000 - 0x10FFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x110000000 - 0x11FFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x120000000 - 0x12FFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x130000000 - 0x13FFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot 3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x1D0000000 - 0x1DFFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x1E0000000 - 0x1EFFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot E</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x1F0000000 - 0x1FFFFFFFF</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SBus Slot F</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="physical-sbus-addresses"><a class="anchor" href="#physical-sbus-addresses"></a>Physical SBus Addresses</h5>
<div class="paragraph">
<p>The SBus has 32 address bits, as described
in the SBus Specification. The following table describes how the Ultra 2
uses the address bits.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 25. Ultra 2 SBus Address Bits</caption>
<colgroup>
<col style="width: 23%;">
<col style="width: 77%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bits</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 - 27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">These bits are the SBus address lines used by an SBus card to
address the contents of the card.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">28 - 31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used by the CPU to select one of the SBus slots. These bits
generate the SlaveSelect lines.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This addressing scheme yields the Ultra 2 addresses shown in
<a href="#hwovr-tbl-34">Device Physical Space in the Ultra 2</a>. Other
implementations might use a different number of address bits.</p>
</div>
<div class="paragraph">
<p>The Ultra 2 has seven SBus slots, four of which are physical. Slots 0
through 3 are available for SBus cards. Slots 4-12 are reserved. The
slots are used as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Slots 0-3 are
physical slots that have DMA-master capability.</p>
</li>
<li>
<p>Slots D, E, and F are not actual physical slots, but refer to the
onboard direct memory access (DMA), SCSI, Ethernet, and audio
controllers. For convenience, these classes of devices are viewed as
being plugged into slots D, E, and F.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some SBus slots are slave-only slots. Drivers that require DMA
capability should use <code>ddi_slaveonly(9F)</code> to determine whether their
device is in a DMA-capable slot. For an example of this function, see
<a href="#attach-entry-point"> Entry Point</a>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="sbus-hardware-configuration-files"><a class="anchor" href="#sbus-hardware-configuration-files"></a>SBus Hardware Configuration Files</h5>
<div class="paragraph">
<p>configuration files are normally unnecessary for SBus devices. However,
on some occasions, drivers for SBus devices need to use hardware
configuration files to augment the information provided by the SBus
card. See the <code>driver.conf(5)</code> and <code>sbus(5)</code> man page for further
details.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-issues"><a class="anchor" href="#device-issues"></a>5.9. Device Issues</h3>
<div class="paragraph">
<p>This section describes issues with special devices.</p>
</div>
<div class="sect3">
<h4 id="timing-critical-sections"><a class="anchor" href="#timing-critical-sections"></a>5.9.1. Timing-Critical Sections</h4>
<div class="paragraph">
<p>While most driver operations can be performed without
mechanisms for synchronization and protection beyond those provided by
the locking primitives, some devices require that a sequence of events
occur in order without interruption. In conjunction with the locking
primitives, the function <code>ddi_enter_critical(9F)</code> asks the
system to guarantee, to the best of its ability, that the current thread
will neither be preempted nor interrupted. This guarantee stays in
effect until a closing call to <code>ddi_exit_critical(9F)</code> is made.
See the <code>ddi_enter_critical(9F)</code> man page for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="delays"><a class="anchor" href="#delays"></a>5.9.2. Delays</h4>
<div class="paragraph">
<p>Many chips specify that they can be accessed only at
specified intervals. For example, the Zilog Z8530 SCC has a “write
recovery time” of 1.6 microseconds. This specification means that a
delay must be enforced with <code>drv_usecwait(9F)</code> when writing
characters with an 8530. In some instances, the specifications do not
make explicit what delays are needed, so the delays must be determined
empirically.</p>
</div>
<div class="paragraph">
<p>Be careful not to compound delays for parts of devices that might exist
in large numbers, for example, thousands of SCSI disk drives.</p>
</div>
</div>
<div class="sect3">
<h4 id="internal-sequencing-logic"><a class="anchor" href="#internal-sequencing-logic"></a>5.9.3. Internal Sequencing Logic</h4>
<div class="paragraph">
<p>Devices with internal sequencing logic map multiple
internal registers to the same external address. The various kinds of
internal sequencing logic include the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Intel 8251A and the Signetics 2651
alternate the same external register between <em>two</em> internal mode
registers. Writing to the first internal register is accomplished by
writing to the external register. This write, however, has the side
effect of setting up the sequencing logic in the chip so that the next
read/write operation refers to the second internal register.</p>
</li>
<li>
<p>The NEC PD7201 PCC has multiple internal data registers. To write a
byte into a particular register, two steps must be performed. The first
step is to write into register zero the number of the register into
which the following byte of data will go. The data is then written to
the specified data register. The sequencing logic automatically sets up
the chip so that the next byte sent will go into data register zero.</p>
</li>
<li>
<p>The AMD 9513 timer has a data pointer register that points at the data
register into which a data byte will go. When sending a byte to the data
register, the pointer is incremented. The current value of the pointer
register <em>cannot</em> be read.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="interrupt-issues"><a class="anchor" href="#interrupt-issues"></a>5.9.4. Interrupt Issues</h4>
<div class="paragraph">
<p>Note the following common interrupt-related issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A controller interrupt does <em>not</em> necessarily indicate that <em>both</em> the
controller <em>and</em> one of its slave devices are ready. For some
controllers, an interrupt can indicate that either the controller is
ready or one of its devices is ready but not both.</p>
</li>
<li>
<p>Not all devices power up with interrupts disabled and can begin
interrupting at any time.</p>
</li>
<li>
<p>Some devices do not provide a way to determine that the board has
generated an interrupt.</p>
</li>
<li>
<p>Not all interrupting boards shut off interrupts when told to do so or
after a bus reset.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="prom-on-sparc-machines"><a class="anchor" href="#prom-on-sparc-machines"></a>5.10. PROM on SPARC Machines</h3>
<div class="paragraph">
<p>Some platforms have a PROM monitor that
provides support for debugging a device without an operating system.
This section describes how to use the PROM on SPARC machines to map
device registers so that they can be accessed. Usually, the device can
be exercised enough with PROM commands to determine whether the device
is working correctly.</p>
</div>
<div class="paragraph">
<p>See the <code>boot(8)</code> man page for a description of the x86 boot subsystem.</p>
</div>
<div class="paragraph">
<p>The PROM has several purposes, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bringing the machine up from power on, or from a hard reset PROM
<code>reset</code> command</p>
</li>
<li>
<p>Providing an interactive tool for examining and setting memory, device
registers, and memory mappings</p>
</li>
<li>
<p>Booting the illumos system.</p>
<div class="paragraph">
<p>Simply powering up the computer and attempting to use its PROM to
examine device registers can fail. While the device might be correctly
installed, those mappings are specific to illumos and do not become
active until the illumos kernel is booted. Upon power up, the PROM maps
only essential system devices, such as the keyboard.</p>
</div>
</li>
<li>
<p>Taking a system crash dump using the <code>sync</code> command</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="open-boot-prom-3"><a class="anchor" href="#open-boot-prom-3"></a>5.10.1. Open Boot PROM 3</h4>
<div class="paragraph">
<p>For complete documentation on the Open Boot PROM, see the
Open Boot PROM Toolkit User&#8217;s Guide and the <code>monitor(8)</code> man page. The
examples in this section refer to a Sun4U architecture. Other
architectures might require different commands to perform actions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Open Boot PROM is currently used on Sun machines with an SBus or
UPA/PCI. The Open Boot PROM uses an “<code>ok</code>” prompt. On older machines,
you might have to type `<code>n&#8217; to get the “`ok</code>” prompt.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the PROM is in <em>secure mode</em> (the <code>security-mode</code> parameter is not
set to <em>none</em>), the PROM password might be required (set in the
<code>security-password</code> parameter).</p>
</div>
<div class="paragraph">
<p>The <code>printenv</code> command displays all parameters and their values.</p>
</div>
<div class="paragraph">
<p>Help is available with the <code>help</code> command.</p>
</div>
<div class="paragraph">
<p>EMACS-style command-line history is available. Use Control-N (next) and
Control-P (previous) to traverse the history list.</p>
</div>
<div class="sect4">
<h5 id="forth-commands"><a class="anchor" href="#forth-commands"></a>Forth Commands</h5>
<div class="paragraph">
<p>The Open Boot PROM uses the Forth programming language. Forth is a
stack-based language. Arguments must be pushed on the stack before
running the correct command (called a <em>word</em>), and the result is left on
the stack.</p>
</div>
<div class="paragraph">
<p>To place a number on the stack, type its value.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok 57
ok 68</pre>
</div>
</div>
<div class="paragraph">
<p>To add the two top values on the stack, use the <code>&#43;</code> operator.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok +</pre>
</div>
</div>
<div class="paragraph">
<p>The result remains on the stack. The stack is shown with the <code>.s</code>
<em>word</em>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok .s</pre>
</div>
</div>
<div class="paragraph">
<p>The default base is hexadecimal. The <code>hex</code> and <code>decimal</code> <em>words</em> can be
used to switch bases.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok decimal
ok .s</pre>
</div>
</div>
<div class="paragraph">
<p>See the Forth User&#8217;s Guide for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="walking-the-proms-device-tree"><a class="anchor" href="#walking-the-proms-device-tree"></a>Walking the PROMs Device Tree</h5>
<div class="paragraph">
<p>The commands <code>pwd</code>, <code>cd</code>, and <code>ls</code> walk the PROM device tree to get to
the device. The <code>cd</code> command must be used to establish a position in the
tree before <code>pwd</code> will work. This example is from an Ultra 1 workstation
with a <code>cgsix</code> frame buffer on an SBus.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok cd /</pre>
</div>
</div>
<div class="paragraph">
<p>To see the devices attached to the current node in the tree, use <code>ls</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok ls
f006a064 SUNW,UltraSPARC@0,0
f00598b0 sbus@1f,0
f00592dc counter-timer@1f,3c00
f004eec8 virtual-memory
f004e8e8 memory@0,0
f002ca28 aliases
f002c9b8 options
f002c880 openprom
f002c814 chosen
f002c7a4 packages</pre>
</div>
</div>
<div class="paragraph">
<p>The full node name can be used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok cd sbus@1f,0
ok ls
f006a4e4 cgsix@2,0
f0068194 SUNW,bpp@e,c800000
f0065370 ledma@e,8400010
f006120c espdma@e,8400000
f005a448 SUNW,pll@f,1304000
f005a394 sc@f,1300000
f005a24c zs@f,1000000
f005a174 zs@f,1100000
f005a0c0 eeprom@f,1200000
f0059f8c SUNW,fdtwo@f,1400000
f0059ec4 flashprom@f,0
f0059e34 auxio@f,1900000
f0059d28 SUNW,CS4231@d,c000000</pre>
</div>
</div>
<div class="paragraph">
<p>Rather than using the full node name in the previous example, you could
also use an abbreviation. The abbreviated command-line entry looks like
the following example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok cd sbus</pre>
</div>
</div>
<div class="paragraph">
<p>The name is actually <code>device@slot,offset</code> (for SBus devices). The
<code>cgsix</code> device is in slot 2 and starts at offset 0. If an SBus device is
displayed in this tree, the device has been recognized by the PROM.</p>
</div>
<div class="paragraph">
<p>The <code>.properties</code> command displays the PROM properties of a device.
These properties can be examined to determine which properties the
device exports. This information is useful later to ensure that the
driver is looking for the correct hardware properties. These properties
are the same properties that can be retrieved with
<code>ddi_getprop(9F)</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok cd cgsix
ok .properties
character-set            ISO8859-1
intr                     00000005 00000000
interrupts               00000005
reg                      00000002 00000000 01000000
dblbuf                   00 00 00 00
vmsize                   00 00 00 01
...</pre>
</div>
</div>
<div class="paragraph">
<p>The reg property defines an array of register description structures
containing the following fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint_t        bustype;       /* cookie for related bus type*/
uint_t        addr;          /* address of reg relative to bus */
uint_t        size;          /* size of this register set */</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the <code>cgsix</code> example, the address is 0.</p>
</div>
</div>
<div class="sect4">
<h5 id="mapping-the-device"><a class="anchor" href="#mapping-the-device"></a>Mapping the Device</h5>
<div class="paragraph">
<p>A device must be mapped into memory to be tested. The PROM can then be
used to verify proper operation of the device by using data-transfer
commands to transfer bytes, words, and long words. If the device can be
operated from the PROM, even in a limited way, the driver should also be
able to operate the device.</p>
</div>
<div class="paragraph">
<p>To set up the device for initial testing, perform the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Determine the SBus slot number the device is in.</p>
<div class="paragraph">
<p>In this example, the <code>cgsix</code> device is located in slot 2.</p>
</div>
</li>
<li>
<p>Determine the offset within the physical address space used by the
device.</p>
<div class="paragraph">
<p>The offset used is specific to the device. In the <code>cgsix</code> example, the
video memory happens to start at an offset of 0x800000.</p>
</div>
</li>
<li>
<p>Use the <code>select-dev</code> <em>word</em> to select the Sbus device and the <code>map-in</code>
<em>word</em> to map the device in.</p>
<div class="paragraph">
<p>The <code>select-dev</code> <em>word</em> takes a string of the device path as its
argument. The <code>map-in</code> <em>word</em> takes an <em>offset</em>, a <em>slot number</em>, and a
<em>size</em> as arguments to map. Like the offset, the size of the byte
transfer is specific to the device. In the <code>cgsix</code> example, the size is
set to 0x100000 bytes.</p>
</div>
<div class="paragraph">
<p>In the following code example, the Sbus path is displayed as an argument
to the <code>select-dev</code> word, and the offset, slot number, and size values
for the frame buffer are displayed as arguments to the <code>map-in</code> word.
Notice the space between the opening quote and / in the <code>select-dev</code>
argument. The virtual address to use remains on top of the stack. The
stack is shown using the <code>.s</code> word. The stack can be assigned a name
with the <code>constant</code> operation.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok " sbus@1f,0" select-dev
ok 800000 2 100000 map-in
ok .s
ok constant fb</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reading-and-writing"><a class="anchor" href="#reading-and-writing"></a>5.10.2. Reading and Writing</h4>
<div class="paragraph">
<p>The PROM provides a variety of 8-bit, 16-bit, and 32-bit operations. In
general, a <code>c</code> (character) prefix indicates an 8-bit (one-byte)
operation; a <code>w</code> (word) prefix indicates a 16-bit (two-byte) operation;
and an <code>L</code> (longword) prefix indicates a 32-bit (four-byte) operation.</p>
</div>
<div class="paragraph">
<p>A suffix of <code>!</code> indicates a write operation. The write operation takes
the first two items off the stack. The first item is the address, and
the second item is the value.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok 55 ffe98000 c!</pre>
</div>
</div>
<div class="paragraph">
<p>A suffix of <code>@</code> indicates a read operation. The read operation takes the
address off the stack.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok ffe98000 c@
ok .s</pre>
</div>
</div>
<div class="paragraph">
<p>A suffix of <code>?</code> is used to display the value without affecting the
stack.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok ffe98000 c?</pre>
</div>
</div>
<div class="paragraph">
<p>Be careful when trying to query the device. If the mappings are not set
up correctly, trying to read or write could cause errors. Special words
are provided to handle these cases. <code>cprobe</code>, <code>wprobe</code>, and <code>lprobe</code>,
for example, read from the given address but return zero if the location
does not respond, or nonzero if it does.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok fffa4000 c@
Data Access Error

ok fffa4000 cprobe
ok .s0

ok ffe98000 cprobe
ok .s
0 ffffffffffffffff</pre>
</div>
</div>
<div class="paragraph">
<p>A region of memory can be shown with the <code>dump</code> word. This takes an
&lt;address&gt; and a &lt;length&gt;, and displays the contents of
the memory region in bytes.</p>
</div>
<div class="paragraph">
<p>In the following example, the <code>fill</code> word is used to fill video memory
with a pattern. <code>fill</code> takes the address, the number of bytes to fill,
and the byte to use. Use <code>wfill</code> and an <code>Lfill</code> for words and longwords.
This fill example causes the <code>cgsix</code> to display simple patterns based on
the byte passed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok " /sbus" select-dev
ok 800000 2 100000 map-in
ok constant fb
ok fb 10000 ff fill
ok fb 20000 0 fill
ok fb 18000 55 fill
ok fb 15000 3 fill
ok fb 10000 5 fillok fb 5000 f9 fill</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="summary-of-illumos-ddidki-services"><a class="anchor" href="#summary-of-illumos-ddidki-services"></a>5.11. Summary of illumos DDI/DKI Services</h3>
<div class="paragraph">
<p>DDI function tables</p>
</div>
<div class="paragraph">
<p>This appendix discusses the interfaces provided by the illumos DDI/DKI.
These descriptions should not be considered complete or definitive, nor
do they provide a thorough guide to usage. The descriptions are intended
to describe what the functions do in general terms. See <code>physio(9F)</code> for
more detailed information. The categories are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#module-functions">Module Functions</a></p>
</li>
<li>
<p><a href="#device-information-tree-node-devinfot-functions">Device Information Tree Node () Functions</a></p>
</li>
<li>
<p><a href="#device-dev_t-functions">Device () Functions</a></p>
</li>
<li>
<p><a href="#property-functions">Property Functions</a></p>
</li>
<li>
<p><a href="#device-software-state-functions">Device Software State Functions</a></p>
</li>
<li>
<p><a href="#memory-allocation-and-deallocation-functions">Memory Allocation and Deallocation Functions</a></p>
</li>
<li>
<p><a href="#kernel-thread-control-and-synchronization-functions">Kernel Thread Control and Synchronization
Functions</a></p>
</li>
<li>
<p><a href="#task-queue-management-functions">Task Queue Management Functions</a></p>
</li>
<li>
<p><a href="#interrupt-functions">Interrupt Functions</a></p>
</li>
<li>
<p><a href="#programmed-io-functions">Programmed I/O Functions</a></p>
</li>
<li>
<p><a href="#direct-memory-access-dma-functions">Direct Memory Access (DMA) Functions</a></p>
</li>
<li>
<p><a href="#user-space-access-functions">User Space Access Functions</a></p>
</li>
<li>
<p><a href="#user-process-event-functions">User Process Event Functions</a></p>
</li>
<li>
<p><a href="#user-process-information-functions">User Process Information Functions</a></p>
</li>
<li>
<p><a href="#user-application-kernel-and-device-access-functions">User Application Kernel and Device Access
Functions</a></p>
</li>
<li>
<p><a href="#time-related-functions">Time-Related Functions</a></p>
</li>
<li>
<p><a href="#power-management-functions">Power Management Functions</a></p>
</li>
<li>
<p><a href="#fault-management-functions">Fault Management Functions</a></p>
</li>
<li>
<p><a href="#kernel-statistics-functions">Kernel Statistics Functions</a></p>
</li>
<li>
<p><a href="#kernel-logging-and-printing-functions">Kernel Logging and Printing Functions</a></p>
</li>
<li>
<p><a href="#buffered-io-functions">Buffered I/O Functions</a></p>
</li>
<li>
<p><a href="#virtual-memory-functions">Virtual Memory Functions</a></p>
</li>
<li>
<p><a href="#device-id-functions">Device ID Functions</a></p>
</li>
<li>
<p><a href="#scsi-functions">SCSI Functions</a></p>
</li>
<li>
<p><a href="#resource-map-management-functions">Resource Map Management Functions</a></p>
</li>
<li>
<p><a href="#system-global-state">System Global State</a></p>
</li>
<li>
<p><a href="#utility-functions">Utility Functions</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This appendix does not discuss STREAMS interfaces; to learn more about
network drivers, see the STREAMS Programming Guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="module-functions"><a class="anchor" href="#module-functions"></a>5.12. Module Functions</h3>
<div class="paragraph">
<p>module functions</p>
</div>
<div class="paragraph">
<p>loadable module functions</p>
</div>
<div class="paragraph">
<p>individual functions</p>
</div>
<div class="paragraph">
<p>The module functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mod_info</code></dt>
<dd>
<p>Query a loadable module</p>
</dd>
<dt class="hdlist1"><code>mod_install</code></dt>
<dd>
<p>Add a loadable module</p>
</dd>
<dt class="hdlist1"><code>mod_remove</code></dt>
<dd>
<p>Remove a loadable module</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="device-information-tree-node-devinfot-functions"><a class="anchor" href="#device-information-tree-node-devinfot-functions"></a>5.13. Device Information Tree Node (<code>dev_info_t</code>) Functions</h3>
<div class="paragraph">
<p>dev_info_t</p>
</div>
<div class="paragraph">
<p>The device information tree node functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_binding_name</code></dt>
<dd>
<p>Return driver binding name</p>
</dd>
<dt class="hdlist1"><code>ddi_dev_is_sid</code></dt>
<dd>
<p>Tell whether a device is self-identifying</p>
</dd>
<dt class="hdlist1"><code>ddi_driver_major</code></dt>
<dd>
<p>Return driver major device number</p>
</dd>
<dt class="hdlist1"><code>ddi_driver_name</code></dt>
<dd>
<p>Return normalized driver name</p>
</dd>
<dt class="hdlist1"><code>ddi_node_name</code></dt>
<dd>
<p>Return the <code>devinfo</code> node name</p>
</dd>
<dt class="hdlist1"><code>ddi_get_devstate</code></dt>
<dd>
<p>Check device state</p>
</dd>
<dt class="hdlist1"><code>ddi_get_instance</code></dt>
<dd>
<p>Get device instance number</p>
</dd>
<dt class="hdlist1"><code>ddi_get_name</code></dt>
<dd>
<p>Return driver binding name</p>
</dd>
<dt class="hdlist1"><code>ddi_get_parent</code></dt>
<dd>
<p>Find the parent of a device information structure</p>
</dd>
<dt class="hdlist1"><code>ddi_root_node</code></dt>
<dd>
<p>Get the root of the <code>dev_info</code> tree</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="device-dev_t-functions"><a class="anchor" href="#device-dev_t-functions"></a>5.14. Device (<code>dev_t</code>) Functions</h3>
<div class="paragraph">
<p>dev_t</p>
</div>
<div class="paragraph">
<p>The device functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_create_minor_node</code></dt>
<dd>
<p>Create a minor node for a device</p>
</dd>
<dt class="hdlist1"><code>ddi_getiminor</code></dt>
<dd>
<p>Get kernel internal minor number from an external <code>dev_t</code></p>
</dd>
<dt class="hdlist1"><code>ddi_remove_minor_node</code></dt>
<dd>
<p>Remove a minor mode for a device</p>
</dd>
<dt class="hdlist1"><code>getmajor</code></dt>
<dd>
<p>Get major device number</p>
</dd>
<dt class="hdlist1"><code>getminor</code></dt>
<dd>
<p>Get minor device number</p>
</dd>
<dt class="hdlist1"><code>makedevice</code></dt>
<dd>
<p>Make device number from major and minor numbers</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="property-functions"><a class="anchor" href="#property-functions"></a>5.15. Property Functions</h3>
<div class="paragraph">
<p>property functions</p>
</div>
<div class="paragraph">
<p>The property functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_prop_exists</code></dt>
<dd>
<p>Check for the existence of a property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_free</code></dt>
<dd>
<p>Free resources consumed by property lookup</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_get_int</code></dt>
<dd>
<p>Look up integer property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_get_int64</code></dt>
<dd>
<p>Look up 64-bit integer property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_lookup_byte_array</code></dt>
<dd>
<p>Look up byte array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_lookup_int_array</code></dt>
<dd>
<p>Look up integer array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_lookup_int64_array</code></dt>
<dd>
<p>Look up 64-bit integer array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_lookup_string</code></dt>
<dd>
<p>Look up string property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_lookup_string_array</code></dt>
<dd>
<p>Look up string array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_remove</code></dt>
<dd>
<p>Remove a property of a device</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_remove_all</code></dt>
<dd>
<p>Remove all properties of a device</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_undefine</code></dt>
<dd>
<p>Hide a property of a device</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_byte_array</code></dt>
<dd>
<p>Create or update byte array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_int</code></dt>
<dd>
<p>Create or update integer property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_int64</code></dt>
<dd>
<p>Create or update 64-bit integer property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_int_array</code></dt>
<dd>
<p>Create or update integer array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_int64_array</code></dt>
<dd>
<p>Create or update 64-bit integer array property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_string</code></dt>
<dd>
<p>Create or update string property</p>
</dd>
<dt class="hdlist1"><code>ddi_prop_update_string_array</code></dt>
<dd>
<p>Create or update string array property</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 26. Deprecated Property Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Functions</th>
<th class="tableblock halign-left valign-top">Replacements</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getlongprop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">see <code>ddi_prop_lookup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getlongprop_buf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getprop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_get_int</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getproplen</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_modify</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_op</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_prop_lookup</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="device-software-state-functions"><a class="anchor" href="#device-software-state-functions"></a>5.16. Device Software State Functions</h3>
<div class="paragraph">
<p>software state functions</p>
</div>
<div class="paragraph">
<p>The device software state functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_get_driver_private</code></dt>
<dd>
<p>Get the address of the device&#8217;s private data area</p>
</dd>
<dt class="hdlist1"><code>ddi_get_soft_state</code></dt>
<dd>
<p>Get pointer to instance soft-state structure</p>
</dd>
<dt class="hdlist1"><code>ddi_set_driver_private</code></dt>
<dd>
<p>Set the address of the device&#8217;s private data area</p>
</dd>
<dt class="hdlist1"><code>ddi_soft_state_fini</code></dt>
<dd>
<p>Destroy driver soft-state structure</p>
</dd>
<dt class="hdlist1"><code>ddi_soft_state_free</code></dt>
<dd>
<p>Free instance soft-state structure</p>
</dd>
<dt class="hdlist1"><code>ddi_soft_state_init</code></dt>
<dd>
<p>Initialize driver soft-state structure</p>
</dd>
<dt class="hdlist1"><code>ddi_soft_state_zalloc</code></dt>
<dd>
<p>Allocate instance soft-state structure</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="memory-allocation-and-deallocation-functions"><a class="anchor" href="#memory-allocation-and-deallocation-functions"></a>5.17. Memory Allocation and Deallocation Functions</h3>
<div class="paragraph">
<p>memory allocation functions</p>
</div>
<div class="paragraph">
<p>The memory allocation and deallocation functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>kmem_alloc</code></dt>
<dd>
<p>Allocate kernel memory</p>
</dd>
<dt class="hdlist1"><code>kmem_free</code></dt>
<dd>
<p>Free kernel memory</p>
</dd>
<dt class="hdlist1"><code>kmem_zalloc</code></dt>
<dd>
<p>Allocate zero-filled kernel memory</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following functions allocate and free memory intended
to be used for DMA. See <a href="#direct-memory-access-dma-functions">Direct Memory Access (DMA)
Functions</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_dma_mem_alloc</code></dt>
<dd>
<p>Allocate memory for DMA transfer</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_mem_free</code></dt>
<dd>
<p>Free previously allocated DMA memory</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following functions allocate and free memory intended to be exported
to user space. See <a href="#user-space-access-functions">User Space Access Functions</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_umem_alloc</code></dt>
<dd>
<p>Allocate page-aligned kernel memory</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_free</code></dt>
<dd>
<p>Free page-aligned kernel memory</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 27. Deprecated Memory Allocation and Deallocation Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_iopb_alloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_alloc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_iopb_free</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_free</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_alloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_alloc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_free</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_free</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="kernel-thread-control-and-synchronization-functions"><a class="anchor" href="#kernel-thread-control-and-synchronization-functions"></a>5.18. Kernel Thread Control and Synchronization Functions</h3>
<div class="paragraph">
<p>condition variable functions</p>
</div>
<div class="paragraph">
<p>kernel thread functions</p>
</div>
<div class="paragraph">
<p>The kernel thread control and synchronization functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>cv_broadcast</code></dt>
<dd>
<p>Wake up all waiting threads</p>
</dd>
<dt class="hdlist1"><code>cv_destroy</code></dt>
<dd>
<p>Free an allocated condition variable</p>
</dd>
<dt class="hdlist1"><code>cv_init</code></dt>
<dd>
<p>Allocate a condition variable</p>
</dd>
<dt class="hdlist1"><code>cv_signal</code></dt>
<dd>
<p>Wake up one waiting thread</p>
</dd>
<dt class="hdlist1"><code>cv_timedwait</code></dt>
<dd>
<p>Await an event with timeout</p>
</dd>
<dt class="hdlist1"><code>cv_timedwait_sig</code></dt>
<dd>
<p>Await an event or signal with timeout</p>
</dd>
<dt class="hdlist1"><code>cv_wait</code></dt>
<dd>
<p>Await an event</p>
</dd>
<dt class="hdlist1"><code>cv_wait_sig</code></dt>
<dd>
<p>Await an event or signal</p>
</dd>
<dt class="hdlist1"><code>ddi_can_receive_sig</code></dt>
<dd>
<p>Determine whether the current thread can receive a signal</p>
</dd>
<dt class="hdlist1"><code>ddi_enter_critical</code></dt>
<dd>
<p>Enter a critical region of control</p>
</dd>
<dt class="hdlist1"><code>ddi_exit_critical</code></dt>
<dd>
<p>Exit a critical region of control</p>
</dd>
<dt class="hdlist1"><code>mutex_destroy</code></dt>
<dd>
<p>Destroy mutual exclusion lock</p>
</dd>
<dt class="hdlist1"><code>mutex_enter</code></dt>
<dd>
<p>Acquire mutual exclusion lock</p>
</dd>
<dt class="hdlist1"><code>mutex_exit</code></dt>
<dd>
<p>Release mutual exclusion lock</p>
</dd>
<dt class="hdlist1"><code>mutex_init</code></dt>
<dd>
<p>Initialize mutual exclusion lock</p>
</dd>
<dt class="hdlist1"><code>mutex_owned</code></dt>
<dd>
<p>Determine whether current thread is holding mutual exclusion lock</p>
</dd>
<dt class="hdlist1"><code>mutex_tryenter</code></dt>
<dd>
<p>Attempt to acquire mutual exclusion lock without waiting</p>
</dd>
<dt class="hdlist1"><code>rw_destroy</code></dt>
<dd>
<p>Destroy a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_downgrade</code></dt>
<dd>
<p>Downgrade a readers/writer lock holding from writer to reader</p>
</dd>
<dt class="hdlist1"><code>rw_enter</code></dt>
<dd>
<p>Acquire a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_exit</code></dt>
<dd>
<p>Release a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_init</code></dt>
<dd>
<p>Initialize a readers/writer lock</p>
</dd>
<dt class="hdlist1"><code>rw_read_locked</code></dt>
<dd>
<p>Determine whether readers/writer lock is held for read or write</p>
</dd>
<dt class="hdlist1"><code>rw_tryenter</code></dt>
<dd>
<p>Attempt to acquire a readers/writer lock without waiting</p>
</dd>
<dt class="hdlist1"><code>rw_tryupgrade</code></dt>
<dd>
<p>Attempt to upgrade readers/writer lock holding from reader to writer</p>
</dd>
<dt class="hdlist1"><code>sema_destroy</code></dt>
<dd>
<p>Destroy a semaphore</p>
</dd>
<dt class="hdlist1"><code>sema_init</code></dt>
<dd>
<p>Initialize a semaphore</p>
</dd>
<dt class="hdlist1"><code>sema_p</code></dt>
<dd>
<p>Decrement semaphore and possibly block</p>
</dd>
<dt class="hdlist1"><code>sema_p_sig</code></dt>
<dd>
<p>Decrement semaphore but do not block if signal is pending</p>
</dd>
<dt class="hdlist1"><code>sema_tryp</code></dt>
<dd>
<p>Attempt to decrement semaphore but do not block</p>
</dd>
<dt class="hdlist1"><code>sema_v</code></dt>
<dd>
<p>Increment semaphore and possibly unblock waiter</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="task-queue-management-functions"><a class="anchor" href="#task-queue-management-functions"></a>5.19. Task Queue Management Functions</h3>
<div class="paragraph">
<p>task queues</p>
</div>
<div class="paragraph">
<p>The task queue management functions are listed below. See the
<code>taskq(9F)</code> man page for more information about these interfaces.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_taskq_create</code></dt>
<dd>
<p>Create a task queue</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_destroy</code></dt>
<dd>
<p>Destroy a task queue</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_dispatch</code></dt>
<dd>
<p>Add a task to a task queue</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_wait</code></dt>
<dd>
<p>Wait for pending tasks to complete</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_suspend</code></dt>
<dd>
<p>Suspend a task queue</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_suspended</code></dt>
<dd>
<p>Check whether a task queue is suspended</p>
</dd>
<dt class="hdlist1"><code>ddi_taskq_resume</code></dt>
<dd>
<p>Resume a suspended task queue</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-functions"><a class="anchor" href="#interrupt-functions"></a>5.20. Interrupt Functions</h3>
<div class="paragraph">
<p>interrupt functions</p>
</div>
<div class="paragraph">
<p>The interrupt functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_intr_add_handler(9F)</code></dt>
<dd>
<p>Adds an interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_add_softint(9F)</code></dt>
<dd>
<p>Adds a soft interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_alloc(9F)</code></dt>
<dd>
<p>Allocates system resources and interrupt vectors for the specified
type of interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_block_disable(9F)</code></dt>
<dd>
<p>Disables the specified range of interrupts. For MSI only.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_block_enable(9F)</code></dt>
<dd>
<p>Enables the specified range of interrupts. For MSI only.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_clr_mask(9F)</code></dt>
<dd>
<p>Clears an interrupt mask if the specified interrupt is enabled.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_disable(9F)</code></dt>
<dd>
<p>Disables the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_dup_handler(9F)</code></dt>
<dd>
<p>Use with MSI-X only. Copies an address and data pair for an allocated
interrupt vector to an unused interrupt vector on the same device.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_enable(9F)</code></dt>
<dd>
<p>Enables the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_free(9F)</code></dt>
<dd>
<p>Releases the system resources and interrupt vectors for a specified
interrupt handle.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_cap(9F)</code></dt>
<dd>
<p>Returns interrupt capability flags for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_hilevel_pri(9F)</code></dt>
<dd>
<p>Returns the minimum priority level for a high-level interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_navail(9F)</code></dt>
<dd>
<p>Returns the number of interrupts available for a particular hardware
device and given interrupt type.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_nintrs(9F)</code></dt>
<dd>
<p>Get the number of interrupts that the device supports for the given
interrupt type.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_pending(9F)</code></dt>
<dd>
<p>Read the interrupt pending bit if one is supported by either the host
bridge or the device.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_pri(9F)</code></dt>
<dd>
<p>Returns the current software priority setting for the specified
interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_softint_pri(9F)</code></dt>
<dd>
<p>Returns the soft interrupt priority for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_get_supported_types(9F)</code></dt>
<dd>
<p>Returns the hardware interrupt types that are supported by both the
device and the host.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_remove_handler(9F)</code></dt>
<dd>
<p>Removes the specified interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_remove_softint(9F)</code></dt>
<dd>
<p>Remove the specified soft interrupt handler.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_cap(9F)</code></dt>
<dd>
<p>Sets the DDI_INTR_FLAG_LEVEL or
DDI_INTR_FLAG_EDGE flag for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_mask(9F)</code></dt>
<dd>
<p>Sets an interrupt mask if the specified interrupt is enabled.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_pri(9F)</code></dt>
<dd>
<p>Sets the interrupt priority level for the specified interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_set_softint_pri(9F)</code></dt>
<dd>
<p>Changes the relative soft interrupt priority for the specified soft
interrupt.</p>
</dd>
<dt class="hdlist1"><code>ddi_intr_trigger_softint(9F)</code></dt>
<dd>
<p>Trigger the specified soft interrupt.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To take advantage of the features of the new framework, use the above
interfaces. Do not use the deprecated interfaces that are listed in the
following table. These deprecated interfaces are retained for
compatibility purposes only.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 28. Deprecated Interrupt Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Interrupt Functions</th>
<th class="tableblock halign-left valign-top">Replacements</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_add_intr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Three-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ddi_intr_alloc(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_add_handler(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_enable(9F)</code></p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_add_softintr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_intr_add_softint(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dev_nintrs(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_intr_get_nintrs(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get_iblock_cookie(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Three-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ddi_intr_alloc(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_get_pri(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_free(9F)</code></p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get_soft_iblock_cookie(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Three-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ddi_intr_add_softint(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_get_softint_pri(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_remove_softint(9F)</code></p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_intr_hilevel(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Three-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ddi_intr_alloc(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_get_hilevel_pri(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_free(9F)</code></p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_remove_intr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Three-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ddi_intr_disable(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_remove_handler(9F)</code></p>
</li>
<li>
<p><code>ddi_intr_free(9F)</code></p>
</li>
</ol>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_remove_softintr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_intr_remove_softint(9F)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_trigger_softintr(9F)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_intr_trigger_softint(9F)</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="programmed-io-functions"><a class="anchor" href="#programmed-io-functions"></a>5.21. Programmed I/O Functions</h3>
<div class="paragraph">
<p>programmed I/O functions</p>
</div>
<div class="paragraph">
<p>The programmed I/O functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_dev_nregs</code></dt>
<dd>
<p>Return the number of register sets a device has</p>
</dd>
<dt class="hdlist1"><code>ddi_dev_regsize</code></dt>
<dd>
<p>Return the size of a device&#8217;s register</p>
</dd>
<dt class="hdlist1"><code>ddi_regs_map_setup</code></dt>
<dd>
<p>Set up a mapping for a register address space</p>
</dd>
<dt class="hdlist1"><code>ddi_regs_map_free</code></dt>
<dd>
<p>Free a previously mapped register address space</p>
</dd>
<dt class="hdlist1"><code>ddi_device_copy</code></dt>
<dd>
<p>Copy data from one device register to another device register</p>
</dd>
<dt class="hdlist1"><code>ddi_device_zero</code></dt>
<dd>
<p>Zero fill the device</p>
</dd>
<dt class="hdlist1"><code>ddi_check_acc_handle</code></dt>
<dd>
<p>Check data access handle</p>
</dd>
<dt class="hdlist1"><code>ddi_get8</code></dt>
<dd>
<p>Read 8-bit data from mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_get16</code></dt>
<dd>
<p>Read 16-bit data from mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_get32</code></dt>
<dd>
<p>Read 32-bit data from mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_get64</code></dt>
<dd>
<p>Read 64-bit data from mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_put8</code></dt>
<dd>
<p>Write 8-bit data to mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_put16</code></dt>
<dd>
<p>Write 16-bit data to mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_put32</code></dt>
<dd>
<p>Write 32-bit data to mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_put64</code></dt>
<dd>
<p>Write 64-bit data to mapped memory, device register, or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_get8</code></dt>
<dd>
<p>Read multiple 8-bit data from mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_get16</code></dt>
<dd>
<p>Read multiple 16-bit data from mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_get32</code></dt>
<dd>
<p>Read multiple 32-bit data from mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_get64</code></dt>
<dd>
<p>Read multiple 64-bit data from mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_put8</code></dt>
<dd>
<p>Write multiple 8-bit data to mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_put16</code></dt>
<dd>
<p>Write multiple 16-bit data to mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_put32</code></dt>
<dd>
<p>Write multiple 32-bit data to mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_rep_put64</code></dt>
<dd>
<p>Write multiple 64-bit data to mapped memory, device register, or DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_peek8</code></dt>
<dd>
<p>Cautiously read an 8-bit value from a location</p>
</dd>
<dt class="hdlist1"><code>ddi_peek16</code></dt>
<dd>
<p>Cautiously read a 16-bit value from a location</p>
</dd>
<dt class="hdlist1"><code>ddi_peek32</code></dt>
<dd>
<p>Cautiously read a 32-bit value from a location</p>
</dd>
<dt class="hdlist1"><code>ddi_peek64</code></dt>
<dd>
<p>Cautiously read a 64-bit value from a location</p>
</dd>
<dt class="hdlist1"><code>ddi_poke8</code></dt>
<dd>
<p>Cautiously write an 8-bit value to a location</p>
</dd>
<dt class="hdlist1"><code>ddi_poke16</code></dt>
<dd>
<p>Cautiously write a 16-bit value to a location</p>
</dd>
<dt class="hdlist1"><code>ddi_poke32</code></dt>
<dd>
<p>Cautiously write a 32-bit value to a location</p>
</dd>
<dt class="hdlist1"><code>ddi_poke64</code></dt>
<dd>
<p>Cautiously write a 64-bit value to a location</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The general programmed I/O functions
listed above can always be used rather than the <code>mem</code>, <code>io</code>, and
<code>pci_config</code> functions that follow. However, the following functions
can be used as alternatives in cases where the type of access is known
at compile time.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_io_get8</code></dt>
<dd>
<p>Read 8-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_get16</code></dt>
<dd>
<p>Read 16-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_get32</code></dt>
<dd>
<p>Read 32-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_put8</code></dt>
<dd>
<p>Write 8-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_put16</code></dt>
<dd>
<p>Write 16-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_put32</code></dt>
<dd>
<p>Write 32-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_get8</code></dt>
<dd>
<p>Read multiple 8-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_get16</code></dt>
<dd>
<p>Read multiple 16-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_get32</code></dt>
<dd>
<p>Read multiple 32-bit data from a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_put8</code></dt>
<dd>
<p>Write multiple 8-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_put16</code></dt>
<dd>
<p>Write multiple 16-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_io_rep_put32</code></dt>
<dd>
<p>Write multiple 32-bit data to a mapped device register in I/O space</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_get8</code></dt>
<dd>
<p>Read 8-bit data from a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_get16</code></dt>
<dd>
<p>Read 16-bit data from a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_get32</code></dt>
<dd>
<p>Read 32-bit data from a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_get64</code></dt>
<dd>
<p>Read 64-bit data from a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_put8</code></dt>
<dd>
<p>Write 8-bit data to a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_put16</code></dt>
<dd>
<p>Write 16-bit data to a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_put32</code></dt>
<dd>
<p>Write 32-bit data to a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_put64</code></dt>
<dd>
<p>Write 64-bit data to a mapped device in memory space or DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_get8</code></dt>
<dd>
<p>Read multiple 8-bit data from a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_get16</code></dt>
<dd>
<p>Read multiple 16-bit data from a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_get32</code></dt>
<dd>
<p>Read multiple 32-bit data from a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_get64</code></dt>
<dd>
<p>Read multiple 64-bit data from a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_put8</code></dt>
<dd>
<p>Write multiple 8-bit data to a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_put16</code></dt>
<dd>
<p>Write multiple 16-bit data to a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_put32</code></dt>
<dd>
<p>Write multiple 32-bit data to a mapped device in memory space or DMA
memory</p>
</dd>
<dt class="hdlist1"><code>ddi_mem_rep_put64</code></dt>
<dd>
<p>Write multiple 64-bit data to a mapped device in memory space or DMA</p>
</dd>
<dt class="hdlist1"><code>pci_config_setup</code></dt>
<dd>
<p>Set up access to PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_teardown</code></dt>
<dd>
<p>Tear down access to PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_get8</code></dt>
<dd>
<p>Read 8-bit data from the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_get16</code></dt>
<dd>
<p>Read 16-bit data from the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_get32</code></dt>
<dd>
<p>Read 32-bit data from the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_get64</code></dt>
<dd>
<p>Read 64-bit data from the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_put8</code></dt>
<dd>
<p>Write 8-bit data to the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_put16</code></dt>
<dd>
<p>Write 16-bit data to the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_put32</code></dt>
<dd>
<p>Write 32-bit data to the PCI Local Bus Configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_config_put64</code></dt>
<dd>
<p>Write 64-bit data to the PCI Local Bus Configuration space</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 29. Deprecated Programmed I/O Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_map_regs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_regs_map_setup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_getll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_get64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_putll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_put64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_getll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_get64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_putll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_put64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_rep_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peekc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peek8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peekd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peek64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peekl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peek32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peeks</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_peek16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_pokec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_poke8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_poked</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_poke64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_pokel</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_poke32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_pokes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_poke16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_putll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_put64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_getll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_get64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_putll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_put64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_rep_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_unmap_regs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_regs_map_free</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>inb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>inl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>inw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_getb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_getl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_getll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_get64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_getw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_putb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_putl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_putll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_put64</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_putw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pci_config_put16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repinsb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repinsd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repinsw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_get16</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repoutsb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put8</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repoutsd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put32</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repoutsw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_io_rep_put16</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="direct-memory-access-dma-functions"><a class="anchor" href="#direct-memory-access-dma-functions"></a>5.22. Direct Memory Access (DMA) Functions</h3>
<div class="paragraph">
<p>DMA functions</p>
</div>
<div class="paragraph">
<p>The DMA functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_dma_alloc_handle</code></dt>
<dd>
<p>Allocate a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_free_handle</code></dt>
<dd>
<p>Free a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_mem_alloc</code></dt>
<dd>
<p>Allocate memory for a DMA transfer</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_mem_free</code></dt>
<dd>
<p>Free previously allocated DMA memory</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_addr_bind_handle</code></dt>
<dd>
<p>Bind an address to a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_buf_bind_handle</code></dt>
<dd>
<p>Bind a system buffer to a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_unbind_handle</code></dt>
<dd>
<p>Unbind the address in a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_nextcookie</code></dt>
<dd>
<p>Retrieve the subsequent DMA cookie</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_getwin</code></dt>
<dd>
<p>Activate a new DMA window</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_numwin</code></dt>
<dd>
<p>Retrieve number of DMA windows</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_sync</code></dt>
<dd>
<p>Synchronize CPU and I/O views of memory</p>
</dd>
<dt class="hdlist1"><code>ddi_check_dma_handle</code></dt>
<dd>
<p>Check a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_set_sbus64</code></dt>
<dd>
<p>Allow 64-bit transfers on SBus</p>
</dd>
<dt class="hdlist1"><code>ddi_slaveonly</code></dt>
<dd>
<p>Report whether a device is installed in a slave access-only location</p>
</dd>
<dt class="hdlist1"><code>ddi_iomin</code></dt>
<dd>
<p>Find the minimum alignment and transfer size for DMA</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_burstsizes</code></dt>
<dd>
<p>Find out the allowed burst sizes for a DMA mapping</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_devalign</code></dt>
<dd>
<p>Find DMA mapping alignment and minimum transfer size</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_alloc</code></dt>
<dd>
<p>Acquire a DMA channel</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_release</code></dt>
<dd>
<p>Release a DMA channel</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_getattr</code></dt>
<dd>
<p>Get the DMA engine attributes</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_prog</code></dt>
<dd>
<p>Program a DMA channel</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_stop</code></dt>
<dd>
<p>Terminate a DMA engine operation</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_disable</code></dt>
<dd>
<p>Disable a DMA channel</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_enable</code></dt>
<dd>
<p>Enable a DMA channel</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_getcnt</code></dt>
<dd>
<p>Get the remaining DMA engine count</p>
</dd>
<dt class="hdlist1"><code>ddi_dmae_1stparty</code></dt>
<dd>
<p>Configure the DMA channel cascade mode</p>
</dd>
<dt class="hdlist1"><code>ddi_dma_coff</code></dt>
<dd>
<p>Convert a DMA cookie to an offset within a DMA handle</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 30. Deprecated Direct Memory Access (DMA) Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_addr_setup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_alloc_handle</code>,
<code>ddi_dma_addr_bind_handle</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_buf_setup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_alloc_handle</code>,
<code>ddi_dma_buf_bind_handle</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_curwin</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_getwin</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_free</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_free_handle</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_htoc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_addr_bind_handle</code>,
<code>ddi_dma_buf_bind_handle</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_movwin</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_getwin</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_nextseg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_nextcookie</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_segtocookie</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_nextcookie</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_setup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_alloc_handle</code>,
<code>ddi_dma_addr_bind_handle</code>,
<code>ddi_dma_buf_bind_handle</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dmae_getlim</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dmae_getattr</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_iopb_alloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_alloc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_iopb_free</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_free</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_alloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_alloc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mem_free</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_mem_free</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hat_getkpfnum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dma_addr_bind_handle</code>,
<code>ddi_dma_buf_bind_handle</code>, <code>ddi_dma_nextcookie</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="user-space-access-functions"><a class="anchor" href="#user-space-access-functions"></a>5.23. User Space Access Functions</h3>
<div class="paragraph">
<p>user space access functions</p>
</div>
<div class="paragraph">
<p>The user space access functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_copyin</code></dt>
<dd>
<p>Copy data to a driver buffer</p>
</dd>
<dt class="hdlist1"><code>ddi_copyout</code></dt>
<dd>
<p>Copy data from a driver</p>
</dd>
<dt class="hdlist1"><code>uiomove</code></dt>
<dd>
<p>Copy kernel data using a <code>uio</code> structure</p>
</dd>
<dt class="hdlist1"><code>ureadc</code></dt>
<dd>
<p>Add character to a <code>uio</code> structure</p>
</dd>
<dt class="hdlist1"><code>uwritec</code></dt>
<dd>
<p>Remove a character from a <code>uio</code> structure</p>
</dd>
<dt class="hdlist1"><code>getminor</code></dt>
<dd>
<p>Get minor device number.</p>
</dd>
<dt class="hdlist1"><code>ddi_model_convert_from</code></dt>
<dd>
<p>Determine a data model type mismatch</p>
</dd>
<dt class="hdlist1"><code>IOC_CONVERT_FROM</code></dt>
<dd>
<p>Determine whether there is a need to translate M_IOCTL contents</p>
</dd>
<dt class="hdlist1"><code>STRUCT_DECL</code></dt>
<dd>
<p>Establish the handle to application data in a possibly differing data</p>
</dd>
<dt class="hdlist1"><code>STRUCT_HANDLE</code></dt>
<dd>
<p>Establish the handle to application data in a possibly differing data</p>
</dd>
<dt class="hdlist1"><code>STRUCT_INIT</code></dt>
<dd>
<p>Establish the handle to application data in a possibly differing data</p>
</dd>
<dt class="hdlist1"><code>STRUCT_SET_HANDLE</code></dt>
<dd>
<p>Establish the handle to application data in a possibly differing data</p>
</dd>
<dt class="hdlist1"><code>SIZEOF_PTR</code></dt>
<dd>
<p>Return the size of pointer in specified data model</p>
</dd>
<dt class="hdlist1"><code>SIZEOF_STRUCT</code></dt>
<dd>
<p>Return the size of a structure in the specified data model</p>
</dd>
<dt class="hdlist1"><code>STRUCT_SIZE</code></dt>
<dd>
<p>Return the size of a structure in the application data model</p>
</dd>
<dt class="hdlist1"><code>STRUCT_BUF</code></dt>
<dd>
<p>Return a pointer to the native mode instance of the structure</p>
</dd>
<dt class="hdlist1"><code>STRUCT_FADDR</code></dt>
<dd>
<p>Return a pointer to the specified field of a structure</p>
</dd>
<dt class="hdlist1"><code>STRUCT_FGET</code></dt>
<dd>
<p>Return the specified field of a structure in the application data</p>
</dd>
<dt class="hdlist1"><code>STRUCT_FGETP</code></dt>
<dd>
<p>Return the specified pointer field of a structure in the application
data model</p>
</dd>
<dt class="hdlist1"><code>STRUCT_FSET</code></dt>
<dd>
<p>Set a specified field of a structure in the application data model</p>
</dd>
<dt class="hdlist1"><code>STRUCT_FSETP</code></dt>
<dd>
<p>Set a specified pointer field of a structure in the application data</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 31. Deprecated User Space Access Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>copyin</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_copyin</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>copyout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_copyout</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_getminor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getminor</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="user-process-event-functions"><a class="anchor" href="#user-process-event-functions"></a>5.24. User Process Event Functions</h3>
<div class="paragraph">
<p>user process event functions</p>
</div>
<div class="paragraph">
<p>The user process event functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pollwakeup</code></dt>
<dd>
<p>Inform a process that an event has occurred</p>
</dd>
<dt class="hdlist1"><code>proc_ref</code></dt>
<dd>
<p>Get a handle on a process to signal</p>
</dd>
<dt class="hdlist1"><code>proc_unref</code></dt>
<dd>
<p>Release a handle on a process to signal</p>
</dd>
<dt class="hdlist1"><code>proc_signal</code></dt>
<dd>
<p>Send a signal to a process</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="user-process-information-functions"><a class="anchor" href="#user-process-information-functions"></a>5.25. User Process Information Functions</h3>
<div class="paragraph">
<p>user process information functions</p>
</div>
<div class="paragraph">
<p>The user process information functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_get_cred</code></dt>
<dd>
<p>Return a pointer to the credential structure of the caller</p>
</dd>
<dt class="hdlist1"><code>drv_priv</code></dt>
<dd>
<p>Determine process credentials privilege</p>
</dd>
<dt class="hdlist1"><code>ddi_get_pid</code></dt>
<dd>
<p>Return the process ID</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 32. Deprecated User Process Information Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Functions</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drv_getparm</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get_pid</code>, <code>ddi_get_cred</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="user-application-kernel-and-device-access-functions"><a class="anchor" href="#user-application-kernel-and-device-access-functions"></a>5.26. User Application Kernel and Device Access Functions</h3>
<div class="paragraph">
<p>user application kernel functions</p>
</div>
<div class="paragraph">
<p>device access functions</p>
</div>
<div class="paragraph">
<p>The user application kernel and device access functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_dev_nregs</code></dt>
<dd>
<p>Return the number of register sets a device has</p>
</dd>
<dt class="hdlist1"><code>ddi_dev_regsize</code></dt>
<dd>
<p>Return the size of a device&#8217;s register</p>
</dd>
<dt class="hdlist1"><code>ddi_devmap_segmap</code>, <code>devmap_setup</code></dt>
<dd>
<p>Set up a user mapping to device memory using the <code>devmap</code> framework</p>
</dd>
<dt class="hdlist1"><code>devmap_devmem_setup</code></dt>
<dd>
<p>Export device memory to user space</p>
</dd>
<dt class="hdlist1"><code>devmap_load</code></dt>
<dd>
<p>Validate memory address translations</p>
</dd>
<dt class="hdlist1"><code>devmap_unload</code></dt>
<dd>
<p>Invalidate memory address translations</p>
</dd>
<dt class="hdlist1"><code>devmap_do_ctxmgt</code></dt>
<dd>
<p>Perform device context switching on a mapping</p>
</dd>
<dt class="hdlist1"><code>devmap_set_ctx_timeout</code></dt>
<dd>
<p>Set the timeout value for the context management callback</p>
</dd>
<dt class="hdlist1"><code>devmap_default_access</code></dt>
<dd>
<p>Default driver memory access function</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_alloc</code></dt>
<dd>
<p>Allocate page-aligned kernel memory</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_free</code></dt>
<dd>
<p>Free page-aligned kernel memory</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_lock</code></dt>
<dd>
<p>Lock memory pages</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_unlock</code></dt>
<dd>
<p>Unlock memory pages</p>
</dd>
<dt class="hdlist1"><code>ddi_umem_iosetup</code></dt>
<dd>
<p>Setup I/O requests to application memory</p>
</dd>
<dt class="hdlist1"><code>devmap_umem_setup</code></dt>
<dd>
<p>Export kernel memory to user space</p>
</dd>
<dt class="hdlist1"><code>ddi_model_convert_from</code></dt>
<dd>
<p>Determine data model type mismatch</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 33. Deprecated User Application Kernel and Device Access Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mapdev</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_setup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mapdev_intercept</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_load</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mapdev_nointercept</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_unload</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mapdev_set_device_acc_attr</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_segmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_segmap_setup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap_setup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hat_getkpfnum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_mmap_get_model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="time-related-functions"><a class="anchor" href="#time-related-functions"></a>5.27. Time-Related Functions</h3>
<div class="paragraph">
<p>time-related functions</p>
</div>
<div class="paragraph">
<p>The time-related functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_get_lbolt</code></dt>
<dd>
<p>Return the number of clock ticks since reboot</p>
</dd>
<dt class="hdlist1"><code>ddi_get_time</code></dt>
<dd>
<p>Return the current time in seconds</p>
</dd>
<dt class="hdlist1"><code>ddi_periodic_add</code></dt>
<dd>
<p>Issue nanosecond periodic timeout requests</p>
</dd>
<dt class="hdlist1"><code>ddi_periodic_delete</code></dt>
<dd>
<p>Cancel nanosecond periodic timeout requests</p>
</dd>
<dt class="hdlist1"><code>delay</code></dt>
<dd>
<p>Delay execution for a specified number of clock ticks</p>
</dd>
<dt class="hdlist1"><code>drv_hztousec</code></dt>
<dd>
<p>Convert clock ticks to microseconds</p>
</dd>
<dt class="hdlist1"><code>drv_usectohz</code></dt>
<dd>
<p>Convert microseconds to clock ticks</p>
</dd>
<dt class="hdlist1"><code>drv_usecwait</code></dt>
<dd>
<p>Busy-wait for specified interval</p>
</dd>
<dt class="hdlist1"><code>gethrtime</code></dt>
<dd>
<p>Get high-resolution time</p>
</dd>
<dt class="hdlist1"><code>gethrvtime</code></dt>
<dd>
<p>Get high-resolution LWP virtual time</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<p>Execute a function after a specified length of time</p>
</dd>
<dt class="hdlist1"><code>untimeout</code></dt>
<dd>
<p>Cancel the previous time out function call</p>
</dd>
<dt class="hdlist1"><code>drv_getparm</code></dt>
<dd>
<p><code>ddi_get_lbolt</code>, <code>ddi_get_time</code></p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 34. Deprecated Time-Related Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drv_getparm</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_get_lbolt</code>, <code>ddi_get_time</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="power-management-functions"><a class="anchor" href="#power-management-functions"></a>5.28. Power Management Functions</h3>
<div class="paragraph">
<p>power management functions</p>
</div>
<div class="paragraph">
<p>The power management functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_removing_power</code></dt>
<dd>
<p>Check if device loses power with DDI_SUSPEND</p>
</dd>
<dt class="hdlist1"><code>pci_report_pmcap</code></dt>
<dd>
<p>Report the power management capability of a PCI device</p>
</dd>
<dt class="hdlist1"><code>pm_busy_component</code></dt>
<dd>
<p>Mark a component as busy</p>
</dd>
<dt class="hdlist1"><code>pm_idle_component</code></dt>
<dd>
<p>Mark a component as idle</p>
</dd>
<dt class="hdlist1"><code>pm_raise_power</code></dt>
<dd>
<p>Raise the power level of a component</p>
</dd>
<dt class="hdlist1"><code>pm_lower_power</code></dt>
<dd>
<p>Lower the power level of a component</p>
</dd>
<dt class="hdlist1"><code>pm_power_has_changed</code></dt>
<dd>
<p>Notify the power management framework of an autonomous power level</p>
</dd>
<dt class="hdlist1"><code>pm_trans_check</code></dt>
<dd>
<p>Device power cycle advisory check</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 35. Deprecated Power Management Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddi_dev_is_needed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inform the system that a device&#8217;s
component is required</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_create_components</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create power-manageable components</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_destroy_components</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destroy power-manageable components</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_get_normal_power</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Get the normal power level of a
device component</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pm_set_normal_power</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set the normal power level of a
device component</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="fault-management-functions"><a class="anchor" href="#fault-management-functions"></a>5.29. Fault Management Functions</h3>
<div class="paragraph">
<p>fault management</p>
</div>
<div class="paragraph">
<p>The fault management functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_fm_init</code></dt>
<dd>
<p>Allocates and initializes resources based on declared fault management</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_fini</code></dt>
<dd>
<p>Cleans up resources that were allocated for this device instance to
support fault management capabilities declared to
<code>ddi_fm_init</code></p>
</dd>
<dt class="hdlist1"><code>ddi_fm_capable</code></dt>
<dd>
<p>Returns the capability bit mask currently set for this device instance</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_handler_register</code></dt>
<dd>
<p>Registers an error handler callback routine with the IO Fault
Management framework</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_handler_unregister</code></dt>
<dd>
<p>Removes an error handler callback routine that was registered with
<code>ddi_fm_handler_register</code></p>
</dd>
<dt class="hdlist1"><code>ddi_fm_acc_err_get</code></dt>
<dd>
<p>Returns the error status for an access handle</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_dma_err_get</code></dt>
<dd>
<p>Returns the error status for a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_acc_err_clear</code></dt>
<dd>
<p>Clears the error status for an access handle</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_dma_err_clear</code></dt>
<dd>
<p>Clears the error status for a DMA handle</p>
</dd>
<dt class="hdlist1"><code>ddi_fm_ereport_post</code></dt>
<dd>
<p>Queues an encoded fault management error report name-value pair list
for delivery to the Fault Manager daemon, <code>fmd(8)</code></p>
</dd>
<dt class="hdlist1"><code>ddi_fm_service_impact</code></dt>
<dd>
<p>Reports the impact of an error</p>
</dd>
<dt class="hdlist1"><code>pci_ereport_setup</code></dt>
<dd>
<p>Initializes support for error report generation and sets up the
resources for subsequent accesses to PCI, PCI/X, or PCI Express
configuration space</p>
</dd>
<dt class="hdlist1"><code>pci_ereport_teardown</code></dt>
<dd>
<p>Releases any resources allocated and setup by
<code>pci_ereport_setup</code> for this device instance</p>
</dd>
<dt class="hdlist1"><code>pci_ereport_post</code></dt>
<dd>
<p>Scans for and posts any PCI, PCI/X, or PCI Express bus errors</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="kernel-statistics-functions-1"><a class="anchor" href="#kernel-statistics-functions-1"></a>5.30. Kernel Statistics Functions</h3>
<div class="paragraph">
<p>kernel statistics functions</p>
</div>
<div class="paragraph">
<p>The kernel statistics (kstats) functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>kstat_create</code></dt>
<dd>
<p>Create and initialize a new kstat</p>
</dd>
<dt class="hdlist1"><code>kstat_delete</code></dt>
<dd>
<p>Remove a kstat from the system</p>
</dd>
<dt class="hdlist1"><code>kstat_install</code></dt>
<dd>
<p>Add a fully initialized kstat to the system</p>
</dd>
<dt class="hdlist1"><code>kstat_named_init</code></dt>
<dd>
<p>Initialize a named kstat</p>
</dd>
<dt class="hdlist1"><code>kstat_runq_back_to_waitq</code></dt>
<dd>
<p>Record a transaction migration from run queue to the wait queue</p>
</dd>
<dt class="hdlist1"><code>kstat_runq_enter</code></dt>
<dd>
<p>Record a transaction addition to the run queue</p>
</dd>
<dt class="hdlist1"><code>kstat_runq_exit</code></dt>
<dd>
<p>Record a transaction removal from the run queue</p>
</dd>
<dt class="hdlist1"><code>kstat_waitq_enter</code></dt>
<dd>
<p>Record a transaction addition to the wait queue</p>
</dd>
<dt class="hdlist1"><code>kstat_waitq_exit</code></dt>
<dd>
<p>Record a transaction removal from the wait queue</p>
</dd>
<dt class="hdlist1"><code>kstat_waitq_to_runq</code></dt>
<dd>
<p>Record a transaction migration from the wait queue to the run queue</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="kernel-logging-and-printing-functions"><a class="anchor" href="#kernel-logging-and-printing-functions"></a>5.31. Kernel Logging and Printing Functions</h3>
<div class="paragraph">
<p>kernel logging functions</p>
</div>
<div class="paragraph">
<p>printing functions</p>
</div>
<div class="paragraph">
<p>The kernel logging and printing functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>cmn_err</code>, <code>vcmn_err</code></dt>
<dd>
<p>Display an error message</p>
</dd>
<dt class="hdlist1"><code>ddi_report_dev</code></dt>
<dd>
<p>Announce a device</p>
</dd>
<dt class="hdlist1"><code>strlog</code></dt>
<dd>
<p>Submit messages to the log driver</p>
</dd>
<dt class="hdlist1"><code>ddi_dev_report_fault</code></dt>
<dd>
<p>Report a hardware failure</p>
</dd>
<dt class="hdlist1"><code>scsi_errmsg</code></dt>
<dd>
<p>Display a SCSI request sense message</p>
</dd>
<dt class="hdlist1"><code>scsi_log</code></dt>
<dd>
<p>Display a SCSI-device-related message</p>
</dd>
<dt class="hdlist1"><code>scsi_vu_errmsg</code></dt>
<dd>
<p>Display a SCSI request sense message</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="buffered-io-functions"><a class="anchor" href="#buffered-io-functions"></a>5.32. Buffered I/O Functions</h3>
<div class="paragraph">
<p>buffered I/O functions</p>
</div>
<div class="paragraph">
<p>The buffered I/O functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>physio</code></dt>
<dd>
<p>Perform physical I/O</p>
</dd>
<dt class="hdlist1"><code>aphysio</code></dt>
<dd>
<p>Perform asynchronous physical I/O</p>
</dd>
<dt class="hdlist1"><code>anocancel</code></dt>
<dd>
<p>Prevent cancellation of an asynchronous I/O request</p>
</dd>
<dt class="hdlist1"><code>minphys</code></dt>
<dd>
<p>Limit the <code>physio</code> buffer size</p>
</dd>
<dt class="hdlist1"><code>biowait</code></dt>
<dd>
<p>Suspend processes pending completion of block I/O</p>
</dd>
<dt class="hdlist1"><code>biodone</code></dt>
<dd>
<p>Release the buffer after buffer I/O transfer and notify blocked</p>
</dd>
<dt class="hdlist1"><code>bioerror</code></dt>
<dd>
<p>Indicate the error in a buffer header</p>
</dd>
<dt class="hdlist1"><code>geterror</code></dt>
<dd>
<p>Return an I/O error</p>
</dd>
<dt class="hdlist1"><code>bp_mapin</code></dt>
<dd>
<p>Allocate virtual address space</p>
</dd>
<dt class="hdlist1"><code>bp_mapout</code></dt>
<dd>
<p>Deallocate virtual address space</p>
</dd>
<dt class="hdlist1"><code>disksort</code></dt>
<dd>
<p>Use a single-direction elevator seek strategy to sort for buffers</p>
</dd>
<dt class="hdlist1"><code>getrbuf</code></dt>
<dd>
<p>Get a raw buffer header</p>
</dd>
<dt class="hdlist1"><code>freerbuf</code></dt>
<dd>
<p>Free a raw buffer header</p>
</dd>
<dt class="hdlist1"><code>biosize</code></dt>
<dd>
<p>Return the size of a buffer structure</p>
</dd>
<dt class="hdlist1"><code>bioinit</code></dt>
<dd>
<p>Initialize a buffer structure</p>
</dd>
<dt class="hdlist1"><code>biofini</code></dt>
<dd>
<p>Uninitialize a buffer structure</p>
</dd>
<dt class="hdlist1"><code>bioreset</code></dt>
<dd>
<p>Reuse a private buffer header after I/O is complete</p>
</dd>
<dt class="hdlist1"><code>bioclone</code></dt>
<dd>
<p>Clone another buffer</p>
</dd>
<dt class="hdlist1"><code>biomodified</code></dt>
<dd>
<p>Check whether a buffer is modified</p>
</dd>
<dt class="hdlist1"><code>clrbuf</code></dt>
<dd>
<p>Erase the contents of a buffer</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="virtual-memory-functions"><a class="anchor" href="#virtual-memory-functions"></a>5.33. Virtual Memory Functions</h3>
<div class="paragraph">
<p>virtual memory functions</p>
</div>
<div class="paragraph">
<p>The virtual memory functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_btop</code></dt>
<dd>
<p>Convert device bytes to pages (round down)</p>
</dd>
<dt class="hdlist1"><code>ddi_btopr</code></dt>
<dd>
<p>Convert device bytes to pages (round up)</p>
</dd>
<dt class="hdlist1"><code>ddi_ptob</code></dt>
<dd>
<p>Convert device pages to bytes</p>
</dd>
<dt class="hdlist1"><code>btop</code></dt>
<dd>
<p>Convert size in bytes to size in pages (round down)</p>
</dd>
<dt class="hdlist1"><code>btopr</code></dt>
<dd>
<p>Convert size in bytes to size in pages (round up)</p>
</dd>
<dt class="hdlist1"><code>ptob</code></dt>
<dd>
<p>Convert size in pages to size in bytes</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 36. Deprecated Virtual Memory Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Functions</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hat_getkpfnum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>devmap</code>, <code>ddi_dma_*_bind_handle</code>,
<code>ddi_dma_nextcookie</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="device-id-functions"><a class="anchor" href="#device-id-functions"></a>5.34. Device ID Functions</h3>
<div class="paragraph">
<p>device ID functions</p>
</div>
<div class="paragraph">
<p>The device ID functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_devid_init</code></dt>
<dd>
<p>Allocate a device ID structure</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_free</code></dt>
<dd>
<p>Free a device ID structure</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_register</code></dt>
<dd>
<p>Register a device ID</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_unregister</code></dt>
<dd>
<p>Unregister a device ID</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_compare</code></dt>
<dd>
<p>Compare two device IDs</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_sizeof</code></dt>
<dd>
<p>Return the size of a device ID</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_valid</code></dt>
<dd>
<p>Validate a device ID</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_str_encode</code></dt>
<dd>
<p>Encode a device ID and minor_name into a null-terminated ASCII
string; return a pointer to that string</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_str_decode</code></dt>
<dd>
<p>Decode the device ID and minor_name from a previously encoded
string; allocate and return pointers to the extracted parts</p>
</dd>
<dt class="hdlist1"><code>ddi_devid_str_free</code></dt>
<dd>
<p>Free all strings returned by the <code>ddi_devid_*</code> functions</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="scsi-functions"><a class="anchor" href="#scsi-functions"></a>5.35. SCSI Functions</h3>
<div class="paragraph">
<p>SCSI functions</p>
</div>
<div class="paragraph">
<p>The SCSI functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>scsi_probe</code></dt>
<dd>
<p>Probe a SCSI device</p>
</dd>
<dt class="hdlist1"><code>scsi_unprobe</code></dt>
<dd>
<p>Free resources allocated during initial probing</p>
</dd>
<dt class="hdlist1"><code>scsi_alloc_consistent_buf</code></dt>
<dd>
<p>Allocate an I/O buffer for SCSI DMA</p>
</dd>
<dt class="hdlist1"><code>scsi_free_consistent_buf</code></dt>
<dd>
<p>Free a previously allocated SCSI DMA I/O buffer</p>
</dd>
<dt class="hdlist1"><code>scsi_init_pkt</code></dt>
<dd>
<p>Prepare a complete SCSI packet</p>
</dd>
<dt class="hdlist1"><code>scsi_destroy_pkt</code></dt>
<dd>
<p>Free an allocated SCSI packet and its DMA resource</p>
</dd>
<dt class="hdlist1"><code>scsi_setup_cdb</code></dt>
<dd>
<p>Set up SCSI command descriptor block (CDB)</p>
</dd>
<dt class="hdlist1"><code>scsi_transport</code></dt>
<dd>
<p>Start a SCSI command</p>
</dd>
<dt class="hdlist1"><code>scsi_poll</code></dt>
<dd>
<p>Run a polled SCSI command</p>
</dd>
<dt class="hdlist1"><code>scsi_ifgetcap</code></dt>
<dd>
<p>Get SCSI transport capability</p>
</dd>
<dt class="hdlist1"><code>scsi_ifsetcap</code></dt>
<dd>
<p>Set SCSI transport capability</p>
</dd>
<dt class="hdlist1"><code>scsi_sync_pkt</code></dt>
<dd>
<p>Synchronize CPU and I/O views of memory</p>
</dd>
<dt class="hdlist1"><code>scsi_abort</code></dt>
<dd>
<p>Abort a SCSI command</p>
</dd>
<dt class="hdlist1"><code>scsi_reset</code></dt>
<dd>
<p>Reset a SCSI bus or target</p>
</dd>
<dt class="hdlist1"><code>scsi_reset_notify</code></dt>
<dd>
<p>Notify the target driver of bus resets</p>
</dd>
<dt class="hdlist1"><code>scsi_cname</code></dt>
<dd>
<p>Decode a SCSI command</p>
</dd>
<dt class="hdlist1"><code>scsi_dname</code></dt>
<dd>
<p>Decode a SCSI peripheral device type</p>
</dd>
<dt class="hdlist1"><code>scsi_mname</code></dt>
<dd>
<p>Decode a SCSI message</p>
</dd>
<dt class="hdlist1"><code>scsi_rname</code></dt>
<dd>
<p>Decode a SCSI packet completion reason</p>
</dd>
<dt class="hdlist1"><code>scsi_sname</code></dt>
<dd>
<p>Decode a SCSI sense key</p>
</dd>
<dt class="hdlist1"><code>scsi_errmsg</code></dt>
<dd>
<p>Display a SCSI request sense message</p>
</dd>
<dt class="hdlist1"><code>scsi_log</code></dt>
<dd>
<p>Display a SCSI-device-related message</p>
</dd>
<dt class="hdlist1"><code>scsi_vu_errmsg</code></dt>
<dd>
<p>Display a SCSI request sense message</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_init</code></dt>
<dd>
<p>SCSI HBA system initialization routine</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_fini</code></dt>
<dd>
<p>SCSI HBA system completion routine</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_attach_setup</code></dt>
<dd>
<p>SCSI HBA attach routine</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_detach</code></dt>
<dd>
<p>SCSI HBA detach routine</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_probe</code></dt>
<dd>
<p>Default SCSI HBA probe function</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_tran_alloc</code></dt>
<dd>
<p>Allocate a transport structure</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_tran_free</code></dt>
<dd>
<p>Free a transport structure</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_pkt_alloc</code></dt>
<dd>
<p>Allocate a <code>scsi_pkt</code> structure</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_pkt_free</code></dt>
<dd>
<p>Free a <code>scsi_pkt</code> structure</p>
</dd>
<dt class="hdlist1"><code>scsi_hba_lookup_capstr</code></dt>
<dd>
<p>Return an index matching capability string</p>
</dd>
</dl>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 37. Deprecated SCSI Functions</caption>
<colgroup>
<col style="width: 45%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Deprecated Function</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>free_pktiopb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_free_consistent_buf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>get_pktiopb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_alloc_consistent_buf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>makecom_g0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_setup_cdb</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>makecom_g0_s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_setup_cdb</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>makecom_g1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_setup_cdb</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>makecom_g5</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_setup_cdb</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_dmafree</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_destroy_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_dmaget</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_init_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_attach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_hba_attach_setup</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_pktalloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_init_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_pktfree</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_destroy_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_resalloc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_init_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_resfree</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_destroy_pkt</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_slave</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_probe</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_unslave</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_unprobe</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resource-map-management-functions"><a class="anchor" href="#resource-map-management-functions"></a>5.36. Resource Map Management Functions</h3>
<div class="paragraph">
<p>resource map functions</p>
</div>
<div class="paragraph">
<p>The resource map management functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>rmallocmap</code></dt>
<dd>
<p>Allocate a resource map</p>
</dd>
<dt class="hdlist1"><code>rmallocmap_wait</code></dt>
<dd>
<p>Allocate a resource map, wait if necessary</p>
</dd>
<dt class="hdlist1"><code>rmfreemap</code></dt>
<dd>
<p>Free a resource map</p>
</dd>
<dt class="hdlist1"><code>rmalloc</code></dt>
<dd>
<p>Allocate space from a resource map</p>
</dd>
<dt class="hdlist1"><code>rmalloc_wait</code></dt>
<dd>
<p>Allocate space from a resource map, wait if necessary</p>
</dd>
<dt class="hdlist1"><code>rmfree</code></dt>
<dd>
<p>Free space back into a resource map</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="system-global-state"><a class="anchor" href="#system-global-state"></a>5.37. System Global State</h3>
<div class="paragraph">
<p>system global state functions</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ddi_in_panic</code></dt>
<dd>
<p>Determine whether the system is in panic state</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="utility-functions-1"><a class="anchor" href="#utility-functions-1"></a>5.38. Utility Functions</h3>
<div class="paragraph">
<p>utility functions</p>
</div>
<div class="paragraph">
<p>The utility functions are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>nulldev</code></dt>
<dd>
<p>Zero return function</p>
</dd>
<dt class="hdlist1"><code>nodev</code></dt>
<dd>
<p>Error return function</p>
</dd>
<dt class="hdlist1"><code>nochpoll</code></dt>
<dd>
<p>Error return function for non-pollable devices</p>
</dd>
<dt class="hdlist1"><code>ASSERT</code></dt>
<dd>
<p>Expression verification</p>
</dd>
<dt class="hdlist1"><code>bcopy</code></dt>
<dd>
<p>Copy data between address locations in the kernel</p>
</dd>
<dt class="hdlist1"><code>bzero</code></dt>
<dd>
<p>Clear memory for a given number of bytes</p>
</dd>
<dt class="hdlist1"><code>bcmp</code></dt>
<dd>
<p>Compare two byte arrays</p>
</dd>
<dt class="hdlist1"><code>ddi_ffs</code></dt>
<dd>
<p>Find the first bit set in a long integer</p>
</dd>
<dt class="hdlist1"><code>ddi_fls</code></dt>
<dd>
<p>Find the last bit set in a long integer</p>
</dd>
<dt class="hdlist1"><code>swab</code></dt>
<dd>
<p>Swap bytes in 16-bit halfwords</p>
</dd>
<dt class="hdlist1"><code>strcmp</code></dt>
<dd>
<p>Compare two null-terminated strings</p>
</dd>
<dt class="hdlist1"><code>strncmp</code></dt>
<dd>
<p>Compare two null-terminated strings, with length limit</p>
</dd>
<dt class="hdlist1"><code>strlen</code></dt>
<dd>
<p>Determine the number of non-null bytes in a string</p>
</dd>
<dt class="hdlist1"><code>strnlen</code></dt>
<dd>
<p>Determine the number of non-null bytes in a string, with length limit</p>
</dd>
<dt class="hdlist1"><code>strcpy</code></dt>
<dd>
<p>Copy a string from one location to another</p>
</dd>
<dt class="hdlist1"><code>strncpy</code></dt>
<dd>
<p>Copy a string from one location to another, with length limit</p>
</dd>
<dt class="hdlist1"><code>strchr</code></dt>
<dd>
<p>Find a character in a string</p>
</dd>
<dt class="hdlist1"><code>sprintf</code>, <code>vsprintf</code></dt>
<dd>
<p>Format characters in memory</p>
</dd>
<dt class="hdlist1"><code>numtos</code></dt>
<dd>
<p>Convert an integer to a decimal string</p>
</dd>
<dt class="hdlist1"><code>stoi</code></dt>
<dd>
<p>Convert a decimal string to an integer</p>
</dd>
<dt class="hdlist1"><code>max</code></dt>
<dd>
<p>Return the larger of two integers</p>
</dd>
<dt class="hdlist1"><code>min</code></dt>
<dd>
<p>Return the lesser of two integers</p>
</dd>
<dt class="hdlist1"><code>va_arg</code></dt>
<dd>
<p>Finds the next value in a variable argument list</p>
</dd>
<dt class="hdlist1"><code>va_copy</code></dt>
<dd>
<p>Copies the state of a variable argument list</p>
</dd>
<dt class="hdlist1"><code>va_end</code></dt>
<dd>
<p>Deletes pointer to a variable argument list</p>
</dd>
<dt class="hdlist1"><code>va_start</code></dt>
<dd>
<p>Finds the pointer to the start of a variable argument list</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="making-a-device-driver-64-bit-ready"><a class="anchor" href="#making-a-device-driver-64-bit-ready"></a>5.39. Making a Device Driver 64-Bit Ready</h3>
<div class="paragraph">
<p>This appendix provides information for device driver writers who are
converting their device drivers to support the 64-bit kernel. It
presents the differences between 32-bit and 64-bit device drivers and
describes the steps to convert 32-bit device drivers to 64-bit. This
information is specific to regular character and block device drivers
only.</p>
</div>
<div class="paragraph">
<p>This appendix provides information on the following subjects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#introduction-to-64-bit-driver-design">Introduction to 64-Bit Driver Design</a></p>
</li>
<li>
<p><a href="#general-conversion-steps">General Conversion Steps</a></p>
</li>
<li>
<p><a href="#well-known-ioctl-interfaces">Well
Known Interfaces</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="introduction-to-64-bit-driver-design"><a class="anchor" href="#introduction-to-64-bit-driver-design"></a>5.40. Introduction to 64-Bit Driver Design</h3>
<div class="paragraph">
<p>For drivers that only need support for the 32-bit kernel, existing
32-bit device drivers will continue to work without recompilation.
However, most device drivers require some changes to run correctly in
the 64-bit kernel, and all device drivers require recompilation to
create a 64-bit driver module. The information in this appendix will
help you to enable drivers for 32-bit and 64-bit environments to be
generated from common source code, thus increasing code portability and
reducing the maintenance effort.</p>
</div>
<div class="paragraph">
<p>Before starting to modify a device driver for the 64-bit environment,
you should understand how the 32-bit environment differs from the 64-bit
environment. In particular, you must be familiar with the C language
data type models ILP32 and LP64. See the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 38. Comparison of ILP32 and LP64 Data Types</caption>
<colgroup>
<col style="width: 34%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">C Type</th>
<th class="tableblock halign-left valign-top">ILP32</th>
<th class="tableblock halign-left valign-top">LP64</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>short</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long long</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>long double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">96</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pointer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The driver-specific issues due to the differences between ILP32 and LP64
are the subject of this appendix. More general topics are covered in the
Solaris 64-bit Developer’s Guide.</p>
</div>
<div class="paragraph">
<p>In addition to general code cleanup to support the data model changes
for LP64, driver writers have to provide support for both 32-bit and
64-bit applications.</p>
</div>
<div class="paragraph">
<p>The <code>ioctl(9E)</code>, <code>devmap(9E)</code>, and <code>mmap(9E)</code> entry points enable data
structures to be shared directly between applications and device
drivers. If those data structures change size between the 32-bit and
64-bit environments, then the entry points must be modified so that the
driver can determine whether the data model of the application is the
same as that of the kernel. When the data models differ, data structures
can be adjusted. See <a href="#io-control-support-for-64-bit-capable-device-drivers">I/O Control Support for
64-Bit Capable Device Drivers</a>, <a href="#32-bit-and-64-bit-data-structure-macros">32-bit and 64-bit
Data Structure Macros</a>, and <a href="#associating-kernel-memory-with-user-mappings">Associating Kernel Memory
With User Mappings</a>.</p>
</div>
<div class="paragraph">
<p>In many drivers, only a few <code>ioctls</code> need this kind of handling. The
other <code>ioctls</code> should work without change as long as these <code>ioctls</code> pass
data structures that do not change in size.</p>
</div>
</div>
<div class="sect2">
<h3 id="general-conversion-steps"><a class="anchor" href="#general-conversion-steps"></a>5.41. General Conversion Steps</h3>
<div class="paragraph">
<p>The sections below provide information on converting drivers to run in a
64-bit environment. Driver writers might need to perform one or more of
the following tasks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use fixed-width types for hardware registers.</p>
</li>
<li>
<p>Use fixed-width common access functions.</p>
</li>
<li>
<p>Check and extend use of derived types.</p>
</li>
<li>
<p>Check changed fields within DDI data structures.</p>
</li>
<li>
<p>Check changed arguments of DDI functions.</p>
</li>
<li>
<p>Modify the driver entry points that handle user data, where needed.</p>
</li>
<li>
<p>Check structures that use 64-bit long types on x86 platforms.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>These steps are explained in detail below.</p>
</div>
<div class="paragraph">
<p>After each step is complete, fix all compiler warnings,
and use <code>lint</code> to look for other problems. The SC5.0 (or newer) version
of <code>lint</code> should be used with <code>Xarch=v9</code> and <code>errchk=longptr64</code>
specified to find 64-bit problems. See the notes on using and
interpreting the output of <code>lint</code> in the Solaris 64-bit Developer’s
Guide.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not ignore compilation warnings during conversion for LP64. Warnings
that were safe to ignore previously in the ILP32 environment might now
indicate a more serious problem.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After all the steps are complete, compile and test the driver as both a
32-bit and 64-bit module.</p>
</div>
<div class="sect3">
<h4 id="use-fixed-width-types-for-hardware-registers"><a class="anchor" href="#use-fixed-width-types-for-hardware-registers"></a>5.41.1. Use Fixed-Width Types for Hardware Registers</h4>
<div class="paragraph">
<p>Many device drivers that manipulate hardware devices use C data
structures to describe the layout of the hardware. In the LP64 data
model, data structures that use <code>long</code> or unsigned long to define
hardware registers are almost certainly incorrect, because <code>long</code> is now
a 64-bit quantity. Start by including <code>&lt;sys/inttypes.h&gt;</code>, and
update this class of data structure to use <code>int32_t</code> or
<code>uint32_t</code> instead of <code>long</code> for 32-bit device data. This approach
preserves the binary layout of 32-bit data structures. For example,
change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct device_regs {
    ulong_t        addr;
    uint_t         count;
};      /* Only works for ILP32 compilation */</code></pre>
</div>
</div>
<div class="paragraph">
<p>to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct device_regs {
    uint32_t        addr;
    uint32_t        count;
};      /* Works for any data model */</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="use-fixed-width-common-access-functions"><a class="anchor" href="#use-fixed-width-common-access-functions"></a>5.41.2. Use Fixed-Width Common Access Functions</h4>
<div class="paragraph">
<p>The illumos DDI allows device registers to be accessed by access
functions for portability to multiple platforms. Previously, the DDI
common access functions specified the size of data in terms of bytes,
words, and so on. For example, <code>ddi_getl(9F)</code> is used to access
32-bit quantities. This function is not available in the 64-bit DDI
environment, and has been replaced by versions of the function that
specify the number of bits to be acted on.</p>
</div>
<div class="paragraph">
<p>These routines were added to the 32-bit kernel in the Solaris 2.6
operating environment, to enable their early adoption by driver writers.
For example, to be portable to both 32-bit and 64-bit kernels, the
driver must use <code>ddi_get32(9F)</code> to access 32-bit data rather than
<code>ddi_getl(9F)</code>.</p>
</div>
<div class="paragraph">
<p>All common access routines are replaced by their fixed-width
equivalents. See the <code>ddi_get8(9F)</code>, <code>ddi_put8(9F)</code>,
<code>ddi_rep_get8(9F)</code>, and <code>ddi_rep_put8(9F)</code> man pages for
details.</p>
</div>
</div>
<div class="sect3">
<h4 id="check-and-extend-use-of-derived-types"><a class="anchor" href="#check-and-extend-use-of-derived-types"></a>5.41.3. Check and Extend Use of Derived Types</h4>
<div class="paragraph">
<p>System-derived types, such as <code>size_t</code>, should be used where
possible so that the resulting variables make sense when passed between
functions. The new derived types <code>uintptr_t</code> or <code>intptr_t</code>
should be used as the integral type for pointers.</p>
</div>
<div class="paragraph">
<p>Fixed-width integer types are useful for representing explicit sizes of
binary data structures or hardware registers, while fundamental C
language data types, such as <code>int</code>, can still be used for loop counters
or file descriptors.</p>
</div>
<div class="paragraph">
<p>Some system-derived types represent 32-bit quantities on a 32-bit system
but represent 64-bit quantities on a 64-bit system. Derived types that
change size in this way include: <code>clock_t</code>, <code>daddr_t</code>,
<code>dev_t</code>, <code>ino_t</code>, <code>intptr_t</code>, <code>off_t</code>, <code>size_t</code>,
<code>ssize_t</code>, <code>time_t</code>, <code>uintptr_t</code>, and
<code>timeout_id_t</code>.</p>
</div>
<div class="paragraph">
<p>When designing drivers that use these derived types, pay particular
attention to the use of these types, particularly if the drivers are
assigning these values to variables of another derived type, such as a
fixed-width type.</p>
</div>
</div>
<div class="sect3">
<h4 id="check-changed-fields-in-ddi-data-structures"><a class="anchor" href="#check-changed-fields-in-ddi-data-structures"></a>5.41.4. Check Changed Fields in DDI Data Structures</h4>
<div class="paragraph">
<p>The data types of some of the fields within DDI data structures, such as
<code>buf(9S)</code>, have been changed. Drivers that use these data structures
should make sure that these fields are being used appropriately. The
data structures and the fields that were changed in a significant way
are listed below.</p>
</div>
<div class="sect4">
<h5 id="buf-structure-changes"><a class="anchor" href="#buf-structure-changes"></a><code>buf</code> Structure Changes</h5>
<div class="paragraph">
<p>changes to</p>
</div>
<div class="paragraph">
<p>The fields listed below pertain to transfer size, which can now exceed
more than 4 Gbytes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">size_t        b_bcount;          /* was type unsigned int */
size_t        b_resid;           /* was type unsigned int */
size_t        b_bufsize;         /* was type long */</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ddidmaattr"><a class="anchor" href="#ddidmaattr"></a><code>ddi_dma_attr</code></h5>
<div class="paragraph">
<p>The <code>ddi_dma_attr(9S)</code> structure defines
attributes of the DMA engine and the device. Because these attributes
specify register sizes, fixed-width data types have been used instead of
fundamental types.</p>
</div>
</div>
<div class="sect4">
<h5 id="ddidmacookie-structure-changes"><a class="anchor" href="#ddidmacookie-structure-changes"></a><code>ddi_dma_cookie</code> Structure Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t     dmac_address;    /* was type unsigned long */
size_t       dmac_size;       /* was type u_int */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ddi_dma_cookie(9S)</code> structure contains a
32-bit DMA address, so a fixed-width data type has been used to define
the address. The size has been redefined as <code>size_t</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="csiarqstatus-structure-changes"><a class="anchor" href="#csiarqstatus-structure-changes"></a><code>csi_arq_status</code> Structure Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint_t    sts_rqpkt_state;         /* was type u_long */
uint_t    sts_rqpkt_statistics;    /* was type u_long */</code></pre>
</div>
</div>
<div class="paragraph">
<p>These fields in the structure do not need to grow and
have been redefined as 32-bit quantities.</p>
</div>
</div>
<div class="sect4">
<h5 id="scsi_pkt-structure-changes"><a class="anchor" href="#scsi_pkt-structure-changes"></a><code>scsi_pkt</code> Structure Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint_t      pkt_flags;           /* was type u_long */
int     pkt_time;        /* was type long */
ssize_t     pkt_resid;           /* was type long */
uint_t      pkt_state;           /* was type u_long */
uint_t      pkt_statistics;      /* was type u_long */</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the <code>pkt_flags</code>, <code>pkt_state</code>, and
<code>pkt_statistics</code> fields in the <code>scsi_pkt(9S)</code> structure do not
need to grow, these fields have been redefined as 32-bit integers. The
data transfer size <code>pkt_resid</code> field <em>does</em> grow and has been
redefined as <code>ssize_t</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="check-changed-arguments-of-ddi-functions"><a class="anchor" href="#check-changed-arguments-of-ddi-functions"></a>5.41.5. Check Changed Arguments of DDI Functions</h4>
<div class="paragraph">
<p>This section describes the DDI function argument data types that have
been changed.</p>
</div>
<div class="sect4">
<h5 id="getrbuf-argument-changes"><a class="anchor" href="#getrbuf-argument-changes"></a><code>getrbuf</code> Argument Changes</h5>
<div class="literalblock">
<div class="content">
<pre>struct buf *getrbuf(int sleepflag);</pre>
</div>
</div>
<div class="paragraph">
<p>In previous releases, <code>sleepflag</code> was defined as a type
<code>long</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="drv_getparm-argument-changes"><a class="anchor" href="#drv_getparm-argument-changes"></a><code>drv_getparm</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int drv_getparm(unsigned int parm, void *value_p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In previous releases, <code>value_p</code> was defined as type
<code>unsigned long</code>. In the 64-bit kernel, <code>drv_getparm(9F)</code> can fetch
both 32-bit and 64-bit quantities. The interface does not define data
types of these quantities, and simple programming errors can occur.</p>
</div>
<div class="paragraph">
<p>The following new routines offer a safer alternative:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">clock_t       ddi_get_lbolt(void);
time_t        ddi_get_time(void);
cred_t        *ddi_get_cred(void);
pid_t         ddi_get_pid(void);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Driver writers
are strongly urged to use these routines instead of
<code>drv_getparm(9F)</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="delay-and-timeout-argument-changes"><a class="anchor" href="#delay-and-timeout-argument-changes"></a><code>delay</code> and <code>timeout</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void delay(clock_t ticks);
timeout_id_t timeout(void (*func)(void *), void *arg, clock_t ticks);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;ticks&gt; argument to the <code>delay(9F)</code> and <code>timeout(9F)</code> routines
has been changed from <code>long</code> to <code>clock_t</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="rmallocmap-and-rmallocmap_wait-argument-changes"><a class="anchor" href="#rmallocmap-and-rmallocmap_wait-argument-changes"></a><code>rmallocmap</code> and <code>rmallocmap_wait</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct map *rmallocmap(size_t mapsize);
struct map *rmallocmap_wait(size_t mapsize);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mapsize</code> argument to
the <code>rmallocmap(9F)</code> and <code>rmallocmap_wait(9F)</code> routines has been
changed from <code>ulong_t</code> to <code>size_t</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="scsiallocconsistent_buf-argument-changes"><a class="anchor" href="#scsiallocconsistent_buf-argument-changes"></a><code>scsi_alloc_consistent_buf</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct buf *scsi_alloc_consistent_buf(struct scsi_address *ap,
    struct buf *bp, size_t datalen, uint_t bflags,
    int (*callback )(caddr_t), caddr_t arg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In previous releases, <code>datalen</code> was defined as an <code>int</code>
and <code>bflags</code> was defined as a <code>ulong</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="uiomove-argument-changes"><a class="anchor" href="#uiomove-argument-changes"></a><code>uiomove</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int uiomove(caddr_t address, size_t nbytes,
    enum uio_rw rwflag, uio_t *uio_p);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>nbytes</code> argument was defined as a
type <code>long</code>, but because <code>nbytes</code> represents a size in bytes,
<code>size_t</code> is more appropriate.</p>
</div>
</div>
<div class="sect4">
<h5 id="cvtimedwait-and-cvtimedwait_sig-argument-changes"><a class="anchor" href="#cvtimedwait-and-cvtimedwait_sig-argument-changes"></a><code>cv_timedwait</code> and <code>cv_timedwait_sig</code> Argument Changes</h5>
<div class="paragraph">
<p>cv_timedwait</p>
</div>
<div class="paragraph">
<p>changes to</p>
</div>
<div class="paragraph">
<p>cv_timedwait_sig</p>
</div>
<div class="paragraph">
<p>changes to</p>
</div>
<div class="paragraph">
<p>argument,</p>
</div>
<div class="paragraph">
<p>cv_timedwait</p>
</div>
<div class="paragraph">
<p>changes to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int cv_timedwait(kcondvar_t *cvp, kmutex_t *mp, clock_t timeout);
int cv_timedwait_sig(kcondvar_t *cvp, kmutex_t *mp,    clock_t timeout);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In previous releases, the <code>timeout</code> argument to the
<code>cv_timedwait(9F)</code> and <code>cv_timedwait_sig(9F)</code> routines was
defined to be of type <code>long</code>. Because these routines represent time in
ticks, <code>clock_t</code> is more appropriate.</p>
</div>
</div>
<div class="sect4">
<h5 id="ddidevicecopy-argument-changes"><a class="anchor" href="#ddidevicecopy-argument-changes"></a><code>ddi_device_copy</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_device_copy(ddi_acc_handle_t src_handle,
    caddr_t src_addr, ssize_t src_advcnt,
    ddi_acc_handle_t dest_handle, caddr_t dest_addr,
    ssize_t dest_advcnt, size_t bytecount, uint_t dev_datasz);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>src_advcnt</code>, <code>dest_advcnt</code>, <code>dev_datasz</code> arguments have
changed type. These arguments were previously defined as <code>long</code>, <code>long</code>,
and <code>ulong_t</code> respectively.</p>
</div>
</div>
<div class="sect4">
<h5 id="ddidevicezero-argument-changes"><a class="anchor" href="#ddidevicezero-argument-changes"></a><code>ddi_device_zero</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_device_zero(ddi_acc_handle_t handle,
    caddr_t dev_addr, size_t bytecount, ssize_t dev_advcnt,
    uint_t dev_datasz):</code></pre>
</div>
</div>
<div class="paragraph">
<p>In previous releases,
<code>dev_advcnt</code> was defined as a type <code>long</code> and <code>dev_datasz</code> as a
<code>ulong_t</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ddidmamem_alloc-argument-changes"><a class="anchor" href="#ddidmamem_alloc-argument-changes"></a><code>ddi_dma_mem_alloc</code> Argument Changes</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ddi_dma_mem_alloc(ddi_dma_handle_t handle,
    size_t length, ddi_device_acc_attr_t *accattrp,
    uint_t flags, int (*waitfp)(caddr_t), caddr_t arg,
    caddr_t *kaddrp, size_t *real_length,
    ddi_acc_handle_t *handlep);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In previous
releases, <code>length</code>, <code>flags</code>, and <code>real_length</code> were defined with
types <code>uint_t</code>, <code>ulong_t</code>, and <code>uint_t *</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="modify-routines-that-handle-data-sharing"><a class="anchor" href="#modify-routines-that-handle-data-sharing"></a>5.41.6. Modify Routines That Handle Data Sharing</h4>
<div class="paragraph">
<p>If a device driver shares data structures that contain
<code>long`s or pointers with a 32-bit application using `ioctl(9E)</code>,
<code>devmap(9E)</code>, or <code>mmap(9E)</code>, and the driver is recompiled for a 64-bit
kernel, the binary layout of data structures will be incompatible. If a
field is currently defined in terms of type <code>long</code> and 64-bit data items
are not used, change the data structure to use data types that remain as
32-bit quantities (<code>int</code> and <code>unsigned</code> <code>int</code>). Otherwise, the driver
needs to be aware of the different structure shapes for ILP32 and LP64
and determine whether a model mismatch between the application and the
kernel has occurred.</p>
</div>
<div class="paragraph">
<p>To handle potential data model differences, the <code>ioctl</code>, <code>devmap</code>, and
<code>mmap</code> driver entry points, which interact directly with user
applications, need to be written to determine whether the argument came
from an application using the same data model as the kernel.</p>
</div>
<div class="sect4">
<h5 id="data-sharing-in-ioctl"><a class="anchor" href="#data-sharing-in-ioctl"></a>Data Sharing in <code>ioctl</code></h5>
<div class="paragraph">
<p>To determine whether a model mismatch exists between the
application and the driver, the driver uses the <code>FMODELS</code> mask to
determine the model type from the <code>ioctl</code> <code>mode</code> argument. The following
values are OR-ed into mode to identify the application data model:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FLP64</code> – Application uses the LP64 data model</p>
</li>
<li>
<p><code>FILP32</code> – Application uses the ILP32 data model</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The code examples in
<a href="#io-control-support-for-64-bit-capable-device-drivers">I/O Control Support for 64-Bit Capable Device
Drivers</a> show how this situation can be handled using
<code>ddi_model_convert_from(9F)</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="data-sharing-in-devmap"><a class="anchor" href="#data-sharing-in-devmap"></a>Data Sharing in <code>devmap</code></h5>
<div class="paragraph">
<p>To enable a 64-bit driver and a 32-bit application to
share memory, the binary layout generated by the 64-bit driver must be
the same as the layout consumed by the 32-bit application. The mapped
memory being exported to the application might need to contain
data-model-dependent data structures.</p>
</div>
<div class="paragraph">
<p>Few memory-mapped devices face this problem because the device registers
do not change size when the kernel data model changes. However, some
pseudo-devices that export mappings to the user address space might want
to export different data structures to ILP32 or LP64 applications. To
determine whether a data model mismatch has occurred, <code>devmap(9E)</code> uses
the <code>model</code> parameter to describe the data model expected by the
application. The <code>model</code> parameter is set to one of the following
values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DDI_MODEL_ILP32</code> – The application uses the
ILP32 data model</p>
</li>
<li>
<p><code>DDI_MODEL_LP64</code> – The application uses the LP64
data model</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The model parameter can be passed untranslated to the
<code>ddi_model_convert_from(9F)</code> routine or to
<code>STRUCT_INIT</code>. See <a href="#32-bit-and-64-bit-data-structure-macros">32-bit and 64-bit Data
Structure Macros</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="data-sharing-in-mmap"><a class="anchor" href="#data-sharing-in-mmap"></a>Data Sharing in <code>mmap</code></h5>
<div class="paragraph">
<p>Because <code>mmap(9E)</code> does not have a parameter that can be
used to pass data model information, the driver&#8217;s <code>mmap(9E)</code> entry point
can be written to use the new DDI function
<code>ddi_model_convert_from(9F)</code>. This function returns one of
the following values to indicate the application&#8217;s data type model:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DDI_MODEL_ILP32</code> – Application expects the
ILP32 data model</p>
</li>
<li>
<p><code>DDI_MODEL_ILP64</code> – Application expects the LP64
data model</p>
</li>
<li>
<p><code>DDI_FAILURE</code> – Function was not called from <code>mmap(9E)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As with <code>ioctl</code> and <code>devmap</code>, the model bits can be passed to
<code>ddi_model_convert_from(9F)</code> to determine whether data
conversion is necessary, or the model can be handed to
<code>STRUCT_INIT</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, migrate the device driver to support the <code>devmap(9E)</code>
entry point.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="check-structures-with-64-bit-long-data-types-on-x86-based-platforms"><a class="anchor" href="#check-structures-with-64-bit-long-data-types-on-x86-based-platforms"></a>5.41.7. Check Structures with 64-bit Long Data Types on x86-Based Platforms</h4>
<div class="paragraph">
<p>You should carefully check structures that use 64-bit long types, such
as <code>uint64_t</code>, on the x86 platforms. The alignment and size can
differ between compilation in 32-bit mode versus a 64-bit mode. Consider
the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &amp;lt;studio&gt;
#include &amp;ltsys&gt;

struct myTestStructure {
        uint32_t        my1stInteger;
        uint64_t        my2ndInteger;
};

{
        struct myTestStructure a;

        printf("sizeof myTestStructure is: %d\n", sizeof(a));
        printf("offset to my2ndInteger is: %d\n", (uintptr_t)&amp;a.bar - (uintptr_t)&amp;a);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On a 32-bit system, this example displays the following results:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>sizeof myTestStructure is: 12
offset to my2ndInteger is: 4</pre>
</div>
</div>
<div class="paragraph">
<p>Conversely, on a 64-bit system, this example displays the following
results:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>sizeof myTestStructure is: 16
offset to my2ndInteger is: 8</pre>
</div>
</div>
<div class="paragraph">
<p>Thus, the 32-bit application and the 64-bit application view the
structure differently. As a result, trying to make the same structure
work in both a 32-bit and 64-bit environment can cause problems. This
situation occurs often, particularly in situations where structures are
passed into and out of the kernel through <code>ioctl</code> calls.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="well-known-ioctl-interfaces"><a class="anchor" href="#well-known-ioctl-interfaces"></a>5.42. Well Known <code>ioctl</code> Interfaces</h3>
<div class="paragraph">
<p>Many <code>ioctl(9E)</code> operations are common to a class of
device drivers. For example, most disk drivers implement many of the
<code>dkio(4I)</code> family of <code>ioctls</code>. Many of these interfaces copy in or copy
out data structures from the kernel, and some of these data structures
have changed size in the LP64 data model. The following section lists
the <code>ioctls`that now require explicit conversion in 64-bit driver
`ioctl</code> routines for the <code>dkio</code>, <code>fdio(4I)</code>, <code>fbio(4I)</code>, <code>cdio(4I)</code>, and
<code>mtio(4I)</code> families of <code>ioctls</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 29%;">
<col style="width: 41%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>ioctl</code> command</th>
<th class="tableblock halign-left valign-top">Affected data structure</th>
<th class="tableblock halign-left valign-top">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DKIOCGAPART</code></p>
</div>
<div class="paragraph">
<p><code>DKIOCSAPART</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>dk_map</code></p>
</div>
<div class="paragraph">
<p><code>dk_allmap</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dkio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DKIOGVTOC</code></p>
</div>
<div class="paragraph">
<p><code>DKIOSVTOC</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>partition</code></p>
</div>
<div class="paragraph">
<p><code>vtoc</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dkio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FBIOPUTCMAP</code></p>
</div>
<div class="paragraph">
<p><code>FBIOGETCMAP</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbcmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FBIOPUTCMAPI</code></p>
</div>
<div class="paragraph">
<p><code>FBIOGETCMAPI</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbcmap_i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FBIOGCURSOR</code></p>
</div>
<div class="paragraph">
<p><code>FBIOSCURSOR</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbcursor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fbio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>CDROMREADMODE1</code></p>
</div>
<div class="paragraph">
<p><code>CDROMREADMODE2</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdrom_read</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CDROMCDDA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdrom_cdda</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CDROMCDXA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdrom_cdxa</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CDROMSUBCODE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdrom_subcode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FDIOCMD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fd_cmd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FDRAW</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fd_raw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fdio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MTIOCTOP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MTIOCGET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtget</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MTIOCGETDRIVETYPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtdrivetype_request</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mtio(4I)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>USCSICMD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uscsi_cmd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scsi_free_consistent_buf(9F)</code></p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="device-sizes"><a class="anchor" href="#device-sizes"></a>5.42.1. Device Sizes</h4>
<div class="paragraph">
<p>nblocks property is exported by each slice of a block device driver.
This property contains the number of 512-byte blocks that each slice of
the device can support. The nblocks property is defined as a signed
32-bit quantity, which limits the maximum size of a slice to 1 Tbyte.</p>
</div>
<div class="paragraph">
<p>Disk devices that provide more than 1 Tbyte of storage per disk must
define the Nblocks property, which should still contain the number of
512 byte blocks that the device can support. However, Nblocks is a
signed 64-bit quantity, which removes any practical limit on disk space.</p>
</div>
<div class="paragraph">
<p>The nblocks property is now deprecated. All disk devices should provide
the Nblocks property.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="console-frame-buffer-drivers"><a class="anchor" href="#console-frame-buffer-drivers"></a>5.43. Console Frame Buffer Drivers</h3>
<div class="paragraph">
<p>Drivers for frame buffers that are used for the system
console must provide interfaces to enable the system to display text on
the console. illumos provides enhanced visual I/O interfaces to enable
the kernel terminal emulator to display text directly on the console
frame buffer. This appendix describes how to add the necessary
interfaces to a frame buffer driver to enable the driver to interact
with the illumos kernel terminal emulator.</p>
</div>
</div>
<div class="sect2">
<h3 id="illumos-consoles-and-the-kernel-terminal-emulator"><a class="anchor" href="#illumos-consoles-and-the-kernel-terminal-emulator"></a>5.44. illumos Consoles and the Kernel Terminal Emulator</h3>
<div class="paragraph">
<p>role of the kernel terminal emulator is to render text onto the console
frame buffer in the proper position and representation determined by the
frame buffer&#8217;s screen height, width, and pixel depth mode. The terminal
emulator also drives scrolling, controls a software cursor, and
interprets ANSI terminal escape sequences. The terminal emulator
accesses the console frame buffer in either VGA text mode or pixel mode,
depending upon the graphics card. To be used as an illumos console frame
buffer driver, your frame buffer driver must be compatible with the
illumos kernel terminal emulator. The target platform is the most
significant factor that determines whether you need to modify your frame
buffer driver to make your driver compatible with the illumos kernel
terminal emulator.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>x86 platforms – Console frame buffer drivers do not need to be
modified because x86 console frame buffer drivers already support the
console frame buffer interfaces.</p>
</li>
<li>
<p>SPARC platforms – Console frame buffer drivers should use the
interfaces described in this appendix to enable the driver to interact
with the illumos kernel terminal emulator.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="x86-platform-console-communication"><a class="anchor" href="#x86-platform-console-communication"></a>5.44.1. x86 Platform Console Communication</h4>
<div class="paragraph">
<p>tem (terminal emulator module)</p>
</div>
<div class="paragraph">
<p>VGA text mode</p>
</div>
<div class="paragraph">
<p>On x86 platforms, the illumos kernel terminal emulator module (<code>tem</code>)
uses VGA text mode exclusively to interact with the <code>vgatext</code> module.
The <code>vgatext</code> module uses industry standard VGA text mode to interact
with x86 compatible frame buffer devices. Because the <code>vgatext</code> module
already supports the console frame buffer interfaces, x86 frame buffer
drivers are compatible with the kernel <code>tem</code> module. You do not need to
add special interfaces to x86 frame buffer drivers.</p>
</div>
<div class="paragraph">
<p>The remainder of this appendix applies to SPARC platforms only.</p>
</div>
</div>
<div class="sect3">
<h4 id="sparc-platform-console-communication"><a class="anchor" href="#sparc-platform-console-communication"></a>5.44.2. SPARC Platform Console Communication</h4>
<div class="paragraph">
<p>video mode</p>
</div>
<div class="paragraph">
<p>SPARC frame buffer drivers typically do not operate in VGA text mode.
SPARC frame buffer drivers typically are required to send pixel patterns
that depict the text and images displayed. The kernel <code>tem</code> requires
SPARC drivers to support specific interfaces to facilitate rendering
data to the screen, perform scrolling, and display a text cursor. How
the driver actually renders data sent from the <code>tem</code> onto the screen
depends on the device. The driver typically draws the data into video
memory according to the hardware and video mode.</p>
</div>
<div class="paragraph">
<p>illumos provides interfaces that enable the kernel terminal emulator to
drive compatible console frame buffers directly. The advantages of
converting a driver to be compatible with the kernel terminal emulator
are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dramatically improved performance, particularly for scrolling</p>
</li>
<li>
<p>Enhanced ANSI text color capabilities</p>
</li>
<li>
<p>The ability to start a login session on the console frame buffer even
when the system console stream is directed out the serial port</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SPARC console frame buffer drivers are not required to be compatible
with the kernel terminal emulator. If the console frame buffer driver is
not compatible with the kernel terminal emulator, the system uses the
FCode terminal emulator in the OpenBoot PROM.</p>
</div>
<div class="paragraph">
<p>The console frame buffer is identified
through the EEPROM <code>screen</code> environment variable. The system determines
whether the console frame buffer is compatible with the kernel terminal
emulator module by checking whether the frame buffer driver exports the
<code>tem-support</code> DDI property. If the <code>tem-support</code> property is exported,
then the system issues the <code>VIS_DEVINIT</code> I/O control (<code>ioctl</code>)
command to the frame buffer driver during system boot, while configuring
the console. If the <code>tem-support</code> DDI property is exported and the
<code>VIS_DEVINIT</code> <code>ioctl</code> command succeeds and returns a compatible
version number to the <code>tem</code>, the system configures the system console to
utilize that frame buffer driver through the kernel terminal emulator.
See the <code>ioctl(9E)</code> man page for information about the I/O control
driver entry point.</p>
</div>
<div class="paragraph">
<p>SPARC drivers that support the kernel terminal emulator should export
the <code>tem-support</code> DDI property. This property indicates that the driver
supports the kernel terminal emulator. If a frame buffer driver exports
the <code>tem-support</code> DDI property, then that driver will be handled early
in the boot process, while the console is being configured. If a frame
buffer driver does not export the <code>tem-support</code> property, then that
driver might not be handled early enough in the boot process.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>tem-support</code></dt>
<dd>
<p>When set to 1, this DDI property indicates that this driver is
compatible with the console kernel frame buffer interface.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The kernel terminal emulator module interacts with the console frame
buffer driver through two major interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Through <code>ioctl</code> interfaces during normal system operation</p>
</li>
<li>
<p>Through polled I/O interfaces during standalone mode</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following section provides detailed information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="console-visual-io-interfaces"><a class="anchor" href="#console-visual-io-interfaces"></a>5.45. Console Visual I/O Interfaces</h3>
<div class="paragraph">
<p>kernel terminal emulator interacts with the console frame buffer driver
through two interfaces. During normal system activity (after a
successful boot of the system), communication between the kernel
terminal emulator and the console frame buffer driver is through <code>ioctl</code>
interfaces. During standalone mode (before system boot or during
debugging), communication between the kernel terminal emulator and the
console frame buffer driver is through polled I/O interfaces. All
activity between the kernel terminal emulator and the console frame
buffer driver is initiated by the kernel terminal emulator, with the
exception of a callback function used by the console frame buffer driver
to notify the kernel terminal emulator of changes in the video mode.</p>
</div>
<div class="paragraph">
<p>The console visual I/O interfaces are documented in detail in the
<code>visual_io(4I)</code> man page. For more information on the video mode
change callback function, see <a href="#video-mode-change-callback-interface">Video Mode Change Callback
Interface</a>.</p>
</div>
<div class="sect3">
<h4 id="io-control-interfaces"><a class="anchor" href="#io-control-interfaces"></a>5.45.1. I/O Control Interfaces</h4>
<div class="paragraph">
<p>During normal system activity, the kernel terminal emulator communicates
with the console frame buffer driver through the <code>ioctl</code> interfaces
listed in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 34%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>ioctl</code> Name</th>
<th class="tableblock halign-left valign-top">Corresponding Data Structure</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_DEVINIT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_devinit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initializes the session between
the terminal emulator module and the frame buffer. See <a href="#vis_devinit" class="bare">#vis_devinit</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_DEVFINI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not Applicable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Terminates the session between the
terminal emulator module and the frame buffer. See <a href="#vis_defini" class="bare">#vis_defini</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_CONSDISPLAY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_consdisplay</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays pixels as a
rectangle. See <a href="#vis_consdisplay" class="bare">#vis_consdisplay</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_CONSCOPY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_conscopy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies a rectangle of pixels
(scroll). See <a href="#vis_conscopy" class="bare">#vis_conscopy</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_CONSCURSOR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_conscursor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays or hides a text
cursor. See <a href="#vis_conscursor" class="bare">#vis_conscursor</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_PUTCMAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_cmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sends the terminal emulator module
color map to the frame buffer driver. See <a href="#vis_putcmap" class="bare">#vis_putcmap</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VIS_GETCMAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_cmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reads the terminal emulator module
color map from the frame buffer. See <a href="#vis_getcmap" class="bare">#vis_getcmap</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="polled-io-interfaces"><a class="anchor" href="#polled-io-interfaces"></a>5.45.2. Polled I/O Interfaces</h4>
<div class="paragraph">
<p>The polled I/O
interfaces provide the same functionality as the <code>VIS_CONSDISPLAY</code>,
<code>VIS_CONSCOPY</code>, and <code>VIS_CONSCURSOR</code> <code>ioctl</code> interfaces. The
polled I/O interfaces are called only when the operating system is
quiesced and in <em>standalone</em> mode. See <a href="#implementing-polled-io-in-console-frame-buffer-drivers">Implementing Polled
I/O in Console Frame Buffer Drivers</a> for more information.</p>
</div>
<div class="paragraph">
<p>While in standalone mode, the kernel terminal emulator communicates with
the console frame buffer driver through the polled I/O interfaces listed
in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 34%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Polled I/O Function</th>
<th class="tableblock halign-left valign-top">Corresponding Data Structure</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(*display)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_consdisplay</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays pixels as a
rectangle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(*copy)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_conscopy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copies a rectangle of pixels
(scroll).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(*cursor)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vis_conscursor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays or hides a text cursor.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="video-mode-change-callback-interface"><a class="anchor" href="#video-mode-change-callback-interface"></a>5.45.3. Video Mode Change Callback Interface</h4>
<div class="paragraph">
<p>The console frame buffer driver and the
kernel terminal emulator must be in agreement about the video mode at
all times. <em>Video mode</em> includes the console screen height, width, and
depth in pixels. Video mode also includes whether communication between
the kernel terminal emulator and the console frame buffer is in VGA text
mode or pixel mode.</p>
</div>
<div class="paragraph">
<p>In order for the console frame buffer driver to notify the kernel
terminal emulator of changes in the video mode, the console frame buffer
driver is initialized with the address of the <code>(*modechg_cb)</code>
kernel terminal emulator callback function described in the following
table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 34%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Callback Function</th>
<th class="tableblock halign-left valign-top">Corresponding Data Structures</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(*modechg_cb)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>vis_modechg_arg</code></p>
</div>
<div class="paragraph">
<p><code>vis_devinit</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keep the terminal emulator module synchronized with the driver video
mode (screen height, width, and pixel depth).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="implementing-the-visual-io-interfaces-in-console-frame-buffer-drivers"><a class="anchor" href="#implementing-the-visual-io-interfaces-in-console-frame-buffer-drivers"></a>5.46. Implementing the Visual I/O Interfaces in Console Frame Buffer Drivers</h3>
<div class="paragraph">
<p>Except for the video mode change callback, all activity between the
driver and the kernel terminal emulator is initiated by the <code>tem</code>
(terminal emulator module). This means that the <code>tem</code> issues all of the
<code>ioctl</code> commands described in this document. The following sections
provide implementation details for each <code>ioctl</code> command. For more
information, see the <code>visual_io(4I)</code> man page and the
<code>/usr/include/sys/visual_io.h</code> include file. See <a href="#video-mode-change-callback-interface">Video
Mode Change Callback Interface</a> for detailed information about the video
mode change callback function.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Each <code>ioctl</code> command should determine whether the <code>FKIOCTL</code> is set in
the <code>ioctl</code> flag argument and return <code>EPERM</code> if that bit is not set.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="vis_devinit"><a class="anchor" href="#vis_devinit"></a>5.46.1. <code>VIS_DEVINIT</code></h4>
<div class="paragraph">
<p>The <code>VIS_DEVINIT</code> <code>ioctl</code> command initializes the frame buffer
driver as the system console device. This <code>ioctl</code> passes the address of
a <code>vis_devinit</code> structure.</p>
</div>
<div class="paragraph">
<p>The <code>tem</code> first loads the address of its video mode change callback
function into the <code>modechg_cb</code> field of the <code>vis_devinit</code>
structure and loads its soft state into the <code>modechg_arg</code> field. The
<code>tem</code> then issues the <code>VIS_DEVINIT</code> <code>ioctl</code> command. The frame
buffer driver then initializes itself and returns a summary of its
configuration back to the <code>tem</code> by setting the <code>version</code>, <code>width</code>,
<code>height</code>, <code>linebytes</code>, <code>depth</code>, <code>mode</code>, and <code>polledio</code> fields in the
<code>vis_devinit</code> structure. The <code>vis_devinit</code> structure is shown in
the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct vis_devinit {
      /*
       * This set of fields are used as parameters passed from the
       * layered frame buffer driver to the terminal emulator.
       */
      int             version;        /* Console IO interface rev */
      screen_size_t   width;          /* Width of the device */
      screen_size_t   height;         /* Height of the device */
      screen_size_t   linebytes;      /* Bytes per scan line */
      int             depth;          /* Device depth */
      short           mode;           /* Display mode Mode */
      struct vis_polledio *polledio;  /* Polled output routines */
      /*
       * The following fields are used as parameters passed from the
       * terminal emulator to the underlying frame buffer driver.
       */
      vis_modechg_cb_t modechg_cb;   /* Video mode change callback */
      struct vis_modechg_arg *modechg_arg;  /* Mode change cb arg */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement the <code>VIS_DEVINIT</code> <code>ioctl</code> command in the console frame
buffer driver, follow these general steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Define a <code>struct</code> to contain the console-specific state. This
structure is private to the console frame buffer driver. This structure
is referred to as <code>consinfo</code> in this appendix. The <code>consinfo</code> structure
contains information such as:</p>
<div class="ulist">
<ul>
<li>
<p>Current size of the blit buffer</p>
</li>
<li>
<p>Pointer to the blit buffer</p>
</li>
<li>
<p>Color map information</p>
</li>
<li>
<p>Driver rendering mode information such as line pitch</p>
</li>
<li>
<p>Background color</p>
</li>
<li>
<p>Video memory address</p>
</li>
<li>
<p>Terminal emulator callback address</p>
</li>
</ul>
</div>
</li>
<li>
<p>Allocate memory:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocate a blit buffer large enough to store a reasonable default
sized rectangle of pixels at the highest video depth. Additional memory
can be allocated if an incoming request exceeds the size of the buffer.
The frame buffer driver&#8217;s largest font is 12×22. Assuming
<code>DEFAULT_HEIGHT</code> is 12, <code>DEFAULT_WIDTH</code> is 22, and the maximum
video depth is 32, the buffer size should be 8448 bytes
(<code>DEFAULT_HEIGHT</code> × <code>DEFAULT_WIDTH</code> × 32).</p>
</li>
<li>
<p>Allocate a <code>vis_polledio</code> structure.</p>
</li>
<li>
<p>Allocate a buffer to hold a cursor. This buffer should be the size of
the largest character. This buffer will not change size.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Obtain the video change callback address and callback context of the
<code>tem</code> from <code>modechg_cb</code> and <code>modechg_ctx</code> and store this
information in the <code>consinfo</code> structure.</p>
</li>
<li>
<p>Populate the <code>vis_polledio</code> structure with entry point addresses
for the polled display, copy, and cursor functions.</p>
</li>
<li>
<p>Provide the appropriate information in the fields of the
<code>vis_devinit</code> structure that was passed to the driver by the <code>tem</code>:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set the <code>version</code> field to <code>VIS_CONS_REV</code>, which is a
constant defined in the <code>/usr/include/sys/visual_io.h</code> header file.</p>
</li>
<li>
<p>Set the <code>mode</code> field to <code>VIS_PIXEL</code>.</p>
</li>
<li>
<p>Set the <code>polledio</code> field to the address of the <code>vis_polledio</code>
structure.</p>
</li>
<li>
<p>Set the <code>height</code> field to the video mode height in pixels.</p>
</li>
<li>
<p>Set the <code>width</code> field to the video mode width in pixels.</p>
</li>
<li>
<p>Set the <code>depth</code> field to the frame buffer pixel depth in bytes (for
example, a 32-bit pixel depth would be 4 bytes).</p>
</li>
<li>
<p>Set the <code>linebytes</code> field to the value of <code>height</code> × <code>width</code> ×
<code>depth</code>.</p>
<div class="paragraph">
<p>This information is sent from the driver to the <code>tem</code> by using the
<code>vis_devinit</code> structure. This information tells the terminal
emulator how to render information and pass it to the graphics driver.</p>
</div>
<div class="paragraph">
<p>Whenever the console frame buffer driver
changes its video mode (specifically <code>height</code>, <code>width</code>, or <code>depth</code>), the
driver <em>must</em> call the video mode change callback function of the <code>tem</code>
to update the <code>vis_devinit</code> structure and to pass this structure
back to the terminal emulator. The terminal emulator passes its mode
change callback function address in the <code>modechg_cb</code> field of the
<code>vis_devinit</code> structure. The mode change callback function has the
following function signature:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>typedef void (*vis_modechg_cb_t)
      (struct vis_modechg_arg *, struct vis_devinit *);</pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the preceding <code>typedef</code>, the mode change callback function
takes two arguments. The first argument is the <code>modechg_arg</code> and the
second argument is the <code>vis_devinit</code> structure. The
<code>modechg_arg</code> is sent from the <code>tem</code> to the driver during the
<code>VIS_DEVINIT</code> <code>ioctl</code> command initialization. The driver must send
the <code>modechg_arg</code> back to the <code>tem</code> with each video mode change
callback.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Initialize the context of the kernel console. Specific requirements
vary depending upon the capability of the graphics device. This
initialization might include such steps as setting the draw engine
state, initializing the palette, or locating and mapping video memory or
the rendering engine so that data can be blitted onto the screen.</p>
</li>
<li>
<p>Return the <code>vis_devinit</code> structure to the caller.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="vis_defini"><a class="anchor" href="#vis_defini"></a>5.46.2. <code>VIS_DEFINI</code></h4>
<div class="paragraph">
<p>The <code>VIS_DEFINI</code> <code>ioctl</code> command releases the driver&#8217;s console
resources and finishes the session.</p>
</div>
<div class="paragraph">
<p>To implement the <code>VIS_DEVFINI</code> <code>ioctl</code> command in the console frame
buffer driver, follow these general steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Reset the console frame buffer driver state.</p>
</li>
<li>
<p>Clear the polled I/O entry points and the kernel terminal emulator
video change function callback address.</p>
</li>
<li>
<p>Release memory.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="vis_consdisplay"><a class="anchor" href="#vis_consdisplay"></a>5.46.3. <code>VIS_CONSDISPLAY</code></h4>
<div class="paragraph">
<p>The <code>VIS_CONSDISPLAY</code> <code>ioctl</code> command displays a rectangle of pixels
at a specified location. This display is also referred to as <em>blitting</em>
a rectangle. The <code>vis_consdisplay</code> structure contains the
information necessary to render a rectangle at the video depth that both
the driver and the <code>tem</code> are using. The <code>vis_consdisplay</code> structure
is shown in the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct vis_consdisplay {
      screen_pos_t    row;      /* Row (in pixels) to display data at */
      screen_pos_t    col;      /* Col (in pixels) to display data at */
      screen_size_t   width;    /* Width of data (in pixels) */
      screen_size_t   height;   /* Height of data (in pixels) */
      unsigned char   *data;    /* Address of pixels to display */
      unsigned char   fg_color; /* Foreground color */
      unsigned char   bg_color; /* Background color */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement the <code>VIS_CONSDISPLAY</code> <code>ioctl</code> command in the console
frame buffer driver, follow these general steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the <code>vis_consdisplay</code> structure.</p>
</li>
<li>
<p>Validate the display parameters. Return an error if any of the display
parameters is out of range.</p>
</li>
<li>
<p>Calculate the size of the rectangle to be blitted into video memory.
Validate this size against the size of the blit buffer created during
<code>VIS_DEVINIT</code>. Allocate additional memory for the blit buffer if
necessary.</p>
</li>
<li>
<p>Retrieve the blit data. This data has been prepared by the kernel
terminal emulator at the agreed upon pixel depth. That depth is the same
pixel depth that was conveyed by the <code>tem</code> during <code>VIS_DEVINIT</code>. The
pixel depth is updated whenever the device driver changes video modes
through callback to the <code>tem</code>. Typical pixel depths are 8-bit color map
indexed, and 32-bit TrueColor.</p>
</li>
<li>
<p>Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
<code>VIS_CONSDISPLAY</code> <code>ioctl</code> completes.</p>
</li>
<li>
<p>Establish the driver-specific console rendering context.</p>
</li>
<li>
<p>If the frame buffer is running in 8-bit color indexed mode, restore
the kernel console color map that the <code>tem</code> set up through a previous
<code>VIS_PUTCMAP</code> <code>ioctl</code>. A lazy color map loading scheme is
recommended to optimize performance. In a <em>lazy</em> scheme, the console
frame buffer only restores colors it has actually used since the
<code>VIS_DEVINIT</code> <code>ioctl</code> was issued.</p>
</li>
<li>
<p>Display the data passed from the <code>tem</code> at the pixel coordinates sent
by the <code>tem</code>. You might need to transform the RGB pixel data byte order.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="vis_conscopy"><a class="anchor" href="#vis_conscopy"></a>5.46.4. <code>VIS_CONSCOPY</code></h4>
<div class="paragraph">
<p>The <code>VIS_CONSCOPY</code> <code>ioctl</code> command copies a rectangular region of
pixels from one location to another location. One use for this <code>ioctl</code>
is to scroll.</p>
</div>
<div class="paragraph">
<p>To implement the <code>VIS_CONSCOPY</code> <code>ioctl</code> command in the console frame
buffer driver, follow these general steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the <code>vis_conscopy</code> structure. The <code>vis_conscopy</code>
structure describes the source and target rectangle sizes and locations.</p>
</li>
<li>
<p>Validate the display parameters. Return an error if any of the display
parameters is out of range.</p>
</li>
<li>
<p>Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
<code>VIS_CONSDISPLAY</code> <code>ioctl</code> completes.</p>
</li>
<li>
<p>Call the function to copy the rectangle.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For optimal performance, use the rendering engine of the graphic device
to implement the copy function. You need to decide how to do the context
management within the driver to set up the rendering engine for best
performance.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="vis_conscursor"><a class="anchor" href="#vis_conscursor"></a>5.46.5. <code>VIS_CONSCURSOR</code></h4>
<div class="paragraph">
<p>The <code>VIS_CONSCURSOR</code> <code>ioctl</code> command displays or hides a cursor. The
<code>vis_conscursor</code> structure is shown in the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct vis_conscursor {
      screen_pos_t    row;      /* Row to display cursor (in pixels) */
      screen_pos_t    col;      /* Col to display cursor (in pixels) */
      screen_size_t   width;    /* Width of cursor (in pixels) */
      screen_size_t   height;   /* Height of cursor (in pixels) */
      color_t         fg_color; /* Foreground color */
      color_t         bg_color; /* Background color */
      short           action;   /* Show or Hide cursor */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement the <code>VIS_CONSCOPY</code> <code>ioctl</code> command in the console frame
buffer driver, follow these general steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the <code>vis_conscursor</code> structure from the kernel terminal
emulator.</p>
</li>
<li>
<p>Validate the display parameters. Return an error if any of the display
parameters are out of range.</p>
</li>
<li>
<p>Invalidate any user context so that user applications cannot
simultaneously access the frame buffer hardware through user memory
mappings. This step is neither allowed nor necessary in polled I/O mode
because user applications are not running. Be sure to hold a lock so
that users cannot restore the mapping through a page fault until the
<code>VIS_CONSDISPLAY</code> <code>ioctl</code> completes.</p>
</li>
<li>
<p>The terminal emulator can call the <code>VIS_CONSCOPY</code> <code>ioctl</code> with one
of the following two actions: <code>SHOW_CURSOR</code> and <code>HIDE_CURSOR</code>.
The following steps describe how to implement this functionality by
reading and writing video memory. You might also be able to use the
rendering engine to do this work. Whether you can use the rendering
engine depends on the frame buffer hardware.</p>
<div class="paragraph">
<p>Take these steps to implement the <code>SHOW_CURSOR</code> functionality:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the pixels within the rectangle where the cursor will be drawn.
These saved pixels will be needed to hide the cursor.</p>
</li>
<li>
<p>Scan all the pixels on the screen bounded by the rectangle where the
cursor will be drawn. Within this rectangle, replace the pixels that
match the specified cursor foreground color (<code>fg_color</code>) with white
pixels. Replace the pixels that match the specified cursor background
color (<code>bg_color</code>) with black pixels. The visual effect is of a
black cursor over white text. This method works with any foreground and
background color of text. Attempting to invert colors based upon color
map position is not feasible. More sophisticated strategies, such as
attempting color inversion using HSB coloring (Hue, Saturation,
Brightness), are not necessary.</p>
<div class="paragraph">
<p>To implement the <code>HIDE_CURSOR</code> functionality, replace the pixels
beneath the cursor rectangle with the pixels saved from the previous
<code>SHOW_CURSOR</code> action.</p>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="vis_putcmap"><a class="anchor" href="#vis_putcmap"></a>5.46.6. <code>VIS_PUTCMAP</code></h4>
<div class="paragraph">
<p>The <code>VIS_PUTCMAP</code> <code>ioctl</code> command establishes the console color map.
The terminal emulator calls this function to set up the color map of the
kernel. The <code>vis_cmap</code> structure is shown in the following code.
This structure only applies to 8-bit color indexed mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">struct vis_cmap {
      int             index;  /* Index into colormap to start updating */
      int             count;  /* Number of entries to update */
      unsigned char   *red;   /* List of red values */
      unsigned char   *green; /* List of green values */
      unsigned char   *blue;  /* List of blue values */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>VIS_PUTCMAP</code> <code>ioctl</code> command is similar to the <code>FBIOPUTCMAP</code>
command. The <code>VIS_PUTCMAP</code> command is specific to the frame buffer
terminal-emulator compatible console code.</p>
</div>
</div>
<div class="sect3">
<h4 id="vis_getcmap"><a class="anchor" href="#vis_getcmap"></a>5.46.7. <code>VIS_GETCMAP</code></h4>
<div class="paragraph">
<p>The terminal emulator calls the <code>VIS_GETCMAP</code> <code>ioctl</code> command to
retrieve the console color map.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="implementing-polled-io-in-console-frame-buffer-drivers"><a class="anchor" href="#implementing-polled-io-in-console-frame-buffer-drivers"></a>5.47. Implementing Polled I/O in Console Frame Buffer Drivers</h3>
<div class="paragraph">
<p>console frame buffer drivers</p>
</div>
<div class="paragraph">
<p>polled I/O interfaces</p>
</div>
<div class="paragraph">
<p>I/O</p>
</div>
<div class="paragraph">
<p>polled I/O interfaces</p>
</div>
<div class="paragraph">
<p>polled I/O interfaces</p>
</div>
<div class="paragraph">
<p>console frame buffer drivers</p>
</div>
<div class="paragraph">
<p>standalone mode</p>
</div>
<div class="paragraph">
<p>The polled I/O interfaces are implemented as functions in the driver and
are called directly by the kernel terminal emulator. The driver passes
the address of its polled I/O entry points to the terminal emulator
during the execution of the <code>VIS_DEVINIT</code> <code>ioctl</code> command. The
<code>VIS_DEVINIT</code> command is initiated by the terminal emulator.</p>
</div>
<div class="paragraph">
<p>The <code>vis_polledio</code> structure is shown in the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef void * vis_opaque_arg_t;

struct vis_polledio {
      struct vis_polledio_arg *arg;
      void    (*display)(vis_opaque_arg_t, struct vis_consdisplay *);
      void    (*copy)(vis_opaque_arg_t, struct vis_conscopy *);
      void    (*cursor)(vis_opaque_arg_t, struct vis_conscursor *);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The polled I/O interfaces provide the same functionality as the
<code>VIS_CONSDISPLAY</code>, <code>VIS_CONSCOPY</code>, and <code>VIS_CONSCURSOR</code>
<code>ioctl</code> interfaces. The polled I/O interfaces should follow the same
steps that are described above for the respective <code>ioctl</code> commands. The
polled I/O interfaces must very strictly adhere to the additional
restrictions that are described in the remainder of this section.</p>
</div>
<div class="paragraph">
<p>The polled I/O interfaces are called only when the
operating system is quiesced and in standalone mode. The system enters
<em>standalone</em> mode whenever the user enters OpenBoot PROM or enters the
<code>kmdb</code> debugger, or when the system panics. Only one CPU and one thread
are active. All other CPUs and threads are stopped. Timesharing, DDI
interrupts, and system services are turned off.</p>
</div>
<div class="paragraph">
<p>Standalone mode severely restricts driver functionality but simplifies
driver synchronization requirements. For example, a user application
cannot access the console frame buffer driver by way of the driver&#8217;s
memory mappings from within a polled I/O routine.</p>
</div>
<div class="paragraph">
<p>In standalone mode, the console frame buffer driver must <em>not</em> perform
any of the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wait for interrupts</p>
</li>
<li>
<p>Wait for mutexes</p>
</li>
<li>
<p>Allocate memory</p>
</li>
<li>
<p>Use DDI or LDI interfaces</p>
</li>
<li>
<p>Use system services</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These restrictions are not difficult to obey since the polled I/O
functions are relatively simple operations. For example, when working
with the rendering engine, the console frame buffer driver can poll a
bit in the device rather than wait for an interrupt. The driver can use
pre-allocated memory to render blit data. DDI or LDI interfaces should
not be needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="frame-buffer-specific-configuration-module"><a class="anchor" href="#frame-buffer-specific-configuration-module"></a>5.48. Frame Buffer Specific Configuration Module</h3>
<div class="paragraph">
<p>console frame buffer drivers</p>
</div>
<div class="paragraph">
<p>video mode change callback interface</p>
</div>
<div class="paragraph">
<p>video mode</p>
</div>
<div class="paragraph">
<p>When the driver-specific <code>fbconfig</code> module causes a change in resolution
or color depth, that <code>fbconfig</code> module must send an <code>ioctl</code> to the frame
buffer driver. This <code>ioctl</code> triggers the frame buffer driver to call the
terminal emulator&#8217;s mode change callback function with the new screen
size and depth. The frame buffer driver and the terminal emulator must
agree about the video mode at all times. When the frame buffer driver
and the terminal emulator do not agree about the video mode, the
information on the screen is illegible and meaningless.</p>
</div>
</div>
<div class="sect2">
<h3 id="the-x-window-system-frame-buffer-specific-ddx-module"><a class="anchor" href="#the-x-window-system-frame-buffer-specific-ddx-module"></a>5.49. The X Window System Frame Buffer Specific DDX Module</h3>
<div class="paragraph">
<p>DDX module</p>
</div>
<div class="paragraph">
<p>When the X Window System exits to the command line, the frame buffer&#8217;s
DDX module must send an <code>ioctl</code> to the frame buffer driver. This <code>ioctl</code>
triggers the frame buffer driver to call the terminal emulator&#8217;s mode
change callback function. This communication keeps the frame buffer
driver and the terminal emulator in agreement about the video mode if
the X Window System starts and then changes the video resolution before
exiting. The frame buffer driver and the terminal emulator must agree
about the video mode at all times. When the frame buffer driver and the
terminal emulator do not agree about the video mode, the information on
the screen is illegible and meaningless.</p>
</div>
</div>
<div class="sect2">
<h3 id="developing-testing-and-debugging-console-frame-buffer-drivers"><a class="anchor" href="#developing-testing-and-debugging-console-frame-buffer-drivers"></a>5.50. Developing, Testing, and Debugging Console Frame Buffer Drivers</h3>
<div class="paragraph">
<p>Debugging a console frame
buffer driver on an active system can be problematic.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Errors that are encountered in the early stages of booting the system
do not generate a core dump.</p>
</li>
<li>
<p>Error or informative messages might not be displayed correctly on the
screen.</p>
</li>
<li>
<p>USB keyboard input might fail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section offers some suggestions to help you develop, test, and
debug console frame buffer drivers.</p>
</div>
<div class="sect3">
<h4 id="testing-the-io-control-interfaces"><a class="anchor" href="#testing-the-io-control-interfaces"></a>5.50.1. Testing the I/O Control Interfaces</h4>
<div class="paragraph">
<p>To test the <code>ioctl</code> commands, create additional <code>ioctl</code> entry points
that are callable from a user application. Be sure to copy in the
arguments appropriately. Use the <code>ddi_copyin(9F)</code> and
<code>ddi_copyout(9F)</code> routines to transfer data to and from user address
space. Then write an application to validate rendering, scrolling, and
cursor behavior. This way, these <code>ioctl</code> commands do not affect your
console while you develop and test the commands.</p>
</div>
<div class="paragraph">
<p>To ensure that the <code>ioctl</code> commands are working correctly, boot the
system and log in. Check whether you get expected behavior when you
execute commands such as <code>prstat</code>(1M), <code>ls</code>(1), <code>vi</code>(1), and <code>man</code>(1).</p>
</div>
<div class="paragraph">
<p>Execute the following script to validate that ANSI color is working
correctly:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/bash
printf "\n\n\n\e[37;40m             Color List       \e[m\n\n"
printf "\e[30m Color 30 black\e[m\n"
printf "\e[31m Color 31 red\e[m\n"
printf "\e[32m Color 32 green\e[m\n"
printf "\e[33m Color 33 yellow\e[m\n"
printf "\e[34m Color 34 blue\e[m\n"
printf "\e[35m Color 35 purple\e[m\n"
printf "\e[36m Color 36 cyan\e[m\n"
printf "\e[37m Color 37 white\e[m\n\n"
printf "\e[40m Backlight 40 black \e[m\n"
printf "\e[41m Backlight 41 red   \e[m\n"
printf "\e[34;42m Backlight 42 green \e[m\n"
printf "\e[43m Backlight 43 yellow\e[m\n"
printf "\e[37;44m Backlight 44 blue  \e[m\n"
printf "\e[45m Backlight 45 purple\e[m\n"
printf "\e[30;46m Backlight 46 cyan  \e[m\n"
printf "\e[30;47m Backlight 47 white \e[m\n\n"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testing-the-polled-io-interfaces"><a class="anchor" href="#testing-the-polled-io-interfaces"></a>5.50.2. Testing the Polled I/O Interfaces</h4>
<div class="paragraph">
<p>The polled I/O interfaces are only available under the following
circumstances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you enter the OpenBoot PROM by using the L1&#43;A keystroke
sequence</p>
</li>
<li>
<p>When you boot the system with a standalone debugger such as <code>kmdb(1)</code></p>
</li>
<li>
<p>When the system panics</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The polled I/O interfaces only become available at a certain point in
the boot process. Polled I/O requests issued from the OpenBoot PROM
before the system is running are not rendered. Similarly, <code>kmdb</code> prompts
issued before the console is configured are not rendered.</p>
</div>
<div class="paragraph">
<p>To test the polled I/O interfaces, enter the OpenBoot PROM by using the
L1&#43;A keystroke sequence. To validate that the polled I/O interfaces
are being used, type the following command at the OpenBoot PROM <code>ok</code>
prompt:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ok 1b emit ." [32m This is a test" 1b emit ." [m"</pre>
</div>
</div>
<div class="paragraph">
<p>The polled I/O interfaces are working properly if the following
statements are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The result of the above command is that the phrase <code>This is a test</code> is
displayed in green.</p>
</li>
<li>
<p>The OpenBoot PROM continues to function correctly.</p>
</li>
<li>
<p>Scrolling performs as expected.</p>
</li>
<li>
<p>The cursor displays correctly.</p>
</li>
<li>
<p>The system can be reentered and continued repeatedly.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="testing-the-video-mode-change-callback-function"><a class="anchor" href="#testing-the-video-mode-change-callback-function"></a>5.50.3. Testing the Video Mode Change Callback Function</h4>
<div class="paragraph">
<p>To determine whether the video mode change callback
function is working properly, log in to the system and use <code>fbconfig(8)</code>
to change the resolution and depth of the frame buffer several times. If
the console continues to display text properly, the video mode change
callback function is working correctly. The kernel terminal emulator
might adjust the font size to accommodate different screen sizes, but
that is not significant to the console frame buffer driver.</p>
</div>
<div class="paragraph">
<p>To determine whether the X Window System and the console frame buffer
driver interact correctly, switch between the X Window System and the
command line several times while modifying the X Window System&#8217;s video
resolution and the command line resolution in different ways. If the X
Window System exits and the console characters are not displayed
correctly, either the X Window System did not notify the driver console
code that the video mode changed or the driver did not call the kernel
terminal emulator&#8217;s video mode change callback function.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-suggestions-for-testing-console-frame-buffer-drivers"><a class="anchor" href="#additional-suggestions-for-testing-console-frame-buffer-drivers"></a>5.50.4. Additional Suggestions for Testing Console Frame Buffer Drivers</h4>
<div class="paragraph">
<p>During boot, the system sends messages to
<code>/var/adm/messages</code> if the system fails to locate or successfully load a
kernel terminal emulator compatible frame buffer driver. To monitor
these messages, type the following command in a separate window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% tail -f /var/adm/messages</pre>
</div>
</div>
<div class="paragraph">
<p>To avoid problems with USB while debugging the driver,
change the EEPROM <code>input-device</code> NVRAM configuration parameter to use a
serial port instead of the keyboard. See the <code>eeprom(8)</code> man page for
more information about this parameter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="document-license"><a class="anchor" href="#document-license"></a>5.51. Document License</h3>

</div>
<div class="sect2">
<h3 id="_public_documentation_license_pdl_version_1_01"><a class="anchor" href="#_public_documentation_license_pdl_version_1_01"></a>5.52. Public Documentation License (PDL), Version 1.01</h3>
<div class="paragraph">
<p><span class="first-word">1.0  DEFINITIONS.</span></p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>1.1.  “Commercial Use” means distribution or otherwise making the
Documentation available to a third party.</p>
</div>
<div class="paragraph">
<p>1.2.  “Contributor” means a person or entity who creates or contributes
to the creation of Modifications.</p>
</div>
<div class="paragraph">
<p>1.3.  “Documentation” means the Original Documentation or Modifications
or the combination of the Original Documentation and Modifications, in
each case including portions thereof.</p>
</div>
<div class="paragraph">
<p>1.4.  “Editable Form” means the preferred form of Documentation for
making Modifications to such documentation. The Documentation can be in
an electronic, compressed or archival form, provided the appropriate
decompression or de-archiving software is widely available for no
charge.</p>
</div>
<div class="paragraph">
<p>1.5.  “Electronic Distribution Mechanism” means a mechanism generally
accepted for the electronic transfer of data.</p>
</div>
<div class="paragraph">
<p>1.6.  “Initial Writer” means the individual or entity identified as the
Initial Writer in the notice required by the Appendix.</p>
</div>
<div class="paragraph">
<p>1.7.  “Larger Work” means a work which combines Documentation or
portions thereof with documentation or other writings not governed by
the terms of this License.</p>
</div>
<div class="paragraph">
<p>1.8.  “License” means this document.</p>
</div>
<div class="paragraph">
<p>1.9.  “Modifications” means any addition to or deletion from the
substance or structure of either the Original Documentation or any
previous Modifications, such as a translation, abridgment, condensation,
or any other form in which the Original Documentation or previous
Modifications may be recast, transformed or adapted. A work consisting
of editorial revisions, annotations, elaborations, and other
modifications which, as a whole represent an original work of
authorship, is a Modification. For example, when Documentation is
released as a series of documents, a Modification is:</p>
</div>
<div class="paragraph">
<p>A.  Any addition to or deletion from the contents of the Original
Documentation or previous Modifications.</p>
</div>
<div class="paragraph">
<p>B.  Any new documentation that contains any part of the Original
Documentation or previous Modifications.</p>
</div>
<div class="paragraph">
<p>1.10.  “Original Documentation” means documentation described as
Original Documentation in the notice required by the Appendix, and
which, at the time of its release under this License is not already
Documentation governed by this License.</p>
</div>
<div class="paragraph">
<p>1.11.  “You” (or “Your”) means an individual or a legal entity
exercising rights under, and complying with all of the terms of, this
License or a future version of this License issued under Section 5.0
(“Versions of the License”). For legal entities, “You” includes any
entity which controls, is controlled by, or is under common control with
You. For purposes of this definition, “control” means (a) the power,
direct or indirect, to cause the direction or management of such entity,
whether by contract or otherwise, or (b) ownership of more than fifty
percent (50%) of the outstanding shares or beneficial ownership of such
entity.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><span class="first-word">2.0  LICENSE GRANTS.</span></p>
</div>
<div class="paragraph">
<p><span class="first-word">2.1  Initial Writer Grant.</span></p>
</div>
<div class="paragraph">
<p>The Initial Writer hereby grants You a world-wide, royalty-free,
non-exclusive license to use, reproduce, prepare Modifications of,
compile, publicly perform, publicly display, demonstrate, market,
disclose and distribute the Documentation in any form, on any media or
via any Electronic Distribution Mechanism or other method now known or
later discovered, and to sublicense the foregoing rights to third
parties through multiple tiers of sublicensees in accordance with the
terms of this License.</p>
</div>
<div class="paragraph">
<p>The license rights granted in this Section 2.1 (“Initial Writer Grant”)
are effective on the date Initial Writer first distributes Original
Documentation under the terms of this License.</p>
</div>
<div class="paragraph">
<p><span class="first-word">2.2.  Contributor Grant.</span></p>
</div>
<div class="paragraph">
<p>Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license to use, reproduce, prepare Modifications of,
compile, publicly perform, publicly display, demonstrate, market,
disclose and distribute the Documentation in any form, on any media or
via any Electronic Distribution Mechanism or other method now known or
later discovered, and to sublicense the foregoing rights to third
parties through multiple tiers of sublicensees in accordance with the
terms of this License.</p>
</div>
<div class="paragraph">
<p>The license rights granted in this Section 2.2 (“Contributor Grant”) are
effective on the date Contributor first makes Commercial Use of the
Documentation.</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.0  DISTRIBUTION OBLIGATIONS.</span></p>
</div>
<div class="paragraph">
<p><span class="first-word">3.1.  Application of License.</span></p>
</div>
<div class="paragraph">
<p>The Modifications which You create or to which You contribute are
governed by the terms of this License, including without limitation
Section 2.2 (“Contributor Grant”). The Documentation may be distributed
only under the terms of this License or a future version of this License
released in accordance with Section 5.0 (“Versions of the License”), and
You must include a copy of this License with every copy of the
Documentation You distribute. You may not offer or impose any terms that
alter or restrict the applicable version of this License or the
recipients' rights hereunder. However, You may include an additional
document offering the additional rights described in Section 3.5
(“Required Notices”).</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.2.  Availability of Documentation.</span></p>
</div>
<div class="paragraph">
<p>Any Modification which You create or to which You contribute must be
made available publicly in Editable Form under the terms of this License
via a fixed medium or an accepted Electronic Distribution Mechanism.</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.3.  Description of Modifications.</span></p>
</div>
<div class="paragraph">
<p>All Documentation to which You contribute must identify the changes You
made to create that Documentation and the date of any change. You must
include a prominent statement that the Modification is derived, directly
or indirectly, from Original Documentation provided by the Initial
Writer and include the name of the Initial Writer in the Documentation
or via an electronic link that describes the origin or ownership of the
Documentation. The foregoing change documentation may be created by
using an electronic program that automatically tracks changes to the
Documentation. You must make all such changes and required information
publicly available for at least five years following release of the
changed Documentation.</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.4.  Intellectual Property Matters.</span></p>
</div>
<div class="paragraph">
<p>Contributor represents that Contributor believes that Contributor&#8217;s
Modifications are Contributor&#8217;s original creation(s), Contributor has
sufficient rights to grant the rights conveyed by this License, or both
of these statements are true.</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.5.  Required Notices.</span></p>
</div>
<div class="paragraph">
<p>You must duplicate the notice in the Appendix in each file of the
Documentation. If it is not possible to put such notice in a particular
Documentation file due to its structure, then You must include such
notice in a location (such as a relevant directory) where a reader would
be likely to look for such a notice, for example, via a hyperlink in
each file of the Documentation that takes the reader to a page that
describes the origin and ownership of the Documentation. If You created
one or more Modification(s) You may add your name as a Contributor to
the notice described in the Appendix.</p>
</div>
<div class="paragraph">
<p>You must also duplicate this License in any Documentation file (or with
a hyperlink in each file of the Documentation) where You describe
recipients' rights or ownership rights.</p>
</div>
<div class="paragraph">
<p>You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of
Documentation. However, You may do so only on Your own behalf, and not
on behalf of the Initial Writer or any Contributor. You must make it
absolutely clear than any such warranty, support, indemnity or liability
obligation is offered by You alone, and You hereby agree to indemnify
the Initial Writer and every Contributor for any liability incurred by
the Initial Writer or such Contributor as a result of warranty, support,
indemnity or liability terms You offer.</p>
</div>
<div class="paragraph">
<p><span class="first-word">3.6.  Larger Works.</span></p>
</div>
<div class="paragraph">
<p>You may create a Larger Work by combining Documentation with other
documents not governed by the terms of this License and distribute the
Larger Work as a single product. In such a case, You must make sure the
requirements of this License are fulfilled for the Documentation.</p>
</div>
<div class="paragraph">
<p><span class="first-word">4.0  APPLICATION OF THIS LICENSE.</span></p>
</div>
<div class="paragraph">
<p>This License applies to Documentation to which the Initial Writer has
attached this License and the notice in the Appendix.</p>
</div>
<div class="paragraph">
<p><span class="first-word">5.0  TRADEMARKS.</span></p>
</div>
<div class="paragraph">
<p>This license does not grant permission to use the trade names,
trademarks, service marks, logos, or product names of the Initial Writer
or any Contributor, except as required for reasonable and customary use
in describing the Origin of the Documentation and reproducing the
content of any of the notices described in the Appendix.</p>
</div>
<div class="paragraph">
<p><span class="first-word">6.0  VERSIONS OF THE LICENSE.</span></p>
</div>
<div class="paragraph">
<p><span class="first-word">6.1.  New Versions.</span></p>
</div>
<div class="paragraph">
<p>Initial Writer may publish revised or new versions of the License from
time to time. Each version will be given a distinguishing version
number.</p>
</div>
<div class="paragraph">
<p><span class="first-word">6.2.  Effect of New Versions.</span></p>
</div>
<div class="paragraph">
<p>Once Documentation has been published under a particular version of the
License, You may always continue to use it under the terms of that
version. You may also choose to use such Documentation under the terms
of any subsequent version of the License published by
__________________[Insert name of the foundation, company, Initial
Writer, or whoever may modify this License]. No one other than
_________________ [Insert name of the foundation, company,
Initial Writer, or whoever may modify this License] has the right to
modify the terms of this License. Filling in the name of the Initial
Writer, Original Documentation or Contributor in the notice described in
the Appendix shall not be deemed to be Modifications of this License.</p>
</div>
<div class="paragraph">
<p><span class="first-word">7.0  DISCLAIMER OF WARRANTY.</span></p>
</div>
<div class="paragraph">
<p>DOCUMENTATION IS PROVIDED UNDER THIS LICENSE ON AN “AS IS” BASIS,
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENTATION IS FREE OF
DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING.
THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE
DOCUMENTATION IS WITH YOU. SHOULD ANY DOCUMENTATION PROVE DEFECTIVE IN
ANY RESPECT, YOU (NOT THE INITIAL WRITER OR ANY OTHER CONTRIBUTOR)
ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS
DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO
USE OF ANY DOCUMENTATION IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS
DISCLAIMER.</p>
</div>
<div class="paragraph">
<p><span class="first-word">8.0  TERMINATION.</span></p>
</div>
<div class="paragraph">
<p>This License and the rights granted hereunder will terminate
automatically if You fail to comply with terms herein and fail to cure
such breach within 30 days of becoming aware of the breach. All
sublicenses to the Documentation which are properly granted shall
survive any termination of this License. Provisions which, by their
nature, must remain in effect beyond the termination of this License
shall survive.</p>
</div>
<div class="paragraph">
<p><span class="first-word">9.0  LIMITATION OF LIABILITY.</span></p>
</div>
<div class="paragraph">
<p>UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT
(INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE INITIAL
WRITER, ANY OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF DOCUMENTATION, OR
ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY
CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL,
WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER
DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO THE USE OF THE
DOCUMENTATION, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE
POSSIBILITY OF SUCH DAMAGES.</p>
</div>
<div class="paragraph">
<p><span class="first-word">10.0  U.S. GOVERNMENT END USERS.</span></p>
</div>
<div class="paragraph">
<p>If Documentation is being acquired by or on behalf of the U.S.
Government or by a U.S. Government prime contractor or subcontractor (at
any tier), then the Government&#8217;s rights in Documentation will be only as
set forth in this Agreement; this is in accordance with 48 CFR 227.7201
through 227.7202-4 (for Department of Defense (DOD) acquisitions) and
with 48 CFR 2.101 and 12.212 (for non-DOD acquisitions).</p>
</div>
<div class="paragraph">
<p><span class="first-word">11.0  MISCELLANEOUS.</span></p>
</div>
<div class="paragraph">
<p>This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. This License shall be governed by
California law, excluding its conflict-of-law provisions. With respect
to disputes or any litigation relating to this License, the losing party
is responsible for costs, including without limitation, court costs and
reasonable attorneys' fees and expenses. The application of the United
Nations Convention on Contracts for the International Sale of Goods is
expressly excluded. Any law or regulation which provides that the
language of a contract shall be construed against the drafter shall not
apply to this License.</p>
</div>
</div>
<div class="sect2">
<h3 id="_public_documentation_license_notice"><a class="anchor" href="#_public_documentation_license_notice"></a>5.53. Public Documentation License Notice</h3>
<div class="paragraph">
<p>The contents of this Documentation are subject to the Public
Documentation License Version 1.01 (the “License”); you may only use
this Documentation if you comply with the terms of this License. A copy
of the License is available at <a href="http://illumos.org/license/PDL" class="bare">http://illumos.org/license/PDL</a></p>
</div>
<div class="paragraph">
<p>The Original Documentation is Writing Device Drivers. The Initial Writer
of the Original Documentation is Sun Microsystems Copyright &#169;
2003-2009. All Rights Reserved. (Initial Writer contact(s):
<a href="http://sun.com" class="bare">http://sun.com</a>).</p>
</div>
<div class="paragraph">
<p>Contributor(s): Joyent, Inc. Portions created by Joyent, Inc. are
Copyright &#169; 2016. All Rights Reserved. (Contributor contact(s):
<a href="http://joyent.com" class="bare">http://joyent.com</a>).</p>
</div>
<div class="paragraph">
<p>This documentation was derived from the source at
<a href="https://github.com/rmustacc/illumos-docbooks">illumos docbooks</a>. For full
changes as required by the PDL, please see the above URL.</p>
</div>
<script src="scroll-spy.js"></script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-07-15 04:30:39 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>